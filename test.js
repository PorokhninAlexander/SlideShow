var Rex = Rex || {};

/**
 * Constants
 */
/** @const */ Rex.FPS = 60;
/** @const */ Rex.Pi = 3.141592653589793;
/** @const */ Rex.Deg2Rad = 0.01745329251994;
/** @const */ Rex.Rad2Deg = 57.29577951308233;
Rex.INFINITY = 1.0e+10;

/**
 * Formats
 */
/** @const */ Rex.FormatUnknown = 0;
/** @const */ Rex.FormatUInt8x1 = 1;
/** @const */ Rex.FormatUInt8x4 = 2;
/** @const */ Rex.FormatUInt16x1 = 3;
/** @const */ Rex.FormatUInt32x1 = 4;
/** @const */ Rex.FormatFloat16x2 = 5;
/** @const */ Rex.FormatFloat16x4 = 6;
/** @const */ Rex.FormatFloat32x1 = 7;
/** @const */ Rex.FormatFloat32x2 = 8;
/** @const */ Rex.FormatFloat32x3 = 9;
/** @const */ Rex.FormatFloat32x4 = 10;
/** @const */ Rex.FormatFloat32x16 = 11;

/**
 * Buffer masks
 */
/** @const */ Rex.BufferRed = 1;
/** @const */ Rex.BufferGreen = 2;
/** @const */ Rex.BufferBlue = 4;
/** @const */ Rex.BufferAlpha = 8;
/** @const */ Rex.BufferDepth = 16;
/** @const */ Rex.BufferStencil = 32;
/** @const */ Rex.BufferColor = 15;
/** @const */ Rex.BufferDepthStencil = 48;
/** @const */ Rex.BufferAll = 63;

/**
 * Blend functions
 */
/** @const */ Rex.BlendNone = 0;
/** @const */ Rex.BlendZero = 1;
/** @const */ Rex.BlendOne = 2;
/** @const */ Rex.BlendSrcColor = 3;
/** @const */ Rex.BlendSrcAlpha = 4;
/** @const */ Rex.BlendDestColor = 5;
/** @const */ Rex.BlendDestAlpha = 6;
/** @const */ Rex.BlendOneMinusSrcColor = 7;
/** @const */ Rex.BlendOneMinusSrcAlpha = 8;
/** @const */ Rex.BlendOneMinusDestColor = 9;
/** @const */ Rex.BlendOneMinusDestAlpha = 10;

/**
 * Depth functions
 */
/** @const */ Rex.DepthNone = 0;
/** @const */ Rex.DepthNever = 1;
/** @const */ Rex.DepthAlways = 2;
/** @const */ Rex.DepthLess = 3;
/** @const */ Rex.DepthEqual = 4;
/** @const */ Rex.DepthGreater = 5;
/** @const */ Rex.DepthLessEqual = 6;
/** @const */ Rex.DepthNotEqual = 7;
/** @const */ Rex.DepthGreaterEqual = 8;

/**
 * Stencil functions
 */
/** @const */ Rex.StencilNone = 0;
/** @const */ Rex.StencilNever = 1;
/** @const */ Rex.StencilAlways = 2;
/** @const */ Rex.StencilLess = 3;
/** @const */ Rex.StencilEqual = 4;
/** @const */ Rex.StencilGreater = 5;
/** @const */ Rex.StencilLessEqual = 6;
/** @const */ Rex.StencilNotEqual = 7;
/** @const */ Rex.StencilGreaterEqual = 8;

/**
 * Stencil operations
 */
/** @const */ Rex.StencilOpKeep = 0;
/** @const */ Rex.StencilOpZero = 1;
/** @const */ Rex.StencilOpReplace = 2;
/** @const */ Rex.StencilOpInvert = 3;
/** @const */ Rex.StencilOpIncr = 4;
/** @const */ Rex.StencilOpDecr = 5;

/**
 * Face modes
 */
/** @const */ Rex.FaceNone = 0;
/** @const */ Rex.FaceFront = 1;
/** @const */ Rex.FaceBack = 2;
/** @const */ Rex.FaceBoth = 3;

/**
 * Draw modes
 */
/** @const */ Rex.DrawPoints = 0;
/** @const */ Rex.DrawLineStrip = 1;
/** @const */ Rex.DrawLineLoop = 2;
/** @const */ Rex.DrawLines = 3;
/** @const */ Rex.DrawTriangleStrip = 4;
/** @const */ Rex.DrawTriangleFan = 5;
/** @const */ Rex.DrawTriangles = 6;

/**
 * Texture formats
 */
/** @const */ Rex.TextureFormatAlpha = 0;
/** @const */ Rex.TextureFormatLuminance = 1;
/** @const */ Rex.TextureFormatLuminanceAlpha = 2;
/** @const */ Rex.TextureFormatRGB = 3;
/** @const */ Rex.TextureFormatRGBA = 4;

/**
 * Texture filters
 */
/** @const */ Rex.TextureFilterPoint = 0;
/** @const */ Rex.TextureFilterLinear = 1;
/** @const */ Rex.TextureFilterBilinear = 2;
/** @const */ Rex.TextureFilterTrilinear = 3;

/**
 * Texture wrap modes
 */
/** @const */ Rex.TextureWrapClamp = 0;
/** @const */ Rex.TextureWrapRepeat = 1;

/**
 * MouseButton
 */
/** @const */ Rex.MouseButtonLeft = 0;
/** @const */ Rex.MouseButtonMid = 1;
/** @const */ Rex.MouseButtonRight = 2;

/**
 * KeyBoard
 */
/** @const */ Rex.KeyList = {
	backspace 		:			8,
	tab 			:			9,
	enter 			:			13,
	shift 			:			16,
	ctrl 			:			17,
	pause 			:			19,
	break 			:			19,
	capsLock 		:			20,
	escape 			:			27,
	pageUp 			:			33,
	pageDown 		:			34,
	home 			:			36,
	leftArrow 		:			37,
	upArrow 		:			38,
	rightArrow 		:			39,
	downArrow 		:			40,
	insert			:			45,
	delete 			:			46,
	null 			:			48,
	one 			:			49,
	two 			:			50,
	three 			:			51,
	four 			:			52,
	five 			:			53,
	six 			:			54,
	seven 			:			55,
	eight 			:			56,
	nine 			:			57,
	a 				:			65,
	b 				:			66,
	c 				:			67,
	d 				:			68,
	e 				:			69,
	f 				:			70,
	g 				:			71,
	h 				:			72,
	i 				:			73,
	j 				:			74,
	k 				:			75,
	l 				:			76,
	m 				:			77,
	n 				:			78,
	o 				:			79,
	p 				:			80,
	q 				:			81,
	r 				:			82,
	s 				:			83,
	t 				:			84,
	u 				:			85,
	v 				:			86,
	w 				:			87,
	x 				:			88,
	y 				:			89,
	z 				:			90,
	f1 				:			112,
	f2 				:			113,
	f3 				:			114,
	f4 				:			115,
	f5 				:			116,
	f6 				:			117,
	f7 				:			118,
	f8 				:			119,
	f9 				:			120,
	f10 			:			121,
	f11 			:			122,
	f12 			:			123,
	numLock 		:			144,
	scrollLock 		:			145,
};

/**
 * Globals
 */
Rex.buffers = undefined;
Rex.layouts = undefined;
Rex.textures = undefined;
Rex.materials = undefined;
Rex.parameters = undefined;
Rex.geometries = undefined;
Rex.meshes = undefined;
Rex.lines = undefined;
Rex.labels = undefined;
Rex.images = undefined;
Rex.widgets = undefined;
Rex.scene = undefined;
Rex.engine = undefined;
Rex.webSocket = undefined;
Rex.otherScene = [];
Rex.otherGui = [];

Rex.undef = function(object, objectName) {

	let errorMessage = "";
	
	if (object === undefined) {
	
		console.error("'%s' is undefined.", objectName);
		
		return true;
	}

	if (object === null) {

		console.error("'%s' is null.", objectName);

		return true;
	}

	return false;
};

Rex.undefProp = function (container, names) {

	if(!Array.isArray(names))
		names = [names];
	
	let ret = false;
	
	for(let i = 0; i < names.length; ++i) {
		
		let name = names[i];

		if(container[name] == undefined) {
			
			console.error("Can't find '%s' in : %O", name, container);
			
			ret = true;
		}
	}
	
	return ret;
};

Rex.undefId = function(container, objectId, name) {

	if(name == undefined)
		name = "object";
	else
		name = "'" + name + "'";
	
	if(container[objectId] == undefined) {
		
		console.error("Can't find %s with id = %s in : %O", name, objectId, container);
		
		return true;
	}
	
	return false;
};



class CoreEventLoop {
	
	constructor() {
		this.tasks = [];
		this.running = true;
		this.stopped = false;
		this._loop();
	}
	
	_loop() {
		if(this.running) requestAnimationFrame(this._loop.bind(this));
		else this.destroy();
		
		if((Rex.gui != null) && (Rex.render == null)) {
			Rex.gui.positioning();
			Rex.gui.draw();
		}
		
		if(this.tasks.length === 0) return;
		let task = this.tasks.shift();
		task();
	}
	
	stop() {
		this.stopped = true;
		tasks.push(() => {
			this.running = false;
		});
	}
	
	addCoreEvent(func) {
		if(this.stopped) return false;
		this.tasks.push(func);
		return true;
	}
	
	destroy() {
		this.tasks = null;
		this._loop = null;
	}
	
}

class CoreEventListener {
	
	constructor(target, signalname, listener, func) {
		this.target = target;
		this.signalname = signalname;
		this.listener = listener;
		this.func = func;
		this.connected = true;
	}
	
	run(args) {
		if(!this.connected || this.listener._$destroyed) return;
		this.listener._$signalSystem.sender = this.target;
		if (!(this && this.func)) console.error("canot real property `apply` of undefined", this, args);
		let ret = this.func.apply(this.listener, args);
		this.listener._$signalSystem.sender = undefined;
		return ret;
	}
	
}

class CoreEvent {
	
	constructor(target) {
		this.target = target;
		this.signals = {};
		this.slots = [];
		this.sender = undefined;
	}
	
	runNow(sigName) {
		let sig = this.signals[sigName];
		if(!sig) {
			return;
		}
		let args = [].slice.call(arguments);
		args.shift();
		for(let listener of sig) {
			listener.run(args);
		}
	}
	
	run(sigName) {
		let sig = this.signals[sigName];
		if(!sig) {
			return;
		}
		let args = [].slice.call(arguments);
		args.shift();
		for(let listener of sig) {
			Rex.eventLoop.addCoreEvent(() => {
				listener.run(args);
			});
		}
	}
	
	connect(signalName, listener, funct) {
		let sig = this.signals[signalName];
		if(!sig) {
			this.signals[signalName] = [];
			sig = this.signals[signalName];
		}
		for(let list of sig) {
			if(list.listener === listener && list.signalname === signalName && list.func.name === funct.name) {
				console.warn("signal already connect", listener, signalName, funct.name);
				return null;
			}
		}
		let slot = new CoreEventListener(this.target, signalName, listener, funct);
		sig.push(slot);
		return slot;
	}
	
	disconnect(signalName, listener, funct) {
		let sig = this.signals[signalName];
		if(!sig) {
			return;
		}
		for(let list of sig) {
			if(list.listener === listener && list.signalname === signalName && list.func.name === funct.name) {
				list.connected = false;
				sig.splice(sig.indexOf(list), 1);
				let slots = listener._$signalSystem.slots;
				slots.splice(slots.indexOf(list),1);
				return;
			}
		}
	}
	
	clear() {
		for(let signalname in this.signals) {
			let arr = this.signals[signalname];
			for(let ss of arr) {
				ss.connected = false;
				let listener = ss.listener._$signalSystem;
				listener.slots.splice(listener.slots.indexOf(ss),1);
			}
		}
		this.signals = {};
		this.slots = [];
		this.sender = null;
		this.target = null;
	}
	
}

class BaseObject {
	
	constructor() {
		this._$signalSystem = new CoreEvent(this);
		this._$destroyed = false;
	}
	
	connect(target, signalname, slot) {
		let res = target._$signalSystem.connect(signalname, this, slot);
		if(res !== null)
			this._$signalSystem.slots.push(res);
	}
	
	//отключает себя от кого-то.
	disconnect(target, signalname, slot) {
		target._$signalSystem.disconnect(signalname, this, slot);
	}
	
	disconnectAll() {
		//отключаем все свои слоты( на кого я подписан). для этого мы берем таргет и отключаем себя у таргета. все,
		// он больше нам ничего не отправит
		while(this._$signalSystem.slots.length !== 0){
			let slot = this._$signalSystem.slots[0];
			slot.target._$signalSystem.disconnect(slot.signalname, this, slot.func);
		}
		//отключаем все свои сигналы (кто подписан на меня). для этого берем свои сигналы сразу и вырубаем их.
		this._$signalSystem.clear();
		
	}
	
	run(signalname) {
		this._$signalSystem.run.apply(this._$signalSystem, arguments);
	}
	
	runNow(signalname) {
		this._$signalSystem.runNow.apply(this._$signalSystem, arguments);
	}
	
	get sender() {
		return this._$signalSystem.sender;
	}
	
	destroy() {
		if(this._$destroyed) {
			return;
		}
		this._$destroyed = true;
		this.disconnectAll();
		this.onDestroy();
	}
	
	onDestroy() {}
	
}

function base64ToBuffer(base64) {
	var raw = window.atob(base64);
	var array = new Uint8Array(new ArrayBuffer(raw.length));
	for(var i = 0; i < raw.length; ++i) {
		array[i] = raw.charCodeAt(i);
	}
	return array;
}

function bufferToBase64(buffer) {
	let binary = '';
	let bytes = new Uint8Array(buffer);
	let len = bytes.byteLength;
	for(var i = 0; i < len; ++i) {
		binary += String.fromCharCode(bytes[i]);
	}
	return window.btoa(binary);
}

function translateVect(vector) {
	if(!Rex.camera || (Rex.camera.position === undefined)) return vector;
	let t = Rex.camera.getZoom();
	//console.log("zoom", t);
	let w = window.innerWidth / 2;
	let h = window.innerHeight / 2;
	let e = new Rex.Vector2((vector.x - w) / t + w + Rex.camera.position.x,
		(vector.y - h) / t + h + Rex.camera.position.y);
	//console.log("Dist", Rex.Vector2.distance(vector, e),w,h);
	return e;
}

function utf8Decode(utf8String) { //https://gist.github.com/chrisveness/bcb00eb717e6382c5608
	const unicodeString = utf8String.replace(/[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function(c) {
			var cc = ((c.charCodeAt(0) & 0x0f) << 12) | ((c.charCodeAt(1) & 0x3f) << 6) | (c.charCodeAt(2) & 0x3f);
			return String.fromCharCode(cc);
		}
	).replace(/[\u00c0-\u00df][\u0080-\u00bf]/g, function(c) {
			var cc = (c.charCodeAt(0) & 0x1f) << 6 | c.charCodeAt(1) & 0x3f;
			return String.fromCharCode(cc);
		}
	);
	return unicodeString;
}

function getParentElementByTag(currentElem, tag) {
	while (currentElem.tagName !== tag && currentElem.localName !== tag) {
		if(currentElem.parentNode.classList == null) {
			return null;
		} else
			currentElem = currentElem.parentNode;
	}
	return currentElem;
}

/**
 * @param currentElem
 * @param className - elem from class list
 */
function getParentElementByClass(currentElem, className) {
	while (!currentElem.classList.contains(className)) {
		if(currentElem.parentNode.classList == null) {
			return null;
		} else
			currentElem = currentElem.parentNode;
	}
	return currentElem;
}

function decomposeObj(obj, string) {
	return string.split('.').reduce((accumulator, currentValue) => {
		if(accumulator == null) return undefined;
		return accumulator[currentValue];
	}, obj);
}

function composeObj(obj, string, value) {
	string.split('.').reduce((accumulator, currentValue, index, array) => {
		if(accumulator[currentValue] == null) accumulator[currentValue] = {};
		if(index === array.length - 1) accumulator[currentValue] = value;
		return accumulator[currentValue];
	}, obj);
	return obj;
}

function joinTextToCompose() {
	let ret = "";
	let arg;
	for (arg in arguments) {
		ret += arguments[arg];
		ret += '.';
	}
	return ret.slice(0, -1);
}

function wrapText(context, text, x, y, maxWidth, lineHeight) {
	var words = text.split(" ");
	var countWords = words.length;
	var line = "";
	let count = 1;
	for (var n = 0; n < countWords; n++) {
		var testLine = line + words[n] + " ";
		var testWidth = context.measureText(testLine).width;
		if (testWidth > maxWidth) {
			context.fillText(line, x || 0, y || 0);
			line = words[n] + " ";
			y += lineHeight || 0;
			count++;
		} else {
			line = testLine;
		}
	}
	context.fillText(line, x, y);
	count++;
	return lineHeight * count;
}

/**
 * Log functions
 */
/** @param {...*} args */ Rex.message = function (args) { console.log.apply(console, arguments); };
/** @param {...*} args */ Rex.error = function (args) { console.error.apply(console, arguments); };

/**
 * Copies class properties
 * @param dest Destination class
 * @param src Source JSON serialized object
 */

Rex.copy = function (dest, src) {
	for (var property in src) {
		var value = dest[property];
		if (value instanceof Rex.Vector2) value.copy(src[property]);
		else if (value instanceof Rex.Vector3) value.copy(src[property]);
		else if (value instanceof Rex.Vector4) value.copy(src[property]);
		else if (value instanceof Rex.Matrix4) value.copy(src[property]);
		else if (value instanceof Uint8Array) dest[property] = new Uint8Array(base64ToBuffer(src[property]));
		else dest[property] = JSON.parse(JSON.stringify(src[property]));
	}
};

Rex.clear = function () {
	if (Rex.gui !== undefined) {
		Rex.gui.destroy();
		delete Rex.gui;
		Rex.gui = undefined;
	}
	if (Rex.camera !== undefined) {
		Rex.camera.clear();
		delete Rex.camera;
		Rex.camera = undefined;
	}
	if (Rex.render != null) {
		Rex.render.stop();
		delete Rex.render;
		Rex.render = null;
	}
	if (Rex.grid != null) {
		Rex.grid.clear();
		Rex.grid = null;
	}
	for (let id in Rex.widgets) {
		let widget = Rex.widgets[id];
		if (widget === undefined) continue;
		widget.view.destroy();
	}

	for (let id in Rex.objects) {
		let object = Rex.objects[id];
		if (object === undefined) continue;
		object.destroy();
	}

	if (Rex.scene !== undefined) Rex.scene.cleanup();
};

function needUpdate(data) {
	if (data.hasOwnProperty('destroyed')) Rex.scene.removeObjects(data.destroyed);
	if (data.hasOwnProperty('scene')) Rex.scene.setState(data.scene);
	if (data.hasOwnProperty('meshes')) Rex.scene.setObjects(Rex.meshes, data.meshes, Mesh);
	if (data.hasOwnProperty('lines')) Rex.scene.setObjects(Rex.lines, data.lines, Line);
	if (data.hasOwnProperty('labels')) Rex.scene.setObjects(Rex.labels, data.labels, Label);
	if (data.hasOwnProperty('buffers')) Rex.scene.setObjects(Rex.buffers, data.buffers, Buffer);
	if (data.hasOwnProperty('layouts')) Rex.scene.setObjects(Rex.layouts, data.layouts, Layout);
	if (data.hasOwnProperty('textures')) Rex.scene.setObjects(Rex.textures, data.textures, Texture);
	if (data.hasOwnProperty('materials')) Rex.scene.setObjects(Rex.materials, data.materials, Material);
	if (data.hasOwnProperty('parameters')) Rex.scene.setObjects(Rex.parameters, data.parameters, Parameter);
	if (data.hasOwnProperty('geometries')) Rex.scene.setObjects(Rex.geometries, data.geometries, Geometry);
	if (data.hasOwnProperty('images')) Rex.scene.setObjects(Rex.images, data.images, Rex.Image);
	if (data.hasOwnProperty('widgets')) Rex.scene.setWidgets(Rex.widgets, data.widgets);
	if (data.hasOwnProperty('objects')) Rex.scene.setRexObjects(Rex.objects, data.objects, Rex.Object);

	if (data.hasOwnProperty('camera')) Rex.scene.setCamera(data.camera, Rex.Camera);
	if (data.hasOwnProperty('gui')) Rex.scene.setGui(data.gui);
	if (Rex.scene !== undefined) Rex.scene.cleanup();
}

function checkAllObject() {
	let check = (array) => {
		for (let key in array) {
			let object = array[key];
			if (object === undefined && object.parentId != -1) continue;
			object.checkInit();
		}
	};
	check(Rex.objects);
	check(Rex.widgets);
	check(Rex.buffers);
	check(Rex.layouts);
	check(Rex.textures);
	check(Rex.materials);
	check(Rex.parameters);
	check(Rex.geometries);
	check(Rex.meshes);
	check(Rex.lines);
	check(Rex.labels);
	check(Rex.images);
}

function needCreate(data) {
	Rex.clear();
	Rex.gui = new Gui({});
	let tempImages = Rex.images;
	eval(atob(data));
	for (let key in tempImages) {
		let img = Rex.images[key];
		if (img === undefined) Rex.images[key] = tempImages[key];
	}
	checkAllObject();
	for (let i = 0; i < Rex.otherScene.length; ++i) {
		Rex.otherScene[i].updateAll();
	}
	for (let i = 0; i < Rex.otherGui.length; ++i) {
		Rex.otherGui[i].id = Rex.gui.id;
	}
	Rex.gui.redraw();
}

/**
 * Accessors
 */
//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
//Rex.getObjects = function(objects, id, constructor) {
//	debugger;
//	if(id === undefined) return id;
//	var object = objects[id];
//	if(object instanceof constructor) return object;
//	object = new constructor();
//	objects[id] = object;
//	Rex.scene.getObject(object, id);
//	return id;
//};

//Rex.getBuffer = function(id) { return Rex.getObjects(Rex.buffers, id, Rex.Buffer); };
//Rex.getLayout = function(id) { return Rex.getObjects(Rex.layouts, id, Rex.Layout); };
//Rex.getTexture = function(id) { return Rex.getObjects(Rex.textures, id, Rex.Texture); };
//Rex.getMaterial = function(id) { return Rex.getObjects(Rex.materials, id, Rex.Material); };
//Rex.getParameter = function(id) { return Rex.getObjects(Rex.parameters, id, Rex.Parameter); };
//Rex.getGeometry = function(id) { return Rex.getObjects(Rex.geometries, id, Rex.Geometry); };
//Rex.getMesh = function(id) { return Rex.getObjects(Rex.meshes, id, Rex.Mesh); };
//Rex.getLine = function(id) { return Rex.getObjects(Rex.lines, id, Rex.Line); };
//Rex.getLabel = function(id) { return Rex.getObjects(Rex.labels, id, Rex.Label); };

/**
 * класс для работы с апи других фреймов.
 * пока умеет только слать сообщения в самый верхний фрейм,
 * если очень будет надо - возможно сделать, чтобы он слал во все фреймы.
 * @instance Rex.FrameApi
 *
 * @example
 * в принимающем фрейме коннектимся на сигнал от Rex.FrameApi
 * this.connect(Rex.FrameApi,"ПАЖАР!ОГОНЬ!",this.onPozar);
 * функция или метод onPozar должна принимать один параментр-объект, у которого будут доступны следующие поля:
 * - eventName {string} - имя еще раз "ПАЖАР!ОГОНЬ!"
 * - data {?} - любая дата, которую передаст фрейм
 * - messageInfo {object} - значение location фрейма отправителя. может пригодится, для проверки от кого именно пришла команда
 *
 * в отправляющем фрейме вызываем Rex.FrameApi.sendMessage("ПАЖАР!ОГОНЬ!", любой_объект_или_значение);
 * важно! любой_объект_или_значение будет передаваться копией,
 * поэтому то что мы туда суем, должно быть КОПИРУЕМЫМ,
 * т.е. без ссылок на DOM-элементы и без циклических ссылок.
 */
class RexFrameApi__Controller extends BaseObject {
	constructor() {
		super();

		window.addEventListener('message', this._$onGetMessage.bind(this));
	}

	/**
	 * метод отправки сообщения в самый верхний фрейм
	 * @param {string} eventName - имя сигнала
	 * @param {?} data - то, что передаем
	 */
	sendMessage(eventName, data) {
		let messageInfo = {};
		try {
			messageInfo = JSON.parse(JSON.stringify(location));
		} catch (e) { }
		
		if (window.top === window.parent) {
			window.top.postMessage({ eventName, data, messageInfo },"*");
		} else {
			window.top.postMessage({ eventName, data, messageInfo },"*");
			window.parent.postMessage({ eventName, data, messageInfo },"*");
		}
	}

	/**
	 * метод, который примет сигнал от браузера в самом верхнем фрейме, и презвратит в сигнал CoreEventSystem
	 * @param {object} e - сообщение
	 * @private
	 */
	_$onGetMessage(e) {
		let data = e.data;
		if (!(data && data.eventName && data.data && data.messageInfo)) return;
		console.log("сообщение между фреймами", e, e.data);
		//TODO check messageInfo?
		this.run(data.eventName, data);
	}

	/**
	 * метод для разбора сообщения по WS от NotificationManager , т.е. пришедшее с плюсов.
	 * @param message_WS - само сообщение.
	 * @private
	 */
	_$parseMessageWS(message_WS) {
		if (!(message_WS && message_WS.eventName && message_WS.data)) {
			console.warn("RexFrameApi__Controller: чтото пошло не так", message_WS);
		}
		this.sendMessage(message_WS.eventName, message_WS.data);
	}
}

/** инстанс для {@link RexFrameApi__Controller} */
Rex.FrameApi = new RexFrameApi__Controller();

/**
 * класс-пример использования {RexFrameApi},
 * в котором мы предоставляем доступ нижним фреймам запустить любое приложение в RexWebTop.
 */
class RexFrameApi__RexWebTopApi extends BaseObject {
	constructor() {
		super();
	}
	
	/**
	 * метод который нужно вызывать из "нижних" фреймов.
	 * @param {string} name - имя приложения
	 * @param {object} [param] - аргументы для запуска
	 */
	createApp(name, param = {}) {
		let data = {name,param};
		Rex.FrameApi.sendMessage("Core.app.createApp",data);
	}
	

}

/** для простоты тоже инстанцируем этот класс в рексе. */
Rex.WebTop = new RexFrameApi__RexWebTopApi();

class Socket {
	
	constructor() {
		this.webSocket = undefined;
	}
	
	handleWebSocket(event) {
		var parseData = JSON.parse(event.data);
		if(parseData.hasOwnProperty("notification")) {
			var type = parseData.notification.type;
			if(type === undefined) return;
			if(type == "create") needCreate(parseData.notification.data);
			else if(type == "update") needUpdate(parseData.notification.data);
			//else if(type == "message") alert(parseData.notification.data);
			else if(type == "link") window.open(parseData.notification.data, "_blank");
			else if(type == "drag" && Rex.gui !== undefined) Rex.gui.dragAndDrop.data = parseData.notification.data;
			else if(type == "Rex.FrameApi") Rex.FrameApi._$parseMessageWS(parseData.notification.data);
			else if(Rex.gui !== undefined) Rex.gui.notificationManager.message(parseData.notification.data, type);
		}
	}
	
	initWebSocket() {
		let url = window.location.href.replace("http", "ws");
		let indexBad = url.indexOf("#");
		if(indexBad != -1)
			url = url.replace(url.slice(indexBad, url.length), ""); // remove #!!!
		this.webSocket = new WebSocket(url);
		
		this.webSocket.onopen = function() {
			console.info("Web Socket connected to " + url);
		};
		
		this.webSocket.onclose = function(event) {
			if(event.wasClean) {
				//alert('Norm close');
				Rex.gui.notificationManager.message('Code: ' + event.code + ' Message: ' + event.reason + " Norm close", "error");
				Rex.gui.redraw();
			} else {
				// alert('Disconnect');
				Rex.gui.notificationManager.message('Code: ' + event.code + ' Message: ' + event.reason + " Disconnect", "error");
				Rex.gui.redraw();
			}
			//alert('Code: ' + event.code + ' Message: ' + event.reason);
		};
		
		this.webSocket.onerror = function(error) {
			alert("Error " + error.message);
		};
		
		document.onbeforeunload = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		document.onunload = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		document.onclose = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		window.onbeforeunload = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		window.onunload = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		window.onclose = function(e) {console.log(e); this.shutdownWebSocket(); }.bind(this);
		
		this.webSocket.onmessage = function(event) {
			Rex.engine = new Engine();
			this.handleWebSocket(event);
			this.webSocket.onmessage = this.handleWebSocket;
		}.bind(this);
	}
	
	shutdownWebSocket() {
		if(this.webSocket === undefined) return;
		Rex.callRpcFunction("RexEngine", "close", []);
		this.webSocket.onclose = function(){};
		this.webSocket.close();
		delete this.webSocket;
		this.webSocket = undefined;
	}
	
}

/**
 * Reqest function
 */
Rex.request = function() {
	if(window.XMLHttpRequest) return new XMLHttpRequest();
	return new ActiveXObject("Microsoft.XMLHTTP");
};

Rex.callRpcFunction = function(library, name, args) {
	if(Rex.webSocket === undefined) return;
	if(Rex.webSocket.webSocket.readyState == WebSocket.CLOSING || Rex.webSocket.webSocket.readyState == WebSocket.CLOSED || Rex.webSocket.webSocket.readyState != WebSocket.OPEN) return;
	var content = {
		function : library + '.' + name,
		args : args
	};
	Rex.webSocket.webSocket.send(JSON.stringify(content));
};

Rex.callWebWidgetMethod = function(instanceId, method, args) {
	if(Rex.widgets == null || Rex.webScene == null) return;
	let object = Rex.webScene.findObject(instanceId);
	if(object == null) {
		for(let gui of Rex.otherGui) {
			if(gui.getID() != instanceId) continue;
			object = gui;
			break;
		}
	}
	if(object != null) object[method].apply(object,args);
};

Rex.callRpcMethod = function(library, instanceId, className, method, args) {
	if(Rex.webSocket === undefined || Rex.webSocket.webSocket.readyState == WebSocket.CLOSING || Rex.webSocket.readyState == WebSocket.CLOSED ||
	   Rex.webSocket.webSocket.readyState != WebSocket.OPEN) {
		Rex.callWebWidgetMethod(instanceId, method, args);
		return;
	} else {
		Rex.callWebWidgetMethod(instanceId, method, args);
	}
	var content = {
		method : library + '.' + className + '.' + method + '.' + instanceId,
		args : args
	};
	Rex.webSocket.webSocket.send(JSON.stringify(content));
};

/**
 * Fullscreen application
 */
Rex.requestFullscreen = function() {
	var body = document.body;
	body.requestFullscreen = body.requestFullscreen || body.mozRequestFullScreen || body.webkitRequestFullscreen;
	document.addEventListener("click", function() { body.requestFullscreen(); });
};

/* eslint-disable no-unused-vars */
/* global Scene Rex Mouse KeyBoard Socket CoreEventLoop Gui*/


/**
 * Base class for Rex object
 */
class RexObject {

	constructor() {
		this._parentId = -2;
		this.inited = false;
		this.preInitChecked = false;
	}

	set parentId(value) {
		if (value != this._parentId) {
			this._parentId = value;
			//this.view.destroy();
		}
	}
	
	get parentId() {
		return this._parentId;
	}

	dynamicInit() {
		this.init();
		for (let i = 0; i < this.children.length; ++i) {
			let child = Scene.findObject(this.children[i]);
			if (child !== undefined) child.dynamicInit();
		}
	}

	init() {
		if (this.inited) return;
		this.onInit();
		this.inited = true;
		this.preInitChecked = true;
		this.onSuccessInit();
	}

	/**
	 * Need override!
	 */
	onInit() {}
	onSuccessInit() {}
	onCheckInit() {
		return true;
	}

	checkInit() {
		if (this.inited) return true;
		if (!this.onCheckInit()) return false;
		let parent = Scene.findObject(this.parentId);
		if ((this.parentId != -1) && (parent === undefined)) return false;
		for (let i = 0; i < this.children.length; ++i) {
			let child = Scene.findObject(this.children[i]);
			if (child === undefined) return false;
		}
		if (parent !== undefined && !parent.preInitChecked) {
			parent.checkInit();
			return false;
		}
		this.preInitChecked = true;
		for (let i = 0; i < this.children.length; ++i) {
			let child = Scene.findObject(this.children[i]);
			this.preInitChecked = child.checkInit();
			if (!this.preInitChecked) return false;
		}
		if (parent === undefined || parent.inited) {
			this.dynamicInit();
			//if(Rex.gui !== undefined) Rex.gui.reposition(this);
		}
		return true;
	}

}

/**
 * Initialize Rex
 */
Rex.init = function (web) {
	Rex.eventLoop = new CoreEventLoop();
	Mouse.get();
	KeyBoard.get();
	Rex.gui = new Gui({});
	let container = document.getElementsByClassName("container")[0];
	Rex.container = container.cloneNode(true);
	document.body.removeChild(container);

	//drag and drop into scene fix 27.05.19
	let container1 = document.getElementById("container1");
	container1.ondragover = (e) => e.preventDefault();
	container1.ondrop = e => {
		let cPos = translateVect(new Rex.Vector2(e.clientX, e.clientY));

		let dropData = {};
		dropData.receiver = -1;
		dropData.pos = {x : Math.floor(cPos.x), y : Math.floor(cPos.y)};
		dropData.data = {};

		Rex.gui.drop(dropData);
	};

	if (web != null) return;
	Rex.webSocket = new Socket();
	Rex.webSocket.initWebSocket();
};


class Listener {
	
	constructor(object, name, handler) {
		this.object = object;
		this.name = name;
		this.handler = handler;
	}
	
};

class EventSystem {
	
	constructor() {
		this.listeners = [];
	}
	
	add(object, name, handler) {
		if(this.find(name) !== undefined) {
			console.error("Already exist listener " + name + ".");
			return false;
		}
		this.listeners.push(new Listener(object, name, handler));
		object.addEventListener(name, handler);
		return true;
	}
	
	find(name) {
		for(let i = 0; i < this.listeners.length; ++i) {
			let listener = this.listeners[i];
			if(listener.name == name) return listener;
		}
		return undefined;
	}
	
	remove(name) {
		let listener = this.find(name);
		if(listener === undefined) {
			console.error("Can't remove event listener " + name + ".");
			return false;
		}
		listener.object.removeEventListener(listener.name, listener.handler);
		return true;
	}
	
	clear() {
		for(let i = 0; i < this.listeners.length; ++i) {
			let listener = this.listeners[i];
			listener.object.removeEventListener(listener.name, listener.handler);
		}
		this.listeners = [];
	}
	
};

// Rex header

Rex.compare = function(v0, v1, epsilon) {
	return (Math.abs(v0 - v1) < (epsilon === undefined ? 1e-6 : epsilon));
};

/**
 * Vector2
 * @constructor
 * @param {number=} y
 * @param {number=} x
 */
Rex.Vector2 = function(x, y) {
	this.x = x || 0;
	this.y = y || 0;
};

/**
 * Prototype
 */
Rex.Vector2.prototype = {
	
	constructor: Rex.Vector2,
	
	set: function(x, y) {
		this.x = x || 0;
		this.y = y || 0;
		return this;
	},
	copy: function(v) {
		this.x = v[0];
		this.y = v[1];
		return this;
	},
	scale: function(v) {
		this.x *= v;
		this.y *= v;
		return this;
	},
	
	add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		return new Rex.Vector2(x, y);
	},
	sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		return new Rex.Vector2(x, y);
	},
	mul: function(v) {
		var x = this.x * v.x;
		var y = this.y * v.y;
		return new Rex.Vector2(x, y);
	},
	dot: function(v) {
		return this.x * v.x + this.y * v.y;
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},
	length2: function() {
		return this.x * this.x + this.y * this.y;
	},
	normalize: function() {
		return this.scale(1 / this.length());
	}
};

Rex.Vector2.distance = function(vec1, vec2) {
	return vec1.sub(vec2).length();
};
Rex.Vector2.compare = function(a, b) {
	if((a.x - b.x) < -Number.EPSILON || (a.x - b.x) > Number.EPSILON) return false;
	if((a.y - b.y) < -Number.EPSILON || (a.y - b.y) > Number.EPSILON) return false;
	return a.sub(b).length2() < Number.EPSILON * Number.EPSILON;
};

/**
 * Vector3
 * @constructor
 * @param {number=} z
 * @param {number=} y
 * @param {number=} x
 */
Rex.Vector3 = function(x, y, z) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
};

/**
 * Prototype
 */
Rex.Vector3.prototype = {
	
	constructor: Rex.Vector3,
	
	set: function(x, y, z) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		return this;
	},
	copy: function(v) {
		this.x = v[0];
		this.y = v[1];
		this.z = v[2];
		return this;
	},
	scale: function(v) {
		this.x *= v;
		this.y *= v;
		this.z *= v;
		return this;
	},
	div: function(v) {
		this.x /= v;
		this.y /= v;
		this.z /= v;
		return this;
	},
	add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		return new Rex.Vector3(x, y, z);
	},
	sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		return new Rex.Vector3(x, y, z);
	},
	mul: function(v) {
		var x = this.x * v.x;
		var y = this.y * v.y;
		var z = this.z * v.z;
		return new Rex.Vector3(x, y, z);
	},
	
	cross: function(v) {
		var x = this.y * v.z - this.z * v.y;
		var y = this.z * v.x - this.x * v.z;
		var z = this.x * v.y - this.y * v.x;
		return new Rex.Vector3(x, y, z);
	},
	dot: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z;
	},
	dot4: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + v.w;
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	},
	normalize: function() {
		return this.scale(1 / this.length());
	}
};

/**
 * Vector4
 * @constructor
 * @param {number=} w
 * @param {number=} z
 * @param {number=} y
 * @param {number=} x
 */
Rex.Vector4 = function(x, y, z, w) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = w || 0;
};

/**
 * Prototype
 */
Rex.Vector4.prototype = {
	
	constructor: Rex.Vector4,
	
	set: function(x, y, z, w) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = w || 0;
		return this;
	},
	copy: function(v) {
		this.x = v[0];
		this.y = v[1];
		this.z = v[2];
		this.w = v[3];
		return this;
	},
	scale: function(v) {
		this.x *= v;
		this.y *= v;
		this.z *= v;
		this.w *= v;
		return this;
	},
	
	add: function(v) {
		var x = this.x + v.x;
		var y = this.y + v.y;
		var z = this.z + v.z;
		var w = this.w + v.w;
		return new Rex.Vector4(x, y, z, w);
	},
	sub: function(v) {
		var x = this.x - v.x;
		var y = this.y - v.y;
		var z = this.z - v.z;
		var w = this.w - v.w;
		return new Rex.Vector4(x, y, z, w);
	},
	mul: function(v) {
		var x = this.x * v.x;
		var y = this.y * v.y;
		var z = this.z * v.z;
		var w = this.w * v.w;
		return new Rex.Vector4(x, y, z, w);
	},
	
	dot3: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w;
	},
	dot: function(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	},
	length3: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	},
	normalize: function() {
		return this.scale(1 / this.length());
	}
};

/**
 * Matrix2
 * @constructor
 * @param {number=} m11
 * @param {number=} m10
 * @param {number=} m01
 * @param {number=} m00
 */
Rex.Matrix2 = function(m00, m01, m10, m11) {
	this.m = new Float32Array([
		m00 || 0, m10 || 0,
		m01 || 0, m11 || 0
	]);
};

/**
 * Prototype
 */
Rex.Matrix2.prototype = {
	
	constructor: Rex.Matrix2,
	
	set: function(m00, m01, m10, m11) {
		var m = this.m;
		m[0] = m00; m[2] = m01;
		m[1] = m10; m[3] = m11;
		return this;
	},
	setElement: function(row, column, v) {
		this.m[column * 2 + row] = v;
		return this;
	}, 
	get: function(row, column) {
		return this.m[column * 2 + row];
	},
	getIdentity: function() {
		var m = this.m;
		m[0] = 1; m[2] = 0;
		m[1] = 0; m[3] = 1;
		return this;
	},
	setRotate(angle) {
		var m = this.m;
		let s = Math.sin(angle * Rex.Deg2Rad);
		let c = Math.cos(angle * Rex.Deg2Rad);
		m[0] = c; m[2] = -s;
		m[1] = s; m[3] = c;
		return this;
	},
	mulVector2: function(v) {
		var m = this.m;
		var vx = v.x, vy = v.y;
		var x = m[0] * vx + m[2] * vy;
		var y = m[1] * vx + m[3] * vy;
		return new Rex.Vector2(x, y);
	},
	getTranspose: function() {
		var m = this.m;
		return new Rex.Matrix2(
			m[0],  m[1],
			m[2],  m[3]
		);
	}
};

/**
 * Globals
 */
Rex.Matrix2.rotate = function(angle) {
	let s = Math.sin(angle * Rex.Deg2Rad);
	let c = Math.cos(angle * Rex.Deg2Rad);
	return new Rex.Matrix2(
		c, -s,
		s, c
	);
};

/**
 * Matrix4
 * @constructor
 * @param {number=} m33
 * @param {number=} m32
 * @param {number=} m31
 * @param {number=} m30
 * @param {number=} m23
 * @param {number=} m22
 * @param {number=} m21
 * @param {number=} m20
 * @param {number=} m13
 * @param {number=} m12
 * @param {number=} m11
 * @param {number=} m10
 * @param {number=} m03
 * @param {number=} m02
 * @param {number=} m01
 * @param {number=} m00
 */
Rex.Matrix4 = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	this.m = new Float32Array([
		m00 || 0, m10 || 0, m20 || 0, m30 || 0,
		m01 || 0, m11 || 0, m21 || 0, m31 || 0,
		m02 || 0, m12 || 0, m22 || 0, m32 || 0,
		m03 || 0, m13 || 0, m23 || 0, m33 || 0
	]);
};

/**
 * Prototype
 */
Rex.Matrix4.prototype = {
	
	constructor: Rex.Matrix4,
	
	set: function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
		var m = this.m;
		m[0] = m00; m[4] = m01; m[8] = m02;  m[12] = m03;
		m[1] = m10; m[5] = m11; m[9] = m12;  m[13] = m13;
		m[2] = m20; m[6] = m21; m[10] = m22; m[14] = m23;
		m[3] = m30; m[7] = m31; m[11] = m32; m[15] = m33;
		return this;
	},
	setColumn3: function(column, vec) {
		var m = this.m;
		switch(column) {
			case 0: {
				m[0] = vec.x;
				m[1] = vec.y;
				m[2] = vec.z;
				break;
			}
			case 1: {
				m[4] = vec.x;
				m[5] = vec.y;
				m[6] = vec.z;
				break;
			}
			case 2: {
				m[8] = vec.x;
				m[9] = vec.y;
				m[10] = vec.z;
				break;
			}
			case 3: {
				m[12] = vec.x;
				m[13] = vec.y;
				m[14] = vec.z;
				break;
			}
			default: {
				m[0] = vec.x;
				m[1] = vec.y;
				m[2] = vec.z;
				break;
			}
		}
		return this;
	},
	copy: function(v) {
		var m = this.m;
		m[0] = v[0]; m[4] = v[4]; m[8] = v[8];   m[12] = v[12];
		m[1] = v[1]; m[5] = v[5]; m[9] = v[9];   m[13] = v[13];
		m[2] = v[2]; m[6] = v[6]; m[10] = v[10]; m[14] = v[14];
		m[3] = v[3]; m[7] = v[7]; m[11] = v[11]; m[15] = v[15];
		return this;
	},
	getIdentity: function() {
		var m = this.m;
		m[0] = 1; m[4] = 0; m[8] = 0;  m[12] = 0;
		m[1] = 0; m[5] = 1; m[9] = 0;  m[13] = 0;
		m[2] = 0; m[6] = 0; m[10] = 1; m[14] = 0;
		m[3] = 0; m[7] = 0; m[11] = 0; m[15] = 1;
		return this;
	},
	getColumn3: function(column) {
		var m = this.m;
		let col = new Rex.Vector3();
		switch(column) {
			case 0: {
				col.x = m[0];
				col.y = m[1];
				col.z = m[2];
				break;
			}
			case 1: {
				col.x = m[4];
				col.y = m[5];
				col.z = m[6];
				break;
			}
			case 2: {
				col.x = m[8];
				col.y = m[9];
				col.z = m[10];
				break;
			}
			case 3: {
				col.x = m[12];
				col.y = m[13];
				col.z = m[14];
				break;
			}
			default: {
				col.x = m[0];
				col.y = m[1];
				col.z = m[2];
				break;
			}
		}
		return col;
	},
	getScale: function() {
		var m = this.m;
		var x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
		var y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
		var z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
		return new Rex.Vector3(x, y, z);
	},
	getTranslate: function() {
		var m = this.m;
		return new Rex.Vector3(m[12], m[13], m[14]);
	},
	getRotate: function() {
		var m = this.m;
		return new Rex.Matrix4(
			m[0], m[4],  m[8], 0,
			m[1], m[5],  m[9], 0,
			m[2], m[6], m[10], 0,
			   0,    0,     0, 1
		);
	},
	
	getTranspose: function() {
		var m = this.m;
		return new Rex.Matrix4(
			 m[0],  m[1],  m[2], m[3],
			 m[4],  m[5],  m[6], m[7],
			 m[8],  m[9], m[10], m[11],
			m[12], m[13], m[14], m[15]
		);
	},
	getInverse43: function() {
		var m = this.m;
		var m00 = m[0], m01 = m[4], m02 = m[8],  m03 = m[12];
		var m10 = m[1], m11 = m[5], m12 = m[9],  m13 = m[13];
		var m20 = m[2], m21 = m[6], m22 = m[10], m23 = m[14];
		var x = m00 * (m11 * m22 - m12 * m21);
		var y = m01 * (m10 * m22 - m12 * m20);
		var z = m02 * (m10 * m21 - m11 * m20);
		var scale = 1 / (x - y + z);
		var ret = new Rex.Matrix4();
		m = ret.m;
		m[0] = (m11 * m22 - m12 * m21) * scale;
		m[1] = (m12 * m20 - m10 * m22) * scale;
		m[2] = (m10 * m21 - m11 * m20) * scale;
		m[4] = (m02 * m21 - m01 * m22) * scale;
		m[5] = (m00 * m22 - m02 * m20) * scale;
		m[6] = (m01 * m20 - m00 * m21) * scale;
		m[8] = (m01 * m12 - m02 * m11) * scale;
		m[9] = (m02 * m10 - m00 * m12) * scale;
		m[10] = (m00 * m11 - m01 * m10) * scale;
		m[12] = -m[0] * m03 - m[4] * m13 - m[8] * m23;
		m[13] = -m[1] * m03 - m[5] * m13 - m[9] * m23;
		m[14] = -m[2] * m03 - m[6] * m13 - m[10] * m23;
		m[15] = 1;
		return ret;
	},
	
	mul: function(m) {
		var m0_m = this.m;
		var m1_m = m.m;
		var m0_m00 = m0_m[0], m0_m01 = m0_m[4], m0_m02 = m0_m[8],  m0_m03 = m0_m[12];
		var m0_m10 = m0_m[1], m0_m11 = m0_m[5], m0_m12 = m0_m[9],  m0_m13 = m0_m[13];
		var m0_m20 = m0_m[2], m0_m21 = m0_m[6], m0_m22 = m0_m[10], m0_m23 = m0_m[14];
		var m0_m30 = m0_m[3], m0_m31 = m0_m[7], m0_m32 = m0_m[11], m0_m33 = m0_m[15];
		var m1_m00 = m1_m[0], m1_m01 = m1_m[4], m1_m02 = m1_m[8],  m1_m03 = m1_m[12];
		var m1_m10 = m1_m[1], m1_m11 = m1_m[5], m1_m12 = m1_m[9],  m1_m13 = m1_m[13];
		var m1_m20 = m1_m[2], m1_m21 = m1_m[6], m1_m22 = m1_m[10], m1_m23 = m1_m[14];
		var m1_m30 = m1_m[3], m1_m31 = m1_m[7], m1_m32 = m1_m[11], m1_m33 = m1_m[15];
		var m00 = m0_m00 * m1_m00 + m0_m01 * m1_m10 + m0_m02 * m1_m20 + m0_m03 * m1_m30;
		var m10 = m0_m10 * m1_m00 + m0_m11 * m1_m10 + m0_m12 * m1_m20 + m0_m13 * m1_m30;
		var m20 = m0_m20 * m1_m00 + m0_m21 * m1_m10 + m0_m22 * m1_m20 + m0_m23 * m1_m30;
		var m30 = m0_m30 * m1_m00 + m0_m31 * m1_m10 + m0_m32 * m1_m20 + m0_m33 * m1_m30;
		var m01 = m0_m00 * m1_m01 + m0_m01 * m1_m11 + m0_m02 * m1_m21 + m0_m03 * m1_m31;
		var m11 = m0_m10 * m1_m01 + m0_m11 * m1_m11 + m0_m12 * m1_m21 + m0_m13 * m1_m31;
		var m21 = m0_m20 * m1_m01 + m0_m21 * m1_m11 + m0_m22 * m1_m21 + m0_m23 * m1_m31;
		var m31 = m0_m30 * m1_m01 + m0_m31 * m1_m11 + m0_m32 * m1_m21 + m0_m33 * m1_m31;
		var m02 = m0_m00 * m1_m02 + m0_m01 * m1_m12 + m0_m02 * m1_m22 + m0_m03 * m1_m32;
		var m12 = m0_m10 * m1_m02 + m0_m11 * m1_m12 + m0_m12 * m1_m22 + m0_m13 * m1_m32;
		var m22 = m0_m20 * m1_m02 + m0_m21 * m1_m12 + m0_m22 * m1_m22 + m0_m23 * m1_m32;
		var m32 = m0_m30 * m1_m02 + m0_m31 * m1_m12 + m0_m32 * m1_m22 + m0_m33 * m1_m32;
		var m03 = m0_m00 * m1_m03 + m0_m01 * m1_m13 + m0_m02 * m1_m23 + m0_m03 * m1_m33;
		var m13 = m0_m10 * m1_m03 + m0_m11 * m1_m13 + m0_m12 * m1_m23 + m0_m13 * m1_m33;
		var m23 = m0_m20 * m1_m03 + m0_m21 * m1_m13 + m0_m22 * m1_m23 + m0_m23 * m1_m33;
		var m33 = m0_m30 * m1_m03 + m0_m31 * m1_m13 + m0_m32 * m1_m23 + m0_m33 * m1_m33;
		return new Rex.Matrix4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
	},
	mulVector3: function(v) {
		var m = this.m;
		var vx = v.x, vy = v.y, vz = v.z;
		var x = m[0] * vx + m[4] * vy + m[8] * vz + m[12];
		var y = m[1] * vx + m[5] * vy + m[9] * vz + m[13];
		var z = m[2] * vx + m[6] * vy + m[10] * vz + m[14];
		return new Rex.Vector3(x, y, z);
	},
	mulVector4: function(v) {
		var m = this.m;
		var vx = v.x, vy = v.y, vz = v.z, vw = v.w;
		var x = m[0] * vx + m[4] * vy + m[8] * vz + m[12] * vw;
		var y = m[1] * vx + m[5] * vy + m[9] * vz + m[13] * vw;
		var z = m[2] * vx + m[6] * vy + m[10] * vz + m[14] * vw;
		var w = m[3] * vx + m[7] * vy + m[11] * vz + m[14] * vw;
		return new Rex.Vector4(x, y, z, w);
	},
	
	toQuaternion: function() {
		var x, y, z, w;
		var mm = this.m;
		var trace = mm[0] + mm[5] + mm[10];
		if(trace > 0) {
			var s = Math.sqrt(trace + 1) * 2;
			x = (mm[6] - mm[9]) / s;
			y = (mm[8] - mm[2]) / s;
			z = (mm[1] - mm[4]) / s;
			w = s * 0.25;
		} else if(mm[0] > mm[5] && mm[0] > mm[10]) {
			var s = Math.sqrt(1 + mm[0] - mm[5] - mm[10]) * 2;
			x = s * 0.25;
			y = (mm[4] + mm[1]) / s;
			z = (mm[8] + mm[2]) / s;
			w = (mm[6] - mm[9]) / s;
		} else if(mm[5] > mm[10]) {
			var s = Math.sqrt(1 + mm[5] - mm[0] - mm[10]) * 2;
			x = (mm[4] + mm[1]) / s;
			y = s * 0.25;
			z = (mm[9] + mm[6]) / s;
			w = (mm[8] - mm[2]) / s;
		} else {
			var s = Math.sqrt(1 + mm[10] - mm[0] - mm[5]) * 2;
			x = (mm[8] + mm[2]) / s;
			y = (mm[9] + mm[6]) / s;
			z = s * 0.25;
			w = (mm[1] - mm[4]) / s;
		}
		return new Rex.Quaternion(x, y, z, w);
	},
	
	equal: function(mat) {
		return Rex.compare(this.m[0], mat.m[0]) &&
			Rex.compare(this.m[1], mat.m[1]) &&
			Rex.compare(this.m[2], mat.m[2]) &&
			Rex.compare(this.m[3], mat.m[3]) &&
			Rex.compare(this.m[4], mat.m[4]) &&
			Rex.compare(this.m[5], mat.m[5]) &&
			Rex.compare(this.m[6], mat.m[6]) &&
			Rex.compare(this.m[7], mat.m[7]) &&
			Rex.compare(this.m[8], mat.m[8]) &&
			Rex.compare(this.m[9], mat.m[9]) &&
			Rex.compare(this.m[10], mat.m[10]) &&
			Rex.compare(this.m[11], mat.m[11]) &&
			Rex.compare(this.m[12], mat.m[12]) &&
			Rex.compare(this.m[13], mat.m[13]) &&
			Rex.compare(this.m[14], mat.m[14]) &&
			Rex.compare(this.m[15], mat.m[15]);
	}
	
};

/**
 * Globals
 */
Rex.Matrix4.scale = function(x, y, z) {
	return new Rex.Matrix4(
		x, 0, 0, 0,
		0, y, 0, 0,
		0, 0, z, 0,
		0, 0, 0, 1
	);
};

Rex.Matrix4.translate = function(x, y, z) {
	return new Rex.Matrix4(
		1, 0, 0, x || 0,
		0, 1, 0, y || 0,
		0, 0, 1, z || 0,
		0, 0, 0, 1
	);
};

Rex.Matrix4.rotateX = function(angle) {
	var s = Math.sin(angle * Rex.Deg2Rad);
	var c = Math.cos(angle * Rex.Deg2Rad);
	return new Rex.Matrix4(
		1, 0,  0, 0,
		0, c, -s, 0,
		0, s,  c, 0,
		0, 0,  0, 1
	);
};

Rex.Matrix4.rotateY = function(angle) {
	var s = Math.sin(angle * Rex.Deg2Rad);
	var c = Math.cos(angle * Rex.Deg2Rad);
	return new Rex.Matrix4(
		 c, 0, s, 0,
		 0, 1, 0, 0,
		-s, 0, c, 0,
		 0, 0, 0, 1
	);
};
Rex.Matrix4.rotateZ = function(angle) {
	var s = Math.sin(angle * Rex.Deg2Rad);
	var c = Math.cos(angle * Rex.Deg2Rad);
	return new Rex.Matrix4(
		c, -s, 0, 0,
		s,  c, 0, 0,
		0,  0, 1, 0,
		0,  0, 0, 1
	);
};

Rex.Matrix4.lookAt = function(from, to, up) {
	var z = from.sub(to).normalize();
	var x = up.cross(z).normalize();
	var y = z.cross(x).normalize();
	return new Rex.Matrix4(
		x.x, x.y, x.z, -from.dot(x),
		y.x, y.y, y.z, -from.dot(y),
		z.x, z.y, z.z, -from.dot(z),
		  0,   0,   0,   1
	);
};

Rex.Matrix4.perspective = function(fov, aspect, near, far) {
	var h = Math.tan(Math.PI * 0.5 - Math.PI * fov / 360);
	var w = h / aspect;
	var nf = near - far;
	return new Rex.Matrix4(
		w, 0,  0, 0,
		0, h,  0, 0,
		0, 0,  (near + far) / nf, 2 * near * far / nf,
		0, 0, -1, 1
	);
};

Rex.Matrix4.ortho = function(left, right, bottom, top, near, far) {
	let rl = right - left;
	let tb = top - bottom;
	let fn = far - near;
	return new Rex.Matrix4(
		2 / rl, 0,      0,       -(right + left) / rl,
		0,      2 / tb, 0,       -(top + bottom) / tb,
		0,      0,      -2 / fn, -(far + near) / fn,
		0,      0,      0,       1
	);
};

/**
 * Quaternion
 * @constructor
 * @param {number=} w
 * @param {number=} z
 * @param {number=} y
 * @param {number=} x
 */
Rex.Quaternion = function(x, y, z, w) {
	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = w || 1;
};

/**
 * Prototype
 */
Rex.Quaternion.prototype = {
	
	constructor: Rex.Quaternion,
	
	set: function(x, y, z, w) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = w || 0;
		return this;
	},
	setAxisAngle: function(axis, angle) {
		var s = Math.sin(angle * 0.5);
		var c = Math.cos(angle * 0.5);
		var ilength = 1 / axis.length();
		this.x = axis.x * ilength * s;
		this.y = axis.y * ilength * s;
		this.z = axis.z * ilength * s;
		this.w = c;
		return this;
	},
	copy: function(v) {
		this.x = v[0];
		this.y = v[1];
		this.z = v[2];
		this.w = v[3];
		return this;
	},
	
	mul: function(q) {
		var x =  this.x * q.w + this.y * q.z - this.z * q.y + this.w * q.x;
		var y = -this.x * q.z + this.y * q.w + this.z * q.x + this.w * q.y;
		var z =  this.x * q.y - this.y * q.x + this.z * q.w + this.w * q.z;
		var w = -this.x * q.x - this.y * q.y - this.z * q.z + this.w * q.w;
		return new Rex.Quaternion(x, y, z, w);
	},
	
	toMatrix: function() {
		var x2 = this.x * 2;
		var y2 = this.y * 2;
		var z2 = this.z * 2;
		var xx2 = this.x * x2;
		var xy2 = this.x * y2;
		var yy2 = this.y * y2;
		var yz2 = this.y * z2;
		var zx2 = this.z * x2;
		var zz2 = this.z * z2;
		var wx2 = this.w * x2;
		var wy2 = this.w * y2;
		var wz2 = this.w * z2;
		var m00 = 1 - yy2 - zz2; var m01 = xy2 - wz2;     var m02 = zx2 + wy2;     var m03 = 0;
		var m10 = xy2 + wz2;     var m11 = 1 - xx2 - zz2; var m12 = yz2 - wx2;     var m13 = 0;
		var m20 = zx2 - wy2;     var m21 = yz2 + wx2;     var m22 = 1 - xx2 - yy2; var m23 = 0;
		var m30 = 0;             var m31 = 0;             var m32 = 0;             var m33 = 1;
		return new Rex.Matrix4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
	}
};

/**
 * BoundBox
 * @constructor
 * @param {number=} min
 * @param {number=} max
 */

Rex.BoundBox = function(min, max) {
	this.min = min;
	this.max = max;
};

/**
 * Prototype
 */
Rex.BoundBox.prototype = {
	
	constructor: Rex.BoundBox,
	
	inside: function(point, radius) {
		if(this.min.x > point.x + radius || this.max.x < point.x - radius) return 0;
		if(this.min.y > point.y + radius || this.max.y < point.y - radius) return 0;
		return 1;
	}
	
};

/**
 * Globals
 */
Rex.Quaternion.rotate = function(axis, angle) {
	var s = Math.sin(angle * Rex.Deg2Rad);
	var c = Math.cos(angle * Rex.Deg2Rad);
	var length = axis.length();
	return new Rex.Quaternion(
		axis.x * s / length,
		axis.y * s / length,
		axis.z * s / length,
		c
	);
};

Rex.getPlaneDistance = function(pt, normal) {
	return -pt.dot(normal);
};

Rex.clamp = function(v, v0, v1) {
	if(v < v0) return v0;
	if(v > v1) return v1;
	return v;
};


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex Color Camera2D CameraOrbit CameraOrtho Gui*/

/**
 * Scene
 * @constructor
 */
class Scene {

	constructor(state) {
		this.background = new Rex.Vector4();
		this.parameters = [];
		this.request = undefined;
		this.customBackground = false;
		if (state !== undefined) Rex.copy(this, state);
		this.needDestroy = [];
		this.setColor();

		if(Rex.scene)
			this.userCustomCSSStyles = Rex.scene.userCustomCSSStyles;
		else 
			this.userCustomCSSStyles = {};

		this.setCustomCSSStyles(this.userCSSStyles);

	}

	setColor(newColor) {
		let color = new Color();
		color.r = this.background.x;
		color.g = this.background.y;
		color.b = this.background.z;
		color.a = this.background.w;

		if ((newColor != null) && !this.customBackground) {
			this.customBackground = true;
			this.background = newColor;
			color.r = newColor.x;
			color.g = newColor.y;
			color.b = newColor.z;
			color.a = newColor.w;
		} else if (!this.customBackground && (Rex.gui != null)) {
			color.fromString(Rex.gui.styleLibrary.getParam("Scene", "backgroundColor", "rgba(0,0,0,0.9)"));
			this.background.x = color.r / 255;
			this.background.y = color.g / 255;
			this.background.z = color.b / 255;
			this.background.w = color.a / 255;
		}
		document.body.style.backgroundColor = `rgba(${color.r},${color.g},${color.b},${color.a / 255})`;
	}

	setParameters(parameters) {
		this.parameters = parameters;
	}

	setCustomCSSStyles(state) {
		if(!state) return;

		// clear
		for (const item in this.userCustomCSSStyles) {
			let v = state[item];
			if (v) continue;
			this.userCustomCSSStyles[item].remove();
			delete this.userCustomCSSStyles[item];
		}

		// add
		for (const item in state) {
			if (this.userCustomCSSStyles[item]) continue;
			let rule = item;
			try {
				rule = decodeURIComponent(escape(window.atob(item)));
			} catch (e) {
				continue;
			}
			let data = state[item];
			try {
				data = decodeURIComponent(escape(window.atob(data)));
			} catch (e) {
				continue;
			}
			let sheet = document.createElement("style")
			sheet.innerHTML = rule + "{" + data + "}";
			document.body.appendChild(sheet);
			this.userCustomCSSStyles[item] = sheet;
		}
	}

	setClipBoard(state) {

		let data = "";
		try {
			data = decodeURIComponent(escape(window.atob(state)));
		} catch (e) {
			console.log(this.widget.type, "clipBoardData ->", "Text DecodeError!", e);
			return;
		}

		if (navigator.clipboard) { // async	
			navigator.clipboard.writeText(data).then(function () {
				console.log("Async: Copying to clipboard was successful!");
			}, function (err) {
				console.error("Async: Could not copy text: ", err);
			});

		} else if (window.clipboardData) { // IE
			window.clipboardData.setData("Text", data);
		} else { // sync
			const commandSuppotr = document.queryCommandSupported;
			const commandCopySuppotr = document.queryCommandSupported("copy");

			let el = document.createElement("textarea");
			el.value = data;
			el.setAttribute("readonly", true);
			document.body.appendChild(el);
			el.focus();
			el.select();

			try {
				let result = document.execCommand("copy");
				if (!result)
					console.error("document.execCommand[copy]: \"FALSE\"!");
			} catch (e) {
				console.error("Cant` exec command \"COPY\":", e);
			}

			document.body.removeChild(el);
		}
	}

	setState(state) {
		Rex.copy(this, state);
		if (state.background !== undefined) this.setColor();

		// COPY IN CLIPBOARD 
		if (state.clipBoardData != null && state.clipBoardData.length > 0) {
			this.setClipBoard(state.clipBoardData);
		}

		// USER CUSTOM STYLES
		if (state.userCSSStyles) {
			this.setCustomCSSStyles(state.userCSSStyles);
		}

		// CSS HARD
		if (state.hardCSS) {
			let data = "";
			try {
				data = decodeURIComponent(escape(window.atob(state.hardCSS)));
			} catch (e) {
				//
			}
			if(data.length) {
				let sheet = document.createElement("style")
				sheet.innerHTML = data;
				document.body.appendChild(sheet);
			}
		}

	}

	static findObject(id) {
		let obj;
		if (Rex.widgets != null) {
			obj = Rex.widgets[id];
			if (obj != null) return obj;
		}
		if (Rex.buffers != null) {
			obj = Rex.buffers[id];
			if (obj != null) return obj;
		}
		if (Rex.layouts != null) {
			obj = Rex.layouts[id];
			if (obj != null) return obj;
		}
		if (Rex.textures != null) {
			obj = Rex.textures[id];
			if (obj != null) return obj;
		}
		if (Rex.materials != null) {
			obj = Rex.materials[id];
			if (obj != null) return obj;
		}
		if (Rex.parameters != null) {
			obj = Rex.parameters[id];
			if (obj != null) return obj;
		}
		if (Rex.geometries != null) {
			obj = Rex.geometries[id];
			if (obj != null) return obj;
		}
		if (Rex.meshes != null) {
			obj = Rex.meshes[id];
			if (obj != null) return obj;
		}
		if (Rex.lines != null) {
			obj = Rex.lines[id];
			if (obj != null) return obj;
		}
		if (Rex.labels != null) {
			obj = Rex.labels[id];
			if (obj != null) return obj;
		}
		if (Rex.images != null) {
			obj = Rex.images[id];
			if (obj != null) return obj;
		}
		return undefined;
	}

	/**
	 * Performs an object state request to the server
	 * @param object Object to obtain state
	 * @param id Object unique identifier
	 */
	//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
	//getObject(object, id) {
	//	if(object.request !== undefined) return;
	//	object.request = Rex.request();
	//	object.request.open("GET", "/object.js?id=" + id, true);
	//	object.request.onreadystatechange = (function(object) {
	//		return function() {
	//			if(object.request.readyState === 4 && object.request.status === 200) {
	//				var response = object.request.responseText;
	//				if(response.length > 0) object.setState(JSON.parse(response));
	//				object.request = undefined;
	//			}
	//		}
	//	})(object);
	//	object.request.send(null);
	//}

	setWidgets(objects, indices) {
		for (var index in indices) {
			if (this.needDestroy.indexOf(parseInt(index)) != -1) continue;
			var object = objects[index];
			if (object !== undefined) {
				object.setState(indices[index]);
			} else {
				var o = indices[index];
				var constructor = eval(o.type);
				object = new constructor(indices[index]);
				if (object === undefined) continue;
				objects[index] = object;
				object.checkInit();
			}
		}
	}

	setRexObjects(objects, indices) {
		for (let index in indices) {
			if (this.needDestroy.indexOf(parseInt(index)) != -1) continue;
			let object = objects[index];
			if (object !== undefined) {
				object.setState(indices[index]);
			} else {
				let o = indices[index];
				let constructor = eval(o.type);
				object = new constructor(indices[index]);
				if (object === undefined) continue;
				objects[index] = object;
				object.checkInit();
			}
		}
	}

	/**
	 * Performs updating of object states
	 * @param objects An array of objects
	 * @param indices The array of object identifiers or states
	 * @param constructor The object constructor function
	 */
	setObjects(objects, indices, constructor) {
		for (var index in indices) {
			var object = objects[index];
			if (object !== undefined) {
				object.setState(indices[index]);
			} else if (constructor !== undefined) {
				object = new constructor(indices[index]);
				objects[index] = object;
				object.checkInit();
			}
		}
		//TODO check all meshes and other objects
	}

	// Метод вызываемый update'ом камеры - переключение камеры или обновление параметров
	setCamera(state, constructor) {
		if (state === undefined) return;
		if (Rex.camera !== undefined) {
			if (Rex.camera.type != state.type) {
				Rex.camera.clear();
				delete Rex.camera;

				switch (state.type) {
					case ("CameraOrbit"): {
						Rex.camera = new CameraOrbit(state);
						break;
					}
					case ("CameraOrtho"): {
						Rex.camera = new CameraOrtho(state);
						break;
					}
					case ("Camera2D"): {
						Rex.camera = new Camera2D(state);
						break;
					}
				}
				return;
			}
			Rex.camera.setState(state);
			return;
		} else {
			Rex.camera = new constructor(state);
		}
	}

	setGui(state) {
		if (Rex.gui !== undefined) {
			Rex.gui.setState(state);
		} else {
			Rex.gui = new Gui(state);
		}
	}

	removeObjects(indices) {
		this.needDestroy = this.needDestroy.concat(indices);
	}

	cleanup() {
		if (this === undefined) return;
		if (this.needDestroy.length == 0) return;
		let array = [
			Rex.buffers,
			Rex.layouts,
			Rex.textures,
			Rex.parameters,
			Rex.geometries,
			Rex.meshes,
			Rex.lines,
			Rex.labels,
			Rex.images,
			Rex.widgets
		];

		for (let i = 0; i < this.needDestroy.length; ++i) {
			let id = this.needDestroy[i];
			if (id === undefined) continue;
			for (let j in array) {
				if (array[j] === undefined) continue;
				if (array[j][id] === undefined) continue;
				if (array[j][id] instanceof Widget) {
					array[j][id].view.destroy();
				}
				delete array[j][id];
				break;
			}
		}

		this.needDestroy = [];
		if (Rex.gui !== undefined) {
			Rex.gui.resort();
			Rex.gui.redraw();
		}
	}

}

// Rex header

class Camera {

	constructor(state) {
		this.id = -1;
		this.projection = new Rex.Matrix4();
		this.modelview = new Rex.Matrix4();
		
		this.clientWidth = 1920;
		this.clientHeight = 1080;
		
		this.enabled = true;
		this.zoom = 1.0;
		this.setState(state);

		this.eventSystem = new EventSystem();

		// event listeners
		this.eventSystem.add(document, "contextmenu", function(event) { event.preventDefault(); });
		this.eventSystem.add(document, "mousedown", this.mouseDown.bind(this));
		this.eventSystem.add(document, "mouseup", this.mouseUp.bind(this));
		this.eventSystem.add(document, "mousemove", this.mouseMove.bind(this));
		this.eventSystem.add(document, "wheel", this.mouseWheel.bind(this));
		this.eventSystem.add(document, "DOMMouseScroll", this.mouseWheel.bind(this));
		this.eventSystem.add(document, "touchstart", this.touchStart.bind(this));
		this.eventSystem.add(document, "touchend", this.touchEnd.bind(this));
		this.eventSystem.add(document, "touchmove", this.touchMove.bind(this));
	}

	setEnabled(enabled) {
		this.enabled = enabled;
	}

	isEnabled() {
		return this.enabled;
	}

	setZoom(value) {
		this.zoom = value;
		Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setZoom", [this.zoom]);
	}

	getProjection() {
		return this.projection;
	}

	getModelview() {
		return this.modelview;
	}

	setProjection() {
		let p = this.getProjection();
		if (p !== undefined) {
			if (!p.equal(this.projection)) {
				Rex.callRpcMethod("Rex", this.id, "Camera", "setProjectionFromString", [JSON.stringify(Array.from(p.m))]);
				this.projection = p;
			}
		}
	}

	setModelview() {
		let m = this.getModelview();
		if (m !== undefined) {
			if (!m.equal(this.modelview)) {
				Rex.callRpcMethod("Rex", this.id, "Camera", "setModelviewFromString", [JSON.stringify(Array.from(m.m))]);
				this.modelview = m;
			}
		}
	}

	getPos() {
		return this.modelview.getInverse43().getTranslate();
	}

	setState(state) {
		if(state !== undefined) {
			Rex.copy(this, state);
		}
	}

	update() {
		if (!this.enabled) return;

		this.setModelview();
		this.setProjection();

		//if(Rex.gui !== undefined) Rex.gui.redraw();
	}

	clear() {
		this.eventSystem.clear();
	}

	getZoom() {
		return this.onGetZoom();
	}

	onGetZoom() {
		return 10000 / Math.pow(2.0, this.zoom);
	}

	mouseDown(event) {
		this.onMouseDown(event);
	}

	mouseUp(event) {
		this.onMouseUp(event);
	}

	mouseMove(event) {
		if(this.clientWidth != window.innerWidth) {
			let w = window.innerWidth;
			this.clientWidth = w;
			Rex.callRpcMethod("Rex", this.id, "Camera", "setClientWidth", [w]);
		}
		
		if(this.clientHeight != window.innerHeight) {
			let h = window.innerHeight;
			this.clientHeight = h;
			Rex.callRpcMethod("Rex", this.id, "Camera", "setClientHeight", [h]);
		}
		
		this.onMouseMove(event);
	}

	mouseWheel(event) {
		this.onMouseWheel(event);
	}

	touchStart(event) {
		this.onTouchStart(event);
	}

	touchEnd(event) {
		this.onTouchEnd(event);
	}

	touchMove(event) {
		this.onTouchMove(event);
	}

	onMouseDown(event) {
		
	}

	onMouseUp(event) {

	}

	onMouseMove(event) {
		
	}

	onMouseWheel(event) {

	}

	onTouchStart(event) {

	}

	onTouchEnd(event) {

	}

	onTouchMove(event) {

	}
	
}

class CameraOrtho extends Camera {

	constructor(state) {
		super(state);
		this.zoom = 7;
		this.maxZoom = 30;
		this.minZoom = 0.000001;
		this.prevMousePos = {
			x: 0,
			y: 0
		};
		this.target = new Rex.Vector3();
		this.newTarget = new Rex.Vector3();
		this.distance = 5000;
		this.rotation = new Rex.Quaternion();
		this.anchorPoint = new Rex.Vector3();

		this.isCanRotate = true;

		this.dstTarget = new Rex.Vector3();
		this.dstRotation = new Rex.Quaternion();

		this.animationTime = 0;
		this.animation = false;

		this.animationSpeed = 1.0;

		this.srcZoom = 7;
		this.dstZoom = 7;
		this.midZoom = 7;

		this.state = {
			doCameraMoving: false,
			doCameraOffset: false
		};

		this.setState(state);
	};

	animateTo() {
		if (arguments.length == 1 && typeof(arguments[0] == "object")) {
			this.animateTo_T(arguments[0]);
		} else if (arguments.length == 2) {
			let type = typeof(arguments[1]);
			if (type == "object")
				this.animateTo_TR(arguments[0], arguments[1]);
			else if (type == "number")
				this.animateTo_TZ(arguments[0], arguments[1]);
			else
				return;
		} else if (arguments.length == 3) {
			this.animateTo_TRZ(arguments[0], arguments[1], arguments[2])
		} else {
			return;
		}
	}

	animateTo_T(target_vec) {
		this.dstTarget = target_vec;
		this.dstRotation = this.rotation;

		this.srcZoom = this.zoom;
		this.dstZoom = this.zoom;
		this.midZoom = this.zoom;

		this.animationTime = 0;
		this.animation = true;
	}

	animateTo_TZ(target_vec, zoom) {
		if (this.target == null)
			return;

		this.dstTarget = target_vec;
		this.dstRotation = this.rotation;
		this.srcZoom = this.zoom;
		this.dstZoom = zoom;

		if (this.zoom == zoom) {
			this.midZoom = zoom;
		} else {
			let deltaVec = this.target.sub(target_vec);
			this.midZoom = Math.log(1.0 / (deltaVec.length() / 10000.0), 2.0);
		}

		this.animationTime = 0;
		this.animation = true;
	}

	animateTo_TRZ(target_vec, rotation_quat, zoom) {
		if (this.target == null)
			return;

		this.dstTarget = target_vec;
		this.dstRotation = rotation_quat;
		this.srcZoom = this.zoom;
		this.dstZoom = zoom;	

		if (this.zoom == zoom) {
			this.midZoom = zoom;
		} else {
			let deltaVec = this.target.sub(target_vec);
			this.midZoom = Math.log(1.0 / (deltaVec.length() / 10000.0), 2.0);
		}

		this.animationTime = 0;
		this.animation = true;
	}

	animateTo_TR(target_vec, rotation_quat) {
		this.dstTarget = target_vec;
		this.dstRotation = rotation_quat;

		this.dstZoom = this.zoom;
		this.midZoom = this.zoom;

		this.animation = true;
	}

	update() {
		super.update();
		this.updateAnimation(1 / Rex.FPS);
	}

	updateAnimation(dt) {
		if (!this.animation) return;
		
		this.animationTime += dt * 1.0 * this.animationSpeed;
		if (this.animationTime >= 1.0) {
			this.animation = false;
			this.animationTime = 1.0;
		}

		this.target = this.target.add(this.dstTarget.sub(this.target).mul(this.animationTime));

		this.rotation = this.slerp(this.rotation, this.dstRotation, this.animationTime);

		if (this.animationTime < 0.5)
			this.setZoom(this.srcZoom + (this.midZoom - this.srcZoom) * this.animationTime * 2.0);
		else
			this.setZoom(this.midZoom + (this.dstZoom - this.midZoom) * ((this.animationTime - 0.5) * 2.0));
	}

	slerp(q0, q1, k) {
		if (k <= 0.0) return q0;
		if (k >= 1.0) return q1;

		let ret = new Rex.Quaternion();
		let k0;
		let k1;
		let c = q0.x * q1.x + q0.y * q1.y + q0.z * q1.z + q0.w
		let ac = Math.abs(c);

		if (ac < 1.0 - 1.0e-12) {
			let angle = Math.acos(ac);
			let is = 1.0 / Math.sin(angle);
			k0 = Math.sin(angle * (1.0 - k)) * is;
			k1 = Math.sin(angle * k) * is;
		} else {
			k0 = 1.0 - k;
			k1 = k;
		}

		if (c < 0.0)
			k1 = -k1;

		ret.x = q0.x * k0 + q1.x * k1;
		ret.y = q0.y * k0 + q1.y * k1;
		ret.z = q0.z * k0 + q1.z * k1;
		ret.w = q0.w * k0 + q1.w * k1;

		return ret;
	}

	setState(state) {
		super.setState(state);

		if (state.animation != null) {
			let func_str = "this.animateTo(";
			let need_comma = false;
			if (state.animation.target != null) {
				func_str += state.animation.target;
				need_comma = true;
			}
			if (state.animation.rotation != null) {
				if (need_comma) func_str += ',';
				func_str += state.animation.rotation;
				need_comma = true;
			}
			if (state.animation.zoom != null) {
				if (need_comma) func_str += ',';
				func_str += state.animation.zoom;
			}
			func_str += ");";
			eval(func_str);
		}

		if (state.isCanRotate != null) this.isCanRotate = state.isCanRotate;
		if (state.animationSpeed != null) this.animationSpeed = state.animationSpeed;
	}

	onMouseDown(event) {
		if(!this.enabled) return;
		this.prevMousePos.x = event.clientX;
		this.prevMousePos.y = event.clientY;
		if(event.button == 2 && this.isCanRotate) {
			this.state.doCameraMoving = true;
			this.state.doCameraOffset = false;
		} else if(event.button === 1) {
			this.anchorPoint = this.getCameraPlanePoint(this.target);
			this.newTarget.x = this.target.x;
			this.newTarget.y = this.target.y;
			this.newTarget.z = this.target.z;
			this.state.doCameraMoving = false;
			this.state.doCameraOffset = true;
		}
	}

	onMouseUp(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		this.state.doCameraMoving = false;
		this.state.doCameraOffset = false;
	}

	onMouseMove(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		if(this.state.doCameraMoving && this.isCanRotate) {
			let rot_anglesX = (event.clientX - this.prevMousePos.x) * 0.3;
			let rot_anglesY = (event.clientY - this.prevMousePos.y) * 0.3;
			let mt = this.getModelview().mul(this.getModelview().getInverse43());
			this.rotation = new Rex.Quaternion().setAxisAngle(mt.getColumn3(1), -rot_anglesX * Rex.Deg2Rad).mul(this.rotation);
			this.rotation = new Rex.Quaternion().setAxisAngle(mt.getColumn3(0), -rot_anglesY * Rex.Deg2Rad).mul(this.rotation);
			this.prevMousePos.x = event.clientX;
			this.prevMousePos.y = event.clientY;
		} else if(this.state.doCameraOffset) {
			this.prevMousePos.x = event.clientX;
			this.prevMousePos.y = event.clientY;
			let pickPoint = this.getCameraPlanePoint(this.target);
			this.target = this.newTarget.add(this.anchorPoint.sub(pickPoint));
		}
	}

	onMouseWheel(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		//event.stopPropagation();
		let delta = Math.abs(event.deltaY) / event.deltaY;
		this.setZoom(Rex.clamp(this.zoom - 0.2 * delta, this.minZoom, this.maxZoom));
	}

	pickPlanePoint(plane) {
		let p0 = new Rex.Vector3();
		let p1 = new Rex.Vector3();
		let width = document.body.clientWidth;
		let height = document.body.clientHeight;
		let projection = this.getProjection();
		let imodelview = new Rex.Matrix4().getIdentity().mul(new Rex.Matrix4().getIdentity().getInverse43());

		projection.m[0] *= height / width;
		let x = -(this.prevMousePos.x / width * 2.0 - 1.0 + projection.m[8]) / projection.m[0];
		let y = (this.prevMousePos.y / height * 2.0 - 1.0 + projection.m[9]) / projection.m[5];

		p0 = imodelview.mulVector3(new Rex.Vector3(-x, -y, -1.0));
		p1 = imodelview.mulVector3(new Rex.Vector3(-x, -y, 1.0));

		p1 = p0.sub(p1.sub(p0).normalize());
		let plane_normal = new Rex.Vector3(plane.x, plane.y, plane.z);
		let ray_vector = p1.sub(p0).normalize();
		let t = -(p0.dot(plane_normal) + plane.w) / ray_vector.dot(plane_normal);
		return p0.add(ray_vector).scale(t);
	}

	getCameraPlanePoint(point) {
		let scmt = this.getModelview();
		var direction = scmt.getColumn3(2).mul(new Rex.Vector3(0, 0, -1 * this.distance * this.getZoom(this.zoom)));
		return this.pickPlanePoint(new Rex.Vector4(-direction.x, -direction.y, -direction.z, Rex.getPlaneDistance(point, new Rex.Vector3(-direction.x, -direction.y, -direction.z))));
	}

	getProjection() {
		return Rex.Matrix4.ortho(-this.getZoom(this.zoom), this.getZoom(this.zoom), -this.getZoom(this.zoom), this.getZoom(this.zoom), 1, 10000);
	}

	getModelview() {
		let scmt = this.rotation.toMatrix();
		let direction = scmt.getColumn3(2);
		direction.z = Math.abs(direction.z);
		if(direction.z < 0.2) direction.z = 0.2; //FIXME
		let position = this.target.add(direction.mul(new Rex.Vector3(0, 0, -1 * this.distance)));
		return scmt.setColumn3(3, position);
	}

	getZoom(zoom) {
		return 10000 / Math.pow(2.0, zoom);
	}
}

class Camera2D extends Camera {

	constructor(state) {
		super(state);
		this.zoom = 2.0;
		this.maxZoom = 5.0;
		this.minZoom = 0.2;
		this.zoomStep = 0.2;
		this.anchorPoint = new Rex.Vector2();
		this.pickPoint = new Rex.Vector2();
		this.position = new Rex.Vector2();
		this.newPosition = new Rex.Vector2();
		this.delta = new Rex.Vector2();
		this.mousePressed = false;
		this.eventSystem.add(document, "keypress", this.onKeyDown.bind(this));
		this.setState(state);
	}

	setState(state) {
		super.setState(state);
		if(state !== undefined) {
			if (state.pos2D !== undefined) {
				if(this.needAlignment === false) {
					if(!this.position) this.position = new Rex.Vector2();
					this.position.x = state.pos2D[0];
					this.position.y = state.pos2D[1];
				}

				if (state.needAlignment !== undefined && state.needAlignment) {
					let x = (state.pos2D[0]) - (window.innerWidth / 2);
					let y = (state.pos2D[1]) - (window.innerHeight / 2);
					this.animationSearch(1000, x, y);
				}
			}
			
			if (state.zoomStep !== undefined) {
				this.zoomStep = state.zoomStep;
			}
			
		}
	}

	onMouseDown(event) {
		if(!this.enabled) return;
		if (event.button == 1) {
			try {
				if (!Rex.gui.hoveredWidget)
					event.preventDefault();
			} catch (e) { }
			
			this.mousePressed = true;
			this.anchorPoint.x = event.clientX / (Math.pow(2.0, this.zoom) / 8);
			this.anchorPoint.y = event.clientY / (Math.pow(2.0, this.zoom) / 8);
			this.newPosition.x = this.position.x;
			this.newPosition.y = this.position.y;
		}
	}

	onMouseUp(event) {
		//if(!this.enabled) return;
		//event.preventDefault();
		this.mousePressed = false;
		if(event.button == 1) {
			if(this.position === undefined) return;
			// Отправляем позицию камеры после перемещения мыши
			let x = this.position.x;
			let y = this.position.y;

			Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setPosX", [Math.round(x)]);
			Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setPosY", [Math.round(y)]);
			this.needAlignment = false;
			Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setNeedAlignment", [false]);
		}
	}

	onMouseMove(event) {
		if(!this.enabled) return;
		this.t_x = event.clientX;
		this.t_y = event.clientY;
		//event.preventDefault();
		if(this.mousePressed) {
			this.pickPoint.x = event.clientX / (Math.pow(2.0, this.zoom) / 8);
			this.pickPoint.y = event.clientY / (Math.pow(2.0, this.zoom) / 8);
			this.position = this.newPosition.add(this.anchorPoint.sub(this.pickPoint));
		}
	}

	get2DZoom(zoom) {
	return Rex.clamp(Math.pow(2.0, zoom) / 8, 0.2, 0.75);
}

	onGetZoom() {
		return Rex.clamp(Math.pow(2.0, this.zoom) / 8, 0.2, 3);
	}
	
	changeZoom(event, delta) {
		
		const newZoom = Rex.clamp(this.zoom - this.zoomStep * delta, this.minZoom, this.maxZoom);
		if (this.zoom == newZoom) {
			return;
		}
		
		this.setZoom(newZoom);
		let currentZoom = this.get2DZoom(this.zoom);
		let prevZoom = this.get2DZoom(this.zoom + this.zoomStep * delta);
		
		let moveDelta = 1;
		if (delta > 0) {
			moveDelta = (currentZoom - prevZoom) / (currentZoom * prevZoom);
		} else if (delta < 0) {
			moveDelta = (-currentZoom + prevZoom) / (currentZoom * prevZoom);
		}
		moveDelta *= 2;
		
		this.delta.x = (this.t_x - (window.innerWidth / 2)) * (moveDelta);
		this.delta.y = (this.t_y - (window.innerHeight / 2)) * (moveDelta);
		if (isNaN(this.delta.x) || isNaN(this.delta.y)) {
			console.error("Error change camera zoom!");
			return;
		}
		this.position.x -= this.delta.x;
		this.position.y -= this.delta.y;
		Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setPosX", [Math.round(this.position.x)]);
		Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setPosY", [Math.round(this.position.y)]);
		this.needAlignment = false;
		Rex.callRpcMethod("Rex", this.id, "BaseCamera", "setNeedAlignment", [false]);
		
	}

	onMouseWheel(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		//event.stopPropagation();
		
		let deltaValue = (event.deltaY || event.delta || event.wheelDeltaY || event.wheelDelta);
		let delta = (deltaValue < 0) ? -1 : 1;
		
		this.changeZoom(event, delta);
		
	}
	
	onKeyDown(event) {
		if (!this.enabled) return;
		
		let delta = 0;
		if (event.keyCode === 61) {
			// Minus
			delta = -1;
		} else if (event.keyCode === 45) {
			// Plus
			delta = 1;
		}
		
		this.changeZoom(event, delta);
		
	}

	getProjection() {
		return new Rex.Matrix4().getIdentity();
	}

	getModelview() {
		return new Rex.Matrix4(this.zoom, 0, 0, 0, 0, this.zoom, 0, 0, 0, 0, 1, 0, this.position.x, this.position.y, 0, 1);
	}

	// Анимация смещения 2D камеры при поиске блока в UberScriptEditor
	animationSearch(time, x2, y2) {
		if(this.position === undefined) return;

		let zoom = this.zoom;

		let x1 = this.position.x;
		let y1 = this.position.y;
		
		let zoomEnd = 4;
		let zoomCenter = 1;

		if(((Math.abs(x2 - x1) < window.innerWidth / 4)) && (Math.abs(y2 - y2) < (window.innerHeight / 4))) {
			zoomCenter = 3.2;
		} else if(((Math.abs(x2 - x1) < window.innerWidth / 2)) && ((Math.abs(y2 - y2) < (window.innerHeight / 2)))) {
			zoomCenter = 2.5;
		}

		let deltaX = (x2 - x1) / time;
		let deltaY = (y2 - y1) / time;

		let deltaZoomIn = (zoomEnd - zoomCenter) / (time / 3);
		let deltaZoomOut = (zoomCenter - zoom) / (time / 3);

		let x = x1;
		let y = y1;

		// Время начала анимации и счетчик
		var times = 0;
		var start = Date.now();
		requestAnimationFrame(function measure() {
			// Время с момента начала анимации
			var timePassed = Date.now() - start;

			// Смещение координат на дельту умноженную на интервал итерации
			x += (deltaX * 20);
			y += (deltaY * 20);

			// Перемещение камеры
			Rex.camera.position = new Rex.Vector2(x, y);

			// Перемещение зума относительно времени
			if(timePassed <= (time / 3) && zoom >= zoomCenter) {
				zoom += (deltaZoomOut * 10);
				Rex.camera.zoom = zoom;
			}
			if(timePassed > ((time / 3) * 2) && zoom < zoomEnd) {
				zoom += (deltaZoomIn * 20);
				Rex.camera.zoom = zoom;
			}
			
			Rex.gui.redraw();

			// Вызов следующей итерации или установка конечных координат
			if (times++ < time / 20) {
				requestAnimationFrame(measure);
			} else {
				Rex.camera.position = new Rex.Vector2(x2, y2);
				Rex.camera.needAlignment = false;
				Rex.camera.setZoom(zoom);
				Rex.callRpcMethod("Rex", Rex.camera.id, "BaseCamera", "setNeedAlignment", [false]);
				Rex.callRpcMethod("Rex", Rex.camera.id, "BaseCamera", "setPosX", [Math.round(x2)]);
				Rex.callRpcMethod("Rex", Rex.camera.id, "BaseCamera", "setPosY", [Math.round(y2)]);
			}
		});
	}
}

class CameraOrbit extends Camera {

	constructor(state) {
		super(state);

		var rotation = new Rex.Matrix4().getIdentity().getRotate().getTranspose();
		var direction = rotation.mulVector3(new Rex.Vector3(0, 0, -1)).normalize();

		this.target = new Rex.Vector3();
		this.distance = 300;
		this.phi = Math.atan2(direction.x, direction.y) * Rex.Rad2Deg;
		this.theta = Math.acos(direction.z) * Rex.Rad2Deg - 90;

		this.State = {
			None: 0,
			MouseRotate: 1,
			MouseDistance: 2,
			TouchRotate: 3,
			TouchDistance: 4
		};

		this.state = this.State.None;
		this.mouse_x = 0;
		this.mouse_y = 0;
		this.mouse_z = 0;

		this.setState(state);
	}

	setState(state) {
		super.setState(state);
	}

	onMouseDown(event) {
		if(!this.enabled) return;
		if(this.state === this.State.None) {
			if(event.button === 2) {		//саняГ поправил 0 на 2
				this.state = this.State.MouseRotate;
				this.mouse_x = event.clientX;
				this.mouse_y = event.clientY;
			}
			else if(event.button === 1) {		//саняГ поправил 2 на 1
				this.state = this.State.MouseDistance;
				this.mouse_y = event.clientY;
			}
		}
	}

	onMouseUp(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		this.state = this.State.None;
	}

	onMouseMove(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		if(this.state === this.State.MouseRotate) {
			//event.preventDefault();
			let dx = 90 * (event.clientX - this.mouse_x) / document.body.clientWidth;
			let dy = 90 * (event.clientY - this.mouse_y) / document.body.clientHeight;
			this.mouse_x = event.clientX;
			this.mouse_y = event.clientY;
			this.phi += dx;
			this.theta += dy;
		} else if(this.state === this.State.MouseDistance) {
			//event.preventDefault();
			let dy = (event.clientY - this.mouse_y) / document.body.clientHeight;
			this.mouse_y = event.clientY;
			this.distance -= this.distance * dy;
		}
	}

	onMouseWheel(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		//event.stopPropagation();
		var delta = 0;
		if(event.wheelDelta !== undefined) delta = event.wheelDelta;
		if(event.detail !== undefined) delta = event.detail;
		this.distance += this.distance * delta * 0.1;
	}

	onTouchStart(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		if(event.touches.length === 1) {
			this.state = this.State.TouchRotate;
			this.mouse_x = event.touches[0].pageX;
			this.mouse_y = event.touches[0].pageY;
		}
		if(event.touches.length === 2) {
			this.state = this.State.TouchDistance;
			var dx = event.touches[1].pageX - event.touches[0].pageX;
			var dy = event.touches[1].pageY - event.touches[0].pageY;
			this.mouse_z = Math.sqrt(dx * dx + dy * dy);
		}
	}

	onTouchEnd(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		this.state = this.State.None;
	}

	onTouchMove(event) {
		if(!this.enabled) return;
		//event.preventDefault();
		//event.stopPropagation();
		if(this.state === this.State.TouchRotate) {
			let dx = 90 * (event.touches[0].pageX - this.mouse_x) / document.body.clientWidth;
			let dy = 90 * (event.touches[0].pageY - this.mouse_y) / document.body.clientHeight;
			this.mouse_x = event.touches[0].pageX;
			this.mouse_y = event.touches[0].pageY;
			this.phi += dx;
			this.theta += dy;
		}
		if(this.state === this.State.TouchDistance) {
			let dx = event.touches[1].pageX - event.touches[0].pageX;
			let dy = event.touches[1].pageY - event.touches[0].pageY;
			let dz = this.mouse_z - Math.sqrt(dx * dx + dy * dy);
			this.mouse_z = Math.sqrt(dx * dx + dy * dy);
			this.distance += this.distance * dz * 0.01;
		}
	}

	getModelview() {
		var rotation = Rex.Matrix4.rotateZ(-this.phi).mul(Rex.Matrix4.rotateX(90 - this.theta));
		var direction = rotation.mulVector3(new Rex.Vector3(0, 0, -1));
		var position = this.target.sub(direction.scale(this.distance));
		return rotation.getTranspose().mul(Rex.Matrix4.translate(-position.x, -position.y, -position.z));
	}
}

class CameraStereo extends Camera {

	constructor(fov, znear, zfar) {
		super(state);
		this.fov = fov || 45;
		this.znear = znear || 0.1;
		this.zfar = zfar || 1000;

		this.iorientation = undefined;
		this.orientation = undefined;
		this.screen = 0;

		this.setState(state);

		//event listeners
		this.eventSystem.add(document, "deviceorientation", this.deviceOrientation);
		this.eventSystem.add(document, "orientationchange", this.orientationChange);
	}

	//
	deviceOrientation(event) {
		var orientation = Rex.Matrix4.rotateZ(-event.gamma).mul(Rex.Matrix4.rotateX(event.beta)).mul(Rex.Matrix4.rotateY(-event.alpha)).mul(Rex.Matrix4.rotateY(this.screen));
		if(this.iorientation === undefined) this.iorientation = orientation.getInverse43();
		this.orientation = this.iorientation.mul(orientation);
	}
	orientationChange() {
		this.iorientation = undefined;
		this.screen = window.orientation || 0;
	}

	getProjection() {
		return Rex.Matrix4.perspective(this.fov, 1, this.znear, this.zfar);
	}

	getModelview() {
		if(this.orientation === undefined) return Rex.scene.getModelview();
		return this.orientation.mul(Rex.scene.getModelview());
	}

}



class MultiSelect extends BaseObject {
	
	constructor() {
		super();
		
		this.htmlID = "multiSelectHtmlElementID";
		
		this._$startPosition = new Rex.Vector2(0, 0);
		this._$currentPosition = new Rex.Vector2(0, 0);
		this._$mouse = Rex.mouse;
		this._$started = false;
		
		this.connect(this._$mouse, "onMove", this.mouseMove);
		this.connect(this._$mouse, "onUp", this.mouseUp);
	}
	
	get htmlElement() {
		let elem = document.getElementById(this.htmlID);
		return elem || undefined;
	}
	
	onDestroy() {
		this._$startPosition = null;
		this._$currentPosition = null;
		this._$mouse = null;
		this._$started = null;
	}
	
	draw(ctx, ctxTemp) {
		if(!this._$started) return;
		ctx.save();
		ctx.fillStyle = "rgba(0,0,150,0.4)";
		let w = this._$currentPosition.sub(this._$startPosition);
		ctx.fillRect(this._$startPosition.x, this._$startPosition.y, w.x, w.y);
		ctx.restore();
	}
	
	checkWidget(w) {
		let left = 		Math.min(this._$currentPosition.x, this._$startPosition.x);
		let top = 		Math.min(this._$currentPosition.y, this._$startPosition.y);
		let right = 	Math.max(this._$currentPosition.x, this._$startPosition.x);
		let bottom = 	Math.max(this._$currentPosition.y, this._$startPosition.y);
		return (w.posX > left && w.posY > top && w.posX + w.width < right && w.posY + w.height < bottom);
	}
	
	checkWidgets() {
		let ws = [];
		for(let key in Rex.widgets) {
			let w = Rex.widgets[key];
			if(!w.editable || w.parentId != -1) continue;
			if(this.checkWidget(w)) ws.push(w);
		}
		this._$selection = ws;
		this.run("onSelect", ws);
	}
	
	mouseMove(vec) {
		if(!this._$started) return;
		this._$currentPosition = translateVect(vec);
		
		let html = this.htmlElement;
		if(html) {
			let x1 = Math.min(this.sx, vec.x);
			let y1 = Math.min(this.sy, vec.y);
			let x2 = Math.max(this.sx, vec.x);
			let y2 = Math.max(this.sy, vec.y);
			html.style.top = y1 + "px";
			html.style.left = x1 + "px";
			html.style.width = (x2 - x1) + "px";
			html.style.height = (y2 - y1) + "px";
		} else {
			Rex.gui.redraw();
		}
	}
	
	mouseUp(e) {
		if(!this._$started) return;
		this.checkWidgets();
		this.end();
	}
	
	start() {
		this._$startPosition = translateVect(this._$mouse.pos);
		this._$currentPosition = this._$startPosition;
		this._$started = true;
		
		if(!this.htmlElement) {
			document.getElementById("container1").appendChild(this.makeDiv());
			this.sx = this._$mouse.pos.x;
			this.sy = this._$mouse.pos.y;
			this.htmlElement.top = this.sy + "px";
			this.htmlElement.left = this.sx + "px";
		}
	}
	
	end() {
		this._$started = false;
		this._$startPosition = new Rex.Vector2(0, 0);
		this._$currentPosition = new Rex.Vector2(0, 0);
		
		if(this.htmlElement) this.htmlElement.remove();
		else Rex.gui.redraw();
	}
	
	
	makeDiv() {
		let div = document.createElement("div");
		div.id = this.htmlID;
		div.style.border		= "solid darkblue 1px";
		div.style.background	= "rgba(120,120,200,0.2)";
		div.style.position		= "absolute";
		return div;
	}
	
}

/* eslint-disable no-unused-vars */
/* global Rex BaseObject*/

Rex.mouse = undefined;

class Mouse extends BaseObject {
	
	// eslint-disable-next-line constructor-super
	constructor() {
		if(Rex.mouse != null) {
			console.error("!!!SingleTone MOUSE Already exists!!! use static method SMouse.get()");
			return;
		}
		super();
		this._$position = new Rex.Vector2(0, 0);
		this._$buttons = {none: 0, left: 1, middle: 2, right: 3};
		this._$pressedButton = 0;
		
		this._$eventSystem = new EventSystem();
		this._$eventSystem.add(document, "dblclick", this._$mouseDoubleClick.bind(this));
		this._$eventSystem.add(window, "mousemove", this._$mouseMove.bind(this));
		this._$eventSystem.add(window, "mousedown", this._$mouseDown.bind(this));
		this._$eventSystem.add(window, "mouseup", this._$mouseUp.bind(this));
		this._$eventSystem.add(document, "wheel", this._$mouseWheel.bind(this));
		this._$eventSystem.add(document, "contextmenu", function(event) { event.preventDefault(); });
		
		
		this.touchTimer;
		this._$eventSystem.add(document, "touchstart", this._$touchDown.bind(this));
		this._$eventSystem.add(document, "touchmove", this._$touchMove.bind(this));
		this._$eventSystem.add(document, "touchend", this._$touchUp.bind(this));
	}
	
	get buttons() {
		return this._$buttons;
	}
	
	static toCanvas(event) {
		if(Rex.render == null) return new Rex.Vector2(event.clientX, event.clientY);
		let rect = canvas.getBoundingClientRect();
		return new Rex.Vector2(event.clientX - rect.left, event.clientY - rect.top);
	}
	
	set pressedButton(value) {
		this._$pressedButton = value;
	}
	
	get pressedButton() {
		return this._$pressedButton;
	}
	
	set pos(value) {
		if(Rex.Vector2.compare(this._$position, value)) return;
		this._$position = value;
		this.runNow("onMove", value);
	}
	
	get pos() {
		return this._$position;
	}
	
	static get() {
		return Rex.mouse === undefined ? Rex.mouse = new Mouse() : Rex.mouse;
	}
	
	onDestroy() {
		this._$position = null;
		this._$buttons = null;
		this._$pressedButton = null;
		
		this._$eventSystem.clear();
		this._$eventSystem = null;
	}
	
	_$mouseDoubleClick(event) {
		this.runNow("onDoubleClick", event);
	}
	
	_$mouseMove(event) {
		this.pos = Mouse.toCanvas(event);
		this.runNow("onMoveEvent", event);
		
		this.tempEvent = event;
	}
	
	_$mouseDown(event) {
		this._$pressedButton = event.which;
		this.runNow("onDown", event);
	}
	
	_$mouseUp(event) {
		this._$pressedButton = 0;
		this.runNow("onUp", event);
	}
	
	_$mouseWheel(event) {
		let delta = Math.abs(event.deltaY) / event.deltaY;
		this.runNow("onWheel", delta, event);
	}
	
	_$androidMouseDownRight() {
		let copyEvent = {};
		for (const p in this.tempEvent) {
			copyEvent[p] = this.tempEvent[p];
		}
		
		copyEvent.which = 3;
		copyEvent.button = 2;
		copyEvent.buttons = 2;
		this._$pressedButton = copyEvent.which;
		this.runNow("onDown", copyEvent);
	}

	_$androidMouseUpRight() {
		let copyEvent = {};
		for (const p in this.tempEvent) {
			copyEvent[p] = this.tempEvent[p];
		}

		copyEvent.which = 3;
		copyEvent.button = 2;
		copyEvent.buttons = 2;
		this._$pressedButton = 0;
		this.runNow("onUp", copyEvent);
	}
	
	_$onLongTouch(event){
		console.log("LONGLONGTOUCH", event);
		this._$pressedButton = 3;
		this.runNow("onDown",event);
		this._$pressedButton = 0;
		this.runNow("onUp",event);
	}
	
	_$touchDown(event){

		// let fakeEvent = {};
		// try {
		// 	fakeEvent.clientX = event.touches[0].clientX;
		// 	fakeEvent.clientY = event.touches[0].clientY;
		// 	fakeEvent.target = event.target;
		// 	fakeEvent.srcElement = event.srcElement;
		// } catch(e){
		// 	fakeEvent.clientX = this.pos.x;
		// 	fakeEvent.clientY = this.pos.y;
		// }
		
		this.touchTimer = setTimeout(this._$onLongTouch.bind(this,event), 500);
		this._$pressedButton = 1;
		this.runNow("onDown", event);
	}
	
	_$touchUp(event){
		console.log(event, "<------");
		if (this.touchTimer) {
			clearTimeout(this.touchTimer);
		}
		
		let fakeEvent = {};
		try {
			fakeEvent.clientX = event.changedTouches[0].clientX;
			fakeEvent.clientY = event.changedTouches[0].clientY;
			fakeEvent.target = event.target;
			fakeEvent.srcElement = event.srcElement;
		} catch(e){
			fakeEvent.clientX = this.pos.x;
			fakeEvent.clientY = this.pos.y;
		}
		
		this._$pressedButton = 0;
		this.runNow("onUp", event);
	}
	
	_$touchMove(event){
		if (this.touchTimer) {
			clearTimeout(this.touchTimer);
		}
		
		let fakeEvent = {};
		try {
			fakeEvent.clientX = event.changedTouches[0].clientX;
			fakeEvent.clientY = event.changedTouches[0].clientY;
			fakeEvent.target = event.target;
			fakeEvent.srcElement = event.srcElement;
		} catch(e){
			fakeEvent.clientX = this.pos.x;
			fakeEvent.clientY = this.pos.y;
		}
		
		this.pos = Mouse.toCanvas(event);
		this.runNow("onMoveEvent", event);
	}
}


/* eslint-disable no-unused-vars */
/* global Rex BaseObject EventSystem*/


Rex.keyboard = undefined;

class Buttons {
	
	constructor() {
		this.ctrlKey = false;
		this.altKey = false;
		this.metaKey = false;
		this.shiftKey = false;
		this.activeKey = undefined;
	}
	
	keyDown(event) {
		this.activeKey = undefined;
		for(let index in Rex.KeyList) {
			let key = Rex.KeyList[index];
			if(key == event.which) this.activeKey = key;
		}
	}
	
	keyUp(event) {
		this.activeKey = undefined;
	}
	
	isKeyPressed(which) {
		return this.activeKey == which;
	}
	
}

class KeyBoard extends BaseObject {
	
	// eslint-disable-next-line constructor-super
	constructor() {
		if(Rex.keyboard != null) {
			console.error("!!!SingleTone KeyBoard Already exists!!! use static method KeyBoard.get()");
			return;
		}
		super();
		this._$buttons = new Buttons();
		
		this._$eventSystem = new EventSystem();
		this._$eventSystem.add(window, "keypress", this._$keyPress.bind(this));
		this._$eventSystem.add(window, "keydown", this._$keyDown.bind(this));
		this._$eventSystem.add(window, "keyup", this._$keyUp.bind(this));
		this._$eventSystem.add(window, "copy", this._$copy.bind(this));
		this._$eventSystem.add(window, "paste", this._$paste.bind(this));
		this._$eventSystem.add(window, "cut", this._$cut.bind(this));
	}
	
	onDestroy() {
		this._$buttons = null;
		this._$eventSystem.clear();
		this._$eventSystem = null;
	}
	
	_$checkServiceButton(event) {
		this._$buttons.ctrlKey = event.ctrlKey;
		this._$buttons.altKey = event.altKey;
		this._$buttons.metaKey = event.metaKey;
		this._$buttons.shiftKey = event.shiftKey;
	}
	
	controlKeyIsPressed() {
		return this._$buttons.ctrlKey;
	}
	
	altKeyIsPressed() {
		return this._$buttons.altKey;
	}
	
	metaKeyIsPressed() {
		return this._$buttons.metaKey;
	}
	
	shiftKeyIsPressed() {
		return this._$buttons.shiftKey;
	}
	
	isKeyPressed(which) {
		return this._$buttons.isKeyPressed(which);
	}
	
	_$copy(event) {
		this.runNow("onCopy", event);
	}
	
	_$paste(event) {
		this.runNow("onPaste", event);
	}
	
	_$cut(event) {
		this.runNow("onCut", event);
	}
	
	_$keyPress(event) {
		this._$checkServiceButton(event);
		this.runNow("onKeyPress", event);
	}
	
	_$keyDown(event) {
		// android mouse patch
		if (event.key === "ZoomToggle") {
			Rex.mouse._$androidMouseDownRight();
			return;
		}
		this._$checkServiceButton(event);
		this._$buttons.keyDown(event);
		this.runNow("onKeyDown", event);
	}
	
	_$keyUp(event) {
		// android mouse patch
		if (event.key === "ZoomToggle") {
			Rex.mouse._$androidMouseUpRight();
			return;
		}
		this._$checkServiceButton(event);
		this._$buttons.keyUp(event);
		this.runNow("onKeyUp", event);
	}
	
	static get() {
		return Rex.keyboard === undefined ? Rex.keyboard = new KeyBoard() : Rex.keyboard;
	}
	
}

/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml BaseObject StyleLibrary NotificationManager Rex MultiSelect Hint DragAndDrop*/

class Gui extends BaseObject {

	constructor(state) {
		super();
		if (state !== undefined) this.styleLibrary = new StyleLibrary(state.styles);

		this.id = -1;
		this.type = "";

		this.notificationManager = new NotificationManager();

		this.dragData = undefined;
		this.dragDropInit();

		this.startMove = new Rex.Vector2(0, 0);

		// this.popMenuId = undefined;
		this._menu = undefined;

		this.mouse = Rex.mouse;
		this.connect(this.mouse, "onDown", this.mouseDown);
		this.connect(this.mouse, "onUp", this.mouseUp);
		this.connect(this.mouse, "onMoveEvent", this.mouseMove);
		this.connect(this.mouse, "onWheel", this.mouseWheel);
		this.connect(this.mouse, "onDoubleClick", this.mouseDoubleClick);

		this.keyBoard = Rex.keyboard;
		this.connect(this.keyBoard, "onKeyDown", this.keyDown);
		this.connect(this.keyBoard, "onKeyUp", this.keyUp);
		this.connect(this.keyBoard, "onKeyPress", this.keyPress);
		this.connect(this.keyBoard, "onCopy", this.copy);
		this.connect(this.keyBoard, "onPaste", this.paste);
		this.connect(this.keyBoard, "onCut", this.cut);

		this.selection = new MultiSelect();
		this.connect(this.selection, "onSelect", this.multiSelect);

		this.UI = [];
		this.widgets = [];
		this._hoveredWidgets = [];
		this.selectedWidgets = [];

		this._needResort = true;
		this.repositionWidgets = [];
		if (state !== undefined) this.setState(state);
	}

	onDestroy() {
		document.removeEventListener ("dragstart", this.dragHandler, false);
		this.clear();
	}

	clear() {
		this.hoveredWidget = undefined;
		this.focusedWidget = undefined;
		this.menu = undefined;
		this.widgets = [];
		this.clearSelectedWidgets();
		this._needResort = false;
		this.needRedrawWidgets = false;
		this.dragAndDrop = null;
	}

	update(state) {
		if (state !== undefined) {
			if (Rex.gui != null) {
				Rex.gui.destroy();
				delete Rex.gui;
			}
			Rex.gui = eval(state);
		}
	}

	showHint() {
		if (this._hw) {
			this.hint = new Hint(this._hw.hint);
			let t = this._hw;
			setTimeout(function () {
				if (t != this._hw) return;
				this.hint.enable = true;
				this.redraw();
			}.bind(this, t), 350);
		} else this.hint = undefined;
	}

	set focusedID(value) {
		if (!Rex.widgets) return;
		let w = Rex.widgets[value];
		if (this.focusedWidget == w) return;
		if (this._fw == w) return;
		if (this._fw) this._fw.onFocused(false);
		this._fw = w;
		if (this._fw) this._fw.onFocused(true);
		if (this.selectedWidgets && this.selectedWidgets.length && this.selectedWidgets.indexOf(this._fw) == -1) {
			if (this._fw && this._fw.type !== "WidgetPopUpMenu") this.clearSelectedWidgets();
		}
	}

	set hoveredWidget(value) {
		if (this._hw == value) return;
		if (this._hw) this._hw.onHovered(false);
		this._hw = value;
		if (this._hw) this._hw.onHovered(true);
		this.run("onHoverWidget", this._hw);
		if (value === undefined) {
			if (Rex.camera !== undefined) {
				this.mousePressed = false;
				Rex.camera.enabled = true;
			}
			Rex.callRpcMethod("Rex", this.id, this.type, "clearHover", []);
			this.redraw();
		} else {
			if (Rex.camera !== undefined && value.view.container != "transformContainer") Rex.camera.enabled = false;
			Rex.callRpcMethod("Rex", this.id, this.type, "setHoverWidgetById", [value.id]);
			this.redraw();
		}
		if (Rex.render != null) this.showHint();
	}

	get hoveredWidget() {
		return this._hw;
	}

	get hovered() {
		return (this.hoveredWidget == null) ? -1 : this.hoveredWidget.id;
	}

	set focusedWidget(value) {
		if (this._fw == value) return;
		if (this._fw) this._fw.onFocused(false);
		this._fw = value;
		if (this._fw) this._fw.onFocused(true);
		if (this.selectedWidgets && this.selectedWidgets.length && this.selectedWidgets.indexOf(this._fw) == -1) {
			if (this._fw && this._fw.type !== "WidgetPopUpMenu") this.clearSelectedWidgets();
		}
		if (value === undefined) {
			Rex.callRpcMethod("Rex", this.id, this.type, "clearFocus", []);
			this.redraw();
		} else {
			Rex.callRpcMethod("Rex", this.id, this.type, "setFocusWidgetById", [value.id]);
			this.redraw();
		}
	}

	get focusedWidget() {
		return this._fw;
	}

	set focused(value) {
		if (!Rex.widgets) return;
		let w = Rex.widgets[value];
		if (this.focusedWidget == w) return;
		this.focusedWidget = w;
	}

	get focused() {
		return (this.focusedWidget) ? this.focusedWidget.id : -1;
	}

	set menu(value) {
		if (this._menu == value) return;
		if (value === undefined) {
			Rex.callRpcMethod("Widgets", this.menu.id, "WidgetPopUpMenu", "destroy", []);
			Rex.callRpcMethod("Rex", this.id, this.type, "clearMenu", []);
		}
		this._menu = value;
	}

	get menu() {
		return this._menu;
	}

	set menuId(value) {
		if (!Rex.widgets) return;
		let m = Rex.widgets[value];
		if (m === undefined && value != -1) this.menuId = value;
		if (this.menu == m) return;
		this.menu = m;
	}

	get menuId() {
		return (this.menu) ? this.menu.id : -1;
	}

	set selectWidgets(value) {
		if (!Rex.widgets) return;
		if (this.selectedWidgets !== undefined && this.selectedWidgets.length > 0) {
			for (let w of this.selectedWidgets) {
				if (!w) continue;
				w.onSelected(false);
			}
		}
		this.selectedWidgets = [];
		for (let key in value) {
			let w = Rex.widgets[value[key]];
			if (!w) continue;
			this.selectedWidgets.push(w);
			w.startMove = new Rex.Vector2(w.posX, w.posY);
			w.onSelected(true);
		}
	}

	get selectWidgets() {
		let s = [];
		for (let key in this.selectedWidgets) {
			s.push(this.selectedWidgets[key].id);
		}
		return s;
	}

	set needResortWidgets(value) {
		this._needResort = value;
	}

	get needResortWidgets() {
		return this._needResort;
	}

	setState(state) {
		Rex.copy(this, state);
		if (state.hasOwnProperty("styles")) {
			this.styleLibrary.load(state.styles);
		}
	}

	sortW(w) {
		let sorter = function (a, b) {
			let wa = Rex.widgets[a];
			let wb = Rex.widgets[b];
			return (wa && wb) ? wa.order - wb.order : 0;
		};
		//w.children.sort(sorter);
		//for(let key in w.children) {
		//	let c = Rex.widgets[key];
		//	if(c)this.sortW(c);
		//}
	}

	resort() {
		this.needResortWidgets = true;
	}

	sortWidgets() {
		if (!this.needResortWidgets) return;
		let temp = [];
		let UI = [];
		for (let key in Rex.widgets) {
			let w = Rex.widgets[key];
			if (!w) continue;
			if (w.parentId != -1) continue;
			if (w.editable) temp.push(w);
			else UI.push(w);
		}
		let sorter = function (a, b) {
			return a.order - b.order;
		};
		temp.sort(sorter);
		UI.sort(sorter);
		for (let key in temp) this.sortW(temp[key]);
		for (let key in UI) this.sortW(UI[key]);
		this.widgets = temp;
		this.UI = UI;
		this.needResortWidgets = false;
	}

	checkHover(vector, event) {
		if (Rex.widgets == null) return;
		if (this.widgets.length === 0) return;
		const path = event.path || (event.composedPath && event.composedPath());
		for (let pathElement of path) {
			if (pathElement.id == null || pathElement.id == "") continue;
			
			let ID = NaN;
			
			try {
				if (pathElement.id.indexOf("w") === 0) {
					ID = parseInt(pathElement.id.slice(1));
				} else {
					ID = parseInt(pathElement.id);
				}
			} catch(e) {}

			if (isNaN(ID))
				continue;

			let widget = Rex.widgets[ID];
			if (!widget) continue;
			// if (this.widgets.indexOf(widget) === -1) continue;
			this.hoveredWidget = widget;
			return true;
		}
		return false;
	}

	checkHoverUI(event) {
		let path = [];
		const ePath = event.path || (event.composedPath && event.composedPath());
		for (let pathElement of ePath) {
			let id = NaN;
			
			
			if (pathElement.id) {
				
				try {
					if (pathElement.id.indexOf("w") === 0) {
						id = parseInt(pathElement.id.slice(1));
					} else {
						id = parseInt(pathElement.id);
					}
				} catch (e) { }
				
			}
			
			if (!isNaN(id)) path.push(id);
		}
		if (path.length === 0) return false;

		let fakeEvent = {};
		fakeEvent.x = event.x;
		fakeEvent.y = event.y;
		fakeEvent.path = path;

		let window = Rex.widgets[path[path.length - 1]];
		if (window == null) return false;
		if (window.parentId !== -1) {
			let t = window.view.checkSelect(fakeEvent, null);
			if (t == null) return false;
			this.hoveredWidget = t;
			return true;
		}
		let t = window.view.checkSelect(fakeEvent, path.pop());
		if (t == null) return false;
		this.hoveredWidget = t;
		return true;
	}

	menuDestroy() {
		let menuIsHover = false;
		if ((this.hoveredWidget instanceof WidgetPopUpMenu) || (this.hoveredWidget instanceof WidgetInvestmentMenuItem) || (this.hoveredWidget instanceof WidgetMenuItem)) {
			menuIsHover = true;
		}
		if (this.menu && !menuIsHover) {
			this.menu = undefined;
		}
		return menuIsHover;
	}
	mouseWheel(delta, event) {
		this.menuDestroy();
		if (this.focusedWidget !== undefined)
			this.focusedWidget.mouseWheel(delta, event);
		this.redraw();
	}

	sendMouseDownWidget(w, event) {
		let p = (w.editable) ? translateVect(this.mouse.pos) : this.mouse.pos;
		w.mouseDown(p.x, p.y, event);
	}

	popMenu(senderId, x, y) {
		Rex.callRpcMethod("Rex", this.id, this.type, "popMenu", [senderId, x, y]);
	}

	mouseDoubleClick(event) {
		if (this.focusedWidget === undefined) return;
		this.focusedWidget.mouseDoubleClick(event);
	}

	mouseDown(event) {
		let cPos = translateVect(this.mouse.pos);
		let menuIsHover = this.menuDestroy();
		if (this.hoveredWidget) {
			this.focusedWidget = this.hoveredWidget;
			if (this.keyBoard.controlKeyIsPressed()) {
				if (this.selectedWidgets && this.selectedWidgets.indexOf(this.focusedWidget) == -1) this.selectedWidgets.push(this.focusedWidget);
			}
			this.sendMouseDownWidget(this.focusedWidget, event);
			this.tempPos = new Rex.Vector2(this.focusedWidget.posX, this.focusedWidget.posY);
			if (this.selectedWidgets) this.multiSelect(this.selectedWidgets);
		} else {
			this.focusedWidget = undefined;
			this.clearSelectedWidgets();
			if (this.mouse.pressedButton === this.mouse.buttons.left) this.selection.start();
		}
		if (this.mouse.pressedButton === this.mouse.buttons.right && !menuIsHover) {
			let p = translateVect(new Rex.Vector2(event.clientX, event.clientY));
			this.popMenu(this.focusedWidget ? this.focusedWidget.id : -1, event.clientX, event.clientY);
		}
		this.startMove = cPos;
	}

	clearSelectedWidgets() {
		if (this.selectedWidgets !== undefined && this.selectedWidgets.length > 0) {
			for (let w of this.selectedWidgets) {
				if (!w) continue;
				w.onSelected(false);
			}
			this.selectedWidgets = [];
			Rex.callRpcMethod("Rex", this.id, this.type, "setSelectWidgets", [JSON.stringify(this.selectWidgets)]);
		}
	}

	confirmMoveSelection() {
		if (!this.selectedWidgets && !this.selectedWidgets.length) return;
		for (let key in this.selectedWidgets) {
			let w = this.selectedWidgets[key];
			if (w == this.focusedWidget) continue;
			w.setPos(Math.round(w.startMove.x + this.delta.x - this.tempPos.x), Math.round(w.startMove.y + this.delta.y - this.tempPos.y));
		}
	}

	mouseUp(event) {
		if (this.focusedWidget) {
			if (this.focusedWidget.moved) {
				this.focusedWidget.setPos(Math.round(this.delta.x), Math.round(this.delta.y));
				this.confirmMoveSelection();
				this.focusedWidget.moved = false;
			}
			let cPos = translateVect(new Rex.Vector2(event.clientX, event.clientY));
			this.focusedWidget.mouseUp(cPos.x, cPos.y, event);
		}
	}

	deltaByGrid(currentPos, destinationPos) {
		let delta = currentPos.add(destinationPos.sub(this.startMove));
		if (Rex.grid !== undefined) {
			let w = window.innerWidth / 2 - Math.floor(window.innerWidth / 2 / Rex.grid.st) * Rex.grid.st;
			let h = window.innerHeight / 2 - Math.floor(window.innerHeight / 2 / Rex.grid.st) * Rex.grid.st;
			delta.x = Math.trunc(Math.floor(((delta.x)) / Rex.grid.st) * Rex.grid.st + w);
			delta.y = Math.trunc(Math.floor(((delta.y)) / Rex.grid.st) * Rex.grid.st + h);
		}
		return delta;
	}

	moveSelection() {
		if (!this.selectedWidgets && !this.selectedWidgets.length) return;
		for (let key in this.selectedWidgets) {
			let w = this.selectedWidgets[key];
			if (w == this.focusedWidget) continue;
			w.view.posX = w.startMove.x + this.delta.x - this.tempPos.x;
			w.view.posY = w.startMove.y + this.delta.y - this.tempPos.y;
			w.view.positioning();
		}
	}

	mouseMove(event) {
		this.mouseMoveHover(event);
		let vector = this.mouse.pos;
		let cPos = translateVect(vector);
		if ((this.mouse.pressedButton === this.mouse.buttons.middle) && (Rex.camera.position != undefined)) {
			this.redraw();
		}

		//короче я попробовал исправить issue #119 если что смотрите туда.
		if (!(this.checkHover(cPos, event) || this.checkHoverUI(event))) {
			this.hoveredWidget = undefined;
		}
		if (this.hoveredWidget) {
			this.hoveredWidget.mouseMove(cPos.x, cPos.y, event);
		}

		//FIX////////////////////////////////////////////////////////////////////////////////
		if (this.focusedWidget)
			if (this.focusedWidget != this.hoveredWidget)
				this.focusedWidget.mouseMove(cPos.x, cPos.y, event);

		if (this.mouse.pressedButton == this.mouse.buttons.left) {
			if (this.focusedWidget && this.focusedWidget.editable) {
				this.focusedWidget.moved = true;
				this.delta = this.deltaByGrid(this.tempPos, cPos);
				this.focusedWidget.view.posX = this.delta.x;
				this.focusedWidget.view.posY = this.delta.y;
				this.focusedWidget.view.positioning();
				this.moveSelection();
			}
		}
	}

	mouseMoveHover(event) {
		if (Rex.widgets === undefined) return;
		let tar = event.target;
		let widget = undefined;
		this.turnOffHover();
		while (!widget) {
			if (tar == null || tar.id === undefined) return;
			let ID = tar.id;
			try {
				if (tar.id.indexOf("w") === 0) {
					ID = parseInt(tar.id.slice(1));
				} 
			} catch(e){}

			widget = Rex.widgets[ID];
			if (widget === undefined) widget = Rex.widgets[tar.id.replace("div", "")];
			if (widget) break;
			tar = tar.parentNode;
		}
		widget.view.recursiveHover(-1);
	}

	turnOffHover() {
		for (let i = 0; i < this._hoveredWidgets.length; i++) {
			let w = this._hoveredWidgets[i];
			w.hover = false;
		}
		this._hoveredWidgets = [];
	}

	drawSelectedWidget(ctx, ctxTemp, w) {
		ctx.strokeRect(w.posX, w.posY, w.width, w.height);
	}

	splashWidgets(ctx, ctxTemp) {
		if (this.focusedWidget) this.drawSelectedWidget(ctx, ctxTemp, this.focusedWidget);
		if (this.hoveredWidget) this.drawSelectedWidget(ctx, ctxTemp, this.hoveredWidget);
		if (!this.selectedWidgets || !this.selectedWidgets.length) return;
		for (let key in this.selectedWidgets) {
			this.drawSelectedWidget(ctx, ctxTemp, this.selectedWidgets[key]);
		}
	}

	prepare(ctx, ctxTemp) {
		if ((Rex.camera == null) || (Rex.camera.position === undefined)) return;
		let zoom = Rex.camera.getZoom() + 0.001;
		let w = document.body.clientWidth / 2;
		let h = document.body.clientHeight / 2;
		let x = Rex.camera.position.x;
		let y = Rex.camera.position.y;
		this.prepareHtml(x, y, zoom);
		if (Rex.render != null) this.prepareCTX(ctx, ctxTemp, x, y, w, h, zoom);
	}

	prepareHtml(x, y, zoom) {
		let transform = document.getElementById("transformContainer");
		if (transform == null) return;
		//transform.style.willChange = "transform";
		transform.style.transform = `scale(${zoom}) translate(${(-x)}px, ${(-y)}px)`;
		//transform.style.transform = `scale(${zoom})`;
		//transform.style.top = (-y) + "px";
		//transform.style.left = (-x) + "px";
	}

	prepareCTX(ctx, ctxTemp, x, y, w, h, zoom) {
		ctx.translate(w, h);
		ctx.scale(zoom, zoom);
		ctx.translate(-w - x, -h - y);
	}

	drawWidgets(ctx, ctxTemp) {
		ctx.save();
		this.prepare(ctx, ctxTemp);
		for (let key in this.widgets) {
			let w = this.widgets[key];
			w.view.draw(ctx, ctxTemp);
		}
		//this.splashWidgets(ctx, ctxTemp);
		this.selection.draw(ctx, ctxTemp);
		ctx.restore();
	}

	drawUI(ctx, ctxTemp) {
		ctx.save();
		for (let key in this.UI) {
			this.UI[key].view.draw(ctx, ctxTemp);
		}
		ctx.restore();
	}

	redraw() {
		this.needRedrawWidgets = true;
	}

	drawHint(ctx, ctxTemp) {
		if (!this.hint) return;
		let p = this.mouse.pos;
		this.hint.posX = p.x;
		this.hint.posY = p.y;

		this.hint.draw(ctx, ctxTemp);
	}

	draw(ctx, ctxTemp) {
		if (!this.needRedrawWidgets) return;
		this.sortWidgets();
		if (Rex.grid != null) {
			Rex.grid.refreshCanvas();
			Rex.grid.draw(Rex.grid.firstBufferCtx, Rex.grid.secondBufferCtx);
		}
		if (Rex.render != null) {
			this.drawWidgets(ctx, ctxTemp);
			this.drawUI(ctx, ctxTemp);
			this.drawHint(ctx, ctxTemp);
		} else {
			this.prepare();
			for (let key in this.widgets) {
				let w = this.widgets[key];
				w.view.draw(ctx, ctxTemp);
			}
			for (let key in this.UI) {
				this.UI[key].view.draw(ctx, ctxTemp);
			}
		}
		if (this.notificationManager.messages.length > 0) {
			this.notificationManager.sendMessage();
		}

		this.needRedrawWidgets = false;
	}

	reposition(widget) {
		this.needRepositioning = true;
		let root = this.getRootWidget(widget);
		if (root === undefined) return;
		if (this.repositionWidgets.indexOf(root) == -1) {
			if (root.parentId == -1 && root.inited) this.repositionWidgets.push(root);
		}
	}

	repositionAll() {
		this.needRepositioning = true;
		for (let key in Rex.widgets) {
			let widget = Rex.widgets[key];
			if (widget === undefined) return;
			if (widget.parentId == -1 && widget.inited) this.repositionWidgets.push(widget);
		}
	}

	refreshAll() {
		for (let key in Rex.widgets) {
			let child = Rex.widgets[key];
			if (child !== undefined && child.inited) {
				child._needRefresh = true;
			}
		}
		this.redraw();
	}

	positioning() {
		if (!this.needRepositioning) return;
		for (let i = 0; i < this.repositionWidgets.length; ++i) {
			let widget = this.repositionWidgets[i];
			if (widget === undefined || !widget.inited) continue;
			if (widget.parentId == -1) widget.view.positioning();
		}
		this.repositionWidgets = [];
		this.needRepositioning = false;
	}

	copy(event) {
		let cPos = translateVect(this.mouse.pos);
		//this.confirmMoveSelection(cPos);//todo При копировании выделенных блочков - в данной функции происходит сеттинг новых координат и они улетают на дельту
		if (this.focusedWidget) {
			let array = [];
			array.push(this.focusedWidget.id);
			if (!this.focusedWidget.editable) return;
			Rex.callRpcMethod("Rex", this.id, this.type, "copy", [JSON.stringify(array)]);
		}
		if (this.selectedWidgets.length) {
			Rex.callRpcMethod("Rex", this.id, this.type, "copy", [JSON.stringify(this.selectWidgets)]);
			return;
		}
	}

	paste(event) {
		let cPos = translateVect(this.mouse.pos);
		Rex.callRpcMethod("Rex", this.id, this.type, "paste", [Math.trunc(cPos.x), Math.trunc(cPos.y)]);
	}

	cut(event) {
		let cPos = translateVect(this.mouse.pos);
		this.confirmMoveSelection(cPos);
		if (this.focusedWidget) {
			let array = [];
			array.push(this.focusedWidget.id);
			if (!this.focusedWidget.editable) return;
			Rex.callRpcMethod("Rex", this.id, this.type, "cut", [JSON.stringify(array)]);
		}
		if (this.selectedWidgets.length) {
			Rex.callRpcMethod("Rex", this.id, this.type, "cut", [JSON.stringify(this.selectWidgets)]);
			return;
		}
	}

	save(event) {
		event.preventDefault();
		Rex.callRpcMethod("Rex", this.id, this.type, "save", []);
	}

	clone(event) {
		let cPos = translateVect(this.mouse.pos);
		//this.confirmMoveSelection(cPos);//todo При копировании выделенных блочков - в данной функции происходит сеттинг новых координат и они улетают на дельту
		if (this.focusedWidget) {
			let array = [];
			array.push(this.focusedWidget.id);
			if (!this.focusedWidget.editable) return;
			Rex.callRpcMethod("Rex", this.id, this.type, "clone", [JSON.stringify(array), Math.trunc(cPos.x), Math.trunc(cPos.y)]);
		}
		if (this.selectedWidgets.length) {
			Rex.callRpcMethod("Rex", this.id, this.type, "clone", [JSON.stringify(this.selectWidgets), Math.trunc(cPos.x), Math.trunc(cPos.y)]);
			return;
		}
		event.preventDefault();
	}

	delete() {
		if (this.focusedWidget) {
			if (!this.focusedWidget.editable) return;
			Rex.callRpcMethod("Rex", this.id, this.type, "deleteWidget", [this.focusedWidget.id]);
		}
		if (this.selectedWidgets.length) {
			Rex.callRpcMethod("Rex", this.id, this.type, "deleteWidgets", [JSON.stringify(this.selectWidgets)]);
			return;
		}
	}

	keyPress(event) {
		if (Rex.console && Rex.console.onKeyPress(event)) return;
		if (!this.focusedWidget) return;
		this.focusedWidget.keyPress(event);
	}

	keyDown(event) {
		if (Rex.console !== undefined && Rex.console.onKeyDown(event)) return;
		//if(!this.focusedWidget) return;
		if (this.keyBoard.isKeyPressed(Rex.KeyList.delete) || this.keyBoard.isKeyPressed(Rex.KeyList.backspace)) {
			this.delete();
		}
		if (this.keyBoard.isKeyPressed(Rex.KeyList.s) && this.keyBoard.controlKeyIsPressed()) {
			this.save(event);
		}
		if (this.keyBoard.isKeyPressed(Rex.KeyList.d) && this.keyBoard.controlKeyIsPressed()) {
			event.preventDefault();
			this.clone(event);
		}
		if (this.focusedWidget) this.focusedWidget.keyDown(event);
	}

	keyUp(event) {
		if (!this.focusedWidget) return;
		this.focusedWidget.keyUp(event);
	}

	multiSelect(selectedWidgets) {
		if (this.selectedWidgets !== undefined && this.selectedWidgets.length > 0) {
			for (let w of this.selectedWidgets) {
				if (!w) continue;
				w.onSelected(false);
			}
		}
		for (let key in selectedWidgets) {
			let w = selectedWidgets[key];
			w.startMove = new Rex.Vector2(w.posX, w.posY);
			w.onSelected(true);
		}
		this.selectedWidgets = selectedWidgets;
		if (this.selectedWidgets.length) Rex.callRpcMethod("Rex", this.id, this.type, "setSelectWidgets", [JSON.stringify(this.selectWidgets)]);
	}

	getRootWidget(widget) {
		if (widget === undefined) return undefined;
		while (widget.parentId != -1) {
			widget = Rex.widgets[widget.parentId];
			if (widget == undefined) break;
		}
		return widget;
	}

	dragDropInit() {
		this.dragHandler = function (event) {
			//TODO stop drag annimation если все undefined
			// if (!Rex.gui.checkHoverUI(event)) return;

			let dragWidget = Rex.gui.hoveredWidget;

			if (!dragWidget.draggable) return;
	
			//мега костыль на много событий
			if (Rex.gui.dragData != undefined) return;
			
			Rex.gui.dragData = dragWidget.drag();
			let dragImage = dragWidget.dragImage;
			
			if(dragImage instanceof(Image) == false) {
				let img = new Image(dragImage);
				img.src = dragImage;
				dragImage = img;
			}

			if(dragImage != undefined)
				event.dataTransfer.setDragImage(dragImage, 0, 0);	
	
			Rex.callRpcMethod("Widgets", dragWidget.id, dragWidget.type, "drag", []);
		}
		document.addEventListener("dragstart", this.dragHandler, false);
	}

	

	drop (dropData) {
		//костыль чтобы 1 раз вызвался дроп у самого верхнего виджета
		//на который можно дропать
		if (this.dragData == undefined) return;
		
		let data = {
			drag : this.dragData,
			drop : dropData
		}
		this.dragData = undefined;
		Rex.callRpcMethod("Rex", Rex.gui.id, Rex.gui.type, "drop", [JSON.stringify(data)]);
	}
}


class Grid {
	
	constructor() {
		this.step = null;
		this.st = 18;
		this.width = document.body.clientWidth;
		this.height = document.body.clientHeight;
		
		this.firstBuffer = document.createElement("canvas");
		this.firstBufferCtx = this.firstBuffer.getContext("2d");
		this.div = document.createElement("div");
		this.div.style.position = "relative";
		this.div.style.width = window.innerWidth + "px";
		this.div.style.height = window.innerHeight + "px";
		document.body.insertBefore(this.div, document.getElementById("container1"));
		this.div.appendChild(this.firstBuffer);
		
		this.secondBuffer = document.createElement("canvas");
		this.secondBufferCtx = this.secondBuffer.getContext("2d");
	}
	
	clear() {
		document.body.removeChild(this.div);
	}
	
	refreshCanvas() {
		this.firstBuffer.width = 1;
		this.secondBuffer.width = 1;
		
		this.firstBuffer.width = window.innerWidth;
		this.firstBuffer.height = window.innerHeight;
		
		this.secondBuffer.width = window.innerWidth;
		this.secondBuffer.height = window.innerHeight;
	}
	
	draw(ctx, ctxTemp) {
		if(Rex.camera === undefined || !(Rex.camera instanceof Camera2D)) return;
		this.width = document.body.clientWidth;
		this.height = document.body.clientHeight;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, window.innerWidth, window.innerHeight);
		ctxTemp.save();
		this.zoom = Rex.camera.getZoom();
		ctxTemp.translate(this.width / 2, this.height / 2);
		ctxTemp.scale(this.zoom, this.zoom);
		ctxTemp.translate(-Rex.camera.position.x, -Rex.camera.position.y);
		let topGrid;
		let bottomGrid;
		let leftGrid;
		let rightGrid;
		if(this.zoom > 1) {
			topGrid = -(this.height + Math.abs(Rex.camera.position.y)) * this.zoom;
			bottomGrid = (this.height + Math.abs(Rex.camera.position.y)) * this.zoom;
			leftGrid = -(this.width + Math.abs(Rex.camera.position.x)) * this.zoom;
			rightGrid = (this.width + Math.abs(Rex.camera.position.x)) * this.zoom;
		} else {
			topGrid = -(this.height + Math.abs(Rex.camera.position.y)) / this.zoom;
			bottomGrid = (this.height + Math.abs(Rex.camera.position.y)) / this.zoom;
			leftGrid = -(this.width + Math.abs(Rex.camera.position.x)) / this.zoom;
			rightGrid = (this.width + Math.abs(Rex.camera.position.x)) / this.zoom;
		}
		
		let thickness = 1 / this.zoom;
		this.step = Math.max(1.0, Math.pow(10.0, Math.ceil(Math.log10(2 / Rex.camera.zoom)))) * this.st;
		let y = Math.floor(topGrid / this.step) * this.step;
		while(y < bottomGrid) {
			if(parseInt(Math.floor(y / this.step + 0.5)) == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(76, 76, 12)";
				ctxTemp.moveTo(leftGrid, y);
				ctxTemp.lineTo(rightGrid, y);
				ctxTemp.stroke();
			} else if(parseInt(Math.floor(y / this.step + 0.5)) % 10 == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(76, 76, 76)";
				ctxTemp.moveTo(leftGrid, y);
				ctxTemp.lineTo(rightGrid, y);
				ctxTemp.stroke();
			} else if(parseInt(Math.floor(y / this.step + 0.5)) % 5 == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(38, 38, 38)";
				ctxTemp.moveTo(leftGrid, y);
				ctxTemp.lineTo(rightGrid, y);
				ctxTemp.stroke();
			} else {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(25, 25, 25)";
				ctxTemp.moveTo(leftGrid, y);
				ctxTemp.lineTo(rightGrid, y);
				ctxTemp.stroke();
			}
			y += this.step;
		}
		
		let x = Math.floor(leftGrid / this.step) * this.step;
		while(x < rightGrid) {
			if(parseInt(Math.floor(x / this.step + 0.5)) == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(76, 76, 12)";
				ctxTemp.moveTo(x, topGrid);
				ctxTemp.lineTo(x, bottomGrid);
				ctxTemp.stroke();
			} else if(parseInt(Math.floor(x / this.step + 0.5)) % 10 == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(76, 76, 76)";
				ctxTemp.moveTo(x, topGrid);
				ctxTemp.lineTo(x, bottomGrid);
				ctxTemp.stroke();
			} else if(parseInt(Math.floor(x / this.step + 0.5)) % 5 == 0) {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(38, 38, 38)";
				ctxTemp.moveTo(x, topGrid);
				ctxTemp.lineTo(x, bottomGrid);
				ctxTemp.stroke();
			} else {
				ctxTemp.beginPath();
				ctxTemp.lineWidth = thickness;
				ctxTemp.strokeStyle = "rgb(25, 25, 25)";
				ctxTemp.moveTo(x, topGrid);
				ctxTemp.lineTo(x, bottomGrid);
				ctxTemp.stroke();
			}
			x += this.step;
		}
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Rex*/
/*
class DragAndDrop {

	constructor(sender, data, type) {
		this.posX = 0;
		this.posY = 0;
		this.sender = sender;
		this.type = "";
		this.data = data;
		this.imageData = undefined;
		this.tempCanvas = document.createElement("canvas");
		this.tempCtx = this.tempCanvas.getContext("2d");
		// if (sender.view.htmlElement != null) {
		// 	sender.view.htmlElement.ondragend = e => {
		// 		Rex.gui.mouseUp(e);
		// 		Rex.mouse.pressedButton = 0;
		// 	};
		// sender.view.htmlElement.ondragstart = e => {this.sendDrag()};
		// sender.view.htmlElement.ondragstart = e => {this.setDragImage(e);};
		// }
	}

	// setDragImage(e) {

	// 	let sender = this.sender;

	// 	if (this.sender == undefined)
	// 		return;

	// 	let dragImage = this.sender.dragImage;

	// 	if (dragImage == undefined)
	// 		return;

	// 	let im = new Image();

	// 	im.src = dragImage;

	// 	e.dataTransfer.setDragImage(im, 0, 0);
	// }

	grabImage(ctx, x, y, width, height) {
		if (this.imageData === undefined) {
			this.tempCanvas.width = ctx.canvas.width;
			this.tempCanvas.height = ctx.canvas.height;
			this.tempCtx.drawImage(ctx.canvas, 0, 0);
			this.imageData = this.tempCtx.getImageData(x, y, width, height);
		}
	}

	draw(ctx) {
		if (this.imageData !== undefined) {
			this.tempCanvas.width = this.imageData.width;
			this.tempCanvas.height = this.imageData.height;
			this.tempCtx.putImageData(this.imageData, 0, 0);
			ctx.drawImage(this.tempCanvas, this.posX, this.posY);
			Rex.gui.redraw();
			ctx.restore();
		}
	}

	mouseMove(x, y) {
		if (this.posX == x && this.posY == y) return;
		this.posX = x;
		this.posY = y;
	}

	sendDrag() {
		Rex.callRpcMethod("Widgets", this.sender.id, this.sender.type, "drag", []);
	}

	sendDrop(data) {
		// let data = undefined;
		// let receiver = Rex.gui.hoveredWidget;
		// if (receiver !== undefined) data = receiver.drop(this);
		// //если супердаты нету, то сетим дефолтную.
		// if (data === undefined) {
		// 	data = {
		// 		drag : {
		// 			sender : this.sender.id,
		// 			data : this.data
		// 		},
		// 		drop : {
		// 			receiver : receiver == undefined ? -1 : receiver.id,
		// 			pos : {
		// 				x : this.posX,
		// 				y : this.posY
		// 			},
		// 			data : {}
		// 		}
		// 	}
		// }

		Rex.callRpcMethod("Rex", Rex.gui.id, Rex.gui.type, "drop", [JSON.stringify(data)]);
	}
}
*/


class Engine {
	
	constructor() {
		document.addEventListener("mousemove", this.mouseMove.bind(this));
		document.addEventListener("mousedown", this.mouseDown.bind(this));
		document.addEventListener("mouseup", this.mouseUp.bind(this));
		document.addEventListener("wheel", this.mouseWheel.bind(this));
		document.addEventListener("dblclick", this.mouseDoubleClick.bind(this));
		
		document.addEventListener("keydown", this.keyDown.bind(this));
		document.addEventListener("keyup", this.keyUp.bind(this));
		
		window.addEventListener("orientationchange", this.changeOrientation.bind(this));
		this.getLoadedDevice();
		this.changeOrientation();
		
		this.oldXX = 0.0;
		this.oldYY = 0.0;
	}
	
	mouseMove(event) {
		if(Math.abs(this.oldXX -  event.clientX) < 2 && Math.abs(this.oldYY - event.clientY) < 2) return;
		//if(Rex.gui != undefined) Rex.gui.mouseMove(event);
		Rex.callRpcFunction("RexEngine", "mouseMove", [event.clientX, event.clientY]);
	}
	
	mouseDown(event) {
		let button = this.translateMouseButton(event.which);
		Rex.callRpcFunction("RexEngine", "mouseDown", [event.clientX, event.clientY, button]);
	}
	
	mouseUp(event) {
		let button = this.translateMouseButton(event.which);
		Rex.callRpcFunction("RexEngine", "mouseUp", [event.clientX, event.clientY, button]);
	}
	
	mouseWheel(event) {
		Rex.callRpcFunction("RexEngine", "mouseWheel", [Math.abs(event.deltaY) / event.deltaY]);
	}
	
	mouseDoubleClick(event) {
		Rex.callRpcFunction("RexEngine", "mouseDoubleClick", [event.clientX, event.clientY]);
	}
	
	keyDown(event) {
		Rex.callRpcFunction("RexEngine", "keyDown", [event.keyCode]);
	}
	
	keyUp(event) {
		Rex.callRpcFunction("RexEngine", "keyUp", [event.keyCode]);
	}
	
	translateMouseButton(which) {
		if(which == 1 || which == 0) return Rex.MouseButtonLeft;
		if(which == 2) return Rex.MouseButtonMid;
		if(which == 3) return Rex.MouseButtonRight;
		return -1;
	}
	
	changeOrientation() {
		let type = screen.orientation.type;
		if(type.indexOf("portrait") != -1) Rex.callRpcFunction("RexEngine", "orientationChange", [false]);
		else Rex.callRpcFunction("RexEngine", "orientationChange", [true]);
	}
	
	getLoadedDevice() {
		var OSName = "Unknown OS";
		if(navigator.userAgent.indexOf("Mobile") != -1) OSName = "Mobile";
		if(navigator.userAgent.indexOf("Win") != -1) OSName = "Windows";
		if(navigator.userAgent.indexOf("Mac") != -1) OSName = "Macintosh";
		if(navigator.userAgent.indexOf("Linux") != -1) OSName = "Linux";
		if(navigator.userAgent.indexOf("Android") != -1) OSName = "Android";
		if(navigator.userAgent.indexOf("like Mac") != -1) OSName = "iOS";
		Rex.callRpcFunction("RexEngine", "deviceOS", [OSName]);
	}
	
}

class canvasObject {
	constructor() {
		this.ctx = document.createElement('canvas').getContext('2d');
	}

	get context() {
		return this.ctx;
	}
}

let canvas = new canvasObject();

function getWidthOfString(text, font) {
	canvas.context.font = font;
	return canvas.context.measureText(text).width;
}

function getLinesNumber(node) {
	let text = node.innerText || node.innerHtml || node.textContent;
	if (text == null || text.length === 0)
		return 0;

	const spaceLetter = '';
	const font = getStyle(node, 'font');

	let result = 1;

	let words = text.split(spaceLetter);
	let width = 0;
	for (let word of words) {
		if (words.indexOf(word) !== words.length - 1)
			word += spaceLetter;

		const wordWidth = getWidthOfString(word, font);
		width += wordWidth;
		if (width >= node.offsetWidth) {
			++result;
			width = wordWidth;
		}
	}

	return result;
}

function getStyle(node, styleName) {
	let oElm = node;
	let strValue = "";
	if (document.defaultView && document.defaultView.getComputedStyle) {
		let v = document.defaultView.getComputedStyle(oElm, "");
		strValue = v[styleName];

		if (strValue == undefined) strValue = node.style[styleName];
	}
	else if (oElm.currentStyle) {
		styleName = styleName.replace(/\-(\w)/g, function (strMatch, p1) { return p1.toUpperCase(); });
		strValue = oElm.currentStyle[styleName];
	}
	return strValue;
}

function getOffsetParentOfConstructor() {
	for (const widget of Rex.widgets) {
		if (widget.type == 'Constructor') {
			return widget.view.htmlElement.offsetParent;
		}
	}

	return null;
}

function getOffsetValues(node) {
	if (node == null)
		return null;

	const offset =
	{
		width: node.scrollWidth - node.offsetWidth,
		height: node.scrollHeight - node.offsetHeight
	};

	return offset;
}

function hasScrollBar(node) {
	const offset = getOffsetValues(node);
	if (offset == null)
		return false;

	return (offset.height > 0 || offset.width > 0)
}

function isHEX(color) {
	return color.indexOf('#') !== -1;
}

function isRGB(color) {
	return color.indexOf('rgb(') !== -1;
}

function isRGBA(color) {
	return color.indexOf('rgba(') !== -1;
}

// color - HEX color
// opacity - value in the range from 0 to 1
// new color value will be written to color valiable
function mixColorWithOpacity(color, opasity) {
	if (color == null || opasity == null)
		return;

	if (!isHEX(color))
		return;

	if (opasity < 0 || opasity >= 1)
		return;

	const tmpColor = color.slice(1);
	let r = parseInt(tmpColor.slice(0, 2), 16);
	let g = parseInt(tmpColor.slice(0, 2), 16);
	let b = parseInt(tmpColor.slice(0, 2), 16);

	r = parseInt(255 - opasity * (255 - r)).toString(16);
	g = parseInt(255 - opasity * (255 - g)).toString(16);
	b = parseInt(255 - opasity * (255 - b)).toString(16);

	return color = '#' + r + g + b;
}

function getColorHEX(color) {
	let result = '#ffffff'

	if (isHEX(color)) {
		const c = color.slice(1);
		let r = 255;
		let g = 255;
		let b = 255;
		let alpha = 1;

		if (c.length === 3 || c.length === 4) {
			r = parseInt(c[0] + c[0], 16);
			g = parseInt(c[1] + c[1], 16);
			b = parseInt(c[1] + c[1], 16);
			tmp = r + g + b;

			if (c.length === 4)
				alpha = parseInt(c[2] + c[2], 16) / 16;
		} else if (c.length === 6 || c.length === 8) {
			r = parseInt(c.slice(0, 2), 16);
			g = parseInt(c.slice(2, 4), 16);
			b = parseInt(c.slice(4, 6), 16);

			if (c.length === 8)
				alpha = parseInt(c.slice(6), 16) / 255;
		}
		
		if (alpha !== 1) {
			r = 255 - alpha * (255 - r);
			g = 255 - alpha * (255 - g);
			b = 255 - alpha * (255 - b);
		}
		
		result = '#' + r.toString(16) + g.toString(16) + b.toString(16);
	} else if (isRGB(color)) {
		const c = color.slice(4, color.length - 1);

		let index = 0;
		let r = parseInt(c.slice(0, index = c.indexOf(','))).toString(16);
		let g = parseInt(c.slice(index + 2, index = c.indexOf(',', index + 1))).toString(16);
		let b = parseInt(c.slice(index + 2)).toString(16);

		if (r.length === 1) r = 0 + r;
		if (g.length === 1) g = 0 + g;
		if (b.length === 1) b = 0 + b;

		result = '#' + r + g + b;
	} else if (isRGBA(color)) {
		const c = color.slice(5, color.length - 1);

		let index = 0;
		let r = parseInt(c.slice(0, index = c.indexOf(',')));
		let g = parseInt(c.slice(index + 2, index = c.indexOf(',', index + 1)));
		let b = parseInt(c.slice(index + 2, index = c.indexOf(',', index + 1)));
		let a = parseFloat(c.slice(index + 2));

		r = parseInt(255 - a * (255 - r)).toString(16);
		g = parseInt(255 - a * (255 - g)).toString(16);
		b = parseInt(255 - a * (255 - b)).toString(16);
		
		if (r.length === 1) r = 0 + r;
		if (g.length === 1) g = 0 + g;
		if (b.length === 1) b = 0 + b;

		result = '#' + r + g + b
	} else {
		result = color;
	};

	return result;
}

//layout argument is not WidgetLayout
//it is layout of table dd-object
function generateBorder(layout, node) {
	const borderStyle = getStyle(node, 'borderStyle');
	const borderWidth = getStyle(node, 'borderWidth');
	const borderColor = getColorHEX(getStyle(node, 'borderColor'));

	if (borderStyle == 'node' ||
		borderStyle == 'hidden' ||
		borderWidth == 0)
	{
		// if htmlNode has no border or border width is 0,
		// then need to make it invisible

		const backgroundColor = getColorHEX(getStyle(node, 'background-color'));

		layout.vLineColor = backgroundColor;
		layout.hLineColor = backgroundColor;
		layout.vLineWidth = function(i, node) { return 0; }
		layout.hLineWidth = function(i, node) { return 0; }
	} else {
		//if htmlNode has border, then need to set it up

		layout.vLineColor = borderColor;
		layout.hLineColor = borderColor;
		layout.vLineWidth = function() { return parseInt(borderWidth); };
		layout.hLineWidth = function() { return parseInt(borderWidth); };

		if (borderStyle == 'dashed') {
			layout.vLineStyle = function() { return {dash:{length: 6, space: 4}}; };
			layout.hLineStyle = function() { return {dash:{length: 6, space: 4}}; };
		} else if (borderStyle == 'dotted') {
			layout.vLineStyle = function() { return {dash:{length: 4, space: 4}}; };
			layout.hLineStyle= function() { return {dash:{length: 4, space: 4}}; };
		}
	}
}

function generateText(node, object) {
	let text = node.innerText || node.textContent || node.value;
	if (text == null || text.length === 0)
		text = "";

	object.text = text;
	object.color = getColorHEX(getStyle(node, 'color'));
	object.alignment = getStyle(node, 'text-align');

	object.fontSize = parseInt(getStyle(node, 'fontSize')) - 2;
	//NOTE: I'll calculate it later
	object.lineHeight = 1;

	let side = ['left', 'top', 'right', 'bottom']
	for (let i = 0; i < side.length; ++i) {
		const value = parseInt(getStyle(node, 'margin-' + side[i]));
		if (isNaN(value))
			continue;

		object.margin[i] = value;
	}

	const vAlignment = getStyle(node, 'align-items');
	//if value of vertical alignemnt type is not 'top'
	if (vAlignment == 'center' ||
	vAlignment === 'left' ||
	vAlignment === 'right' ||
	vAlignment === 'safe' ||
	vAlignment === 'unsafe' ||
	vAlignment === 'flex-end') {
		const linesNumber = getLinesNumber(node);
		//NOTE: the string height value may be unique for every font,
		//		bold and italic styles can't change it.
		//		I'll try to calculate this value later
		// const stringHeight = 1.17;
		const stringHeight = 1.24;
		// calculate margin-top value
		let topValue = node.getBoundingClientRect().height - (object.fontSize * linesNumber * stringHeight * object.lineHeight);
		if (vAlignment !== 'flex-end') {
			//if value of virtical alignment type is 'center', then need to divide the margin-top value by 2
			topValue -= object.margin[1];
			topValue /= 2;
		} else {
			//if value of virtical alignment type is 'bottom'
			topValue -= object.margin[1] * 2;
		}

		object.margin[1] += topValue;
	}

	const italic = getStyle(node, 'font-style');
	if (italic === 'oblique' || italic == 'italic')
		object.italics = true;
	else object.italics = false;

	const bold = getStyle(node, 'font-weight');
	// font-weight value can be a number
	if (bold === 'bold' ||
		bold === 'bolder' ||
		parseInt(bold) >= 600)
		object.bold = true;
	else object.bold = false;

	//NOTE: i can get inherited style value using a webkitTextDecorationsInEffect;
	const decoration = window.getComputedStyle(node).webkitTextDecorationsInEffect;
	// set decoration style
	if (decoration == 'underline' ||
		decoration == 'overline' ||
		decoration == 'line-through')
	object.decoration = decoration;
}

class PDFPage {

	constructor() {
		this._content = [];
	}

	generateContent(widget, imgs) {
		if (widget == null)
			return;

		let docData = {
			firstId : widget.id,
			currentHeight : 0,
			images: imgs,
			docHeight : widget.view.htmlElement.offsetHeight
		}

		widget.generateContent(this._content, docData);
	}

	get content() {
		return this._content;
	}

};

class PDFCreator extends RexObject {

    constructor() {
        super();

        this._documentName = "";

        // document pages
        this._pages = [];
        // document images
        this._images = [];
        // widgets from which pages are generated
        this._widgets = [];

        // this object defines document content, size, etc.
        // you can read more here: https://pdfmake.github.io/docs/document-definition-object/page/
        this._documentDefinition = 
        {
            // [left, top, right, bottom] or [horizontal, vertical] or just a number for equal margins
            pageMargins : [0, 0, 0, 0],
            // a string or { width: number, height: number }
            // you can use these string values
            // ‘A/B/C 0-10’, 'RA0-4’, 'SRA0-4'
            // ‘EXECUTIVE’, ‘FOLIO’, ‘LEGAL’, ‘LETTER’, ‘TABLOID’
            pageSize : 'A4',
            // by default we use portrait, you can change it to landscape if you wish
            pageOrientation : 'portrait'
        }
    }

    setState(state) {
        if (state.pageSize != null) this.documentSize = state.pageSize;
        if (state.name != null) this.documentName = state.name;
        if (state.orientation != null) this.documentOrientation = state.orientation;
        if (state.widgetId != null) this.appendPage(state.widgetId);
        if (state.needSave != null) this.save();

        if (state.remove != null) {
            for (let id of state.remove) {
                this.removePage(id);
            }
        }
    }

    set documentName(name) {
        if (name == null) {
            console.error('PDFCreator: documentSize -> name string is null');
            return;
        }

        if (typeof(name) !== 'string') {
            console.error('PDFCreator: documentSize -> name object isn\'t string');
            return;
        }

        if (name === '') {
            console.error('PDFCreator: documentSize -> name string is empty');
            return;
        }

        this._documentName = name;
    }

    get documentName() {
        return this._documentName;
    }

    set documentSize(size) {
        if (size == null) {
            console.error('PDFCreator: documentSize -> size object is empty');
            return;
        }

        let type = typeof(size);
        if (type !== 'string' && type !== 'object') {
            console.error('PDFCreator: documentSize -> size object has bad type');
            return;
        }

        this._documentDefinition.pageSize = size;
    }

    get documentSize() {
        return this._documentDefinition.pageSize;
    }

    set documentOrientation(orientation) {
        if (orientation == null) {
            console.error('PDFCreator: documentOrientation -> orientation string is null');
            return;
        }

        let type = typeof(orientation)
        if (type !== 'string' && type !== 'number') {
            console.error('PDFCreator: documentOrientation -> orientation object has bad type');
            return;
        }

        if (orientation === '') {
            console.error('PDFCreator: documentOrientation -> orientation string is empty');
            return;
        }

        if (orientation === 'portrait' || orientation === 'landscape') {
            this._documentDefinition.pageOrientation = orientation;
        } else {
            if (orientation == 0) {
                this._documentDefinition.pageOrientation = 'portrait';
            } else if (orientation == 1) {
                this._documentDefinition.pageOrientation = 'landscape';
            } else {
                console.error('PDFCreator: documentOrientation -> unknown orientation');
            }
        }
    }

    get documentOrientation() {
        return this._documentDefinition.pageOrientation;
    }

    get numPages() {
        return this._pages.length;
    }

    appendPage(widgetID) {
        if (widgetID == null) {
            console.error('PDFCreator: appendPage -> widgetID is null');
            return;
        }

        if (typeof(widgetID) !== 'number') {
            if (typeof(widgetID) === 'string') {
                widgetID = parseInt(widgetID);
                if (isNaN(widgetID)) {
                    console.error('PDFCreator: appendPage -> widgetID is NaN');
                    return;
                }
            } else {
                console.error('PDFCreator: appendPage -> widgetID has bad type');
                return;
            }
        }

        let widget = Rex.widgets[widgetID];
        if (widget == null) {
            console.error('PDFCreator: appendPage -> Rex has no widget with id \'' + widgetID + '\'');
            return;
        }

        if (this._pages.length !== 0) {
            let last = this._pages[this._pages.length - 1];
            last._content[last._content.length - 1].pageBreak = 'after';
        }

        let page = new PDFPage();
        page.generateContent(widget, this._images);
        this._pages.push(page);
        this._widgets.push(widgetID);
    }

    removePage(widgetID) {
        if (widgetID == null) {
            console.error('PDFCreator: removePage -> widgetID is null');
            return;
        }

        if (typeof(widgetID) !== 'number') {
            if (typeof(widgetID) === 'string') {
                widgetID = parseInt(widgetID);
                if (isNaN(widgetID)) {
                    console.error('PDFCreator: removePage -> widgetID is NaN');
                    return;
                }
            } else {
                console.error('PDFCreator: removePage -> widgetID has bad type');
                return;
            }
        }

        let index = this._widgets.indexOf(widgetID);
        if (index === -1) {
            console.error('PDFCreator: removePage -> document has no that page');
            return;
        }

        this._widgets.splice(index, 1);
        this._pages.splice(index, 1);
    }

    save() {
		this._mainContent = [];

        // generate main content from pages
		for (const page of this._pages) {
			for (const cont of page._content) {
				this._mainContent.push(cont);
			}
		}

        // define pdkmake lib content
		this._documentDefinition.content = this._mainContent;

        // set up fonts
		pdfMake.vfs = globalThis.pdfMake.vfs;
		if (this._documentName.indexOf('.pdf') === -1)
			this._documentName += '.pdf';

        if (this._images.length === 0)
            // save document on the client pc
			pdfMake.createPdf(this._documentDefinition).download(this._documentName);
    }

}

// Rex header

Rex.Buffer = {};

/**
 * Buffer
 * @constructor
 */
class Buffer extends RexObject {
	
	constructor(state) {
		super();
		this.stride = undefined;
		this.data = new Uint8Array([]);
		
		this.old_data = undefined;
		
		this.array = undefined;
		
		this.buffer = undefined;
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setStride(stride) {
		this.stride = stride;
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
	/// bind uniform buffer
	bindUniform(index, format) {
		
		var gl = Rex.render.gl;
		
		// update buffer data
		if(this.old_data !== this.data) {
			this.array = new Float32Array(this.data.buffer);
			this.old_data = this.data;
		}
		
		// set uniform buffer
		if(format === Rex.FormatFloat32x1) gl.uniform1fv(index, this.array);
		else if(format === Rex.FormatFloat32x2) gl.uniform2fv(index, this.array);
		else if(format === Rex.FormatFloat32x3) gl.uniform3fv(index, this.array);
		else if(format === Rex.FormatFloat32x4) {
			if(this.data.byteLength === 64) gl.uniformMatrix4fv(index, false, this.array);
			else gl.uniform4fv(index, this.array);
		} else {
			Rex.error("Rex.Buffer.bindUniform(): unknown format: " + format);
			return false;
		}
		
		return true;
	}
	
	/// bind array buffer
	bindArray(type, layout) {
		
		var gl = Rex.render.gl;
		
		// create buffer
		if(this.buffer === undefined) {
			this.buffer = gl.createBuffer();
		}
		
		// update buffer data
		if(this.old_data !== this.data) {
			gl.bindBuffer(type, this.buffer);
			gl.bufferData(type, this.data, gl.STATIC_DRAW);
			this.old_data = this.data;
		}
		
		// bind buffer
		if(type === gl.ARRAY_BUFFER) {
			
			// get WebGL formats
			if(Rex.Buffer.vertex_sizes === undefined) {
				
				// vertex sizes
				Rex.Buffer.vertex_sizes = [
					undefined, undefined,
					4,
					undefined, undefined,
					2, 4,
					1, 2, 3, 4
				];
				
				// vertex types
				Rex.Buffer.vertex_types = [
					undefined, undefined,
					gl.UNSIGNED_BYTE,
					undefined, undefined,
					gl.HALF_FLOAT_OES, gl.HALF_FLOAT_OES,
					gl.FLOAT, gl.FLOAT, gl.FLOAT, gl.FLOAT
				];
			}
			
			// enable vertex attributes
			for(var i = 0; i < layout.vertex_formats.length; i++) {
				gl.bindBuffer(type, this.buffer);
				var vertex_format = layout.vertex_formats[i];
				var vertex_size = Rex.Buffer.vertex_sizes[vertex_format];
				var vertex_type = Rex.Buffer.vertex_types[vertex_format];
				if(vertex_size === undefined || vertex_type === undefined) return false;
				gl.vertexAttribPointer(i, vertex_size, vertex_type, false, layout.vertex_stride, layout.vertex_offsets[i]);
				gl.enableVertexAttribArray(i);
			}
		}
		else if(type === gl.ELEMENT_ARRAY_BUFFER) {
			gl.bindBuffer(type, this.buffer);
		}
		
		return true;
	}
	
	/// unbind array buffer
	unbindArray(type, layout) {
		
		var gl = Rex.render.gl;
		
		// unbind buffer
		if(type === gl.ARRAY_BUFFER) {
			
			// disable vertex attributes
			for(var i = 0; i < layout.vertex_formats.length; i++) {
				gl.disableVertexAttribArray(i);
			}
		}
		
		return true;
	}
	
}


/**
 * Geometry
 * @constructor
 */

class Geometry extends RexObject {
	
	constructor(state) {
		super();
		this.layout = undefined;
		
		this.vertex_buffer = undefined;
		this.index_buffer = undefined;
		
		this.bound_center = new Rex.Vector3();
		this.bound_radius = 0;
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	onSuccessInit() {
		this.layout = Rex.layouts[this.layout];
		this.vertex_buffer = Rex.buffers[this.vertex_buffer];
		this.index_buffer = Rex.buffers[this.index_buffer];
	}
	
	setLayout(layout) {
		this.layout = layout;
	}
	
	setVertexBuffer(buffer) {
		this.vertex_buffer = buffer;
	}
	
	setIndexBuffer(buffer) {
		this.index_buffer = buffer;
	}
	
	setState(state) {
		Rex.copy(this, state);
		if(state.vertex_buffer != null || state.index_buffer != null || state.layout != null) {
			this.inited = false;
			let vertexBuffer = Rex.buffers[state.vertex_buffer];
			if(vertexBuffer != null) vertexBuffer.inited = false;
			let indexBuffer = Rex.buffers[state.index_buffer];
			if(indexBuffer != null) indexBuffer.inited = false;
			this.checkInit();
		}
	}
	
	/// bind geometry
	bind() {
		
		var gl = Rex.render.gl;
		
		// mesh layout
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.layout instanceof Rex.Layout)) {
		//	this.layout = Rex.getLayout(this.layout);
		//	if(!(this.layout instanceof Rex.Layout)) return false;
		//}
		
		// vertex buffer
		//if(!(this.vertex_buffer instanceof Rex.Buffer)) {
		//	this.vertex_buffer = Rex.getBuffer(this.vertex_buffer);
		//	if(!(this.vertex_buffer instanceof Rex.Buffer)) return false;
		//}
		
		// index buffer
		//if(!(this.index_buffer instanceof Rex.Buffer)) {
		//	this.index_buffer = Rex.getBuffer(this.index_buffer);
		//	if(!(this.index_buffer instanceof Rex.Buffer)) return false;
		//}
		// bind buffers
		if(!this.vertex_buffer.bindArray(gl.ARRAY_BUFFER, this.layout)) return false;
		if(!this.index_buffer.bindArray(gl.ELEMENT_ARRAY_BUFFER, this.layout)) return false;
		
		return true;
	}
	
	/// unbind geometry
	unbind() {
		
		var gl = Rex.render.gl;
		
		// check geometry
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.layout instanceof Rex.Layout)) return false;
		//if(!(this.vertex_buffer instanceof Rex.Buffer)) return false;
		//if(!(this.index_buffer instanceof Rex.Buffer)) return false;
		
		// unbind buffers
		if(!this.vertex_buffer.unbindArray(gl.ARRAY_BUFFER, this.layout)) return false;
		if(!this.index_buffer.unbindArray(gl.ELEMENT_ARRAY_BUFFER, this.layout)) return false;
		
		return true;
	}
	
}


/**
 * Layout
 * @constructor
 */

class Layout extends RexObject {
	
	constructor(state) {
		super();
		this.vertex_stride = 0;
		this.index_format = Rex.FormatUnknown;
		
		this.vertex_formats = [];
		this.vertex_offsets = [];
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
}


// Rex header

/**
 * Label
 * @constructor
 */

class Label extends RexObject {
	
	constructor(state) {
		super();
		this.text = '';
		this.font = '';
		this.align = '';
		this.color = '';
		
		this.position_x = 0;
		this.position_y = 0;
		
		this.transform = new Rex.Matrix4();
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setText(text) {
		this.text = text;
	}
	
	setFont(font) {
		this.font = font;
	}
	
	setAlign(align) {
		this.align = align;
	}
	
	setColor(color) {
		this.color = color;
	}
	
	setPosition(x, y) {
		this.position_x = x;
		this.position_y = y;
	}
	
	setTransform(transform) {
		this.transform = transform;
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
	draw(ctx) {
		var m = this.transform.m;
		var width = Rex.render.width;
		var height = Rex.render.height;
		
		ctx.font = this.font;
		ctx.textAlign = this.align;
		ctx.fillStyle = this.color;
		ctx.setTransform(m[0], m[1], m[4], m[5], m[12] * width, m[13] * height);
		ctx.fillText(this.text, this.position_x, this.position_y);
		Rex.gui.redraw();
	}
	
}

// Rex header

/**
 * Line
 * @constructor
 */
class Line extends RexObject {
	
	constructor(state) {
		super();
		this.color = '';
		this.cap = '';
		this.width = 1;
		
		this.transform = new Rex.Matrix4();
		
		this.points = [];
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setColor(color) {
		this.color = color;
	}
	
	setCap(cap) {
		this.cap = cap;
	}
	
	setWidth(width) {
		this.width = width;
	}
	
	setTransform(transform) {
		this.transform = transform;
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
	draw(ctx) {
		if(this.points.length > 2) {
			var m = this.transform.m;
			var width = Rex.render.width;
			var height = Rex.render.height;
			ctx.setTransform(m[0], m[1], m[4], m[5], m[12] * width, m[13] * height);
			ctx.lineCap = this.cap;
			ctx.lineWidth = this.width;
			ctx.strokeStyle = this.color;
			ctx.beginPath();
			ctx.moveTo(this.points[0] * width, this.points[1] * height);
			for(var i = 2; i < this.points.length; i += 2) {
				ctx.lineTo(this.points[i + 0] * width, this.points[i + 1] * height);
			}
			ctx.stroke();
		}
		Rex.gui.redraw();
	}
	
}

// Rex header
Rex.Material = {};
/**
 * Globals
 */
Rex.Material.buffer_mask = 0;
Rex.Material.blend_src = Rex.BlendNone;
Rex.Material.blend_dest = Rex.BlendNone;
Rex.Material.depth_func = Rex.DepthNone;
Rex.Material.stencil_func = Rex.StencilNone;
Rex.Material.stencil_ref = 0xff;
Rex.Material.stencil_fail = Rex.StencilOpKeep;
Rex.Material.stencil_zfail = Rex.StencilOpKeep;
Rex.Material.stencil_zpass = Rex.StencilOpKeep;
Rex.Material.polygon_factor = 0;
Rex.Material.polygon_units = 0;
Rex.Material.cull_face = Rex.FaceNone;

/**
 * Begin/end material rendering
 */
Rex.Material.begin = function() {
	Rex.Material.buffer_mask = undefined;
	Rex.Material.blend_src = undefined;
	Rex.Material.blend_dest = undefined;
	Rex.Material.depth_func = undefined;
	Rex.Material.stencil_func = undefined;
	Rex.Material.stencil_ref = undefined;
	Rex.Material.stencil_fail = undefined;
	Rex.Material.stencil_zfail = undefined;
	Rex.Material.stencil_zpass = undefined;
	Rex.Material.polygon_factor = undefined;
	Rex.Material.polygon_units = undefined;
	Rex.Material.cull_face = undefined;
};

Rex.Material.end = function() {
	var gl = Rex.render.gl;
	gl.colorMask(true, true, true, true);
	gl.depthMask(true);
	gl.stencilMask(0xff);
	gl.blendFunc(gl.ONE, gl.ZERO);
	gl.disable(gl.BLEND);
	gl.depthFunc(gl.ALWAYS);
	gl.disable(gl.DEPTH_TEST);
	gl.stencilFunc(gl.ALWAYS, 0, 0xff);
	gl.disable(gl.STENCIL_TEST);
	gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	gl.polygonOffset(0, 0);
	gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.cullFace(gl.BACK);
	gl.disable(gl.CULL_FACE);
	Rex.Material.begin();
};

/**
 * Material
 * @constructor
 */

class Material extends RexObject {
	
	constructor(state) {
		super();
		this.vertex_shader = '';
		this.fragment_shader = '';
		
		this.buffer_mask = Rex.BufferAll;
		
		this.blend_src = Rex.BlendNone;
		this.blend_dest = Rex.BlendNone;
		
		this.depth_func = Rex.DepthNone;
		
		this.stencil_func = Rex.StencilNone;
		this.stencil_ref = 0xff;
		
		this.stencil_fail = Rex.StencilOpKeep;
		this.stencil_zfail = Rex.StencilOpKeep;
		this.stencil_zpass = Rex.StencilOpKeep;
		
		this.polygon_factor = 0;
		this.polygon_units = 0;
		
		this.cull_face = Rex.FaceNone;
		this.draw_mode = Rex.DrawTriangles;
		
		this.parameters = [];
		this.textures = [];
		
		this.program = undefined;
		this.projection = undefined;
		this.modelview = undefined;
		this.camera = undefined;
		this.viewport = undefined;
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setVertexShader(src) {
		this.vertex_shader = src;
	}
	
	setFragmentShader(src) {
		this.fragment_shader = src;
	}
	
	setBufferMask(mask) {
		this.buffer_mask = mask;
	}
	
	setBlendFunc(src, dest) {
		this.blend_src = src;
		this.blend_dest = dest;
	}
	
	setDepthFunc(func) {
		this.depth_func = func;
	}
	
	setStencilFunc(func, ref) {
		this.stencil_func = func;
		this.stencil_ref = ref;
	}
	
	setStencilOp(fail, zfail, zpass) {
		this.stencil_fail = fail;
		this.stencil_zfail = zfail;
		this.stencil_zpass = zpass;
	}
	
	setPolyginOffset(factor, units) {
		this.polygon_factor = factor;
		this.polygon_units = units;
	}
	
	setCullFace(face) {
		this.cull_face = face;
	}
	
	setDrawMode(mode) {
		this.draw_mode = mode;
	}
	
	setParameters(parameters) {
		this.parameters = parameters;
	}
	
	setTextures(textures) {
		this.textures = textures;
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
	/// bind material
	bind() {
		
		var gl = Rex.render.gl;
		
		// check material
		if(this.program === null) return false;
		
		// compile program
		if(this.program === undefined) {
			
			// create shader
			var create_shader = function(type, source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);
				if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					Rex.error("Rex.Material.bind(): can't compile shader");
					Rex.error(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
					return null;
				}
				return shader;
			};
			
			// vertex shader
			var vertex_shader = create_shader(gl.VERTEX_SHADER, this.vertex_shader);
			if(vertex_shader === null) {
				this.program = null;
				return false;
			}
			
			// fragment shader
			var fragment_shader = create_shader(gl.FRAGMENT_SHADER, this.fragment_shader);
			if(fragment_shader === null) {
				gl.deleteShader(vertex_shader);
				this.program = null;
				return false;
			}
			
			// create program
			var program = gl.createProgram();
			gl.attachShader(program, vertex_shader);
			gl.attachShader(program, fragment_shader);
			gl.bindAttribLocation(program, 0, "attribute_0");
			gl.bindAttribLocation(program, 1, "attribute_1");
			gl.bindAttribLocation(program, 2, "attribute_2");
			gl.bindAttribLocation(program, 3, "attribute_3");
			gl.bindAttribLocation(program, 4, "attribute_4");
			gl.bindAttribLocation(program, 5, "attribute_5");
			gl.bindAttribLocation(program, 6, "attribute_6");
			gl.bindAttribLocation(program, 7, "attribute_7");
			gl.linkProgram(program);
			if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				Rex.error("Rex.Material.bind(): can't link program");
				Rex.error(gl.getProgramInfoLog(program));
				gl.deleteShader(vertex_shader);
				gl.deleteShader(fragment_shader);
				gl.deleteProgram(program);
				this.program = null;
				return false;
			}
			
			// bind textures
			gl.useProgram(program);
			var index_0 = gl.getUniformLocation(program, "texture_0");
			var index_1 = gl.getUniformLocation(program, "texture_1");
			var index_2 = gl.getUniformLocation(program, "texture_2");
			var index_3 = gl.getUniformLocation(program, "texture_3");
			if(index_0 !== null) gl.uniform1i(index_0, 0);
			if(index_1 !== null) gl.uniform1i(index_1, 1);
			if(index_2 !== null) gl.uniform1i(index_2, 2);
			if(index_3 !== null) gl.uniform1i(index_3, 3);
			
			this.program = program;
		}
		
		// get WebGL functions
		if(Rex.Material.blend_functions === undefined) {
			Rex.Material.blend_functions = [
				gl.ZERO,
				gl.ZERO,
				gl.ONE,
				gl.SRC_COLOR,
				gl.SRC_ALPHA,
				gl.DST_COLOR,
				gl.DST_ALPHA,
				gl.ONE_MINUS_SRC_COLOR,
				gl.ONE_MINUS_SRC_ALPHA,
				gl.ONE_MINUS_DST_COLOR,
				gl.ONE_MINUS_DST_ALPHA
			];
			Rex.Material.depth_functions = [
				gl.NEVER,
				gl.NEVER,
				gl.ALWAYS,
				gl.LESS,
				gl.EQUAL,
				gl.GREATER,
				gl.LEQUAL,
				gl.NOTEQUAL,
				gl.GEQUAL
			];
			Rex.Material.stencil_functions = [
				gl.NEVER,
				gl.NEVER,
				gl.ALWAYS,
				gl.LESS,
				gl.EQUAL,
				gl.GREATER,
				gl.LEQUAL,
				gl.NOTEQUAL,
				gl.GEQUAL
			];
			Rex.Material.stencil_operations = [
				gl.KEEP,
				gl.ZERO,
				gl.REPLACE,
				gl.INVERT,
				gl.INCR,
				gl.DECR
			];
			Rex.Material.cull_faces = [
				gl.FRONT,
				gl.FRONT,
				gl.BACK,
				gl.FRONT_AND_BACK
			];
		}
		
		// buffer mask
		if(Rex.Material.buffer_mask !== this.buffer_mask) {
			var r = (this.buffer_mask & Rex.BufferRed) !== 0;
			var g = (this.buffer_mask & Rex.BufferGreen) !== 0;
			var b = (this.buffer_mask & Rex.BufferBlue) !== 0;
			var a = (this.buffer_mask & Rex.BufferAlpha) !== 0;
			var d = (this.buffer_mask & Rex.BufferDepth) !== 0;
			gl.colorMask(r, g, b, a);
			gl.depthMask(d);
			gl.stencilMask(this.buffer_mask >> 8);
			Rex.Material.buffer_mask = this.buffer_mask;
		}
		
		// blend function
		if(Rex.Material.blend_src !== this.blend_src || Rex.Material.blend_dest !== this.blend_dest) {
			if(this.blend_src === Rex.BlendNone || this.blend_dest === Rex.BlendNone) {
				gl.blendFunc(gl.ONE, gl.ZERO);
				gl.disable(gl.BLEND);
			} else {
				gl.blendFunc(Rex.Material.blend_functions[this.blend_src], Rex.Material.blend_functions[this.blend_dest]);
				gl.enable(gl.BLEND);
			}
			Rex.Material.blend_src = this.blend_src;
			Rex.Material.blend_dest = this.blend_dest;
		}
		
		// depth function
		if(Rex.Material.depth_func !== this.depth_func) {
			if(this.depth_func === Rex.DepthNone) {
				gl.depthFunc(gl.ALWAYS);
				gl.disable(gl.DEPTH_TEST);
			} else {
				gl.depthFunc(Rex.Material.depth_functions[this.depth_func]);
				gl.enable(gl.DEPTH_TEST);
			}
			Rex.Material.depth_func = this.depth_func;
		}
		
		// stencil function
		if(Rex.Material.stencil_func !== this.stencil_func || Rex.Material.stencil_ref !== this.stencil_ref) {
			if(this.stencil_func === Rex.StencilNone) {
				gl.stencilFunc(gl.ALWAYS, 0, 0xff);
				gl.disable(gl.STENCIL_TEST);
			} else {
				gl.stencilFunc(Rex.Material.stencil_functions[this.stencil_func], this.stencil_ref, 0xff);
				gl.enable(gl.STENCIL_TEST);
			}
			Rex.Material.stencil_func = this.stencil_func;
			Rex.Material.stencil_ref = this.stencil_ref;
		}
		
		// stencil operation
		if(Rex.Material.stencil_fail !== this.stencil_fail || Rex.Material.stencil_zfail !== this.stencil_zfail || Rex.Material.stencil_zpass !== this.stencil_zpass) {
			gl.stencilOp(Rex.Material.stencil_operations[this.stencil_fail], Rex.Material.stencil_operations[this.stencil_zfail], Rex.Material.stencil_operations[this.stencil_zpass]);
			Rex.Material.stencil_fail = this.stencil_fail;
			Rex.Material.stencil_zfail = this.stencil_zfail;
			Rex.Material.stencil_zpass = this.stencil_zpass;
		}
		
		// polygon offset
		if(Rex.Material.polygon_factor !== this.polygon_factor || Rex.Material.polygon_units !== this.polygon_units) {
			if(this.polygon_factor === 0 && this.polygon_units === 0) {
				gl.polygonOffset(0, 0);
				gl.disable(gl.POLYGON_OFFSET_FILL);
			} else {
				gl.polygonOffset(this.polygon_factor, this.polygon_units);
				gl.enable(gl.POLYGON_OFFSET_FILL);
			}
			Rex.Material.polygon_factor = this.polygon_factor;
			Rex.Material.polygon_units = this.polygon_units;
		}
		
		// cull face
		if(Rex.Material.cull_face !== this.cull_face) {
			if(this.cull_face === Rex.FaceNone) {
				gl.cullFace(gl.BACK);
				gl.disable(gl.CULL_FACE);
			} else {
				gl.cullFace(Rex.Material.cull_faces[this.cull_face]);
				gl.enable(gl.CULL_FACE);
			}
			Rex.Material.cull_face = this.cull_face;
		}
		
		// bind program
		var program = this.program;
		gl.useProgram(program);
		
		// scene projection matrix
		if(this.projection === undefined) this.projection = gl.getUniformLocation(program, "rex_projection");
		if(this.projection !== null) gl.uniformMatrix4fv(this.projection, false, Rex.render.getProjection().m);
		
		// scene modelview matrix
		if(this.modelview === undefined) this.modelview = gl.getUniformLocation(program, "rex_modelview");
		if(this.modelview !== null) gl.uniformMatrix4fv(this.modelview, false, Rex.render.getModelview().m);
		
		// scene camera position
		var camera = Rex.render.getCamera();
		if(this.camera === undefined) this.camera = gl.getUniformLocation(program, "rex_camera");
		if(this.camera !== null) gl.uniform3f(this.camera, camera.x, camera.y, camera.z);
		
		if(this.viewport === undefined) this.viewport = gl.getUniformLocation(program, "rex_viewport");
		if(this.viewport !== null) gl.uniform4f(this.viewport, Rex.render.width, Rex.render.height, 1.0 / Rex.render.width, 1.0 / Rex.render.height);
		
		// scene shader parameters
		Rex.Parameter.bindArray(program, Rex.scene.parameters);
		
		// material shader parameters
		Rex.Parameter.bindArray(program, this.parameters);
		
		// material textures
		Rex.Texture.bindArray(this.textures);
		
		return true;
	}
	
}

// Rex header

Rex.Mesh = {};

/**
 * Globals
 */
Rex.Mesh.material = null;
Rex.Mesh.geometry = null;

/**
 * Begin/end mesh rendering
 */
Rex.Mesh.begin = function() {
	Rex.Mesh.material = null;
	Rex.Mesh.geometry = null;
	Rex.Texture.units = [];
};

Rex.Mesh.end = function() {
	if(Rex.Mesh.geometry !== null) {
		Rex.Mesh.geometry.unbind();
	}
	Rex.Mesh.begin();
};

/**
 * Mesh
 * @constructor
 */

class Mesh extends RexObject {
	
	constructor(state) {
		super();
		this.enabled = true;
		this.order = 0;
		
		this.geometry = undefined;
		this.material = undefined;
		
		this.index_begin = 0;
		this.index_end = 0;
		
		this.distance_begin = 0;
		this.distance_end = 0;
		
		this.transform = new Rex.Matrix4();
		
		this.parameters = [];
		this.textures = [];
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	onCheckInit() {
		if(Rex.geometries[this.geometry] == null) return false;
		if(Rex.materials[this.material] == null) return false;
		return true;
	}
	
	onSuccessInit() {
		this.geometry = Rex.geometries[this.geometry];
		this.material = Rex.materials[this.material];
	}
	
	setEnabled(enabled) {
		this.enabled = enabled;
	}
	
	setOrder(order) {
		this.order = order;
	}
	
	setMaterial(material) {
		this.material = material;
	}
	
	setGeometry(geometry) {
		this.geometry = geometry;
	}
	
	setIndexRange(begin, end) {
		this.index_begin = begin;
		this.index_end = end;
	}
	
	setDistanceRange(begin, end) {
		this.distance_begin = begin;
		this.distance_end = end;
	}
	
	setTransform(transform) {
		this.transform = transform;
	}
	
	setParameters(parameters) {
		this.parameters = parameters;
	}
	
	setTextures(textures) {
		this.textures = textures;
	}
	
	setState(state) {
		Rex.copy(this, state);
		if(state.geometry != null || state.material != null) {
			this.inited = false;
			this.checkInit();
		}
	}
	
	/// check visibility
	inside(viewport) {
		if(this.geometry == null) return false;
		// check geometry
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.geometry instanceof Geometry)) {
		//	this.geometry = Rex.getGeometry(this.geometry);
		//	if(!(this.geometry instanceof Geometry)) return false;
		//}
		
		// transform bound sphere
		var scale = this.transform.getScale();
		var bound_center = this.transform.mulVector3(this.geometry.bound_center);
		var bound_radius = this.geometry.bound_radius * Math.max(scale.x, scale.y, scale.z);
		
		// check distance
		var distance = bound_center.sub(viewport.camera).length();
		if(distance <= this.distance_begin) return false;
		if(distance > this.distance_end) return false;
		
		// check viewport visibility
		return viewport.insideSphere(bound_center, bound_radius);
	}
	
	/// bind mesh
	bind() {
		var gl = Rex.render.gl;
		
		// bind material
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.material instanceof Material)) {
		//	this.material = Rex.getMaterial(this.material);
		//	if(!(this.material instanceof Material)) return false;
		//}
		if(Rex.Mesh.material !== this.material) {
			if(!this.material.bind()) {
				Rex.Mesh.material = null;
				return false;
			}
			Rex.Mesh.material = this.material;
		}
		
		// bind geometry
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.geometry instanceof Geometry)) {
		//	this.geometry = Rex.getGeometry(this.geometry);
		//	if(!(this.geometry instanceof Geometry)) return false;
		//}
		if(Rex.Mesh.geometry !== this.geometry) {
			if(Rex.Mesh.geometry !== null) {
				Rex.Mesh.geometry.unbind();
				Rex.Mesh.geometry = null;
			}
			if(!this.geometry.bind()) {
				Rex.Mesh.geometry = null;
				return false;
			}
			Rex.Mesh.geometry = this.geometry;
		}
		
		// mesh transformation matrix
		var program = this.material.program;
		var transform = gl.getUniformLocation(program, "rex_transform");
		if(transform !== null) gl.uniformMatrix4fv(transform, false, this.transform.m);
		
		// mesh shader parameters
		Rex.Parameter.bindArray(program, this.parameters);
		
		// mesh textures
		Rex.Texture.bindArray(this.textures);
		
		return true;
	}
	
	/// draw mesh
	draw() {
		
		var gl = Rex.render.gl;
		
		// check mesh
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.material instanceof Rex.Material)) return false;
		//if(!(this.geometry instanceof Rex.Geometry)) return false;
		
		// get WebGL draw modes
		if(Rex.Mesh.draw_modes === undefined) {
			Rex.Mesh.draw_modes = [
				gl.POINTS,
				gl.LINE_STRIP,
				gl.LINE_LOOP,
				gl.LINES,
				gl.TRIANGLE_STRIP,
				gl.TRIANGLE_FAN,
				gl.TRIANGLES
			];
		}
		
		// draw parameters
		var type = undefined;
		var count = undefined;
		var offset = undefined;
		var index_format = this.geometry.layout.index_format;
		var size = this.geometry.index_buffer.data.length;
		if(index_format === Rex.FormatUInt8x1) {
			type = gl.UNSIGNED_BYTE;
			offset = this.index_begin;
			count = size;
		} else if(index_format === Rex.FormatUInt16x1) {
			type = gl.UNSIGNED_SHORT;
			offset = this.index_begin * 2;
			count = size / 2;
		} else if(index_format === Rex.FormatUInt32x1) {
			type = gl.UNSIGNED_INT;
			offset = this.index_begin * 4;
			count = size / 4;
		}
		
		// draw mesh
		var mode = Rex.Mesh.draw_modes[this.material.draw_mode];
		if(this.index_end !== 0) count = this.index_end - this.index_begin;
		gl.drawElements(mode, count, type, offset);
	}
	
}

// Rex header

Rex.Parameter = {};

/**
 * Bind array of parameters
 */
Rex.Parameter.bindArray = function(program, parameters) {
	for(var i = 0; i < parameters.length; i++) {
		if(!(parameters[i] instanceof Parameter)) parameters[i] = Rex.parameters[parameters[i]];
		if(parameters[i] instanceof Parameter) parameters[i].bind(program);
	}
};

/**
 * Parameter
 * @constructor
 */
class Parameter extends RexObject {
	
	constructor(state) {
		super();
		this.name = '';
		this.format = Rex.FormatUnknown;
		
		this.buffer = undefined;
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	onSuccessInit() {
		this.buffer = Rex.buffers[this.buffer];
	}
	
	setName(name) {
		this.name = name;
	}
	
	setFormat(format) {
		this.format = format;
	}
	
	setBuffer(buffer) {
		this.buffer = buffer;
	}
	
	setState(state) {
		Rex.copy(this, state);
		if(state.buffer != null) {
			this.inited = false;
			this.checkInit();
		}
	}
	
	/// bind parameter
	bind(program) {
		
		var gl = Rex.render.gl;
		
		// buffer
		//Пока закомментирую, если уже точно нигде не выстрелит. То можно убрать это.
		//if(!(this.buffer instanceof Buffer)) {
		//	this.buffer = Rex.getBuffer(this.buffer);
		//	if(!(this.buffer instanceof Buffer)) return false;
		//}
		
		// find parameter
		var index = gl.getUniformLocation(program, this.name);
		if(index === null) return false;
		
		// bind parameter
		return this.buffer.bindUniform(index, this.format);
	}
	
}

// Rex header

/**
 * Viewport
 * @constructor
 */

class Viewport {
	
	constructor() {
		this.projection = new Rex.Matrix4();
		this.modelview = new Rex.Matrix4();
		this.camera = new Rex.Vector3();
		
		this.plane_l = new Rex.Vector4();
		this.plane_r = new Rex.Vector4();
		this.plane_b = new Rex.Vector4();
		this.plane_t = new Rex.Vector4();
		this.plane_n = new Rex.Vector4();
		this.plane_f = new Rex.Vector4();
	}
	
	set(aspect, projection, modelview) {
		
		// projection matrix
		this.projection.copy(projection.m);
		this.projection.m[0] /= aspect;
		
		// modelview matrix
		this.modelview.copy(modelview.m);
		
		// camera position
		this.camera = modelview.getInverse43().getTranslate();
		
		// modelview projection matrix
		var mvp = this.projection.mul(modelview);
		var m = mvp.m;
		
		// extract viewport cliping planes
		this.plane_l.set(m[3] + m[0], m[7] + m[4], m[11] + m[8], m[15] + m[12]);
		this.plane_r.set(m[3] - m[0], m[7] - m[4], m[11] - m[8], m[15] - m[12]);
		this.plane_b.set(m[3] + m[1], m[7] + m[5], m[11] + m[9], m[15] + m[13]);
		this.plane_t.set(m[3] - m[1], m[7] - m[5], m[11] - m[9], m[15] - m[13]);
		this.plane_n.set(m[3] + m[2], m[7] + m[6], m[11] + m[10], m[15] + m[14]);
		this.plane_f.set(m[3] - m[2], m[7] - m[6], m[11] - m[10], m[15] - m[14]);
		this.plane_l.scale(1 / this.plane_l.length3());
		this.plane_r.scale(1 / this.plane_r.length3());
		this.plane_b.scale(1 / this.plane_b.length3());
		this.plane_t.scale(1 / this.plane_t.length3());
		this.plane_n.scale(1 / this.plane_n.length3());
		this.plane_f.scale(1 / this.plane_f.length3());
	}
	
	insideSphere(center, radius) {
		if(this.plane_l.dot3(center) < -radius) return false;
		if(this.plane_r.dot3(center) < -radius) return false;
		if(this.plane_b.dot3(center) < -radius) return false;
		if(this.plane_t.dot3(center) < -radius) return false;
		if(this.plane_n.dot3(center) < -radius) return false;
		if(this.plane_f.dot3(center) < -radius) return false;
		return true;
	}
	
}

// Rex header

/**
 * Render
 * @constructor
 * @param {*=} attributes
 * @param {*=} overlay
 * @param {*=} canvas
 */
class Render {
	
	constructor(canvas, overlay, tempCanvas, attributes) {
		console.clear();
		if(Rex.container != null) document.body.insertBefore(Rex.container, document.getElementById("container1"));
		// WebGL canvas
		if(canvas !== undefined) this.canvas = canvas;
		else this.canvas = document.getElementById("canvas");
		
		// 2d context canvas
		if(overlay !== undefined) this.overlay = overlay;
		else this.overlay = document.getElementById("overlay");
		
		if(tempCanvas !== undefined) this.tempCanvas = tempCanvas;
		else this.tempCanvas = document.getElementById("tempCanvas");
		
		// WebGL attributes
		if(attributes === undefined) attributes = {
			alpha : true, depth : true,
			stencil : true, antialias : true,
			premultipliedAlpha : true,
			preserveDrawingBuffer : false
		};
		
		try {
			this.gl = this.canvas.getContext("webgl", attributes) || this.canvas.getContext("experimental-webgl", attributes);
			if(this.overlay !== null) this.ctx = this.overlay.getContext("2d");
			if(this.tempCanvas !== null) this.ctxTemp = this.tempCanvas.getContext("2d");
		}
		catch(error) {
			Rex.error("Rex.Render(): " + error);
			alert("Can't initialize WebGL");
			this.gl = null;
			this.ctx = null;
			this.ctxTemp = null;
			return;
		}
		
		// list of extensions
		this.extensions = this.gl.getSupportedExtensions();
		for(var i = 0; i < this.extensions.length; i++) {
			Rex.message(this.extensions[i]);
		}
		
		// enable extensions
		this.OES_texture_float = this.gl.getExtension("OES_texture_float");
		this.OES_texture_half_float = this.gl.getExtension("OES_texture_half_float");
		this.OES_element_index_uint = this.gl.getExtension("OES_element_index_uint");
		this.OES_vertex_half_float = this.gl.getExtension("OES_vertex_half_float");
		this.OES_vertex_array_object = this.gl.getExtension("OES_vertex_array_object");
		this.OES_standard_derivatives = this.gl.getExtension("OES_standard_derivatives");
		this.EXT_texture_filter_anisotropic = this.gl.getExtension("EXT_texture_filter_anisotropic");
		this.ANGLE_instanced_arrays = this.gl.getExtension("ANGLE_instanced_arrays");
		
		// FPS counter
		this.time = Date.now();
		this.fps = 0;
		
		// render viewport
		this.viewport = new Viewport();
		
		// viewport size
		this.width = undefined;
		this.height = undefined;
		this.request = undefined;
		//this.ratio = 1;
	}
	
	setViewport(aspect, projection, modelview) {
		this.viewport.set(aspect, projection, modelview);
	}
	
	getProjection() {
		return this.viewport.projection;
	}
	
	getModelview() {
		return this.viewport.modelview;
	}
	
	getCamera() {
		return this.viewport.camera;
	}
	
	update() {
		this.width = window.innerWidth;
		this.height = window.innerHeight;
		if(this.canvas.width !== this.width || this.canvas.height !== this.height) {
			this.canvas.width = this.width;
			this.canvas.height = this.height;
			if(this.overlay !== null) {
				this.overlay.width = this.width;
				this.overlay.height = this.height;
				if(Rex.gui != undefined) Rex.gui.redraw();
				if(Rex.gui != undefined) Rex.gui.repositionAll();
			}
			if(this.tempCanvas !== null) {
				this.tempCanvas.width = this.width;
				this.tempCanvas.height = this.height;
			}
		}
		
		// update FPS
		var time = Date.now();
		this.fps = this.fps * 0.9 + 100 / (time - this.time);
		this.time = time;
		if(Rex.camera !== undefined) Rex.camera.update();
	}
	
	timeout(time) {
		return time - (Date.now() - this.time);
	}
	
	stop() {
		this.ctx.clearRect(0, 0, canvas.width, canvas.height);
		Rex.render.gl.clearColor(Rex.scene.background.x, Rex.scene.background.y, Rex.scene.background.z, Rex.scene.background.w);
		Rex.render.gl.clear(Rex.render.gl.COLOR_BUFFER_BIT | Rex.render.gl.DEPTH_BUFFER_BIT | Rex.render.gl.STENCIL_BUFFER_BIT);
		cancelAnimationFrame(this.request);
		let container = document.getElementsByClassName("container")[0];
		Rex.container = container.cloneNode(true);
		document.body.removeChild(container);
	}
	
	render(time) {
		// default arguments
		time = time || 1000 / Rex.FPS;
		var camera = Rex.camera;
		var render = Rex.render;
		var scene = Rex.scene;
		var gl = render.gl;
		
		// update render
		this.update();
		
		// update viewport
		var aspect = this.width / this.height;
		if(camera === undefined) {
			this.request = window.requestAnimationFrame(function() { this.render(time); }.bind(this));
			return;
		}
		
		this.setViewport(aspect, camera.getProjection(), camera.getModelview());

		// resize viewport
		gl.viewport(0, 0, this.width, this.height);

		// clear background
		if(!scene.customBackground) {
			let color = new Color();
			color.fromString(Rex.gui.styleLibrary.getParam("Scene", "backgroundColor", "rgba(255,0,0,0.3)"));
			scene.background.x = color.r / 255;
			scene.background.y = color.g / 255;
			scene.background.z = color.b / 255;
			scene.background.w = color.a / 255;
		}
		gl.clearColor(scene.background.x, scene.background.y, scene.background.z, scene.background.w);

		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		
		// get meshes
		var meshes = [];
		for(var key in Rex.meshes) {
			meshes.push(Rex.meshes[key]);
		}
		
		// render meshes
		Rex.Mesh.begin();
		Rex.Material.begin();
		for(var i = 0; i < meshes.length; i++) {
			if(!meshes[i].inited) continue;
			if(!meshes[i].inside(render.viewport)) continue;
			if(!meshes[i].enabled) continue;
			if(!meshes[i].bind()) continue;
			meshes[i].draw();
		}
		Rex.Material.end();
		Rex.Mesh.end();
		
		// render labels
		if(this.ctx !== undefined) {
			if(Rex.gui !== undefined && Rex.gui.needRepositioning) {
				Rex.gui.positioning();
			}
			
			if(Rex.gui !== undefined && Rex.gui.needRedrawWidgets) {
				this.ctx.clearRect(0, 0, Rex.render.width, Rex.render.height);
				this.ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
				// render widgets
				this.ctx.save();
				Rex.gui.draw(this.ctx, this.ctxTemp);
				this.ctx.restore();
				
				// render lines
				this.ctx.save();
				for (var key in Rex.lines) {
					Rex.lines[key].draw(this.ctx);
				}
				this.ctx.restore();
				
				// render labels
				this.ctx.save();
				for (var key in Rex.labels) {
					Rex.labels[key].draw(this.ctx);
				}
				this.ctx.restore();
				
				
				// render FPS
				this.ctx.save();
				this.ctx.textAlign = "end";
				this.ctx.fillStyle = "white";
				this.ctx.font = "24px arial";
				this.ctx.fillText("FPS: " + Math.floor(this.fps), this.width - 8, 24);
				this.ctx.restore();
			}
			
		}
		
		// next frame
		this.request = window.requestAnimationFrame(function() { this.render(time); }.bind(this));
	}
	
	/**
	 * The global stereo scene render function
	 * @param {number=} time Render interval
	 * @param {number=} offset Stereo offset
	 * @param {number=} radius Stereo radius
	 */
	stereoRender(radius, offset, time) {
		
		// default arguments
		radius = radius || 0.032;
		offset = offset || 0;
		time = time || 1000 / Rex.FPS;
		
		var camera = Rex.camera;
		var render = Rex.render;
		var scene = Rex.scene;
		var gl = render.gl;
		
		// update render
		this.update();
		
		// update viewport
		var aspect = this.width / this.height / 2;
		var projection = new Rex.Matrix4();
		
		// resize viewport
		gl.viewport(0, 0, this.width, this.height);
		
		// clear background
		if(this.ctx !== undefined) this.ctx.clearRect(0, 0, this.width, this.height);
		if(!scene.customBackground) {
			let color = new Color();
			color.fromString(Rex.gui.styleLibrary.getParam("Scene", "backgroundColor", "rgba(255,0,0,0.3)"));
			scene.background.x = color.r / 255;
			scene.background.y = color.g / 255;
			scene.background.z = color.b / 255;
			scene.background.w = color.a / 255;
		}
		gl.clearColor(scene.background.x, scene.background.y, scene.background.z, scene.background.w);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		
		// get meshes
		var meshes = [];
		for(var key in Rex.meshes) {
			meshes.push(Rex.meshes[key]);
		}
		
		// left eye
		projection.copy(camera.getProjection().m);
		projection.m[8] += offset;
		this.setViewport(aspect, projection, Rex.Matrix4.translate(radius, 0, 0).mul(camera.getModelview()));
		gl.viewport(0, 0, this.width / 2, this.height);
		
		// render meshes
		Rex.Mesh.begin();
		Rex.Material.begin();
		for(var i = 0; i < meshes.length; i++) {
			if(!meshes[i].inside(render.viewport)) continue;
			if(!meshes[i].enabled) continue;
			if(!meshes[i].bind()) continue;
			meshes[i].draw();
		}
		Rex.Material.end();
		Rex.Mesh.end();
		
		// right eye
		projection.copy(camera.getProjection().m);
		projection.m[8] -= offset;
		this.setViewport(aspect, projection, Rex.Matrix4.translate(-radius, 0, 0).mul(camera.getModelview()));
		gl.viewport(this.width / 2, 0, this.width / 2, this.height);
		
		// render meshes
		Rex.Mesh.begin();
		Rex.Material.begin();
		for(var i = 0; i < meshes.length; i++) {
			if(!meshes[i].inside(render.viewport)) continue;
			if(!meshes[i].enabled) continue;
			if(!meshes[i].bind()) continue;
			meshes[i].draw();
		}
		Rex.Material.end();
		Rex.Mesh.end();
		
		// next frame
		setTimeout(function() { this.stereoRender(radius, offset, time); }.bind(this), this.timeout(time));
	}
	
};

// Rex header

Rex.Texture = {};

/**
 * Globals
 */
Rex.Texture.units = [];

/**
 * Bind array of textures
 */
Rex.Texture.bindArray = function(textures) {
	for(var i = 0; i < textures.length; i++) {
		if(!(textures[i] instanceof Texture)) textures[i] = Rex.textures[textures[i]];
		if(textures[i] instanceof Texture) textures[i].bind();
	}
};

/**
 * Texture
 * @constructor
 */

class Texture extends RexObject {
	
	constructor(state) {
		super();
		this.unit = 0;
		this.data = '';
		
		this.format = Rex.TextureFormatRGBA;
		this.filter = Rex.TextureFilterBilinear;
		this.wrap = Rex.TextureWrapRepeat;
		
		this.image = undefined;
		this.texture = undefined;
		
		if(state !== undefined) Rex.copy(this, state);
		if(Rex.render == null) {
			Rex.render = new Render();
			Rex.render.render();
		}
	}
	
	setUnit(unit) {
		this.unit = unit;
	}
	
	setFormat(format) {
		this.format = format;
	}
	
	setFilter(filter) {
		this.filter = filter;
	}
	
	setWrap(wrap) {
		this.wrap = wrap;
	}
	
	setState(state) {
		Rex.copy(this, state);
	}
	
	/// create texture
	create() {
		var gl = Rex.render.gl;
		
		// check texture
		if(this.image === null) return false;
		if(this.texture === null) return false;
		
		// save old texture
		var old_texture = Rex.Texture.units[0];
		
		// create texture
		gl.bindTexture(gl.TEXTURE_2D, this.texture);
		
		// select format
		if(this.format === Rex.TextureFormatAlpha) {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, gl.ALPHA, gl.UNSIGNED_BYTE, this.image);
		} else if(this.format === Rex.TextureFormatLuminance) {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, this.image);
		} else if(this.format === Rex.TextureFormatLuminanceAlpha) {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, this.image);
		} else if(this.format === Rex.TextureFormatRGB) {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.image);
		} else if(this.format === Rex.TextureFormatRGBA) {
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.image);
		} else {
			Rex.error("Rex.Texture.create(): unknown texture format: " + this.format);
		}
		
		// select filter
		if(this.filter === Rex.TextureFilterPoint) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		} else if(this.filter === Rex.TextureFilterLinear) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		} else if(this.filter === Rex.TextureFilterBilinear) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.generateMipmap(gl.TEXTURE_2D);
		} else if(this.filter === Rex.TextureFilterTrilinear) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.generateMipmap(gl.TEXTURE_2D);
		} else {
			Rex.error("Rex.Texture.create(): unknown texture filter: " + this.filter);
		}
		
		// select wrap
		if(this.wrap === Rex.TextureWrapRepeat) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
		} else if(this.wrap === Rex.TextureWrapClamp) {
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		} else {
			Rex.error("Rex.Texture.create(): unknown texture wrap: " + this.wrap);
		}
		
		// restore old texture
		if(!(old_texture instanceof Texture)) gl.bindTexture(gl.TEXTURE_2D, null);
		else gl.bindTexture(gl.TEXTURE_2D, old_texture.texture);
	}
	
	/// bind texture
	bind(program) {
		
		var gl = Rex.render.gl;
		
		// check texture
		if(this.texture === null) return false;
		
		// create texture
		if(this.texture === undefined) {
			this.texture = gl.createTexture();
			this.image = new Image();
			this.image.onload = () => {
				this.create();
			};
			this.image.src = this.data;
		}
		
		// get WebGL texture units
		if(Rex.Texture.active_textures === undefined) {
			Rex.Texture.active_textures = [
				gl.TEXTURE0,
				gl.TEXTURE1,
				gl.TEXTURE2,
				gl.TEXTURE3,
				gl.TEXTURE4,
				gl.TEXTURE5,
				gl.TEXTURE6,
				gl.TEXTURE7
			];
		}
		
		// bind texture
		if(Rex.Texture.units[this.unit] !== this.texture) {
			Rex.Texture.units[this.unit] = this.texture;
			gl.activeTexture(Rex.Texture.active_textures[this.unit]);
			gl.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.activeTexture(gl.TEXTURE0);
		}
		
		return true;
	}
	
}

// Rex header

/**
 * @param state
 * @constructor
 */
Rex.Image = class RexImage extends RexObject {
	
	constructor(state) {
		super();
		this.image = undefined;
		this.data = '';
		if(state !== undefined) this.setState(state);
	}
	
	setState(state) {
		if(state != null && state.clean != null) {
			delete this.image;
			this.image = undefined;
			this.data = undefined;
		}

		let oldData = this.data;
		Rex.copy(this, state);
		if(oldData != this.data) {
			delete this.image;
			if(this.data.length == 0) {
				this.image = undefined;
			} else {
				this.image = new Image();
				this.image.src = this.data;
			}
		}
	}
	
};


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global RexObject Rex Render WidgetViewCanvas WidgetViewHtml*/

let debugFocus = true;

class Widget extends RexObject {
	
	constructor(state) {
		super();
		this.id = -1;
		
		this._visible = true;
		this.editable = false;
		this.draggable = false;
		this.dragImage = null;
		//add to test by smag 27.05.19
		this._dropable = false;

		this.styleToChildren = false;
		this.styleName = "";
		
		this._posX = -500;
		this._posY = -500;
		
		this._aposX = -500;
		this._aposY = -500;
		
		this._width = 20;
		this._height = 20;
		
		this.minWidth = 0;
		this.minHeight = 0;
		
		this.maxWidth = 0;
		this.maxHeight = 0;
		
		this.marginLeft = 0;
		this.marginRight = 0;
		this.marginTop = 0;
		this.marginBottom = 0;
		
		this.paddingLeft = 0;
		this.paddingRight = 0;
		this.paddingTop = 0;
		this.paddingBottom = 0;
		
		this.children = [];
		
		this._order = -1;

		this._id = -1;
		
		this.transform = [];
		this.customStyle = {};
		
		this._backgroundColor =  null;
		this._textColor =  null;
		this._borderColor =  null;
		this._borderSize =  null;
		this._borderRadius =  null;
		this._borderType = null;
		
		this.fontFamily = null;
		this.fontSize = null;
		this.fontItalic = false;
		this.fontBold = false;
		this.textDecoration = null;
		this.textAlign = 2;
		this.iconName = null;
		this.activated = true;
		
		if(state.typeView !== undefined) {
			this.id = state.id;
			this.typeView = state.typeView;
			if((state.typeView === "canvas") && (Rex.render == null)) {
				Rex.render = new Render();
				Rex.render.render();
			}
			this.createView(); //абстрактный
		} else {
			console.error("твой стейт - гавно!");
		}
		this.setState(state);
	}
	
	setState(state) {
		if (state.dropable != undefined) this.dropable = state.dropable;
		this.view.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetViewCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetViewHtml(this);
		}
	}
	
	onSuccessInit() {
		this.view.init();
	}

	// Every widget is represented as table in pdf document
	// Because table has more styles then any other dd-object in this lib
	// Read the documentation here https://pdfmake.github.io/docs/

	// the argument should be an array
	generateContent(content, docData) {
		if (this.visible === false)
			return;

		//widget content
		let widgetTable = {
			// Widget width, if widget is a container, then this array contains width values of each child widget
			widths: [],
			// Widget height, if widget is a container, then this array contains height values of each child widget
			heights: [],
			// This array contains object data of this widget, and it serves as container for children data
			body: []
		};

		// This object may be useful, if you need to add style, whose value can be a function
		// Only tables can have a layout object

		let pLeft = parseInt(getStyle(this.view.htmlElement, 'padding-left'));
		pLeft = isNaN(pLeft) ? 0 : pLeft;
		let pRight = parseInt(getStyle(this.view.htmlElement, 'padding-right'));
		pRight = isNaN(pRight) ? 0 : pRight;
		let pTop = parseInt(getStyle(this.view.htmlElement, 'padding-top'));
		pTop = isNaN(pTop) ? 0 : pTop;
		let pBottom = parseInt(getStyle(this.view.htmlElement, 'padding-bottom'));
		pBottom = isNaN(pBottom) ? 0 : pBottom;

		let widgetLayout = {
			//set all padding values to 0
			paddingLeft: function(i, node) {
				 if (i == 0)
					return pLeft;
				return 0;
			},
			paddingRight: function(i, node) {
				if (i == node.table.body.length - 1)
					return pRight;
				return 0;
			},
			paddingTop: function(i, node) {
				if (i == 0)
					return pTop;
				return 0;
			},
			paddingBottom: function(i, node) {
				if (i == node.table.body.length - 1)
					return pBottom;
				return 0;
			}

			// Another styles:
			// vLineColor: function(i, node) {} - set color value to vertical lines.
			// hLineColor: function(i, node) {} - set color value to horizontal lines. 
			// Functions above must return a string value. Example: 'red', '#000000'

			// vLineWidth: function(i, node) {} - set width value to vertical lines. 
			// hLineWidth: function(i, node) {} - set width value to horizontal lines.
			// Functions above must return a numeric value. Example: 1, 2, 3, ... , n

			// vLineStyle: function(i, node) {} - set some style object to vertical lines. 
			// hLineStyle: function(i, node) {} - set some style object to horizontal lines. 
			// Functions above must return an object value.
			// Example: an object like this '{dash: {length: 6, space: 4}}' makes all table lines dashed

			// fillColor: function(rowIndex, node, columnIndex)
			// Function above must return a string value as LineColor functions
		};

		generateBorder(widgetLayout, this.view.htmlElement);

		let thisContent =
		{
			table: widgetTable,
			layout: widgetLayout,
			margin: [0, 0, 0, 0]
		};

		// const html = this.view.htmlElement;
		// const mLeft = parseInt(getStyle(html, 'margin-left'));
		// const mTop = parseInt(getStyle(html, 'margin-top'));
		// const mRight = parseInt(getStyle(html, 'margin-right'));
		// const mBottom = parseInt(getStyle(html, 'margin-bottom'));

		// thisContent.margin = [mLeft, mTop, mRight, mBottom];

		this.onGenerateContent(thisContent, docData)

		// let hMargin = (thisContent.margin[0] + thisContent.margin[2]) / thisContent.table.widths.length;
		// let vMargin = (thisContent.margin[1] + thisContent.margin[3]) / thisContent.table.heights.length;

		// if (hMargin === 0 && vMargin === 0)

		// for (let i = 0; i < thisContent.table.widths.length; ++i) {
		// 	thisContent.table.widths[i] -= hMargin;
		// }

		// for (let i = 0; i < thisContent.table.heights.length; ++i) {
		// 	thisContent.table.heights[i] -= vMargin;
		// }

		content.push(thisContent)
	}

	// the argument should be an object
	onGenerateContent(content, docData) {
		const html = this.view.htmlElement;
		let table = content.table;

		let bWidth = parseInt(getStyle(html, 'borderWidth'))
		bWidth = isNaN(bWidth) ? 0 : bWidth;

		const size = this.view.htmlElement.getBoundingClientRect();

		table.widths.push(size.width - (bWidth * 2));
		table.heights.push(size.height - (bWidth * 2));

		table.body.push([
			{
				text: this.type + " doesn't support conversion to PDF",
				fontSize: 12,
				margin: [0, (size.height - (12 * 1.17)) / 2, 0, 0],
				alignment: 'center'
			}]);
	}

	set dropable (value){ 
		//с плюсов сеттим флаг 
		if (this._dropable == value) return; 
		
		this._dropable = value; 
		if (this.view == undefined || this.view.htmlElement == undefined){
			console.error("Error can't add drop handler");return;
		}

		if (value) 
			this.view.htmlElement.ondrop = e => {this.drop(e);};
		else 
			this.view.htmlElement.ondrop = null;
	} 

	set width(value) {
		if(value != this._width) {
			this._width = value;
		}
	}
	
	get width() {
		return  this._width;
	}
	
	set height(value) {
		if(value != this._height) {
			this._height = value;
		}
	}
	
	get height() {
		return this._height;
	}
	
	set visible(value) {
		if(value != this._visible) {
			this._visible = value;
			this.view.update();
		}
	}
	
	get visible() {
		return this._visible;
	}
	
	set order(value) {
		if(value != this._order) {
			Rex.gui.needResortWidgets = true;
			this._order = value;
		}
		return value;
	}
	
	get order() {
		return this._order;
	}
	
	setPosX(x) {
		if(Rex.compare(this.posX, Math.round(x), 1)) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setPosX", [Math.round(x)]);
	}
	
	setPosY(y) {
		if(Rex.compare(this.posY, Math.round(y), 1)) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setPosY", [Math.round(y)]);
	}
	
	updateAPos(){
		this._aposX = this.view.getAPosX();
		this._aposY = this.view.getAPosY();
		if (Rex.widgets === undefined) return;
		for (let key of this.children){
			let child = Rex.widgets[key];
			if (child == null) continue;
			child.updateAPos();
		}
	}
	
	get aPosX() {
		return this.view.getAPosX();
	}
	
	get aPosY() {
		return this.view.getAPosY();
	}
	
	get posX() {
		return this._posX;
	}
	
	set posX(value) {
		this._posX = value;
		//this._aposX = this.view.getAPosX();
	}
	
	get posY() {
		return this._posY;
	}
	
	set posY(value) {
		this._posY = value;
		//this._aposY = this.view.getAPosY();
	}
	
	setWidth(w) {
		if(Rex.compare(this.width, w, 1)) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setWidth", [w]);
	}
	
	setHeight(h) {
		if(Rex.compare(this.height, h, 1)) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setHeight", [h]);
	}
	
	setPos(x, y) {
		Rex.callRpcMethod("Widgets", this.id, "Widget", "setPos", [Math.round(x), Math.round(y)]);
		this.updateAPos();
	}
	
	setGeometry(x, y, width, height) {
		if(Rex.compare(this.posX, Math.round(x), 1) && Rex.compare(this.posY, Math.round(y), 1) && Rex.compare(this.width, Math.round(width), 1) && Rex.compare(this.height, Math.round(height), 1)) return;
		Rex.callRpcMethod("Widgets", this.id, "Widget", "setGeometry", [Math.round(x), Math.round(y), Math.round(width), Math.round(height)]);
	}
	
	isHovered() {
		if(this.id < 0) return false;
		return this.id == Rex.gui.hovered;
	}
	
	isFocused() {
		if(this.id < 0) return false;
		return this.id == Rex.gui.focused;
	}
	
	isSelected() {
		if(Rex.gui === undefined) return false;
		return Rex.gui.selectWidgets.indexOf(this.id) != -1;
	}
	
	setVisible(v) {
		if(this.visible == v) return;
		this.visible = v;
		for(let i = 0; i < this.children.length; ++i) {
			let child = Rex.widgets[this.children[i]];
			if(child !== undefined) child.setVisible(v);
		}
		Rex.callRpcMethod("Widgets", this.id, "Widget", "setVisible", [this.visible]);
	}
	
	isVisible() {
		return this.visible;
	}
	
	isEditable() {
		return this.editable;
	}
	
	getAngle() {
		return Math.acos(this.transform[0]) * (this.transform[1] > 0 ? 1 : -1);
	}
	
	isDraggable () {
		return this.draggable;
	}

	drag() {
		return {
				data : this.onDrag(),
				sender : this.id
			}
	}
	
	onDrag() {
		return this.view.onDrag();
	}
	
	drop(event) {
		console.log ("DROP IN WIDGET");
		let dropData = {};
		let cPos = translateVect(new Rex.Vector2(event.clientX, event.clientY));

		dropData.receiver = this.id;
		// dropData.pos = {x : Math.floor(cPos.x), y : Math.floor(cPos.y)};
		dropData.pos = {x : event.clientX, y : event.clientY};
		dropData.data = this.onDrop(event,cPos);
		
		Rex.gui.drop(dropData);
		this.onDrop(event, cPos);
	}


	
	onDrop(e,cPos) {
		return this.view.onDrop(event, cPos);
	}
	
	mouseDown(x, y, event) {
		this.onMouseDown(x, y, event);
	}
	
	mouseUp(x, y, event) {
		this.onMouseUp(x, y, event);
	}
	
	mouseMove(x, y, event) {
		this.onMouseMove(x, y, event);
	}
	
	mouseWheel(value) {
		this.onMouseWheel(value);
	}
	
	mouseDoubleClick(event) {
		Rex.callRpcMethod("Widgets", this.id, "Widget", "mouseDoubleClick", []);
		this.onMouseDoubleClick(event);
	}
	
	keyDown(event) {}
	
	keyPress(event) {}
	
	keyUp(event) {}
	
	copy(event) {}
	
	paste(event) {}
	
	cut(event) {}
	
	onMouseDown(x, y, event) {}
	
	onMouseUp(x, y, event) {}
	
	onMouseMove(x, y) {}
	
	onFocused(focused) {}
	
	onHovered(hovered) {}
	
	onSelected(value) {}
	
	onMouseDoubleClick(event) {
	
	}
	
	onMouseWheel(value) {
		let parent = Rex.widgets[this.parentId];
		if(parent !== undefined) parent.mouseWheel(value);
	}
	
};


/**
 * Created by prg-30 on 01.06.2017.
 */

class ClientConsole {
	constructor(){

		this.sockets = [];
		this.buffer = [];
		this.comandsBuffer = [];
		this.comCursor = 0;
		this.ctx = Rex.render.ctx;
		this.bgcolor = "rgba(0,85,0,0.7)";
		this.frcolor = "rgba(255, 255, 255, 0.8)";
		this.fmcolor = "rgba(255, 255, 150, 0.9)";
		this.font = "15px RobotoRegular";
		this.curSocket = undefined;
		this.height = 20 * 20;
		this.posY = -this.height;
		this._visible = false;
		//this.input = new ConsoleInput({flagUpdate : true, id:5464131698435, type : "WidgetInput", parentId : -1, text:"Command"});
		// this.input.height = 30/Rex.render.height;
		// this.input.width = 1;
		// this.input.posY = - this.input.height;
		// this.input.posX = 0;
		// this.input.drawer.setBackgroundParameters(this.bgcolor, 5);
		// this.input.drawer.setGradientParameters(this.bgcolor, "rgba(0, 50, 0, 0.2)", 0);
		//Rex.widgets[-666] = this.input;
		this.mov = false;

	}
	get commandCursor() {
		return this.comCursor;
	}

	set commandCursor(value) {
		if(value > this.comandsBuffer.length - 1) {
			this.comCursor = this.comandsBuffer.length-1;
			return
		}
		if(value < 0) {
			this.comCursor = 0;
			return;
		}
		this.comCursor = value;

	}

	get visible() {

		return this._visible;
	}

	set visible(value) {

		if(value == this._visible) return value;

		this._visible = value;

		if(value) {
			this.input.onFocused(true);
			this.fallIn()
		} else {
			this.input.onFocused(false);
			this.fallOut();
		}
		return value;
	}

	fallIn() {
		this.mov = true;
		this.posY = -this.height;
		for(let i = 0; i < 25; ++i) {
			setTimeout(function() {
				this.posY = this.posY + 15;
				if(i == 24) {
					this.mov =false;
					if(this.posY != 0 ) this.posY = 0;
				}
				Rex.gui.redraw();
			}.bind(this), 10 * i);
		}
	}

	fallOut() {
		this.mov = true;
		this.posY = 0;
		for(let i = 0; i < 30; ++i) {
			setTimeout(function() {
				this.posY = this.posY - 15;
				if(i == 29) {
					this.mov =false;
					if(this.posY != -this.height) this.posY = -this.height;
				}
				Rex.gui.redraw();
			}.bind(this), 10 * i);
		}
	}

	draw() {
		if(!this._visible && !this.mov) return;
		this.ctx.save();
		Rex.gui.updateFocused(this.input);
		this.ctx.fillStyle = this.bgcolor;
		this.ctx.fillRect(0, this.posY, Rex.render.width, this.height);
		this.ctx.fillStyle = this.frcolor;
		this.input.posY = (this.posY + this.height - this.input.height) / Rex.render.height ;
		this.input.draw(this.ctx, Rex.render.ctxTemp);
		this.ctx.font = this.font;
			for(let i = this.buffer.length -1; i >= 0; --i) {
				let y = this.posY + this.height - 15 - (this.buffer.length - i) * 15;
				if(y < -30) break;
					this.ctx.fillText(this.buffer[i], 25, y);
			}
		this.ctx.restore();
	}

	bufSend(message) {
		this.buffer.push(message);
		console.log()
	}

	send(message) {
		this.comandsBuffer.push(message);
		this.commandCursor = this.comandsBuffer.length - 1;
		if(this.curSocket == undefined) {
			this.bufSend("No connection");
			return;
		}
		this.curSocket.send(message);
		this.bufSend("Send:" + message);
	}

	handleWebSocket(event) {
		var parseData = JSON.parse(event.data);
		this.bufSend(event.data);
	};

	parseCommand(command){
		if(command[0] !== "/") {this.send(command); return};
		let i = 1;
		//command[0] = "";
		let comm = "";
		while(i < command.length && command[i] !== " ") {
			comm += command[i];
			++i;
		}
		let com = command.substr(1);
		if(comm == "connect") { try{ this.connect(com.substr(comm.length))} catch(err) {Rex.gui.notificationManager.message("Bad addres", "error")} };
		if(comm == "help") this.help();
		if(comm == "disconnect") this.disconnect();
		if(comm == "send") this.send(com.substr(comm.length));
	}

	help() {
		this.bufSend("/connect ws:/ / _adress:port --> connecting websocket");
		this.bufSend("/send -- >  sending on last connected websocket");
		this.bufSend("/disconnect  --> disconnecting all websocket");
	}
	onKeyDown(event) {
		if(!this._visible && event.which !=192) return false;
		let sys = false;
		switch(event.which){
			case 13 : this.parseCommand(this.input.text);
				this.input.text = "";
				this.input.str = "";
				sys = true;
				break;
			case 192 : if(event.ctrlKey) this.visible = !this._visible;
				sys = true;
				break;
			case 40 : this.input.text = (this.comandsBuffer[this.comCursor] != undefined) ? this.comandsBuffer[this.comCursor] : "commands history is empty";
				this.input.str = this.input.text;
				this.commandCursor++;
				break;
			case 38 : this.input.text = (this.comandsBuffer[this.comCursor] != undefined) ? this.comandsBuffer[this.comCursor] : "commands history is empty";
				this.input.str = this.input.text;
				this.commandCursor--;
				break;
		}
		if(!sys) {
			this.input.keyDown(event);
			Rex.gui.redraw();
		}
		return true;
	}

	onKeyPress(event) {

		if(!this._visible) return false;
		let sys = false;
		//switch(event.which){
		//	case 13 : this.parseCommand(this.input.text);
		//			this.input.text = "";
		//			this.input.str = "";
		//			sys = true;
		//		break;
		//	case 192 : if(event.ctrlKey) this.visible = !this._visible;
		//		sys = true;
		//		break;
		//}
		if(!sys) {
			this.input.keyPress(event);
			Rex.gui.redraw();
		}
		return true;

	}

	disconnect() {
		this.comandsBuffer.push("/disconnect");
		this.commandCursor = this.comandsBuffer.length - 1;
		for(let i = 0; i < this.sockets.length; ++i) {
			delete this.sockets[i];
		}
		this.sockets = [];
	}

	connect(address) {
		this.comandsBuffer.push("/connect" + address);
		this.commandCursor = this.comandsBuffer.length - 1;
		this.bufSend("Connect:" + address);
		let socket = new WebSocket(address);
		socket.onopen = function() {
			Rex.console.bufSend("Conected");
			//this.handleWebSocket(event);
			Rex.console.bufSend(event.data);

		};

		socket.onclose = function(event) {
			let even = JSON.parse(event);
			Rex.console.bufSend(even.name + " closed Conection");
			if(this == Rex.console.curSocket) Rex.console.curSocket = undefined;
		};

		socket.onmessage = function(event) {
			Rex.console.bufSend("response: " + event.data);
		};

		socket.onerror = function(event) {
			Rex.console.bufSend("Error: " + event.data);
		};

		this.curSocket = socket;

	}
}

class Hint {
	
	constructor(hint) {
		this.hint = hint || "";
		this.posX = 0;
		this.posY = 0;
		this.baseWidth = 300;
		this.height = 150;
		this.color = new Color(66, 66, 66, 190);
		this.fontcolor = new Color(255, 255, 255, 255);
		this.marginTop = 20;
		this.enable = false;
		this.linesText = [];
	}

	setPos(posX, posY) {
		this.posX = posX;
		this.posY = posY;
	}

	drawTriangle(ctx, x, y, lengthX, lengthY) {
		ctx.save();
		ctx.fillStyle = this.geometricFillColor;
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x - lengthX / 2, y - lengthY);
		ctx.lineTo(x + lengthX / 2, y - lengthY);
		ctx.fill();
		ctx.restore();
	}

	drawRoundedBackground(ctx, x, y, w, h) {
		ctx.save();
		ctx.beginPath();
		let r = x + w;
		let b = y + h;
		ctx.moveTo(x + 6, y);
		ctx.lineTo(r - 6, y);
		ctx.quadraticCurveTo(r, y, r, y + 6);
		ctx.lineTo(r, y + h - 6);
		ctx.quadraticCurveTo(r, b, r - 6, b);
		ctx.lineTo(x + 6, b);
		ctx.quadraticCurveTo(x, b, x, b - 6);
		ctx.lineTo(x, y + 6);
		ctx.quadraticCurveTo(x, y, x + 6, y);
		ctx.fill();
		ctx.restore();
	}

	getHeightToText(context, text, width, lineHeight) {
		let lines = text.split("\\n");
		let count = 1;
		this.linesText = [];
		for (let i = 0; i < lines.length; ++i) {
			let words = lines[i].split(" ");
			let countWords = words.length;
			let line = "";
			for (let n = 0; n < countWords; n++) {
				let testLine = line + words[n] + " ";
				let testWidth = context.measureText(testLine).width;
				if (testWidth > width) {
					this.linesText[count - 1] = line;
					line = words[n] + " ";
					count++;
				}
				else {
					line = testLine;
				}
			}
			this.linesText[count - 1] = line;
			count++;
		}
		return lineHeight * count;

	}

	getWidthText(context) {
		let maxWidth = 0;
		for (let i = 0; i < this.linesText.length; ++i) {
			let widthLine = context.measureText(this.linesText[i]).width;
			if(widthLine > maxWidth) maxWidth = widthLine;
		}
		return maxWidth;
	}

	drawText(ctx, x, y, lineHeight) {
		for(let i = 0; i < this.linesText.length; ++i) {
			ctx.fillText(this.linesText[i], x || 0, y || 0);
			y += lineHeight || 0;
		}
	}

	draw(ctx, ctxTemp) {
		if(this.posX === 0 && this.posY === 0) return;
		if(this.hint === "" || this.hint === undefined) return;
		if(!this.enable) return;
		ctx.save();
		ctx.font = "12px Roboto";
		ctx.textAlign = "left";
		ctx.textBaseline = "middle";

		this.height = this.getHeightToText(ctx, this.hint, this.baseWidth - 15, this.marginTop);
		let maxWWW = this.getWidthText(ctx);

		if(maxWWW  < this.baseWidth) {
			this.width = maxWWW + 25;
		}
		else this.width = this.baseWidth;

		ctx.fillStyle = this.color.colorToString();
		if(this.posY - this.height - 11 > 0) {
			this.drawTriangle(ctx, this.posX, this.posY - 3, 8, 8);
			this.drawRoundedBackground(ctx, this.posX - 10, this.posY - this.height - 11, this.width, this.height);
			ctx.fillStyle = this.fontcolor.colorToString();
			this.drawText(ctx, this.posX - 5, this.posY - this.height - 11 + this.marginTop, this.marginTop);
		}
		else {
			this.drawTriangle(ctx, this.posX + 10, this.posY, 8, -8);
			this.drawRoundedBackground(ctx, this.posX - 10, this.posY + 8, this.width, this.height);
			ctx.fillStyle = this.fontcolor.colorToString();
			this.drawText(ctx, this.posX - 5, this.posY + 8 + this.marginTop, this.marginTop);
		}
		ctx.restore();
	}
	
}

//used WidgetWindow
class Resizer {
	
	constructor(widget) {
		
		this.resizeType = {
			none : 0,
			n : 1,		// n - (верх, центр),
			ne : 2,		// ne - (верхний правый угол),
			e : 3,		// e - (право),
			se : 4,		// se - (правый нижний угол),
			s : 5,		// s - (низ, центр),
			sw : 6,		// sw - (левый нижний угол),
			w : 7,		// w - (лево),
			nw : 8		// nw - (левый верхний угол)
		};
		this.widget = widget;
		this.needResize = true;
		this.resize = this.resizeType.none;
		this.startResizePos = new Rex.Vector2(0, 0);
		this.startResize = new Rex.Vector2(0, 0);
		this.startMove = new Rex.Vector2(0, 0);
		
		this.cursorType = ["n-resize", "ne-resize", "e-resize", "se-resize", "s-resize", "sw-resize", "w-resize", "nw-resize", "default", "move"];
	}
	
	checkResize(mouseX, mouseY) {
		if(this.widget === undefined) return;
		if(this.needResize) return;
		
		// Погрешность определения границы стороны
		let errorLine = 20;
		let errorDiff = 10;
		let px = this.widget.aPosX;
		let py = this.widget.aPosY;
		let w = 0;
		let h = 0;
		if(this.widget.typeView == "canvas") {
			w = this.widget.width;
			h = this.widget.height;
		} else {
			w = this.widget.width;
			h = this.widget.height;
		}
		let mouse = new Rex.Vector2(mouseX, mouseY);
		let radius = 10;
		let shiftX = [w / 2, w, w, w, w / 2, 0, 0, 0];
		let shiftY = [0, 0, h / 2, h, h, h, h / 2 , 0];
		for(let i = 0; i < shiftX.length; ++i) {
			let distance = Rex.Vector2.distance(new Rex.Vector2(px + shiftX[i], py + shiftY[i]), mouse);
			if(distance < radius) {
				if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[i];
				this.resize = i + 1;
				return;
			}
		}
		
		w += px;
		h += py;
		
		// Ресайз на краю сторон
		
		// TOP
		if((((px + errorLine) < mouseX) && (mouseX < (w - errorLine))) && (((py - errorDiff) < mouseY) && (mouseY < (py + errorDiff)))) {
			this.resize = 1;
			if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[0];
			return;
		}
		
		// RIGHT
		if(((w - errorDiff < mouseX) && (mouseX < w + errorDiff)) && ((py + errorLine < mouseY) && (mouseY < h - errorLine))) {
			this.resize = 3;
			if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[2];
			return;
		}
		
		// BOTTOM
		if(((px + errorLine < mouseX) && (mouseX < w - errorLine)) && ((h - errorDiff < mouseY) && (mouseY < h + errorDiff))) {
			this.resize = 5;
			if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[4];
			return;
		}
		
		// LEFT
		if(((px - errorDiff < mouseX) && (mouseX < px + errorDiff)) && ((py + errorLine < mouseY) && (mouseY < h - errorLine))) {
			this.resize = 7;
			if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[6];
			return;
		}
		
		if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[8];
		this.resize = this.resizeType.none;
	}
	
	mouseMove(x ,y) {
		this.checkResize(x, y); 
		if(this.needResize) {
			let newPos = new Rex.Vector2(x, y);
			let delta = newPos.sub(this.startResizePos);
			let deltaSizeX = [0, delta.x, delta.x, delta.x, 0, -delta.x, -delta.x, -delta.x];
			let deltaSizeY = [-delta.y, -delta.y, 0, delta.y, delta.y, delta.y, 0, -delta.y];
			let deltaPosX = [
				this.startMove.x,
				this.startMove.x,
				this.startMove.x,
				this.startMove.x,
				this.startMove.x,
				this.startMove.x + delta.x,
				this.startMove.x + delta.x,
				this.startMove.x + delta.x
			];
			let deltaPosY = [
				this.startMove.y + delta.y,
				this.startMove.y + delta.y,
				this.startMove.y,
				this.startMove.y,
				this.startMove.y,
				this.startMove.y,
				this.startMove.y,
				this.startMove.y + delta.y
			];
			
			let minimumWidth = this.widget.minWidth;
			let minimumHeight = this.widget.minHeight;
			if(this.widget.minContentWidth !== undefined) {
				if(this.widget.minContentWidth > this.widget.minWidth){
					minimumWidth = this.widget.minContentWidth;
				}
			}
			if(this.widget.minContentHeight !== undefined) {
				if(this.widget.minContentHeight > this.widget.minHeight){
					minimumHeight = this.widget.minContentHeight;
				}
			}
			
			if(this.widget.typeView == "html" && this.resize != 0) this.widget.view.startMoving();
			
			for(let i = 0; i < deltaSizeX.length; ++i) {
				if(i + 1 != this.resize) continue;
				let posX = deltaPosX[i];
				let posY = deltaPosY[i];
				let width = this.startResize.x + deltaSizeX[i];
				let height = this.startResize.y + deltaSizeY[i];
				if (this.widget.view.htmlElement != null)	this.widget.view.htmlElement.style.cursor = this.cursorType[i];
				if(((minimumWidth) > width) || ((minimumHeight ) > height)) continue;
				this.widget.setPosX(posX);
				this.widget.setPosY(posY);
				if(this.widget.width != width && width > this.widget.paddingLeft + this.widget.paddingRight) this.widget.setWidth(width);
				if(this.widget.height != height && height > this.widget.paddingTop + this.widget.paddingBottom) this.widget.setHeight(height);
			}
			Rex.gui.redraw();
			if(Rex.gui === undefined) return;
			Rex.gui.reposition(this.widget);
		}
	}
	
	mouseDown(x, y) {
		if(this.resize != this.resizeType.none) {
			this.startResizePos.x = x;
			this.startResizePos.y = y;
			this.startResize.x = this.widget.width;
			this.startResize.y = this.widget.height;
			this.startMove.x = this.widget.posX;
			this.startMove.y = this.widget.posY;
			this.needResize = true;
			Rex.gui.needMove = false;
		}
	}
	
	mouseUp() {
		this.needResize = false;
		this.resize = this.resizeType.none;
	}
	
	draw(ctx, ctxTemp) {
		if(!this.needResize) return;
		let px = this.widget.posX;
		let py = this.widget.posY;
		let w = this.widget.width;
		let h = this.widget.height;
		ctx.strokeStyle = "rgb(100, 168, 209)";
		ctx.lineWidth = 1;
		ctx.beginPath();
		
		// Рисуем линии в зависимости от стороны ресайза
		switch (this.resize){
			case 1: {
				ctx.moveTo(px, py);
				ctx.lineTo(px + w, py);
				break;
			}
			case 3: {
				ctx.moveTo(px + w, py);
				ctx.lineTo(px + w, py + h);
				break;
			}
			case 5: {
				ctx.moveTo(px, py + h);
				ctx.lineTo(px + w, py + h);
				break;
			}
			case 7: {
				ctx.moveTo(px, py);
				ctx.lineTo(px, py + h);
				break;
			}
		}
		ctx.stroke();
		
		let radius = 5;
		let shiftX = [w / 2, w, w, w, w / 2, 0, 0, 0];
		let shiftY = [0, 0, h / 2, h, h, h, h / 2 , 0];
		for(let i = 0; i < shiftX.length; ++i) {
			if(i + 1 != this.resize) continue;
			if(this.resize == 0) continue;
			this.drawCircle(ctx, px + shiftX[i], py + shiftY[i], radius, "rgb(100, 168, 209)");
		}
	}
	
	drawCircle(ctx, x, y, radius, color) {
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
		ctx.fill();
	}
	
	onMake() {
		let childHtml = "";
		
		if(!this.needResize) return ``;
		let radius = 5;
		let px = this.widget.posX;
		let w = this.widget.width + this.widget.paddingLeft + this.widget.paddingRight;
		let h = this.widget.height + this.widget.paddingTop + this.widget.paddingBottom;
		
		let t = 0;
		let l = 0;
		let drW = 0;
		let drH = 0;
		let drawLine = false;
		// Рисуем линии в зависимости от стороны ресайза
		switch(this.resize) {
			case 1:
			{		//T
				drW = w;
				drawLine = true;
				break;
			}
			case 3:
			{		//R
				l = w - radius;
				drH = h;
				drawLine = true;
				
				break;
			}
			case 5:
			{		//B
				t = h - radius;
				drW = w;
				drawLine = true;
				
				break;
			}
			case 7:
			{		//L
				drH = h;
				drawLine = true;
				
				break;
			}
		}
		
		if(drawLine) {
			childHtml += `<div style="
								border: solid rgb(100, 168, 209) 1px;
								background: rgba(100, 168, 209, 0.5);
								top: 	${(t) + "px"};
								left: 	${(l) + "px"};
								width:	${(drW) + "px"};
								height:	${(drH) + "px"};
								position:absolute;
								"></div>`;
			
		}
		
		// Точки ресайза
		let shiftT = [0,		 0, 		h / 2, h, h, h, h / 2, 0];
		let shiftL = [w / 2,	 w, 		w, w, w / 2, 0, 0, 0	];
		for(let i = 0; i < shiftT.length; ++i) {
			if(i + 1 != this.resize) continue;
			if(this.resize == 0) continue;
			childHtml += `<div style="
									border: solid rgb(100, 168, 209) 1px;
									border-radius: ${(radius / 2) + "px"};
									background: rgba(100, 168, 209, 0.5);
									top: 	${(shiftT[i] - radius) + "px"};
									left: 	${(shiftL[i] - radius) + "px"};
									width:	${(radius) + "px"};
									height:	${(radius) + "px"};
									position:absolute;
									"></div>`;
			
		}
		
		return childHtml;
		
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex Color*/

class NotificationIdMessages {
	constructor() {
		this.messageId = 0;
	}

	getMessageId() {
		return "message" + this.messageId++;
	}
}

class Message {
	constructor(Data, type, manager) {
		this.data = Data;
		this.type = type;
		if(Rex.render != null) {
			this.ctx = Rex.render.ctx;
			this.canvas = Rex.render.overlay;
		}
		this.width = 300;
		this.height = 100;
		this.padding = new Rex.Vector2(25, 125);
		this.timeInterval = 0;
		this.manager = manager;
		this.color = (this.type == "error") ? new Color(150, 0, 0, 125) : (this.type == "info") ?  new Color(0, 150, 0, 125) : new Color(240, 200, 0, 125)  ;
		this.fontcolor = new Color(255, 255, 255, 255);

		this.htmlID = manager.messagesManager.getMessageId();
	}

	get htmlElement() {
		let html = document.getElementById(this.htmlID);
		return html != undefined ?  html : undefined;
	}

	draw(offset) {
		let paddingLeft = 25;
		let paddingRight = 25;
		let rightOffset = 25;

		let x = window.innerWidth - (this.width + this.padding.x);
		let y = window.innerHeight - this.padding.y - offset;

		if(this.htmlElement === undefined) {
			let temp = document.createElement("div");
			temp.id = this.htmlID;
			temp.className = "Message";
			temp.style.top = y + "px";
			temp.style.left = (x - paddingLeft - rightOffset) + "px";
			temp.style.width = (this.width + paddingRight + paddingLeft - rightOffset / 2) + "px";
			temp.style.height = this.height + "px";
			temp.style.background = this.color.colorToString();
			temp.style.color = this.fontcolor.colorToString();

			temp.innerText = this.data;
			console.log("MESSAGE:", this.data);

			let parent = document.body;
			parent.appendChild(temp);
			setTimeout(function() {
				let html = this.htmlElement;
				if(html !== undefined) this.htmlElement.remove();
			}.bind(this), 5000);
		} else {
			let temp = this.htmlElement;
			if(temp == undefined) return;
			temp.style.top = y + "px";
			temp.style.background = this.color.colorToString();
			temp.style.color = this.fontcolor.colorToString();
		}
	}

	runfade(){
		for(let i = 0; i < 10; ++i) {
			setTimeout(function() {
				this.clear();
			}.bind(this), 50 * i);
		}
	}

	clear() {
		if(this.color.a > 10) {
			this.color = this.color.getFaded(65);
			this.fontcolor = this.fontcolor.getFaded(65);
			if(Rex.gui !== undefined) Rex.gui.redraw();
			return;
		}
		if(this == this.manager.messages[0]) this.manager.messages.shift();
		if(Rex.gui !== undefined) Rex.gui.redraw();
	}
}

class NotificationManager  {
	
	constructor() {
		this.sleep = 1;
		this.interval = 10;
		this.messages = [];
		this.animOffset = 0;
		this.timeInterval = 0;
		this.messagesManager = new NotificationIdMessages();
	}

	animate(){
		if (this.animOffset > 0) {
			this.animOffset = this.animOffset - 1;
			Rex.gui.redraw();
			return;
		}
		Rex.gui.redraw();
	}
	
	message(data, type) {
		
		if(type == "system") {
			if(Rex.MEMUSAGE == null) Rex.MEMUSAGE = new MemoryUsageViewer();
			Rex.MEMUSAGE.addData(data);
			return;
		}
		
		if(type == "disableMessages") {
			this.disabledMessage = true;
		}

		if(type == "error" && data.indexOf("Code: 1006 Message:  Disconnect") != -1) {
			this.disconnectMessage();
		}
		
		if(this.disabledMessage) return;
		
		let decData;
		try {decData = decodeURIComponent(escape(window.atob(data)));}
		catch(e) {decData = data; /*console.log(this.type,"setState->", "DecodeError, but fucking dances!")*/};
		if(Rex.console) Rex.console.bufSend(type + ": " + decData);
		let newMess = new Message(decData, type, this);
		this.messages.push(newMess);
		this.animOffset = 120;
		setTimeout(function(){this.runfade()}.bind(newMess),3500);
		for(let i = 0; i<this.animOffset; ++i) {
			setTimeout(function() {
				this.animate()
			}.bind(this), this.sleep * i);
		}
		if(Rex.gui !== undefined) Rex.gui.redraw();
		sendNotification("Уведомление от сервера", {
			body: decData,
			dir: "auto"
		});
	}
	
	sendMessage() {
		for(let i = this.messages.length - 1; i >= 0; --i) {
			let offset = (this.messages[i].height + this.interval) * (this.messages.length -1 - i );
			this.messages[i].draw(offset - this.animOffset);
		}
	}

	disconnectMessage() {

		let disconnectContainer = document.createElement("div");
		disconnectContainer.classList.add("DisconnectContainer");
		
		let disconnectView = document.createElement("div");
		disconnectView.classList.add("DisconnectView");
		disconnectContainer.appendChild(disconnectView);

		let disconnectText = document.createElement("div");
		disconnectText.classList.add("DisconnectText");
		disconnectText.textContent = "Server Disconnected";
		disconnectView.appendChild(disconnectText);
		
		let closeDiscMessBtn = document.createElement("div");
		closeDiscMessBtn.classList.add("DisconnectBtn");
		closeDiscMessBtn.textContent = "Ok";
		closeDiscMessBtn.addEventListener("click", function(){
			this.remove();
		}.bind(disconnectContainer), false);
		disconnectView.appendChild(closeDiscMessBtn);

		document.body.appendChild(disconnectContainer);

	}
}

function sendNotification(title, options) {
	if(!("Notification" in window)) {
		alert("Ваш браузер не поддерживает HTML Notifications, его необходимо обновить.");
	} else if(Notification.permission === "granted") {
		var notification = new Notification(title, options);
		function clickFunc() { alert("Пользователь кликнул на уведомление"); }
		notification.onclick = clickFunc;
	} else if(Notification.permission !== "denied") {
		Notification.requestPermission(function (permission) {
			if (permission === "granted") {
				var notification = new Notification(title, options);
			} else {
				//alert('Вы запретили показывать уведомления'); // Юзер отклонил наш запрос на показ уведомлений
			}
		});
	}
}

class MemoryUsageViewer {
	
	constructor() {
		this.memoryData = [];
		this.memoryLimit = 0;
		this.showing = false;
		
		this.size = 100;
		
		for(let i = 0; i < this.size; ++i) this.memoryData.push(0);
		
		
		window.addEventListener("keypress", this.eventKey.bind(this), false);
		
		this.view = document.createElement("div");
		this.view.classList.add("ConsoleContainer");
		this.view.style.display = "none";
		
		this.viewContainer = document.createElement("div");
		this.viewContainer.classList.add("ConsoleViewContainer");
		this.view.appendChild(this.viewContainer);
		
		this.lineData = document.createElement("div");
		this.lineData.classList.add("ConsoleLine");
		this.view.appendChild(this.lineData);
		
		//<!--SVG-->
		let namespaceURL = decodeURIComponent(escape(window.atob("aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc=")));
		this.svgContainer = document.createElementNS(namespaceURL, "svg");
		this.svgContainer.classList.add("ConsoleSVG");
		this.lineData.appendChild(this.svgContainer);
		
		//<!--COLOR GRADIENT LINE-->
		// this.htmlGradient = document.createElementNS(namespaceURL, "linearGradient");
		// this.htmlGradient.setAttribute("id", this.colorGradientID);
		// this.htmlGradient.setAttribute("x1", color_x1);
		// this.htmlGradient.setAttribute("y1", color_y1);
		// this.htmlGradient.setAttribute("x2", color_x2);
		// this.htmlGradient.setAttribute("y2", color_y2);
		// this.stop1 = document.createElementNS(namespaceURL, "stop");
		// this.stop1.setAttribute("offset", 0);
		// this.stop1.setAttribute("stop-color", this.color1);
		// this.stop2 = document.createElementNS(namespaceURL, "stop");
		// this.stop2.setAttribute("offset", 100);
		// this.stop2.setAttribute("stop-color", this.color2);
		//
		
		//<!--LINE MEMORY-->
		this.htmlLine = document.createElementNS(namespaceURL, "path");
		this.htmlLine.setAttribute("class", "MemUsagePath");
		this.htmlLine.setAttribute("stroke-width", 3);
		this.svgContainer.appendChild(this.htmlLine);
		
		this.htmlLineMin = document.createElementNS(namespaceURL, "text");
		this.htmlLineMin.setAttribute("class", "ConsoleText");
		this.svgContainer.appendChild(this.htmlLineMin);
		
		this.htmlLineMax = document.createElementNS(namespaceURL, "text");
		this.htmlLineMax.setAttribute("class", "ConsoleText");
		this.svgContainer.appendChild(this.htmlLineMax);
		
		//<!--LINE LIMIT-->
		this.htmlLineLimit = document.createElementNS(namespaceURL, "path");
		this.htmlLineLimit.setAttribute("class", "MemLimit");
		this.htmlLineLimit.setAttribute("stroke-width", 3);
		this.svgContainer.appendChild(this.htmlLineLimit);
		
		this.htmlLineLimitText = document.createElementNS(namespaceURL, "text");
		this.htmlLineLimitText.setAttribute("class", "ConsoleText");
		this.svgContainer.appendChild(this.htmlLineLimitText);
		
		this.listData = document.createElement("div");
		this.listData.classList.add("ConsoleListData");
		this.lineData.appendChild(this.listData);
		
		
		//<!--CLOSE-->
		this.viewContainerClose = document.createElement("div");
		this.viewContainerClose.classList.add("ConsoleViewContainerClose");
		this.viewContainerClose.addEventListener("click", this.hide.bind(this), false);
		this.viewContainerClose.textContent = "Close";
		this.viewContainer.appendChild(this.viewContainerClose);
		
		
		//<!--INNER CONSOLE-->
		let container = document.getElementById("container1");
		if(container != null) {
			container.appendChild(this.view);
		}
		
	}
	
	addData(strData) {
		
		let mem = strData.substr(16, strData.indexOf("MaxMEMLIMIT") - 16);
		this.memoryLimit = strData.substr(strData.indexOf("MaxMEMLIMIT") + 11);
		
		this.memoryData.push(parseFloat(mem)/1024);
		this.memoryData = this.memoryData.slice(1);
		
		let memItem = document.createElement("div");
		this.listData.appendChild(memItem);
		memItem.textContent += (parseFloat(mem)/1024 + "Kb \n");
		this.listData.scrollTop = this.listData.scrollHeight - this.listData.clientHeight;
		
		this.update();
	}
	
	update() {
		
		let w = this.svgContainer.clientWidth;
		let h = this.svgContainer.clientHeight;
		
		let onePointX = w / (this.size - 1);
		let onePointY = (h / this.memoryLimit) * 0.9;
		
		// LIMIT
		this.htmlLineLimit.setAttribute("d", "M 0 " + (h - (this.memoryLimit * onePointY)) + " L" + parseInt(this.size * onePointX) + " " + (h - (this.memoryLimit * onePointY)));
		this.htmlLineLimitText.setAttribute("x", 0);
		this.htmlLineLimitText.setAttribute("y", (h - (this.memoryLimit * onePointY)));
		this.htmlLineLimitText.textContent = this.memoryLimit + "Mb";
		
		// MEMORY USAGE
		let d = "M 0 " + h + " L ";
		for(let i = 0; i < this.size ; i++) {
			let value = this.memoryData[i];
			let vX = parseInt(i * onePointX);
			let vY = (h - parseInt((value / 1000) * onePointY));
			d += vX + " " + vY + " ";
			
			if(i == 0) {
				this.htmlLineMin.textContent = value + "Kb";
				this.htmlLineMin.setAttribute("x", 0);
				this.htmlLineMin.setAttribute("y", h);
			}
			if(i == this.size - 1) {
				this.htmlLineMax.textContent = value + "Kb";
				if(this.htmlLineMax.getClientRects().length > 0) this.htmlLineMax.setAttribute("x", w - this.htmlLineMax.getClientRects()[0].width);
				this.htmlLineMax.setAttribute("y", h);
			}
			
		}
		this.htmlLine.setAttribute("d", d + parseInt(this.size * onePointX) + " " + h);
		
	}
	
	show() {
		this.view.style.display = "block";
		this.showing = true;
		this.update();
	}
	
	hide() {
		this.view.style.display = "none";
		this.showing = false;
		
	}
	
	eventKey(e) {
		if(e.which == 96) { // KEY = '`'
			if(this.showing) this.hide();
			else this.show();
		}
		
	}
	
	
}


class AttributeObject {
	
	constructor(name, value) {
		this.name = name;
		this.value = value;
		this.enabled = true;
	}
	
	toString() {
		return `${this.name}="${this.value}"`;
	}

	toStyleString(){
		return `${this.name}:${this.value}`;
	}
	
}

class AttributeManager {
	
	constructor(view) {
		this.view = view;
		this.attributes = {};
		this.styleAtributes = {};
	}
	
	loadStyle(stateStyle){
		for( let name in stateStyle ){
			let value = stateStyle[name];
			if (document.body.style.hasOwnProperty(name) || (name.substr(0,2)==='--')) {
				this.addStyleAtribute(name, value);
				return;
			}
			this.addAttribute(name,value);
		}
	}
	
	addAttribute(name, value) {
		if(name == "style") {
			console.error("can`t add special Attribute 'Style'. For set styles attributes use addStyleAttribute" +
				" method");
			return;
		}
		if(this.attributes[name] !== undefined) {
			let attribute = this.attributes[name];
			if(attribute === undefined) {
				console.error("Can't add attribute name: ", name);
				return;
			}
			attribute.name = name;
			attribute.value = value;
			return this.attributes[name];
		}
		this.attributes[name] = new AttributeObject(name, value);
		return this.attributes[name];
	}
	
	/// удаляет атрибут! удаляет совсем из атрибут менеджера. проблема в том, что в следующем onSetStyle этот
	// атрибут возможно вернется.
	// ищет в атрибутах, и удаляет. если не нашел ищет в стилях и удаляет там.
	// совет по использованию - в мейке самого себя.
	removeAttribute(name) {
		if(this.attributes[name] !== undefined) {
			delete this.attributes[name];
			return;
		}
		if(this.styleAtributes[name] !== undefined) {
			delete this.styleAtributes[name];

			return;
		}
	}
	
	// делает атрибут активным или не активным. не удаляет атрибут, тем самым в следующем onSetStyle этот атрибут
	// обновится, но не изменит своего состояния ВКЛ/ВЫКЛ.
	// совет по использованию - в мейке родителя для чилдов. или для длительного отключения какого-либо параметра.
	// или для div - чтобы специфические атрибуты не попадали в див.
	setAttributeEnabled(name, enabled){
		if (this.attributes[name] !== undefined){
			this.attributes[name].enabled = enabled;
		}
	}
	
	// тоже самое, что и setAttributeEnabled только для стилей.
	setStyleAttributeEnabled(name, enabled){
		if (this.styleAtributes[name] !== undefined){
			this.styleAtributes[name].enabled = enabled;
		}
	}
	
	getAttributeByName(name) {
		return this.attributes[name];
	}
	
	toString() {
		let tempString = "";
		for(let key in this.attributes) {
			let attribute = this.attributes[key];
			if (attribute.enabled)	tempString += attribute.toString() + " ";
		}
		if(this.styleAtributes.length !== 0) {
			tempString += 'style="' + this.toStyleString() + '"';
		}
		return tempString;
	}
	
	addStyleAtribute(name, value){
		if(this.styleAtributes[name] !== undefined) {
			let style = this.styleAtributes[name];
			if(style === undefined) {
				console.error("Can't add style-attribute name: ", name);
				return;
			}
			style.name = name;
			style.value = value;
			return this.styleAtributes[name];
		}
		this.styleAtributes[name] = new AttributeObject(name, value);
		return this.styleAtributes[name];
	}
	
	getStyleAttributeByName(name) {
		return this.styleAtributes[name];
	}
	
	toStyleString(){
		let tempString = "";
		for(let key in this.styleAtributes) {
			let attribute = this.styleAtributes[key];
			if (attribute.enabled)	tempString += attribute.toStyleString() + "; ";
		}
		return tempString;
	}
	
}

/**
 * Created by Aleksandr G. on 27.10.2017.
 */


class StyleLibrary {

	constructor(state) {

		this.styleLib = {};
		
	}
	
	load(state){
		if(state === undefined) return;
		if(!state.hasOwnProperty("library_name")) return;
		let stateCopy = {};
		Rex.copy(stateCopy,state);
		
		this.styleLib = {};
		
		for (let key in stateCopy) {
			if (key == "library_name") continue;
			this.recurFillStyle(stateCopy, key);
		}
		if(Rex.gui!==undefined) Rex.gui.refreshAll();
	}
	
	recurFillStyle(state, names){
		if (state[names].hasOwnProperty("isFill")) return;
		let obj = {};
		if (state[names].hasOwnProperty("parentStyle")){
			let parentName = state[names].parentStyle;
			if(state.hasOwnProperty(parentName)) {
				this.recurFillStyle(state,parentName);
				Rex.copy(obj, this.styleLib[parentName]);
			}
		}
		state[names].isFill = true;
		this.styleLib[names] = obj;
		Rex.copy(this.styleLib[names],state[names]);
	}
	
	getParam(styleName,paramName,defaultValue){
		if(this.styleLib === undefined){
			return defaultValue;
		}
		if (!this.styleLib.hasOwnProperty(styleName)) { 
			return defaultValue;
		}
		if (!this.styleLib[styleName].hasOwnProperty(paramName)) {
			return defaultValue;
		}
		return this.styleLib[styleName][paramName];
 	}
}

/**
 * Created by prg-30 on 02.06.2017.
 */

class ConsoleInput extends Widget {

	constructor(state) {
		super(state);
		this.text = '';
		this.str = '';
		this.header = '';
		this.offset = 4;
		this.anchorPos = new Rex.Vector2(this.posX , this.posY);
		this.anchorSize = new Rex.Vector2(this.width , this.height);

		//курсор
		this.cursorPosition = this.text.length;
		this.heightCaret = this.anchorSize.x / 2 + (this.anchorSize.y / 2 / 3);
		this.widthCaret = 2;
		this.enabled = false;
		this.widthText = [];
		this.countWidth = true;
		this.anchorPoint = new Rex.Vector2();
		this.offsetLeft = 0;
		this.offsetRight = 0;
		this.textTemp = '';
		this.mv = false; //передвижение стрелками(true)/(false) добавление символов
		this.caretPosition = 0; //позиция каретки
		this.delete = false; //если удаляем символы, позицианирование текста в поле
		this.needMove = false;
		this.charLength = 8;

		//выделенный текст
		this.selectPosition = -1;
		this.left = false;

		this.specSymbols = {
			SHIFT		: 0x10,
			DELETE		: 0x2E,
			BACKSPACE 	: 0x08,
			ENTER 		: 0x0D,
			CTRL 		: 0x11,
			ALT 		: 0x12,
			LEFT_ARROW 	: 0x25,
			UP_ARROW 	: 0x26,
			RIGHT_ARROW : 0x27,
			DOWN_ARROW 	: 0x28,
			A			: 0x41,
			ESC			: 0x1B
		};

		this.radius = 1;

		super.setState(state);
		this.view.update();
		//this.text = decodeURIComponent(escape(window.atob(this.text)));
		this.str = this.text;
	}

	setState(state) {
		if(state === undefined) return;
		Rex.copy(this, state);
		//this.text = decodeURIComponent(escape(window.atob(this.text)));
		this.str = this.text;
	}

	onDraw(ctx, ctxTemp) {
		this.drawer.gradientBackground(ctx);
		this.anchorPos = new Rex.Vector2(this.posX, this.posY);
		this.anchorSize = new Rex.Vector2(this.width, this.height);
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.font = `${this.anchorSize.y / 2}px Arial`;
		this.heightCaret = this.anchorSize.y / 2 + (this.anchorSize.y / 2 / 3);
		if(this.cursorPosition > this.str.length) {
			console.error("this is not validate");
			this.cursorPosition = this.str.length;
		}

		this.drawer.drawLine(ctx, this.posX, this.posY + this.height, this.posX + this.width, this.posY + this.height, 2, 1,
			this.drawer.getParam("geometricFillColor" ,  "rgb(158, 158, 158)"));
		this.drawer.lineAnimation(ctx, ctxTemp, this.drawer.getParam("animationLineWidth" ,  2),
			this.drawer.getParam("animationStrokeColor" ,  "rgb(99, 215, 203)"));
		if(this.animation.getRadiusAnimation() > this.anchorSize.x && !this.isFocused()) this.animation.endAnimation();

		this.caretPosition = this.anchorPos.x + ctxTemp.measureText(this.str.substr(0, this.cursorPosition)).width + this.offset  - this.offsetLeft;
		this.drawSelect(ctxTemp, this.anchorPos.x, this.anchorPos.y);
		this.onOffsetLeft(ctxTemp,this.anchorPos.x,this.anchorSize.x);
		this.drawText(ctxTemp, this.anchorPos.x, this.anchorPos.y, this.anchorSize.x);

		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(this.anchorPos.x, this.anchorPos.y, this.anchorSize.x, this.anchorSize.y);
		ctx.drawImage(ctxTemp.canvas, 0, 0);

		if (this.isHovered())
			this.drawer.drawRect(ctx, this.posX, this.posY, this.width, this.height, 0,
				this.drawer.getParam("hoverColor", "rgba(0, 0, 0, 0.1)"));
		if(this.text.length != 0 || this.isFocused()) {
			this.drawer.setStyleParameters(`12px Arial`, this.drawer.strokeStyle, "rgb(128,128,128)");
			this.drawer.header(ctx, this.anchorPos.x + this.anchorSize.x * 0.03, this.anchorPos.y - 5, this.header);
		} else {
			this.drawer.setStyleParameters(`15px Arial`, this.drawer.strokeStyle, "rgb(189,189,189)");
			this.drawer.header(ctx, this.anchorPos.x + this.anchorSize.x * 0.03,this.anchorPos.y + this.anchorSize.y / 2 + this.fontSize / 3, this.header);
		}
	}

	drawText(ctx, x, y, width) {
		if(1) {
			ctx.fillStyle = "#FFF";
			ctx.fillRect(this.caretPosition, y + this.heightCaret / 3, this.widthCaret, this.heightCaret / 1.3);
		}
		ctx.fillStyle = "#FFF";
		ctx.fillText(this.text, x + this.offset - this.offsetLeft, y + this.heightCaret);
		if(this.countWidth) {
			this.widthText = [];
			for(let i = 0; i < this.str.length + 1; ++i) {
				this.widthText.push(ctx.measureText(this.str.substr(0, i)).width + this.offset);
			}
		}
	}

	drawSelect(ctx, x, y) {
		if(this.selectPosition == -1) return;
		let startSelect = x + ctx.measureText(this.str.slice(0, this.getSelectionStart())).width - this.offsetLeft;
		ctx.fillStyle = "rgba(0, 92, 255, 0.8)";
		ctx.fillRect(startSelect + this.offset, y + this.heightCaret / 3, ctx.measureText(this.getSelectionText()).width, this.heightCaret / 1.3);
	}

	keyDown(event) {
		switch(event.which) {
			case this.specSymbols.BACKSPACE: this.deleteChar(event.which);
				break;
			case this.specSymbols.DELETE: this.deleteChar(event.which);
				break;
			case this.specSymbols.LEFT_ARROW: this.moveChar(event);
				break;
			case this.specSymbols.RIGHT_ARROW: this.moveChar(event);
				break;
			case this.specSymbols.A: this.ctrlA(event);
				break;
			case this.specSymbols.ESC: this.Esc(event);
				break;
			default:
				break;
		}
	}

	Esc(specSymbol){
		if(specSymbol.which == this.specSymbols.ESC){
			if(this.text.length != 0){
				if(this.selectPosition != -1){
					this.clearSelect(true);
					this.updateParameters();
					return;
				}
			}
		}
	}

	ctrlA(specSymbol){
		if(specSymbol.which == this.specSymbols.A && specSymbol.ctrlKey){
			if(this.text.length != 0){
				this.selectPosition = 0;
				this.cursorPosition = this.text.length;
				this.mv = true;
				this.updateParameters();
				return;
			}
		}
	}

	keyUp(event){
	}

	keyPress(event) {
		if(event.charCode != 13) {
			if(this.cursorPosition == 0 && this.str.length == 0) {
				this.str += this.getChar(event);
				this.cursorPosition++;
				this.countWidth = true;
			} else if(this.selectPosition != -1) {
				this.str = this.str.slice(0, this.getSelectionStart()) + this.getChar(event) + this.str.slice(this.getSelectionEnd(), this.str.length);
				this.cursorPosition = this.str.slice(0, this.getSelectionStart()).length + 1;
				this.countWidth = true;
				this.delete = true;
				this.clearSelect(false);
			} else {
				this.str = this.str.slice(0, this.cursorPosition) + this.getChar(event) + this.str.slice(this.cursorPosition, this.str.length);
				this.cursorPosition++;
				this.countWidth = true;
				this.delete = false;
			}
			this.mv = false;
			this.updateParameters();
		}
	}

	deleteChar(specSymbol) {
		if(this.selectPosition != -1) {
			this.str = this.str.substring(0, this.getSelectionStart()) + this.str.substring(this.getSelectionEnd(), this.str.length);
			this.cursorPosition = this.str.substring(0, this.getSelectionStart()).length;
			this.clearSelect(true);
			this.countWidth = true;
			this.delete = true;
			this.mv = true;
			return;
		}
		if(specSymbol == this.specSymbols.BACKSPACE) {
			if(this.cursorPosition == 0) return;
			this.cursorPosition--;
			this.str = this.str.slice(0, this.cursorPosition) + this.str.slice(this.cursorPosition + 1, this.str.length);
			this.countWidth = true;
		} else if(specSymbol == this.specSymbols.DELETE) {
			if(this.cursorPosition == this.str.length) return;
			this.str = this.str.slice(0, this.cursorPosition) + this.str.slice(this.cursorPosition + 1, this.str.length);
			this.countWidth = true;
		}
		this.delete = true;
		this.mv = true;
		this.updateParameters();
	}

	moveChar(specSymbol) {
		if(specSymbol.which == this.specSymbols.LEFT_ARROW) {
			if(this.cursorPosition != 0) {
				if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.selectPosition == -1) this.selectPosition = this.cursorPosition;
				this.cursorPosition--;
				this.left = true;
				if(specSymbol.ctrlKey) {
					for(let i = this.cursorPosition; i >= 0; --i) {
						if(specSymbol.shiftKey && this.selectPosition == -1) {
							this.selectPosition = this.cursorPosition + 1;
						}
						if(i - 1 == 0) {
							this.cursorPosition = i - 1;
							this.updateParameters();
							return;
						}
						if(!this.isNotAlpha(this.str[i]) && this.isNotAlpha(this.str[i - 1])) {
							this.updateParameters();
							return;
						}
						this.cursorPosition = i - 1;
					}

				}
				this.mv = true;
				this.needchange = false;
				this.updateParameters();
			}
		} else if(specSymbol.which == this.specSymbols.RIGHT_ARROW) {
			if(this.cursorPosition != this.str.length) {
				if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.selectPosition == -1) this.selectPosition = this.cursorPosition;
				this.cursorPosition++;
				this.left = false;
				if(specSymbol.ctrlKey) {
					for(this.cursorPosition; this.cursorPosition <= this.str.length; ++this.cursorPosition) {
						if(specSymbol.shiftKey && this.selectPosition == -1) this.selectPosition = this.cursorPosition - 1;
						if(this.cursorPosition == this.str.length) {
							this.updateParameters();
							return;
						}
						if(!this.isNotAlpha(this.str[this.cursorPosition - 1]) && this.isNotAlpha(this.str[this.cursorPosition])) {
							this.updateParameters();
							return;
						}
					}
				}
				this.mv = true;
				this.updateParameters();
			}
		}
		if(!specSymbol.shiftKey && this.selectPosition != -1) this.clearSelect(true);
	}

	mouseMove(x, y) {
		if(this.isHovered()) {
			document.body.style.cursor = 'text';

		} else {
			document.body.style.cursor = 'default';
		}
		this.onMouseMove(x,y);

	}

	cut(event) {
		event.clipboardData.setData('text/plain', this.getSelectionText());
		this.str = this.str.substring(0, this.getSelectionStart()) + this.str.substring(this.getSelectionEnd(), this.str.length);
		this.cursorPosition = this.str.substring(0, this.getSelectionStart()).length;
		this.clearSelect(true);
		this.countWidth = true;
		event.preventDefault();
	}

	copy(event) {
		event.clipboardData.setData('text/plain', this.getSelectionText());
		event.preventDefault();
	}

	paste(event) {
		if(event.clipboardData.types.indexOf('text/plain') > -1){
			if(this.selectPosition != -1) {
				this.str = this.str.slice(0, this.getSelectionStart()) + event.clipboardData.getData('text/plain') + this.str.slice(this.getSelectionEnd(), this.str.length);
				this.cursorPosition = this.text.slice(0, this.getSelectionEnd()).length;
				this.clearSelect(false);
			} else {
				this.str = this.str.slice(0, this.cursorPosition) + event.clipboardData.getData('text/plain') + this.str.slice(this.cursorPosition, this.str.length);
				this.cursorPosition = this.str.slice(0, event.clipboardData.getData('text/plain').length + this.cursorPosition).length;
			}
			this.updateParameters();
			event.preventDefault();
			this.countWidth = true;
		}
	}

	getSelectionStart() {
		return Math.min(this.selectPosition, this.cursorPosition);
	}

	getSelectionEnd() {
		return Math.max(this.selectPosition, this.cursorPosition);
	}

	getSelectionText() {
		return this.str.substring(this.getSelectionStart(), this.getSelectionEnd());
	}

	getChar(event) {
		if (event.which != 0 && event.charCode != 0) { // все кроме IE
			if (event.which < 32) return null; // спец. символ
			return String.fromCharCode(event.which); // остальные
		}
		return null; // спец. символ
	}

	isNotAlpha(letter) {
		let symbols = /[\.\,\+\-\*/= _\[\]\{\}\(\)\<\>:;\\'"\|!@#\$%\^&\?]/;
		return symbols.test(letter);
	}

	clearSelect(needSend) {
		this.selectPosition = -1;
		if(needSend) this.updateParameters();
	}

	update() {
		setInterval(function() {this.enabled = !this.enabled;}.bind(this), 500);
	}

	updateParameters() {
		this.text = this.str;
		//Rex.callRpcMethod('Widgets', this.id, this.type, 'setParameters', [window.btoa(unescape(encodeURIComponent(this.str))), this.cursorPosition, this.selectPosition]);
	}

	onFocused(focused) {
		if(!focused) {
			this.clearSelect(true);
		} else {
			this.animation.startAnimation();
		}
	}

	onMouseUp(x, y){
		this.needMove = false;
		this.anchorPoint.x = 0;
		this.updateParameters();
	}

	onMouseMove(x, y){
		if(this.widthText.length > 1 && this.offsetLeft == 0){
			if(this.needMove && this.anchorPoint.x != 0 && (this.widthText.length > 1)){
				if(x <= ((this.anchorPos.x + this.anchorSize.x * 0.005)  + this.widthText[this.widthText.length - 1]) && x >= this.anchorPos.x  - this.widthCaret){
					let delta = x - (this.widthText[this.cursorPosition] + this.anchorPos.x);
					if(Math.abs(delta) > this.charLength * .95){
						if(this.selectPosition == -1) this.selectPosition = this.cursorPosition;
						this.cursorPosition += Math.round(delta / this.charLength);
						this.mv = true;
						this.updateParameters();
					}
				}
			}
		}else if(this.offsetLeft != 0){
			if(this.needMove && this.anchorPoint.x != 0 && (this.widthText.length > 1)){
				if(x >= (this.anchorPos.x + this.anchorSize.x * 0.02 )  - this.offsetLeft - this.offset - this.widthCaret){
					let delta = x - (this.widthText[this.cursorPosition] + this.anchorPos.x - this.widthCaret) + this.offsetLeft;
					if(Math.abs(delta) > this.charLength * .95){
						if(this.selectPosition == -1) this.selectPosition = this.cursorPosition;
						this.cursorPosition += Math.round(delta / this.charLength);
						this.mv = true;
						this.updateParameters();
					}
				}
			}
		}
	}

	onMouseDown(x, y) {
		if(this.widthText.length > 1 && this.offsetLeft == 0){
			let begin = (this.anchorPos.x ) + this.widthText[0] * 0.6;
			let end = (this.anchorPos.x + this.widthText[this.widthText.length - 1]) - (this.widthText[this.widthText.length-1] - this.widthText[this.widthText.length-2]) * 0.4;
			if((x >= this.anchorPos.x ) && (x <= begin)) {
				this.cursorPosition = 0;
				this.selectPosition = -1;

			} else if((x >= begin) && (x < end)) {
				for(let i = 0; i < this.widthText.length - 2; i++){
					let l = (this.anchorPos.x)  + (this.widthText[i + 1] - this.widthText[i]) * 0.6 + this.widthText[i];
					let r = (this.anchorPos.x)  + (this.widthText[i + 2] - this.widthText[i+1]) * 0.4 + this.widthText[i+1];
					if(x > l && x < r) {
						this.cursorPosition = i+1;
						this.selectPosition = -1;
						break;
					}
				}
			} else if(x >= end){
				this.cursorPosition = this.widthText.length - 1;
				this.selectPosition = -1;
			}
			this.anchorPoint.x = x;
			this.needMove = true;
			this.mv = false;
			this.clearSelect(true);
			this.updateParameters();

		} else if(this.offsetLeft != 0){
			for(let i = 0; i < this.widthText.length - 2; i++){
				let l = (this.anchorPos.x)  + (this.widthText[i + 1] - this.widthText[i]) * 0.6 + this.widthText[i] - this.offsetLeft;
				let r = (this.anchorPos.x)  + (this.widthText[i + 2] - this.widthText[i+1]) * 0.4 + this.widthText[i+1] - this.offsetLeft;
				if(x > l && x < r) {
					this.cursorPosition = i+1;
					this.selectPosition = -1;
					break;
				}else if(x > this.caretPosition && x < (this.anchorSize.x + this.anchorPos.x) && this.cursorPosition == this.text.length - 1){
					this.cursorPosition = this.text.length;
					this.selectPosition = -1;
				}
			}
			this.anchorPoint.x = x;
			this.needMove= true;
			this.mv = false;
			this.clearSelect(true);
			this.updateParameters();
		}

	}

	onOffsetLeft(ctx,x,width){
		if(ctx.measureText(this.text).width + this.offset + this.widthCaret < width || this.cursorPosition == 0 || this.cursorPosition < 3){
			this.offsetLeft = 0;
		} else if(ctx.measureText(this.text.substr(0, this.cursorPosition)).width + this.offset + this.widthCaret > width && !this.mv){
			//когда курсор в конце текста
			if(this.cursorPosition == this.text.length){
				this.offsetLeft = ctx.measureText(this.text.substr(0, this.cursorPosition)).width - width + width * 0.02 ;
			}else
			//если курсор между началом и концом текста
			if(this.cursorPosition > 0 && this.cursorPosition < this.text.length && this.caretPosition + this.widthCaret > width + x && !this.delete){
				this.offsetLeft = ctx.measureText(this.text.substr(0, this.cursorPosition)).width + width * 0.02 - width;
			}
			//передвижение каретки, без ввода символов
		} else if(this.mv && (this.caretPosition > x + width - this.widthCaret || this.caretPosition < x + this.widthCaret)){
			if(this.caretPosition < x + this.widthCaret){
				this.offsetLeft = ctx.measureText(this.text.substr(0, this.cursorPosition)).width;
			} else if(this.caretPosition > width + x - this.widthCaret){
				this.offsetLeft = ctx.measureText(this.text.substr(0, this.cursorPosition)).width - width +  width * 0.02;
			}

		}else if(this.mv && (this.caretPosition > x - this.widthCaret && this.caretPosition < x + width + this.widthCaret)){
			if(this.caretPosition + ctx.measureText(this.text.substr(this.cursorPosition)).width < width + x){
				if(this.text.length == this.cursorPosition){
					this.offsetLeft  = ctx.measureText(this.text.substr(0, this.cursorPosition)).width - width + width * 0.02 ;
				} else if(this.cursorPosition > 0 && this.cursorPosition < this.text.length){
					this.offsetLeft = ctx.measureText(this.text.substr(0, this.cursorPosition)).width - width + width * 0.02 + ctx.measureText(this.text.substr(this.cursorPosition)).width;
				}
			}

		}
	}
}

/**
 /**
 * WidgetDrawer
 */
class Color {
	
	constructor(r, g, b, a) {
		this.r = Math.round(r);
		this.g = Math.round(g);
		this.b = Math.round(b);
		this.a = a;
		this.F = true;
	}
	
	colorToString() {
		let Res = `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a / 255})`;
		return Res;
	}
	
	fromString(str) {
		if(str.indexOf("rgb(") !== -1) {
			let tstr = str.replace("rgb(", "");
			tstr = tstr.replace(")", "");
			let arr = tstr.split(",", 3);
			if(arr.length == 3) {
				this.r = Math.round(arr[0]);
				this.g = Math.round(arr[1]);
				this.b = Math.round(arr[2]);
				this.a = 255;
			}
			else {
				console.error("error parse rgb : ", str);
			}
		}
		else if(str.indexOf("rgba(") !== -1) {
			let tstr = str.replace("rgba(", "");
			tstr = tstr.replace(")", "");
			let arr = tstr.split(",", 4);
			if(arr.length == 4) {
				this.r = Math.round(arr[0]);
				this.g = Math.round(arr[1]);
				this.b = Math.round(arr[2]);
				this.a = arr[3] * 255;
			}
			else {
				console.error("error parse rgba : ", str);
			}
		}
		else {
			console.error("color parse fail : ", str);
		}
		
	}
	
	getFaded(fadePercent) {
		let Fader = function(I) {
			let R = Math.round(I * (fadePercent / 100));
			return R;
		};
		let r, g, b, a;
		r = Fader(this.r);
		g = Fader(this.g);
		b = Fader(this.b);
		a = Fader(this.a);
		return new Color(r, g, b, a);
	}
	
	getGradient(color, t) {
		if(t > 1.0) return this;
		let dr = (color.r - this.r) * t;
		let dg = (color.g - this.g) * t;
		let db = (color.b - this.b) * t;
		let da = (color.a - this.a) * t;
		let nc = new Color(this.r + dr, this.g + dg, this.b + db, this.a + da);
		//console.log(nc, this, this.r + dr, this.g + dg, this.b + db, this.a + da);
		return nc;
	}
	
	mixColor(mixColor) {
		return new Color(Math.round((this.r + mixColor.r) / 2), Math.round((this.g + mixColor.g) / 2),
			Math.round((this.g + mixColor.g) / 2), Math.round((this.a + mixColor.a) / 2));
	}
	
	isEqal(value) {
		if(value.F && value.r == this.r && value.g == this.g && value.b == this.b && value.a == this.a) return true;
		return false;
	}
	
};

class WidgetDrawer {
	
	constructor(widget) {
		this.widget = widget;
	}
	
	getParams(paramName, defaultValue) {
		if (paramName == null) 
			return defaultValue;
		if ((this.widget !== undefined) && (this.widget.customStyle !== undefined) && (this.widget.customStyle.hasOwnProperty(paramName)))
			return this.widget.customStyle[paramName];
		if((this.widget !== undefined) && (this.widget.styleName !== undefined))
				return Rex.gui.styleLibrary.getParam(this.widget.styleName, paramName, defaultValue);
		else
			return Rex.gui.styleLibrary.getParam(this.styleName, paramName, defaultValue);
	}
	
	transform(ctx, transformMatrix, translate) {
		ctx.setTransform(transformMatrix.get(0, 0), transformMatrix.get(0, 1), transformMatrix.get(1, 0), transformMatrix.get(1, 1), translate.x, translate.y);
	}
	
	transformMousePos(x, y) {
		let mousePos = new Rex.Vector3(x, y, 0.0);
		if(this.widget.transform.length != 0) {
			let mat = new Rex.Matrix4();
			let w = this.widget;
			
			mat.copy(w.transform);
			
			let fulcrumX = w.posX + w.width / 2;
			let fulcrumY = w.posY + w.height / 2;
			
			mat.m[12] = fulcrumX * (1 - mat.m[0]) + fulcrumY * mat.m[1];
			mat.m[13] = fulcrumX * mat.m[4] + fulcrumY * (1 - mat.m[0]);
			
			mousePos = mat.getInverse43().mulVector3(mousePos);
		}
		return mousePos;
	}
	
	drawShadow(ctx) {
		if(this.widget === undefined) return;
		if(this.widget.elevation === undefined) return;
		if(this.hasOwnProperty("elevationShadow")) {
			this.onDrawShadow(ctx);
		}
		else {
			console.log("Error! ElevationShadow styles undefined!", this.widget);
		}
	}
	
	onDrawShadow(ctx) {
		this.drawRectShadow(ctx);
	}
	
	drawRectShadow(ctx) {
		if((this.widget.elevation === undefined) || (isNaN(this.widget.elevation))) return;
		
		ctx.save();
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.14)";
		ctx.shadowBlur = 1.5694 * this.widget.elevation - 0.9402;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = this.widget.elevation;
		ctx.fillRect(this.widget.aPosX + 1, this.widget.aPosY + 1, this.widget.width - 2, this.widget.height - 2);
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.12)";
		ctx.shadowBlur = 1.9064 * this.widget.elevation - 0.104;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0.0112 * this.widget.elevation * this.widget.elevation + 0.0119 * this.widget.elevation + 2.4644;
		ctx.fillRect(this.widget.aPosX + 1, this.widget.aPosY + 1, this.widget.width - 2, this.widget.height - 2);
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
		ctx.shadowBlur = 0.3864 * this.widget.elevation + 4.2153;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0.4822 * this.widget.elevation + 0.101;
		ctx.fillRect(this.widget.aPosX + 1, this.widget.aPosY + 1, this.widget.width - 2, this.widget.height - 2);
		ctx.restore();
	}
	
	drawCircleShadow(ctx, x, y, width, height) {
		
		if((this.widget.elevation === undefined) || (isNaN(this.widget.elevation))) return;
		
		ctx.save();
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.14)";
		ctx.shadowBlur = 1.5694 * this.widget.elevation - 0.9402;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = this.widget.elevation;
		ctx.beginPath();
		ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 360, 0);
		ctx.stroke();
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.12)";
		ctx.shadowBlur = 1.9064 * this.widget.elevation - 0.104;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0.0112 * this.widget.elevation * this.widget.elevation + 0.0119 * this.widget.elevation + 2.4644;
		ctx.beginPath();
		ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 360, 0);
		ctx.stroke();
		
		ctx.shadowColor = "rgba(0, 0, 0, 0.2)";
		ctx.shadowBlur = 0.3864 * this.widget.elevation + 4.2153;
		ctx.shadowOffsetX = 0;
		ctx.shadowOffsetY = 0.4822 * this.widget.elevation + 0.101;
		ctx.beginPath();
		ctx.arc(x + width / 2, y + height / 2, width / 2, 0, 360, 0);
		ctx.stroke();
		ctx.restore();
	}
	
	//backgrounds
	
	drawRect(ctx, x, y, width, height, radius, color) {
		ctx.save();
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.moveTo(x + radius, y);
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.fill();
		ctx.restore();
	}
	
	background(ctx) {
		this.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height,
			this.getParams("backgroundRadius", 2),
			this.getParams("backgroundColor", "rgba(207, 207, 207, 1)"));
	}
	
	drawHeaderBackground(ctx) {
		ctx.save();
		ctx.fillStyle = this.getParams("headerBackground", "rgba(0, 0, 0, 0)");
		ctx.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.headerLayout.height + this.widget.headerLayout.paddingTop + this.widget.headerLayout.paddingBottom);
		ctx.restore();
	}
	
	//animations
	
	circleAnimation(ctx, ctxTemp, color) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.save();
		ctxTemp.fillStyle = color;
		ctxTemp.beginPath();
		let x = this.widget.aPosX;
		let y = this.widget.aPosY;
		let w = this.widget.width;
		let h = this.widget.height;
		if(this.widget.view.animation.getMousePos().x == 0 && this.widget.view.animation.getMousePos().y == 0) {
			this.widget.view.animation.setMousePos(x + w / 2, y + h / 2);
		}
		ctxTemp.arc(this.widget.view.animation.getMousePos().x, this.widget.view.animation.getMousePos().y, this.widget.view.animation.getRadiusAnimation(ctx, ctxTemp), 0, 2 * Math.PI, false);
		ctxTemp.fill();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(x, y, w, h);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	circleBoundAnimation(ctx, ctxTemp, boundX, boundY, x, y, color) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.save();
		ctxTemp.fillStyle = color;
		ctxTemp.beginPath();
		ctxTemp.arc(x + boundX, y + boundY, this.widget.view.animation.getRadiusAnimation(), 0, 2 * Math.PI, false);
		ctxTemp.fill();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.beginPath();
		ctxTemp.arc(x + boundX, y + boundY, boundX + boundY, 0, 2 * Math.PI, false);
		ctxTemp.fill();
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	circleCustomSizeBoundAnimation(ctx, ctxTemp, x, y, width, height, color) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.save();
		ctxTemp.fillStyle = color;
		ctxTemp.beginPath();
		ctxTemp.arc(x + width / 2, y + height / 2, this.widget.view.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, width, height), 0, 2 * Math.PI, false);
		ctxTemp.fill();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.beginPath();
		ctxTemp.arc(x + width / 2, y + height / 2, width / 2 + height / 2, 0, 2 * Math.PI, false);
		ctxTemp.fill();
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	lineAnimation(ctx, ctxTemp, lineWidth, color) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.save();
		let x = this.widget.aPosX;
		let y = this.widget.aPosY;
		let w = this.widget.width;
		let h = this.widget.height;
		ctxTemp.strokeStyle = lineWidth;
		ctxTemp.lineWidth = color;
		ctxTemp.beginPath();
		ctxTemp.lineTo(x + w / 2 + this.widget.view.animation.getRadiusAnimation(), y + h - 2);
		ctxTemp.lineTo(x + w / 2 - this.widget.view.animation.getRadiusAnimation(), y + h - 2);
		ctxTemp.stroke();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(x, y, w, h);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	inputLineAnimation(ctx, ctxTemp, x, y, w, h) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		let animationLineWidth = this.getParams("animationLineWidth", 2);
		ctxTemp.save();
		if(this.widget.valid) ctxTemp.strokeStyle = this.getParams("lineColor", "rgba(110, 110, 110, 1)");
		else ctxTemp.strokeStyle = this.getParams("lineAndTextColorInvalid", "rgba(255, 0, 0, 0.4)");
		ctxTemp.lineWidth = animationLineWidth;
		ctxTemp.beginPath();
		ctxTemp.lineTo(x + w / 2 + this.widget.view.getCustomSizeRadiusAnimation(ctx, w, animationLineWidth), y + h - animationLineWidth);
		ctxTemp.lineTo(x + w / 2 - this.widget.view.getCustomSizeRadiusAnimation(ctx, w, animationLineWidth), y + h - animationLineWidth);
		ctxTemp.stroke();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(x, y, w, h);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	tabLineAnimation(ctx, ctxTemp, oldCurrentItem, currentItem) {
		if(!this.widget.view.animation.enable) return;
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		ctxTemp.save();
		
		if(oldCurrentItem.posX < currentItem.posX) {
			let lineWidth = this.getParams("lineWidth", 3);
			ctxTemp.strokeStyle = this.getParams("underLine", "rgba(110, 110, 110, 1)");
			ctxTemp.lineWidth = lineWidth;
			let oldX = oldCurrentItem.posX;
			let newX = currentItem.posX;
			let y = currentItem.posY + currentItem.height - lineWidth / 2;
			let h = currentItem.height;
			let newW = currentItem.width;
			ctxTemp.beginPath();
			let k = this.widget.view.animation.getRadiusAnimationFixSpeed(ctx, ctxTemp, this.widget.width, h, 1.8);
			if((oldX + newW + k) > (newX + newW)) {
				this.widget.view.animation.endAnimation();
			}
			else {
				ctxTemp.moveTo(oldX + k, y);
				ctxTemp.lineTo(oldX + newW + k, y);
				ctxTemp.stroke();
				ctxTemp.globalCompositeOperation = 'destination-in';
				ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
				ctx.drawImage(ctxTemp.canvas, 0, 0);
			}
		}
		else {
			let lineWidth = this.getParams("lineWidth", 3);
			ctxTemp.strokeStyle = this.getParams("underLine", "rgba(110, 110, 110, 1)");
			ctxTemp.lineWidth = lineWidth;
			let oldX = oldCurrentItem.posX;
			let oldW = oldCurrentItem.width;
			let newX = currentItem.posX;
			let y = currentItem.posY + currentItem.height - lineWidth / 2;
			let h = currentItem.height;
			ctxTemp.beginPath();
			let k = this.widget.view.animation.getRadiusAnimationFixSpeed(ctx, ctxTemp, this.widget.width, h, 1.8);
			if((oldX - k) < newX) {
				this.widget.view.animation.endAnimation();
			}
			else {
				ctxTemp.moveTo(oldX - k + oldW, y);
				ctxTemp.lineTo(oldX - k, y);
				ctxTemp.stroke();
				ctxTemp.globalCompositeOperation = 'destination-in';
				ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
				ctx.drawImage(ctxTemp.canvas, 0, 0);
			}
		}
		ctxTemp.restore();
	}
	
	
	// line
	drawLine(ctx, startX, startY, endX, endY, lineWidth, padding, color) {
		ctx.save();
		ctx.strokeStyle = color;
		ctx.lineWidth = lineWidth;
		ctx.beginPath();
		ctx.moveTo(startX, startY - padding);
		ctx.lineTo(endX, endY - padding);
		ctx.stroke();
		ctx.restore();
	}
	
	// border
	drawStrokeRect(ctx, x, y, width, height, radius, padding, lineWidth, color) {
		ctx.save();
		ctx.beginPath();
		ctx.strokeStyle = color;
		ctx.lineWidth = lineWidth;
		ctx.moveTo(x + radius + padding, y + padding);
		ctx.lineTo(x + width - radius - padding, y + padding);
		ctx.quadraticCurveTo(x + width - padding, y + padding, x + width - padding, y + radius + padding);
		ctx.lineTo(x + width - padding, y + height - radius - padding);
		ctx.quadraticCurveTo(x + width - padding, y + height - padding, x + width - radius - padding, y + height - padding);
		ctx.lineTo(x + radius + padding, y + height - padding);
		ctx.quadraticCurveTo(x + padding, y + height - padding, x + padding, y + height - radius - padding);
		ctx.lineTo(x + padding, y + radius + padding);
		ctx.quadraticCurveTo(x + padding, y + padding, x + radius + padding, y + padding);
		ctx.stroke();
		ctx.restore();
	}
	
	//triangle
	drawFillTriangle(ctx, x, y, width, height, color) {
		//треугольник с центром в (x, y) и вершиной в (x, y - height)
		ctx.save();
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.moveTo(x, y - height);
		ctx.lineTo(x - width, y + height);
		ctx.lineTo(x + width, y + height);
		ctx.fill();
		ctx.restore();
	}
	
	drawFillTriangleLateral(ctx, x, y, width, height, color) {
		//треугольник с центром в (x, y) и вершиной в (x, y - height)
		ctx.save();
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.moveTo(x - width / 2, y - height);
		ctx.lineTo(x - width / 2, y + height);
		ctx.lineTo(x + width / 2, y);
		ctx.fill();
		ctx.restore();
	}
	
	drawStrokeTriangle(ctx, x, y, width, height, color, lineWidth) {
		//треугольник с центром в (x, y) и вершиной в (x, y - height)
		ctx.save();
		ctx.beginPath();
		ctx.strokeStyle = color;
		ctx.lineWidth = lineWidth;
		ctx.moveTo(x, y - height);
		ctx.lineTo(x - width, y + height);
		ctx.lineTo(x + width, y + height);
		ctx.stroke();
		ctx.restore();
	}
	
	strokeTriangleCustom(ctx, x, y, w, h, lineWidth, color) {
		ctx.save();
		ctx.strokeStyle = color;
		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.moveTo(x + 4, y + h / 2);
		ctx.lineTo(x + w / 5 * 2, y + h - 4);
		ctx.lineTo(x + w - 4, y + h / 4);
		ctx.stroke();
		ctx.restore();
	}
	
	circle(ctx, x, y, radius, lineWidth, strokeColor, fillColor) {
		ctx.save();
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
		ctx.fillStyle = fillColor;
		ctx.fill();
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = strokeColor;
		ctx.stroke();
		ctx.restore();
	}
	
	// Метод для анимации нажатий кнопок Stick`a
	arc(ctx, centerX, centerY, radius, startAng, endAng, lineWidth, strokeColor, fillColor) {
		ctx.save();
		ctx.beginPath();
		ctx.moveTo(centerX, centerY);
		ctx.lineTo(centerX, centerY);
		ctx.arc(centerX, centerY, radius, startAng, endAng, false);
		ctx.lineTo(centerX, centerY);
		ctx.moveTo(centerX, centerY);
		ctx.closePath();
		ctx.fillStyle = fillColor;
		ctx.lineWidth = lineWidth;
		ctx.strokeStyle = strokeColor;
		ctx.stroke();
		ctx.fill();
		ctx.restore();
	}
	
	//custom
	
	header(ctx, x, y, header) {
		ctx.save();
		ctx.fillStyle = this.getParams("fillStyle", "rgb(158, 158, 158)");
		ctx.font = this.getParams("font", "Arial");
		ctx.fillText(header, x, y);
		ctx.restore();
	}
	
	drawTextLeft(ctx, x, y, text, fontSize, font, color, fontStyle) {
		ctx.save();
		ctx.imageSmoothingEnabled = true;
		ctx.font = (fontStyle ? fontStyle : "") + fontSize + "px " + font;
		ctx.textBaseline = "top";
		if(color !== undefined) ctx.fillStyle = color;
		ctx.fillText(text, x, y);
		ctx.restore();
	}
	
	drawTextCenter(ctx, x, y, text, fontSize, font, color, fontStyle) {
		ctx.save();
		ctx.imageSmoothingEnabled = true;
		ctx.font = (fontStyle ? fontStyle : "") + fontSize + "px " + font;
		ctx.textBaseline = "top";
		if(color !== undefined) ctx.fillStyle = color;
		let w = ctx.measureText(text).width;
		ctx.fillText(text, x - w / 2, y);
		ctx.restore();
	}
	
	drawTextRight(ctx, x, y, text, fontSize, font, color, fontStyle) {
		ctx.save();
		ctx.imageSmoothingEnabled = true;
		ctx.font = (fontStyle ? fontStyle : "") + fontSize + "px " + font;
		ctx.textBaseline = "top";
		if(color !== undefined) ctx.fillStyle = color;
		let w = ctx.measureText(text).width;
		ctx.fillText(text, x - w, y);
		ctx.restore();
	}
	
};

class WidgetAnimation {
	
	constructor(widget) {
		this.time = 0;
		this.enable = false;
		this.widget = widget;
		this.mousePos = new Rex.Vector2();
	}
	
	startAnimation() {
		Rex.gui.redraw();
		this.time = Rex.render.time;
		this.enable = true;
	}
	
	endAnimation() {
		if(this.enable) Rex.gui.redraw();
		this.time = 0;
		this.enable = false;
	}
	
	setMousePos(x, y) {
		let pos = this.widget.view.drawer.transformMousePos(x, y);
		this.mousePos.x = pos.x;
		this.mousePos.y = pos.y;
	}
	
	getMousePos() {
		if(this.enable) Rex.gui.redraw();
		return this.mousePos;
	}
	
	getRadiusAnimation(ctx, ctxTemp) {
		if(this.widget === undefined) {
			console.error("this.widget === undefined");
			return 1000;
		}
		
		if(this.enable) Rex.gui.redraw();
		let w = this.widget.width / Rex.render.width;
		let h = this.widget.height / Rex.render.height;
		
		let maxRadius = this.widget.width + this.widget.height;			// Радиус анимации (как далеко отрисовывается)
		let speed = (2.0 * Math.max(w, h));								// Скорость анимации
		let animation = (ctx !== undefined && !this.widget.pressed);	// Тип анимации(зависит от удерживания кнопки)
		let time = (Rex.render.time - this.time);						// Текущее время анимации
		
		// Прозрачность анимации
		if(animation) ctx.globalAlpha = (1 - ((time * speed) / maxRadius));
		
		if((time * speed) > maxRadius) {
			
			if(animation) {
				this.endAnimation();
				ctx.globalAlpha = 0;
			}
			return maxRadius;
		} 
		return (Rex.render.time - this.time) * speed;
	}

	getCustomSizeRadiusAnimation(ctx, ctxTemp, width, height) {
		if(this.widget === undefined) {
			console.error("this.widget === undefined");
			return 1000;
		}

		if(this.enable) Rex.gui.redraw();
		let w = width / Rex.render.width;
		let h = height / Rex.render.height;

		let maxRadius = width + height;			// Радиус анимации (как далеко отрисовывается)

		let speed = (2.0 * Math.max(w, h));								// Скорость анимации
		let animation = (ctx !== undefined && !this.widget.pressed);	// Тип анимации(зависит от удерживания кнопки)
		let time = (Rex.render.time - this.time);						// Текущее время анимации

		// Прозрачность анимации
		if(animation) ctx.globalAlpha = (1 - ((time * speed) / maxRadius));

		if((time * speed) > maxRadius) {

			if(animation) {
				this.endAnimation();
				ctx.globalAlpha = 0;
			}
			return maxRadius;
		}
		return (Rex.render.time - this.time) * speed;
	}

	getRadiusAnimationFixSpeed(ctx, ctxTemp, width, height, speed) {
		if(this.widget === undefined) {
			console.error("this.widget === undefined");
			return 1000;
		}

		if(this.enable) Rex.gui.redraw();

		let maxRadius = width + height;			// Радиус анимации (как далеко отрисовывается)

		let animation = (ctx !== undefined && !this.widget.pressed);	// Тип анимации(зависит от удерживания кнопки)
		let time = (Rex.render.time - this.time);						// Текущее время анимации

		if((time * speed) > maxRadius) {

			if(animation) {
				this.endAnimation();
			}
			return maxRadius;
		}
		return (Rex.render.time - this.time) * speed;
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml BaseObject Rex*/
class WidgetView extends BaseObject {
	
	constructor(widget) {
		super();
		this.widget = widget;
		this._needRefresh = true;
	}
	
	setState(state) {}
	init() {}
	onInit() {}
	
	update() {
		if(Rex.widgets === undefined) {
			this._needRefresh = true;
			return;
		}
		let parent = Rex.widgets[this.widget.parentId];
		if(parent !== undefined) {
			parent.view.update();
		}
		this._needRefresh = true;
		Rex.gui.redraw();
	}
	
	updatePosition() {}
	
	inside(x, y) {
		console.error("она не будет вызываться (с) рут");
		return false;
	}
	
	checkSelect(x, y, e) {
		return undefined;
	}
	
	onCheckSelect(x, y) {
		return undefined;
	}
	
	
	reDraw() {
		this.onRedraw();
	}
	
	
	draw() {
		this.onDraw();
	}
	
	onDrag(dragAndDrop) {
		return true;
	}
	
	positioning() {}
	onPositioning() {}
	onDraw() {}
	onRedraw() {}
	onFocused() {}
	onDestroy() {}
	updateStyle() {}
	
	keyDown(event) {}
	keyUp(event) {}
	keyPress(event) {}
	mouseDown(x, y, event) {}
	mouseUp(x, y, event) {}
	mouseMove(x, y, event) {}
	mouseWheel(value) {}
	onMouseDown(x, y, event) {}
	onMouseUp(x, y, event) {}
	onMouseDoubleClick(event) {}
	onMouseMove(x, y, event) {}
	onMouseWheel(value) {}
	
}


/**
 * WidgetButton
 */
class WidgetButton extends Widget {
	
	constructor(state) {
		super(state);
		this.pressed = false;
		this.mousePos = new Rex.Vector2();
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetButtonCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetButtonHtml(this);
		}
	}
	
	onInit() {
		
	}

	onGenerateContent(content) {
		const htmlButton = this.view.htmlElement;
		const htmlText = this.view.htmlText;

		//get last content, that was added to the content array
		let widgetTable = content.table;

		let bWidth = parseInt(getStyle(htmlButton, 'borderWidth'))
		bWidth = isNaN(bWidth) ? 0 : bWidth;

		const buttonSize = htmlButton.getBoundingClientRect();
		widgetTable.widths.push(buttonSize.width - (bWidth * 2));
		widgetTable.heights.push(buttonSize.height - (bWidth * 2));

		widgetTable.body.push([{margin:[0, 0, 0, 0]}]);

		//body of this widget
		let body = widgetTable.body[0][0];

		generateText(htmlText, body);
		
		//set background-color
		body.fillColor = getColorHEX(getStyle(htmlButton, 'background-color'));
	}

	onMouseDown(x, y, event) {
		let button = Rex.engine.translateMouseButton(event.which);
		if(button != Rex.MouseButtonLeft) return;
		this.view.onMouseDown(x, y, event);
		if(!this.pressed) {
			Rex.callRpcMethod('Widgets', this.id, this.type, 'press', []);
			this.press = true;
		}
	}
	
	onMouseUp(x, y, event) {
		let button = Rex.engine.translateMouseButton(event.which);
		if(button != Rex.MouseButtonLeft) return;
		if(this.pressed) {
			Rex.callRpcMethod('Widgets', this.id, this.type, 'unpress', []);
			this.press = false;
		}
	}
	
	set lineHeight(value) {
		if (value == null) return;
		this.view.htmlElement.style.lineHeight = value + "%";
	}
	
}


/**
 * WidgetCheckBox
 */

class WidgetCheckBox extends Widget {
	
	constructor(state) {
		super(state);
		this.checked = false;
		this.iconAlign = 0;
		this.icon = undefined;
		this.label = undefined;
		this.setState(state);
		this.widthCheck = 17;
		this.heightCheck = 17;
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetCheckBoxCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetCheckBoxHtml(this);
		}
	}

    setChecked(value) {
        this.checked = value;
        Rex.callRpcMethod('Widgets', this.id, this.type, 'setChecked', [value]);
        this.view.update();
        if(value) {
            //this.animation.startAnimation();
            if(this.parentId != -1) {
                let p = Rex.widgets[this.parentId];
                if(p) {
                    let children = p.children;
                    for(let key in children) {
                        let w = Rex.widgets[children[key]];
                        if(!w) continue;
                        if(w === this) continue;
                        if((w.type === this.type) && (w.checked) && (w._isRadioButton)) {
                            w.setChecked(false);
                        }
                    }
                }
            } else {
                for(let key in Rex.widgets) {
                    let w = Rex.widgets[key];
                    if(!w) continue;
                    if(w === this) continue;
                    if((w.type === this.type) && (w.checked) && (w._isRadioButton) && w.parentId == -1) {
                        w.setChecked(false);
                    }
                }
            }

        }
    }
	
	onHovered(hovered) {
		document.body.style.cursor = hovered ? 'pointer' : 'default';
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		this.checked = !this.checked;
		//this.view.startAnimation();

		if (this._isRadioButton)
			this.setChecked(true);
		else Rex.callRpcMethod('Widgets', this.id, this.type, 'setChecked', [this.checked]);
	}
	
	set lineHeight(value) {
		if (value == null) return;
		this.view.htmlElement.style.lineHeight = value + "%";
	}
	
};


class WidgetTree extends Widget {
	
	constructor(state) {
		super(state);
		this.items = new Map();
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetTreeCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetTreeHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		// console.log("PRESS IN REXTREE SIMPLE");
		this.view.mouseDown(x, y, event);
	}
	
	onMouseUp(x, y, event) {
		this.view.mouseUp(x, y, event);
	}
	
	onMouseDoubleClick(x, y, event) {
		this.view.mouseDoubleClick(x, y, event);
	}
	
	keyUp(event) {
		if(event.which != 0x2E && event.which != 0x08) return;
		if(this.selectItem !== undefined) {
			Rex.callRpcMethod("Widgets", this.id, this.type, "removeItem", [this.selectedItemId]);
		}
	}
	
	callExpand(id,expand) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setExpandedItem', [numbId,expand]);
	}
	
	callExpandAll(param) {
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setExpandedAll', [param]);
	}
	
	callSetHover (id) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setHoveredItem', [numbId]);
	}
	
	setSelected(id) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setSelectedItem', [numbId]);
	}
	
	callMousePress(buttonId, id) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		let numBut = parseInt(buttonId);
		if (isNaN(numBut)) {console.error("Error but: "+buttonId); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseDownItem', [numBut,numbId]);
	}
	
	callMouseUp(buttonId, id) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		let numBut = parseInt(buttonId);
		if (isNaN(numBut)) {console.error("Error but: "+buttonId); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpItem', [numBut,numbId]);
	}
	
	callMouseDouble(buttonId, id) {
		let numbId = parseInt(id);
		if (isNaN(numbId)) {console.error("Error id: "+id); return;}
		let numBut = parseInt(buttonId);
		if (isNaN(numBut)) {console.error("Error but: "+buttonId); return;}
		Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseDoubleClickItem', [numbId]);
	}
	
	onDrop(event,pos){
		return this.view.onDrop(event,pos);
	}
}


/**
 * WidgetGantt
 */
class GanttTask {
 
	constructor() {
		this._$vVisible = true;
	}
	
	set visible (visible) {
		if (this._$vVisible == visible) return 0;
		
		this._$vVisible = visible;
		if(visible) this.view.htmlElement.style.setProperty("display", "block");
		else this.view.htmlElement.style.setProperty("display", "none");
		for(let child of this.children){
			let taskChild = this.gantt.tasks.get(child);
			if(!this.visible) taskChild.visible = false;
			else if(this.expanded) taskChild.visible = true;
		}
		
	}
	
	setExpanded(exp) {
		if(this.expanded == exp) return;
		if(this.children.length == 0) return;
		Rex.callRpcMethod('Widgets', this.gantt.id, 'WidgetGantt', 'setExpandedTask', [this.id, exp]);
	}
	
	
	setHovered(h) { Rex.callRpcMethod('Widgets', this.gantt.id, 'WidgetGantt', 'setHoveredTask', [h ? this.id : -1]); }
	
	/**
	 * @method getID
	 * @return {Number}
	 */
	get id() { return this._$vID; }
	
	/**
	 * @method setID
	 */
	set id(_id) { this._$vID = _id; }
	
	
	/**
	 * @method getGantt
	 * @return {WidgetGantt}
	 */
	get gantt() { return this._$vBaseGantt; }
	
	/**
	 * @method setGantt
	 */
	set gantt(_gantt) { this._$vBaseGantt = _gantt; }
	
	/**
	 * @method getName
	 * @return {String}
	 */
	get name() { return this._$vName; }
	
	set name(value) { this._$vName = value; }
	
	/**
	 * @method getStart
	 * @return {Datetime}
	 */
	get start() { return this._$vStart; }
	
	set start(value) { this._$vStart = value; }
	
	/**
	 * @method getEnd
	 * @return {Datetime}
	 */
	get end() { return this._$vEnd; }
	
	set end(value) { this._$vEnd= value; }
	
	/**
	 * @method getColor
	 * @return {String}
	 */
	get color() { return this._$vColor; }
	
	set color(value) { this._$vColor= value; }
	
	/**
	 * @method getDepend
	 * @return {String}
	 */
	get depend() { return this._$vDepend; }
	
	set depend(value) {
		this._$vDepend = value;
	}
	
	/**
	 * @method getResource
	 * @return {String}
	 */
	get res() {
		if (this._$vRes) return this._$vRes;
		else return '&nbsp';
	}

	set res(value) { this._$vRes = value; }
	/**
	 * @method getCompVal
	 * @return {Boolean}
	 */
	get compVal() {
		if (this._$vComp) return this._$vComp;
		else return false;
	};
	
	set comp(value) { this._$vComp = value; }
	
	/**
	 * @method getCompStr
	 * @return {String}
	 */
	get compStr() {
		if (this._$vComp) return this._$vComp + '%';
		else return '';
	};

	/**
	 * Returns task duration as a fortmatted string based on the current selected format
	 * @method getDuration
	 * @param vFormat {String} selected format (minute,hour,day,week,month)
	 * @return {String}
	 */
	duration(vFormat) {
		if (vFormat == null) {
			console.log('duration(vFormat) is bed!');
			return undefined
		}
		if (vFormat == FormatDateProcess.Hour) {
			let tmpPer = Math.ceil((this.end - this.start) / (60 * 60 * 1000));
			if (tmpPer == 1) this._$vDuration = '1 Hour';
			else this._$vDuration = tmpPer + ' Hours';
		} else if (vFormat == FormatDateProcess.Minute) {
			let tmpPer = Math.ceil((this.end - this.start) / (60 * 1000));
			if (tmpPer == 1) this._$vDuration = '1 Minute';
			else this._$vDuration = tmpPer + ' Minutes';
		} else { //if(vFormat == FormatDateProcess.Day) {
			let tmpPer = Math.ceil((this.end - this.start) / (24 * 60 * 60 * 1000) - 1);
			if (tmpPer == 1) this._$vDuration = '1 Day';
			else this._$vDuration = tmpPer + ' Days';
		}
		return this._$vDuration;
	}

	/**
	 * Returns task parent ID
	 * @method getParent
	 * @return {Number}
	 */
	get parent() { return this._$vParent;}
	
	set parent(value) { this._$vParent = value; }
	
	/**
	 * @method getLevel
	 * @return {Number}
	 */
	get level() { return this._$vLevel; }

	/**
	 * Returns the X position of the left side of the task bar on the graph (right side)
	 * @method getStartX
	 * @return {Number}
	 */
	get startX() { return this._$x1; }

	/**
	 * Returns the Y position of the top of the task bar on the graph (right side)
	 * @method getStartY
	 * @return {Number}
	 */
	get startY() { return this._$y1; }

	/**
	 * Returns the X position of the right of the task bar on the graph (right side)
	 * @method getEndX
	 * @return {Int}
	 */
	get endX() { return this._$x2; }

	/**
	 * Returns the Y position of the bottom of the task bar on the graph (right side)
	 * @method getEndY
	 * @return {Number}
	 */
	get endY() { return this._$y2; }

	/**
	 * @method getVisible
	 * @return {Boolean}
	 */
	get visible() { return this._$vVisible; }
	
	/**
	 * Set task dependencies
	 * @method setDepend
	 * @param pDepend {String} A comma delimited list of task IDs the current task depends on.
	 */
	set depend(pDepend) { this._$vDepend = pDepend; }

	/**
	 * Set task start date/time
	 * @method setStart
	 * @param pStart {Datetime} 
	 */
	set start(pStart) { this._$vStart = pStart; }

	/**
	 * Set task end date/time
	 * @method setEnd
	 * @param pEnd {Datetime}
	 */
	set end(pEnd) { this._$vEnd = pEnd; }

	/**
	 * Set task tree level
	 * @method setLevel
	 * @param pLevel {Number} 
	 */
	set level(pLevel) { this._$vLevel = pLevel; }

	/**
	 * Set task completion percentage
	 * @method setCompVal
	 * @param pCompVal {Number} 
	 */
	set compVal(pCompVal) { this._$vComp = pCompVal; }

	/**
	 * Set a task bar starting position (left)
	 * @method setStartX
	 * @param pX {Number} 
	 */
	set startX(pX) { this._$x1 = pX; }

	/**
	 * Set a task bar starting position (top)
	 * @method setStartY
	 * @param pY {Number} 
	 */
	set startY(pY) { this._$y1 = pY; }

	/**
	 * Set a task bar starting position (right)
	 * @method setEndX
	 * @param pX {Number} 
	 */
	set endX(pX) { this._$x2 = pX; }

	/**
	 * Set a task bar starting position (bottom)
	 * @method setEndY
	 * @param pY {Number} 
	 */
	set endY(pY) { this._$y2 = pY; }
}

class WidgetGantt extends Widget {

	constructor(state) {

		super(state);
		this._$vShowDur = true;
		this._$vShowRes = true;
		this._$vShowComp = true;
		this._$vShowStartDate = true;
		this._$vShowEndDate = true;
		this._$vDateDisplayFormat = GanttDateFormat.ddmmyy;
		this._$vFormat = FormatDateProcess.Day;
		this._$vTaskList = new Map();
		this._$vDepId = 1;
		this.setState(state);
	}

	createView() {
		if (this.typeView === "canvas") this.view = new WidgetGanttCanvas(this);
		else if (this.typeView === "html") this.view = new WidgetGanttHtml(this);
	}

	onFocused(f) { return true; }

	onMouseDown(x, y, event) { this.view.mouseDown(x, y, event); }

	onMouseUp(x, y, event) { this.view.mouseUp(x, y, event); }

	onMouseDoubleClick(event) { this.view.mouseDoubleClick(event); }
	
	keyUp(event) {
		if(event.which != 0x2E && event.which != 0x08) return;
		if(this.selectTask !== undefined) Rex.callRpcMethod("Widgets", this.id, this.type, "removeTask", [this.selectedTaskId]);
	}
	
	onMouseMove(x, y, event) {}

	/**
	 * Calculates X/Y coordinates of a task and sets the Start and End properties of the TaskItem
	 * @method calcTaskXY
	 */
	calcTaskXY() {
		let vList = this._$vTaskList;
		for (let task of vList.values()) {
			let vID = task.id;
			let vTaskDiv = document.getElementById("taskbar_" + vID);
			let vBarDiv = document.getElementById("bardiv_" + vID);
			let vParDiv = document.getElementById("childgrid_" + vID);
			if (vBarDiv) {
				task.startX = vBarDiv.offsetLeft;
				task.startY = vParDiv.offsetTop + vBarDiv.offsetTop + 6;
				task.endX = vBarDiv.offsetLeft + vBarDiv.offsetWidth;
				task.endY = vParDiv.offsetTop + vBarDiv.offsetTop + 6;
			}
		}
	};
	
	/**
	 * @method clearDependencies
	 */
	clearDependencies() {
		let parent = document.getElementById('rightSide');
		let depLine;
		let vMaxId = this._$vDepId;
		for (let i = 1; i < vMaxId; i++) {
			depLine = document.getElementById("line" + i);
			if (depLine) parent.removeChild(depLine);
		};
		this._$vDepId = 1;
	};

	/**
	 * Draw a straight line (colored one-pixel wide DIV), need to parameterize doc item
	 * @method sLine
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * 
	 */
	sLine(x1, y1, x2, y2) {
		let vLeft = Math.min(x1, x2);
		let vTop = Math.min(y1, y2);
		let vWid = Math.abs(x2 - x1) + 1;
		let vHgt = Math.abs(y2 - y1) + 1;

		let vDoc = document.getElementById('rightSide');
		if(!vDoc) return;

		// retrieve DIV
		let oDiv = document.createElement('div');

		oDiv.id = "line" + this._$vDepId++;
		oDiv.style.position = "absolute";
		oDiv.style.margin = "0px";
		oDiv.style.padding = "0px";
		oDiv.style.overflow = "hidden";
		oDiv.style.border = "0px";

		// set attributes
		oDiv.style.zIndex = 0;
		oDiv.style.backgroundColor = "red";

		oDiv.style.left = vLeft + "px";
		oDiv.style.top = vTop + "px";
		oDiv.style.width = vWid + "px";
		oDiv.style.height = vHgt + "px";

		oDiv.style.visibility = "visible";

		vDoc.appendChild(oDiv);
	};

	/**
	 * Draw a diaganol line (calc line x,y pairs and draw multiple one-by-one sLines)
	 * @method dLine
	 * @param {Number} x1 
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 */
	dLine(x1, y1, x2, y2) {
		let dx = x2 - x1;
		let dy = y2 - y1;
		let x = x1;
		let y = y1;

		let n = Math.max(Math.abs(dx), Math.abs(dy));
		dx = dx / n;
		dy = dy / n;
		for (let i = 0; i <= n; i++) {
			let vx = Math.round(x);
			let vy = Math.round(y);
			this.sLine(vx, vy, vx, vy);
			x += dx;
			y += dy;
		};
	};

	/**
	 * Draw dependency line between two points (task 1 end -> task 2 start)
	 * @method drawDependency
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 */
	drawDependency(x1, y1, x2, y2) {
		if (x1 + 10 < x2) {
			this.sLine(x1, y1, x1 + 4, y1);
			this.sLine(x1 + 4, y1, x1 + 4, y2);
			this.sLine(x1 + 4, y2, x2, y2);
			this.dLine(x2, y2, x2 - 3, y2 - 3);
			this.dLine(x2, y2, x2 - 3, y2 + 3);
			this.dLine(x2 - 1, y2, x2 - 3, y2 - 2);
			this.dLine(x2 - 1, y2, x2 - 3, y2 + 2);
		} else {
			this.sLine(x1, y1, x1 + 4, y1);
			this.sLine(x1 + 4, y1, x1 + 4, y2 - 10);
			this.sLine(x1 + 4, y2 - 10, x2 - 8, y2 - 10);
			this.sLine(x2 - 8, y2 - 10, x2 - 8, y2);
			this.sLine(x2 - 8, y2, x2, y2);
			this.dLine(x2, y2, x2 - 3, y2 - 3);
			this.dLine(x2, y2, x2 - 3, y2 + 3);
			this.dLine(x2 - 1, y2, x2 - 3, y2 - 2);
			this.dLine(x2 - 1, y2, x2 - 3, y2 + 2);
		}
	};

	/**
	 * Draw all task dependencies 
	 * @method DrawDependencies
	 */
	drawDependencies() {
		//First recalculate the x,y
		this.calcTaskXY();
		this.clearDependencies();

		let vList = this._$vTaskList;
		for (let task of vList.values()) {
			if(task.depend){
				let dep = vList.get(task.depend);
				if(dep == null) {
					task.depend = undefined;
					continue
				} else if(dep.visible && task.visible && dep.end < task.start) this.drawDependency(dep.endX, dep.endY, task.startX - 1, task.startY)
			}
		}
	};
	
	/**
	 * @method parseDateStr
	 * @param pDateStr {String} - A string that contains the date (i.e. "01/01/09")
	 * @param pFormatStr {String} - The date format (mm/dd/yyyy,dd/mm/yyyy,yyyy-mm-dd)
	 * @return {Datetime}
	 */
	parseDateStr(pDateStr, pFormatStr) {
		let vDate = new Date();
		vDate.setTime(Date.parse(pDateStr));
		let vDateParts = pDateStr.split('/');
		switch (pFormatStr) {
			case GanttDateFormat.ddmmyyyy: //0
				vDate.setFullYear(parseInt(vDateParts[2], 10), parseInt(vDateParts[1], 10) - 1, parseInt(vDateParts[0], 10));
				break;
			case GanttDateFormat.mmddyyyy : //1
				vDate.setFullYear(parseInt(vDateParts[2]), parseInt(vDateParts[0]) - 1, parseInt(vDateParts[1]));
				break;
			case GanttDateFormat.yyyymmdd: //2
				vDate.setFullYear(parseInt(vDateParts[0], 10), parseInt(vDateParts[1], 10) - 1, parseInt(vDateParts[2], 10));
				break;
			case GanttDateFormat.yyyyddmm: //3
				vDate.setFullYear(parseInt(vDateParts[0], 10), parseInt(vDateParts[2], 10) - 1, parseInt(vDateParts[1], 10));
				break;
			case GanttDateFormat.ddmmyy: //4
				vDate.setFullYear(parseInt(vDateParts[2], 10), parseInt(vDateParts[1], 10) - 1, parseInt(vDateParts[0], 10));
				break;
			case GanttDateFormat.mmddyy : //5
				vDate.setFullYear(parseInt(vDateParts[2], 10), parseInt(vDateParts[0], 10) - 1, parseInt(vDateParts[1], 10));
				break;
			case GanttDateFormat.yymmdd: //6
				vDate.setFullYear(parseInt(vDateParts[0], 10), parseInt(vDateParts[1], 10) - 1, parseInt(vDateParts[2], 10));
				break;
			case GanttDateFormat.yyddmm: //3
				vDate.setFullYear(parseInt(vDateParts[0], 10), parseInt(vDateParts[2], 10) - 1, parseInt(vDateParts[1], 10));
				break;
		}
		return (vDate);
	}
	
	get tasks() { return this._$vTaskList; }
}



class WidgetScroll extends Widget {
	
	constructor(state) {
		super(state);
		
		this.arrowsVisible0or1 = 1;
		this.value = 0;
		this.contentSize = 500;
		this.scrollType = 1;
		this.pressed = false;
		this.pressedSlider = false;
		this.start = 0.0;
		this.length = 0.0;
		this.mouseScrollingStep = 36;
		this.arrowsScrollingStep = 36;
		
		this.sizeSlider = 0;
		
		this.setState(state);
	}
	
	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetScrollCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetScrollHtml(this);
		}
	}
	
	////      пересылка по вьюшку.
	
	setValue(v) { this.view.setValue(v); }
	mouseDown(x, y) { this.view.onMouseDown(x,y); }
	mouseUp(x, y) { this.view.onMouseUp(x,y) }
	mouseMove(x, y) { this.view.onMouseMove(x,y); }
	mouseWheel(event) { this.view.onMouseWheel(event); }
	//FIXME возможно надо ON.... и вообще в базовой вьюшке обработать

}

/**
 * WidgetLayout
 */

class WidgetLayout extends Widget {
	
	constructor(state) {
		super(state);
		this.minContentWidth = 0;
		this.minContentHeight = 0;
		this.baseLayoutOrientation = 0;
		this.setState(state);
		this._widgetOrder = [];
		this._direction = 0;
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetLayoutCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetLayoutHtml(this);
		}
	}

	onGenerateContent(content) {
		//set color for outer lines and make inner lines invisible
		const width = parseInt(getStyle(this.view.htmlElement, 'borderWidth'));
		content.layout.hLineWidth = function(i, node) {
			if (i != 0 && i != node.table.body.length)
				return 0;
			return width;
		 };

		 content.layout.vLineWidth = function(i, node) {
			if (i != 0 && i != node.table.body[0].length)
				return 0;
			return width;
		 }

		 const size = this.view.htmlElement.getBoundingClientRect();
		 if (this.children.length === 0) {
			 content.table.body.push([{}]);
			 if (this.type == 'WidgetLayoutVertical') {
				content.table.heights.push(size.height);
			 } else if (this.type == 'WidgetLayoutHorizontal') {
				content.table.widths.push(size.width);
			 }
		 }
	}

	set direction(value) {
		this._direction = value
	}

	get direction() {
		return this._direction;
	}

	set scrollable(value) {
		if (value == null) return;
		this._scrollable = value;
		this.view.setScrollable();
	}

	get scrollable() {
		return this._scrollable;
	}
	
	onMouseDown(x, y, event) {
		if (this.editMode) {
			if (this._swapWidgetA != null) return;
			if (this._hoveredWidget !== this && this._hoveredWidget != null) {
				this._swapWidgetA = this._hoveredWidget;
			}
		}
	}
	
	onMouseUp(x, y, event) {
		if (this.editMode) {
			if (this._swapWidgetA == null) return;
			
			if (event.shiftKey === true) {
				if ((this._swapWidgetA !== this._hoveredWidget)
					&& (this._hoveredWidget !== this) && (this._hoveredWidget != null)) {
					this._swapWidgetB = this._hoveredWidget;
					this.swapWidgets(this._swapWidgetA.id, this._swapWidgetB.id);
				}
			}
			
			this._swapWidgetA = null;
			this._swapWidgetB = null;
		}
	}
	
	onMouseMove(x, y, event) {
		if (this.editMode) {
			if (this._swapWidgetA == null) return;
			if (event.shiftKey === true) return;
			
			if ((this._swapWidgetA !== this._hoveredWidget)
				&& (this._hoveredWidget !== this) && (this._hoveredWidget != null)) {
				this._swapWidgetB = this._hoveredWidget;
				this.swapWidgets(this._swapWidgetA.id, this._swapWidgetB.id);
			}
		}
	}
	
	swapWidgets(widgetID_A, widgetID_B) {
		if (widgetID_A == widgetID_B) return;
		if (!widgetID_A || !widgetID_B) return;
		
		const widgetA = Rex.widgets[widgetID_A].view.htmlElement;
		const widgetB = Rex.widgets[widgetID_B].view.htmlElement;
		if (!widgetA || !widgetB) return;
		
		const widgetA_index = this.view.htmlElement.children.indexOf(widgetA);
		const widgetB_index = this.view.htmlElement.children.indexOf(widgetB);
		
		if (widgetA_index === widgetB_index) return;
		
		widgetA.remove();
		if (widgetA_index < widgetB_index) {
			this.view.htmlElement.insertBefore(widgetA, widgetB.nextElementSibling);
		} else if (widgetA_index > widgetB_index) {
			this.view.htmlElement.insertBefore(widgetA, widgetB);
		}
		
		Rex.callRpcMethod("Widgets", this.id, this.type, "swapWidgetsById", [parseInt(widgetID_A), parseInt(widgetID_B)]);
		this.view.spacing = this._spacing;
	}
	
}

/*
 * Created by Andrey Nikulin on 10.12.2018
 */

class WidgetLayoutFlex extends WidgetLayout {

    constructor(state) {
        super(state);
        this.setState(state);
    }

    createView() {
        if(this.typeView === "html") {
            this.view = new WidgetLayoutFlexHtml(this);
        }
    }

}

/**
 * Created by prg-40 on 18.09.2017.
 */

class WidgetLayoutGrid extends WidgetLayout {

	constructor(state) {
		super(state);
		this.hovered_widget = null;
		this.hovered_widget_cell = null;
		this.resizeCell = null;
		this.lastResizer = null;
	}

	createView() {
		if (this.typeView === "canvas") {
			this.view = new WidgetLayoutGridCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetLayoutGridHtml(this);
		}
	}

	expand() {
		//нужно именно два равно когда мы проверяем айдишники. Так как теперь айдишник может быть строкой.
		if (this.view.htmlElement.parentElement === undefined) {
			this.posX = 0;
			this.posY = 0;
			this.width = window.innerWidth;
			this.height = window.innerHeight;
		}

		if (this.children.length >= 0) {
			this.onExpand();
		} else {
			this.minContentHeight = 0;
			this.minContentWidth = 0;
		}
	}

	onExpand() {
		this.view.redrawGrid(this.countRow, this.countCol);
	}

	onMouseDown(x, y, event) {
		if (this.editMode === true) {
			const epath = event.path || (event.composedPath && event.composedPath());
			if (this.hovered_widget !== this &&
				this.hovered_widget != null) {
				for (let i = 0; i < epath.length; i++) {
					let path = epath[i];
					if (path.classList.contains("LayoutGridCell")) {
						this.hovered_widget_cell = path;
						break;
					}
				}
			}

			if (this.lastResizer != null)
				this.resizeCell = this.lastResizer.parentElement;
		}
	}

	onMouseUp(x, y, event) {
		if (this.editMode === true) {
			this.hovered_widget = null;
			this.hovered_widget_cell = null;

			if (this.resizeCell != null) {

				for (let i = 0; i < this.countRow; i++) {
					const value = this._templateRow[i] * this.height;
					Rex.callRpcMethod("Widgets", this.id, this.type, "setRowHeight", [i, value]);
				}

				for (let i = 0; i < this.countCol; i++) {
					const value = this._templateCol[i] * this.width;
					Rex.callRpcMethod("Widgets", this.id, this.type, "setColumnWidth", [i, value]);
				}

				this.resizeCell = null;
			}

		}
	}

	onMouseMove(x, y, event) {
		if (this.editMode === true) {
			if (this.hovered_widget_cell != null) {
				const epath = event.path || (event.composedPath && event.composedPath());
				for (let i = 0; i < epath.length; i++) {
					let path = epath[i];
					if (path.classList == null) continue;
					if (path.classList.contains("LayoutGridCell")) {
						this.replaceWidgetCell(this.hovered_widget_cell, path);
						break;
					}
				}
			}

			let targetElement = event.target;

			if (targetElement !== undefined) {
				if (targetElement.classList.contains("cell-resizer")) {
					if (targetElement.parentCell.parentId !== this.id) return;
					if (this.lastResizer == null) {
						targetElement.style.background = "gray";
						this.lastResizer = targetElement;
					}
				} else {
					if (this.lastResizer != null && this.resizeCell == null) {
						this.lastResizer.style.background = "none";
						this.lastResizer = null;
					}
				}
			}

			if (this.resizeCell != null) {
				if (this.lastResizer.classList.contains("cell-resizer-left")) {
					// Вычисляем относительную позицию клика по X
					let relX = this.clickPosX(x);
					this.resizeLeft(relX);
				}
				if (this.lastResizer.classList.contains("cell-resizer-right")) {
					//Вычисляем относительную позицию клика по X
					let relX = this.clickPosX(x);
					this.resizeRight(relX);
				}
				else if (this.lastResizer.classList.contains("cell-resizer-top")) {
					//Вычисляем относительную позицию клика по Y
					let relY = this.clickPosY(y);
					this.resizeTop(relY);
				}
				else if (this.lastResizer.classList.contains("cell-resizer-bottom")) {
					//Вычисляем относительную позицию клика по Y
					let relY = this.clickPosY(y);
					this.resizeBottom(relY);
				}
			}
		}
	}

	resizeLeft(relX) {
		let currentMaxWidth = this.getWidgetMaxWidthInCol(this.resizeCell.col);
		let prevMaxWidth = this.getWidgetMaxWidthInCol(this.resizeCell.col - 1);

		let sum = 0;
		for (let i = 0; i < this.resizeCell.col; ++i) {
			sum += this._templateCol[i];
		}

		const leftPos = sum * this.view.styleWidth;
		const dWidth = (leftPos - relX);

		const prevCellIndex = this.resizeCell.row * this.countCol + (this.resizeCell.col - 1);
		const prevCell = this.view.htmlElement.children[prevCellIndex];

		if (this.getCellStyleData(this.resizeCell, "width") + dWidth <= currentMaxWidth) return;
		if (this.getCellStyleData(prevCell, "width") - dWidth <= prevMaxWidth) return;

		this._templateCol[this.resizeCell.col] += dWidth / this.view.styleWidth;
		this._templateCol[this.resizeCell.col - 1] -= dWidth / this.view.styleWidth;

		this.view.generateGridTemplateColumns();
	}

	resizeRight(relX) {
		let currentMaxWidth = this.getWidgetMaxWidthInCol(this.resizeCell.col);
		let nextMaxWidth = this.getWidgetMaxWidthInCol(this.resizeCell.col + 1);

		let sum = 0;
		for (let i = 0; i < this.resizeCell.col + 1; ++i) {
			sum += this._templateCol[i];
		}

		const leftPos = sum * this.view.styleWidth;
		const dWidth = leftPos - relX;

		const nextCellIndex = this.resizeCell.row * this.countCol + (this.resizeCell.col + 1);
		const nextCell = this.view.htmlElement.children[nextCellIndex];

		if (this.getCellStyleData(this.resizeCell, "width") - dWidth <= currentMaxWidth) return;
		if (this.getCellStyleData(nextCell, "width") + dWidth <= nextMaxWidth) return;

		this._templateCol[this.resizeCell.col] -= dWidth / this.view.styleWidth;
		this._templateCol[this.resizeCell.col + 1] += dWidth / this.view.styleWidth;

		this.view.generateGridTemplateColumns();
	}

	resizeTop(relY) {
		let currentMaxHeight = this.getWidgetMaxHeightInRow(this.resizeCell.row);
		let upperMaxHeight = this.getWidgetMaxHeightInRow(this.resizeCell.row - 1);

		let sum = 0;
		for (let i = 0; i < this.resizeCell.row; ++i) {
			sum += this._templateRow[i];
		}

		const topPos = sum * this.view.styleHeight;
		const dHeight = topPos - relY;

		const upperCellIndex = (this.resizeCell.row - 1) * this.countCol + this.resizeCell.col;
		const upperCell = this.view.htmlElement.children[upperCellIndex];

		if (this.getCellStyleData(this.resizeCell, "height") + dHeight <= currentMaxHeight) return;
		if (this.getCellStyleData(upperCell, "height") - dHeight <= upperMaxHeight) return;

		this._templateRow[this.resizeCell.row] += dHeight / this.view.styleHeight;
		this._templateRow[this.resizeCell.row - 1] -= dHeight / this.view.styleHeight;

		this.view.generateGridTemplateRows();
	}

	resizeBottom(relY) {
		let currentMaxHeight = this.getWidgetMaxHeightInRow(this.resizeCell.row);
		let bottomMaxHeight = this.getWidgetMaxHeightInRow(this.resizeCell.row + 1);

		let sum = 0;
		for (let i = 0; i < this.resizeCell.row + 1; ++i) {
			sum += this._templateRow[i];
		}

		const topPos = sum * this.view.styleHeight;
		const dHeight = topPos - relY;

		const bottomCellIndex = (this.resizeCell.row + 1) * this.countCol + this.resizeCell.col;
		const bottomCell = this.view.htmlElement.children[bottomCellIndex];

		if (this.getCellStyleData(this.resizeCell, "height") - dHeight <= currentMaxHeight) return;
		if (this.getCellStyleData(bottomCell, "height") + dHeight <= bottomMaxHeight) return;

		this._templateRow[this.resizeCell.row] -= dHeight / this.view.styleHeight;
		this._templateRow[this.resizeCell.row + 1] += dHeight / this.view.styleHeight;

		this.view.generateGridTemplateRows();
	}

	getWidgetMaxWidthInCol(col) {
		let retValue = 0;

		for (let i = 0; i < this.view.countRow; i++) {
			let index = i * this.view.countCol + col;

			let cell = this.view.htmlElement.children[index];
			let child = cell.children[cell.children.length - 1];

			if (child === undefined) continue;
			if (child.id === "") continue;

			let widget = Rex.widgets[child.id];
			if (widget === undefined) continue;

			let width = widget.minWidth;
			if (width > retValue)
				retValue = width;
		}

		return retValue;
	}

	getWidgetMaxHeightInRow(row) {
		let retValue = 0;

		for (let i = 0; i < this.view.countCol; i++) {
			let index = row * this.view.countCol + i;

			let cell = this.view.htmlElement.children[index];
			let child = cell.children[cell.children.length - 1];

			if (child === undefined) continue;
			if (child.id === "") continue;

			let widget = Rex.widgets[child.id];
			if (widget === undefined) continue;

			let height = widget.minHeight;
			if (height > retValue)
				retValue = height;
		}

		return retValue;
	}

	clickPosX(x) {
		return x - this.aPosX;
	}

	clickPosY(y) {
		return y - this.aPosY;
	}

	replaceWidgetCell(oldCell, newCell) {
		if (oldCell === newCell) return;
		if (oldCell == null) return;
		if (newCell == null) return;

		let oldCellWidget = null;
		let newCellWidget = null;

		if (oldCell.parentId !== this.id)  {
			oldCellWidget = Rex.widgets[oldCell.parentId];
			oldCell = this.getCellByChild(oldCellWidget.view.htmlElement);
			if (!oldCell) return;
		}

		if (newCell.parentId !== this.id) {
			newCellWidget = Rex.widgets[newCell.parentId];
			newCell = this.getCellByChild(newCellWidget.view.htmlElement);
			if (!newCell) return;
		}

		this.hovered_widget_cell = newCell;
		Rex.callRpcMethod('Widgets', this.id, this.type, "replaceWidgetCell", [oldCell.row, oldCell.col, newCell.row, newCell.col]);
	}

	getCellByChild(child) {
		if (!this.cells) return null;
		const id = child.id.replace(/\D+/g, '');
		for (let i = 0; i < this.cells.length; i++) {
			for (let j = 0; j < this.cells[0].length; j++) {
				let cell = this.cells[i][j];

				if (cell == null) continue;
				if (id == cell) {
					return this.view.htmlElement.children[i * this.cells[0].length + j];
				}
			}
		}
		return null;
	}

	setEditMode(value) {
		this.editMode = value;
		if (this.editMode)
			this.view.setHover(!this._transparentBorder);
		else this.view.setHover(false);
	}

	applyPadding() {
		for (let i = 0; i < this.cellPaddings.length; i++) {
			for (let j = 0; j < this.cellPaddings[0].length; j++) {
				if(this.cellPaddings[i][j] == null) continue;
				let cellPaddings = this.cellPaddings[i][j];
				this.setCellPadding(i, j,
					Math.round(cellPaddings[0]),  	//left
					Math.round(cellPaddings[1]),  	//right
					Math.round(cellPaddings[2]), 	//top
					Math.round(cellPaddings[3]), 	//bottom
					false);
			}
		}
	}

	setCellPadding(row, col, left, right, top, bottom, Rpc = true) {
		let cell = this.view.htmlElement.children[row * this.countCol + col];
		if (cell === undefined) return;

		cell.style.marginLeft = left + "px";
		cell.style.marginRight = right + "px";
		cell.style.marginTop = top + "px";
		cell.style.marginBottom = bottom + "px";

		if (Rpc === true)
			Rex.callRpcMethod('Widgets', this.id, this.type, "setCellPadding", [row, col, left, right, top, bottom]);
	}

	getCellStyleData(cell, style) {
		if (style === "") return;
		if (!cell) return;

		let retData = this.view.getStyle(cell, style);
		return parseInt(retData);

	}

	set swapCells(swapData) {
		if (!Rex.widgets) return;
		const fromRow = swapData[0];
		const fromCol = swapData[1];
		const toRow = swapData[2];
		const toCol = swapData[3];

		const fromCell = this.view.htmlElement.children[fromRow * this.countCol + fromCol];
		const toCell = this.view.htmlElement.children[toRow * this.countCol + toCol];
		if (!fromCell || !toCell) return;
		if (fromCell === toCell) return;

		let oldCellWidget = Rex.widgets[this.cells[toCell.row][toCell.col]];
		let newCellWidget = Rex.widgets[this.cells[fromCell.row][fromCell.col]];

		if (newCellWidget !== undefined) {
			fromCell.appendChild(newCellWidget.view.htmlElement);

			newCellWidget.view.htmlElement.style.width = "100%";
			newCellWidget.view.htmlElement.style.height = "100%";
		}
		if (oldCellWidget !== undefined) {
			toCell.appendChild(oldCellWidget.view.htmlElement);

			oldCellWidget.view.htmlElement.style.width = "100%";
			oldCellWidget.view.htmlElement.style.height = "100%";
		}
	}

	set templateRows(value) {
		if (!value) return;
		this._templateRow = value;
		this.view.generateGridTemplateRows();
	}

	set templateColumns(value) {
		if (!value) return;
		this._templateCol = value;
		this.view.generateGridTemplateColumns();
	}
}


/**
 * Created by prg-37 on 17.09.2017.
 */

class WidgetLayoutVertical extends WidgetLayout {
	
	constructor(state) {
		super(state);
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetLayoutVerticalCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetLayoutVerticalHtml(this);
		}
	}

	onGenerateContent(content, docData) {
		super.onGenerateContent(content);

		let widgetTable = content.table;
		//get content body
		let body = widgetTable.body;

		const view = this.view;
		const html = view.htmlElement;
		const size = html.getBoundingClientRect();

		//get border width. If widget has no border, value will be 0
		let bWdith = parseInt(getStyle(html, 'borderWidth'));
		bWdith = isNaN(bWdith) ? 0 : bWdith;

		//set widget width
		widgetTable.widths.push(size.width - bWdith * 2);

		const hasScroll = hasScrollBar(html);
		if (hasScroll)
			html.style.overflow = 'hidden';

		//sum of children heights
		let heights = 0;
		for (const id of this.children) {
			const child = Rex.widgets[id];
			if (child == null)
				continue;

			let childContent = [];
			//generate a child content
			child.generateContent(childContent, docData);

			let cHeight = 0;
			//get border width value
			let cbWidth = parseInt(getStyle(child.view.htmlElement, 'borderWidth'));
			cbWidth = isNaN(cbWidth) ? 0 : cbWidth;

			//get child height into the loop, because child can be a container
			for (const height of childContent[0].table.heights)
				cHeight += height + cbWidth * 2;
			
			if (!hasScroll) {
				heights += cHeight;
				widgetTable.heights.push(cHeight);
			}

			docData.currentHeight += cHeight;
			if (docData.currentHeight >= docData.docHeight && hasScroll) {
				docData.currentHeight = 0;
				// if (cHeight > docData.docHeight) {
					childContent[0].pageBreak = 'before';
				// } else childContent[0].pageBreak = 'after';
			}

			const hAlignmentType = view._childrenHorizontalAlignType;
			if (hAlignmentType !== 1 && hAlignmentType !== 0) {
				let delta = widgetTable.widths[0] - childContent[0].table.widths[0] - cbWidth;
				if (hAlignmentType === 2)
					delta /= 2;
				else delta -= cbWidth;

				childContent[0].margin[0] += delta;				
			}

			body.push(childContent)
		}

		if (hasScroll)
			html.style.overflow = 'auto';

		//check for dHeight
		let delta = (size.height - bWdith * 2) - heights;
		if (delta !== 0) {
			if (view.childrenVerticalAlignType === 1){
				//if alignment type is 'top', then need to change height of the last table cell
				widgetTable.heights[widgetTable.heights.length - 1] += delta;
			} else if (view.childrenVerticalAlignType === 2) {
				//if the type is 'center', then need to change height of first and last cells
				delta /= 2;
				widgetTable.heights[widgetTable.heights.length - 1] += delta;
				widgetTable.heights[0] += delta;
				body[0][0].margin[1] += delta;
			} else if (view.childrenVerticalAlignType === 3) {
				//if the type is 'bottom', then need to change height of the first cell
				widgetTable.heights[0] += delta;
				body[0][0].margin[1] += delta;
			}
		}
	}
}


/**
 * Created by prg-37 on 17.09.2017.
 */

class WidgetLayoutHorizontal extends WidgetLayout {
	
	constructor(state) {
		super(state);
		this.setState(state);
		
		this.ratioX = 0;
		this.ratioY = 0;
		
		this.space = 0;
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetLayoutHorizontalCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetLayoutHorizontalHtml(this);
		}
	}

	onGenerateContent(content, docData) {
		super.onGenerateContent(content);

		let widgetTable = content.table;
		widgetTable.body.push([]);
		//get content body
		let body = widgetTable.body[0];

		const view = this.view;
		const html = view.htmlElement;
		const size = html.getBoundingClientRect();
		//get border width. If widget has no border, value will be 0
		let bWidth = parseInt(getStyle(html, 'borderWidth'));
		bWidth = isNaN(bWidth) ? 0 : bWidth;
		//set widget height
		widgetTable.heights.push(size.height - (bWidth * 2));

		//sum of children widths
		let widths = 0;
		for (const id of this.children) {
			const child = Rex.widgets[id];
			if (child == null)
				continue;

			//generate a child content
			child.generateContent(body, docData);
			//get generated content
			const childContent = body[body.length - 1];
			//get border width value
			let cbWidth = parseInt(getStyle(child.view.htmlElement, 'borderWidth'));
			cbWidth = isNaN(cbWidth) ? 0 : cbWidth;

			let width = 0;
			let heights = 0;
			//get child width into the loop, because child can be a container
			for (const w of childContent.table.widths)
				width += w + cbWidth * 2;

			widths += width;
			widgetTable.widths.push(width);

			//get child height into the loop, because child can be a container
			for (const height of childContent.table.heights)
				heights += height;

			//get vertical alignment value
			const vAlignment = view._childrenVerticalAlignType;
			if (vAlignment === 2) {
				//calculate value of central offset
				const center = (widgetTable.heights[0] - heights) / 2;
				childContent.margin[1] += center - cbWidth;
			} else if (vAlignment === 3) {
				//calculate value of top offset
				const top = widgetTable.heights[0] - heights;
				childContent.margin[1] += top - (cbWidth * 2);
			}

			//set width value of a child to width array of content table
			widgetTable.widths.push(width);
		}

		//check for dWidth
		let delta = size.width - widths;
		if (delta !== 0) {
			if (view._childrenHorizontalAlignType === 1) {
				//if alignment type is 'left', then need to change width of the last table cell
				widgetTable.widths[widgetTable.widths.length - 1] += delta;
			} else if (view._childrenHorizontalAlignType !== 1) {
				if (view._childrenHorizontalAlignType === 2) {
					//if the type is 'center', then need to change width of first and last cells
					delta /= 2;
					widgetTable.widths[0] += delta;
					widgetTable.widths[widgetTable.widths.length - 1] += delta;
				} else if (view._childrenHorizontalAlignType === 3) {
					//if the type is 'right', then need to change width of the first cell
					widgetTable.widths[0] += delta;
				}

				//if the type is not 'left', need to add margin
				let fContent = widgetTable.body[0][0];
				fContent.margin[0] += delta;
			}
		}
	}
	
}


/* eslint-disable no-unused-vars */
/* global Widget WidgetScrollAreaCanvas WidgetScrollAreaHtml*/

/**
 * WidgetScrollArea
 */

class WidgetScrollArea extends Widget {
	
	constructor(state) {
		super(state);
		
		this.scrollHorizontal = undefined;
		this.scrollVertical = undefined;
		
		this.dataLayout = undefined;
		
		this.horizontalScrollShow = -1;
		this.verticalScrollShow = -1;
		
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetScrollAreaCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetScrollAreaHtml(this);
		}
	}
	
	mouseWheel(value) {
		this.view.onMouseWheel(value);
	}
	
}


/**
 * Created by prg-30 on 02.06.2017.
 */

/* eslint-disable no-unused-vars */
/* global Widget WidgetInputCanvas WidgetInputHtml Rex*/

class WidgetInput extends Widget {

	constructor(state) {
		super(state);
		this._text = "";
		this.str = "";
		this._header = "";

		this.valid = true;

		// this._cursorPosition = this.text.length;
		this._cursorPosition = -1;

		this._selectPosition = -1;

		this.setState(state);
		this.str = this.text;
		this.fontSize = "";
	}

	createView() {
		if (this.typeView === "canvas") {
			this.view = new WidgetInputCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetInputHtml(this);
		}
	}

	onGenerateContent(content) {
		let widgetTable = content.table;
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);

		let headerBody = widgetTable.body[0][0];
		let textBody = widgetTable.body[1][0];

		const html = this.view.htmlElement;
		const htmlSize = html.getBoundingClientRect();
		const headerHtml = this.view.headerElement;
		const headerSize = headerHtml.getBoundingClientRect();
		const textHtml = this.view.inputElement;
		const textSize = textHtml.getBoundingClientRect();

		let bWdith = parseInt(getStyle(html, 'borderWidth'));
		bWdith = isNaN(bWdith) ? 0 : bWdith;

		widgetTable.widths.push(htmlSize.width - bWdith * 2);
		widgetTable.heights.push(headerSize.height - bWdith);
		widgetTable.heights.push(textSize.height - bWdith);

		generateText(headerHtml, headerBody);
		generateText(textHtml, textBody);

		const background = getColorHEX(getStyle(html, 'background-color'));
		
		headerBody.fillColor = background;
		textBody.fillColor = background;
	}

	pressEnter(value) {
		// if (value) this.updateParameters(true);
		Rex.callRpcMethod("Widgets", this.id, this.type, "pressEnter", [value]);
	}

	mouseMove(x, y) {
		if (this.isHovered() && this.isFocused()) {
			document.body.style.cursor = "text";
		} else {
			document.body.style.cursor = "default";
		}
		this.onMouseMove(x, y);
	}

	updateParameters() {
		this.text = this.str;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setParameters", [this.text, this.cursorPosition, this.selectPosition]);
	}

	get cursorPosition() {
		return this._cursorPosition;
	}

	set cursorPosition(value) {
		if (this._cursorPosition != value) {
			this._cursorPosition = value;
			this.view.onChangeCursorPosition(value);
			this.view.update();
		}
	}

	get selectPosition() {
		return this._selectPosition;
	}

	set selectPosition(value) {
		if (this._selectPosition != value) {
			this._selectPosition = value;
			this.view.update();
		}
	}

	//пересылка всего в рисовальщик
	keyDown(event) {
		this.view.keyDown(event);
	}

	keyUp(event) {
		this.view.keyUp(event);
	}

	keyPress(event) {
		this.view.keyPress(event);
	}

	onMouseMove(x, y, event) {
		this.view.onMouseMove(x, y);
	}

	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y);
	}

	onMouseUp(x, y) {
		this.view.onMouseUp(x, y);
	}

	onFocused(focused) {
		this.view.onFocused(focused);
		if (focused) {
			this.view.inputElement.focus();
			// if (this.view.inputElement) {
			// 	setTimeout(function () { // при создании нового инпута(пример: диалоговое окно) устанавливаем фокус, но HTML элемент еще не отрисовался и фокус не установился...
			// 	}.bind(this), 500);
			// }
		}
	}

}


/**
 * WidgetTab
 */

class WidgetTab extends Widget {
	
	constructor(state) {
		super(state);
		this.currentTab = -1;
		this.oldCurrentTab = -1;
		
		this.headerLayoutId = -1;
		this.currentTabId = -1;
		
		super.setState(state);
		
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetTabCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetTabHtml(this);
		}
	}
	
}

/**
 * WidgetComboBox
 */

class WidgetComboBox extends Widget {
	
	constructor(state) {
		super(state);
		this.header = '';
		this.expanded = false;
		this._$currentIndex = -1;
		this._$currentHoverIndex = -1;
		this._$headerVisible = false;
		this._$currentHeaderText = '';
		super.setState(state);
		
		this.scrollVertical = undefined;	//scroll V
		this.scrollHorizontal = undefined;	//scroll H
		
		this.heightChilds = 0;
		this.maxWidthArrow = 50;
		this.minWidthArrow = 15;
		this.widthArrow = this.width / 10;
	}

	setExpand (flag) {
		// if (this.expanded == flag) return;
		this.expanded = flag;//самому себе
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setExpanded', [this.expanded]);
	}
	
	setCurrentItemIndex (index) {
		if (index == -1){this.resetItemIndex();return true;}

		if (!this.checkIndex(index)) return false;
		this._$currentIndex = index;

		Rex.callRpcMethod('Widgets', this.id, this.type, 'setCurrentItem', [this._$currentIndex]);
		return true;
	}

	resetItemIndex() {
		this._$currentIndex = -1;
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setCurrentItem', [this._$currentIndex]);
	}

	checkIndex (index) {return !(index < 0 || this.children == undefined || index>this.children.length);}

	sendHoverIndex (index) {
		if (this._$currentHoverIndex == index) return;
		this._$currentHoverIndex = index;
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setHoverIndex', [this._$currentHoverIndex]);
	}
	
	setHeaderText (text) {
		if (this._$currentHeaderText == text) return false;
		this._$currentHeaderText = text;

		Rex.callRpcMethod('Widgets', this.id, this.type, 'setHeaderText', [this._$currentHeaderText]);
	}

	setHeaderVisible (flag) {
		if (this._$headerVisible == flag) return false;
		this._$headerVisible = flag;

		Rex.callRpcMethod('Widgets', this.id, this.type, 'setVisibleText', [this._$headerVisible]);
	}

	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetComboBoxCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetComboBoxHtml(this);
		}
	}
	
	onCheckInit() { return true;}
	
	onInit() {
		for (let child of this.children)
			if (child != undefined && child.view != undefined)
				this.view.appendChild(child.view);
	}
	
	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y, event);
	}
	
	onMouseWheel(value) {
		this.view.onMouseWheel(value);
	}
	
	onFocused(focused) {
		if(!focused) {
			this.setExpand(false);	//NOTE тут раньше просто присваивалось. может лишнее rex.gui.reposition
			Rex.gui.permamentWidget = undefined;
		}
	}

	
}

/**
 * WidgetWindow
 */

class WidgetWindow extends Widget {
	
	constructor(state) {
		super(state);
		this.needMove = false;
		this.startMousePos = new Rex.Vector2(0, 0);
		this.startMove = new Rex.Vector2(0, 0);
		
		this.minHeight = 25;
		this.minWidth = 25;
		
		this.minContentWidth = 0;
		this.minContentHeight = 0;
		
		this.horizontalSizePolicy = 0;
		this.verticalSizePolicy = 0;
		
		this.horizontalAlignType = 0;
		this.verticalAlignType = 0;
		
		this.enableHeader = null;
		this.needAttach = true;
		this.needUnAttach = true;
		
		this.resizer = new Resizer(this);
		this.blockResizer = false;
		
		this.setState(state);
	}
	
	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetWindowCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetWindowHtml(this);
		}
	}
	
	onFocused(f) {
		this.view.onFocused(f);
		if(f) return;
		this.needMove = false;
	}
	
	setAPOSv() {
		this.APOSX = 0;
		this.APOSY = 0;
		let obj = this.view.htmlElement;
		if(this.parentId != -1) obj = obj.offsetParent;
		if (obj.offsetParent) {
			do {
				this.APOSX += obj.offsetLeft;
				this.APOSY += obj.offsetTop;
			}
			while (obj = obj.offsetParent);
		}
	}

	onMouseDown(x, y, event) {
		this.resizer.mouseDown(event.clientX, event.clientY);
		
		this.setAPOSv();
		
		let APOSX = 0;
		let APOSY = 0;
		let obj = this.view.htmlElement;
		if (obj.offsetParent) {
			do {
				APOSX += obj.offsetLeft;
				APOSY += obj.offsetTop;
			}
			while (obj = obj.offsetParent);
		}
		
		let px = this.APOSX + this.paddingLeft;
		let py = this.APOSY + this.paddingTop;
		let w = this.width - this.paddingLeft - this.paddingRight;
		
		let min = new Rex.Vector2(px, py);
		let max = new Rex.Vector2(px + w, py + 30);
		let boundBox = new Rex.BoundBox(min, max);
		
		// if(boundBox.inside(new Rex.Vector2(x, y), 0)) { //проверить на хидере ли курсор
		const path = event.path || (event.composedPath && event.composedPath());
		if(path.indexOf(this.view.headerElement) != -1) { //проверить на хидере ли курсор

			this.needMove = this.checkHeaderButtons(event);
			this.resizer.needResize = false;
			
			this.deltaPressX = event.clientX - APOSX;
			this.deltaPressY = event.clientY - APOSY;
			
			// Если мы нажали на кнопки MINIMAZE FULL CLOSE - НЕ ДВИГАТЬ И НЕ РЕСАЙЗИТЬ
			if(event.target != null) {
				let className = event.target.className;
				if( className == "MaxBtn" || className == "MaxBtnSpan" || className == "XBtn" || className == "XBtnSpan" || className == "MinBtn" || className == "MinBtnSpan")
					this.needMove = false;
			}
		}
		this.startWidth = this.width;
		this.startHeight = this.height;
		
		this.view.onMouseDown(x, y, event);
	}

	checkHeaderButtons(event) {
		const path = event.path || (event.composedPath && event.composedPath());
		if(null != event && null != path) {
			if(path.indexOf(this.view.maxElement) != -1) return false;
			if(path.indexOf(this.view.minElement) != -1) return false;
			if(path.indexOf(this.view.closeElement) != -1) return false;
	
			for(let node of this.view.leftButtonsContainer.children) {
				if(path.indexOf(node) != -1) return false;
			}
		}
		return true;
	}
	
	onMouseUp(x, y, event) {
		this.resizer.mouseUp();
		this.view.onMouseUp(x, y, event);
		this.needMove = false;
		this.startWidth = -1;
		this.startHeight = -1;
		this.blockResizer = false;
		
		this.setPos(parseInt(this.view.htmlElement.style.left), parseInt(this.view.htmlElement.style.top));
		
		if(this.typeView == "html") this.view.stopMoving();
	}
	
	onMouseDoubleClick(event) {
		this.view.onMouseDoubleClick(event);
	}
	
	onMouseMove(x, y, event) {
		if(!this.blockResizer) this.resizer.mouseMove(event.clientX, event.clientY);
		if(this.needMove && !this.resizer.needResize) {
			
			if(this.typeView == "html") this.view.startMoving();
			this.blockResizer = true;
			
			if (this.view.htmlElement != null) this.view.htmlElement.style.cursor = this.resizer.cursorType[9];
			else document.body.style.cursor = this.resizer.cursorType[9];
			
			if(this.needAttach) this.view.onNeedAttach(event.clientX, event.clientY);
			
			let submitPos = {};
			submitPos.x = this.APOSX;
			submitPos.y = this.APOSY;
			
			// POS X
			if(this.horizontalAlignType == 0 && this.parentId == -1) submitPos.x = event.clientX - this.deltaPressX;
			else if(this.horizontalAlignType == 0 && this.parentId != -1) {
				submitPos.x = event.clientX - this.deltaPressX - this.APOSX;
			} else submitPos.x = this.APOSX;
			
			// POS Y
			if(this.verticalAlignType == 0 && this.parentId == -1) submitPos.y = event.clientY - this.deltaPressY;
			else if(this.verticalAlignType == 0 && this.parentId != -1) {
				submitPos.y = event.clientY - this.deltaPressY - this.APOSY;
			} else submitPos.y = this.APOSY;
			// LEFT TOP
			if(this.horizontalAlignType == 1) {
				submitPos.x = 0;
			}
			if(this.verticalAlignType == 1) {
				submitPos.y = 0;
			}
			
			// CENTER CENTER
			if(this.horizontalAlignType == 2) {
				submitPos.x = null;
				this.view.htmlElement.style.left = "calc(50% - " + (this.view.htmlElement.offsetWidth / 2) + "px)";
				
			}
			if(this.verticalAlignType == 2) {
				submitPos.y = null;
				this.view.htmlElement.style.top = "calc(50% - " + (this.view.htmlElement.offsetHeight / 2) + "px)";
			}
			
			// BOTTOM RIGHT
			if(this.horizontalAlignType == 3) {
				submitPos.x = null;
				this.view.htmlElement.style.left = "calc(100% - " + (this.view.htmlElement.offsetWidth) + "px)";
			}
			if(this.verticalAlignType == 3) {
				submitPos.y = null;
				this.view.htmlElement.style.top = "calc(100% - " + (this.view.htmlElement.offsetHeight) + "px)";
			}
			
			if(submitPos.x != null) this.view.htmlElement.style.left = submitPos.x + "px";
			if(submitPos.y != null) this.view.htmlElement.style.top = submitPos.y + "px";
			this.setAPOSv();
			// console.log("SET POS WW: ",submitPos.x,submitPos.y );
			
			if(Rex.gui === undefined) return;
			Rex.gui.reposition(this);
			
			//this.view.update();
		}
		this.view.onMouseMove(x, y, event);
	}
}


/* eslint-disable no-unused-vars */
/* global Scene Widget WidgetSliderHtml*/

/**
 * WidgetSlider
 */

class WidgetSlider extends Widget {
	
	constructor(state) {
		super(state);
		super.setState(state);
	}
	
	createView() {
		this.view = new WidgetSliderHtml(this);
	}
	
	mouseDown(x, y, event) { this.view.mouseDown(x, y, event); }
	
	mouseUp(x, y, event) { this.view.mouseUp(x, y, event); }
	
	mouseMove(x, y, event) { this.view.mouseMove(x, y, event); }

	mouseWheel(d, e) { this.view.mouseWheel(d, e); }
	
	
}


/**
 * WidgetTextArea
 */

class WidgetTextArea extends Widget {

	constructor(state) {
		super(state);
		this.text = '';			// Исходный текст напечатанный пользователем
		this.textDraw = '';		// Форматированный текст для формирования строк и отрисовки
		this.header = '';

		//курсор
		this.cursorPosition = 0;
		this.cursorLine = 0;
		this.lineHeight = 0;

		//выделенный текст
		this.globalSelectPosition = -1;
		this.selectPosition = -1;
		this.selectLine = 0;
		this.setState(state);
	}

	onGenerateContent(content) {
		let widgetTable = content.table;
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);

		let headerBody = widgetTable.body[0][0];
		let textBody = widgetTable.body[1][0];

		const html = this.view.htmlElement;
		const htmlSize = html.getBoundingClientRect();
		const headerHtml = this.view.headerElement;
		const headerSize = headerHtml.getBoundingClientRect();
		const textHtml = this.view.textAreaElement;
		const textSize = this.getBoundingClientRect();

		let bWdith = parseInt(getStyle(html, 'borderWidth'));
		bWdith = isNaN(bWdith) ? 0 : bWdith;

		widgetTable.widths.push(htmlSize.width - bWdith * 2);
		widgetTable.heights.push(headerSize.eight - bWdith);
		widgetTable.heights.push(textSize.height - bWdith);

		generateText(headerHtml, headerBody);
		generateText(textHtml, textBody);

		const background = getColorHEX(getStyle(html, 'background-color'));
		
		headerBody.fillColor = background;
		textBody.fillColor = background;
	}

	createView() {
		if (this.typeView === "canvas") {
			this.view = new WidgetTextAreaCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetTextAreaHtml(this);
		}
	}

	mouseMove(x, y) {
		if (this.isHovered() && this.isFocused()) {
			document.body.style.cursor = 'text';
		} else { document.body.style.cursor = 'default'; }
		this.view.onMouseMove(x, y);
	}

	// pressEnter(value) {
	// 	if(value) this.updateParameters(true);
	// 	Rex.callRpcMethod("Widgets", this.id, this.type, "pressEnter", [value]);
	// }

	updateParameters() {
		this.view.update();
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setParameters', [this.text, this.cursorPosition, this.selectPosition, this.globalSelectPosition, this.cursorLine, this.selectLine]);
	}

	set lineHeight(value) {
		if (value == null) return;
		this.view.textAreaElement.style.lineHeight = value + "%";
	}

	keyDown(event) { this.view.keyDown(event); }
	keyUp(event) { this.view.keyUp(event); }
	keyPress(event) { this.view.keyPress(event); }
	onMouseWheel(event) { this.view.onMouseWheel(event); }
	onFocused(focused) { this.view.onFocused(focused); }
	onMouseDown(x, y) { this.view.onMouseDown(x, y); }
	onMouseUp(x, y) { this.view.onMouseUp(x, y); }

}

/**
 * WidgetLabel
 */
	
class WidgetLabel extends Widget {
	
	constructor(state) {
		super(state);
		this.setState(state);
	}

	onGenerateContent(content) {
		const html = this.view.htmlElement;
		const size = html.getBoundingClientRect();
		let widgetTable = content.table;

		//get last content, that was added to the content array
		let bWidth = parseInt(getStyle(html, 'borderWidth'))
		bWidth = isNaN(bWidth) ? 0 : bWidth;

		widgetTable.widths.push(size.width - (bWidth * 2));
		widgetTable.heights.push(size.height - (bWidth * 2));

		widgetTable.body.push([{margin:[0, 0, 0, 0]}]);

		//body of this widget
		let body = widgetTable.body[0][0];

		generateText(html, body);

		//set background-color
		body.fillColor = getColorHEX(getStyle(html, 'background-color'));
	}
	
	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetLabelCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetLabelHtml(this);
		}
	}

	set lineHeight(value) {
		if (value == null) return;
		this.view.htmlElement.style.lineHeight = value + "%";
	}

}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global WidgetButton WidgetLoaderCanvas WidgetLoaderHtml bufferToBase64 Rex*/

class WidgetLoader extends WidgetButton {
	
	constructor(state) {
		super(state);

		this._fileName = '';
		this._fileType = 'text/plain';
		this._fileData = '';
		this._fileSize = -1;
		this._loaderMode = 0;

		super.setState(state);
	}

	setState(state) {
		super.setState(state);

		if (state.fileName != null) this.fileName = state.fileName;
		if (state.fileType != null) this.fileType = state.fileType;
		if (state.fileData != null) this.fileData = state.fileData;
		if (state.loaderMode != null) this.loaderMode = state.loaderMode;
		if (state.fileSave != null) {
			if (state.fileSave == true) {
				this.downloadFile();
			}
		}

		if (state.file != null) {
			const file = state.file;
			this.downloadFile(file.name, file.data, file.type);
		}
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetLoaderCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetLoaderHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		super.onMouseDown(x, y, event);
	}

	set fileName(name) {
		this._fileName = name;
	}

	get fileName() {
		return this._fileName; 
	}

	set fileType(type) {
		this._fileType = type;
	}

	get fileType() {
		return this._fileType;
	}

	set fileData(data) {
		this._fileData = atob(data);
		this._fileSize = data.length;
	}

	get fileData() {
		return this._fileData;
	}

	set loaderMode(mode) {
		this._loaderMode = mode;
	}

	get loaderMode() {
		return this._loaderMode;
	}
	
	//FileList
	loadFiles(files) {
		// let files = event.target.files;
		let objectFiles = {
			files: []
		};
		for(let i = 0; i < files.length; ++i) {
			let file = files[i];
			let reader = new FileReader();
			reader.onload = function(event) {
				let content = event.target.result;
				if (content.byteLength > 1e6 + 1e6*0.024) {
					alert("To long file. Max 1 MiB");
					console.log( "content length",content.byteLength);
					return;
				}

				objectFiles.files.push({
					name: file.name,
					type: file.type,
					size: file.size,
					data: bufferToBase64(content)
				});
				if(i == files.length - 1) Rex.callRpcMethod("Widgets", this.id, this.type, "uploadFile", [JSON.stringify(objectFiles)]);
			}.bind(this);
			reader.readAsArrayBuffer(file);
		}
	}

	downloadFile() {
		if (this._fileSize == -1) {
			return;
		}

		if (this._fileData.length == 0) {
			return;
		}

		if (this._fileName == "") {
			this._fileName = "unnamed";
		}

		let type = this._fileType;
		let file = new Blob([this._fileData], {type});

		const link = document.createElement('a');
		link.href = URL.createObjectURL(file);
		link.download = this._fileName;
		document.body.appendChild(link);
		link.click();
		setTimeout(() => {
			window.URL.revokeObjectURL(URL.createObjectURL(file));
		});
	}
	
}


class WidgetLoading extends Widget {
	
	constructor(state) {
		super(state);
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetLoadingHtml(this);
		}
	}
	
}

/**
 * WidgetSwitch
 */

class WidgetSwitch extends Widget {
	
	constructor(state) {
		super(state);
		this.enable = false;
		this.pressed = false;
		this.textOn = "";
		this.textOff = "";
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetSwitchCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetSwitchHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		this.view.update();
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setPressed', [true]);
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		this.view.update();
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setEnableSwitch', [!this.enable]);
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setPressed', [false]);
	}
	
}

/**
 * WidgetSwitch
 */
	
class WidgetStick extends Widget {
	
	constructor(state) {
		super(state);
		this.currentButton = -1;
		this.buttons = {
			Up: 0,
			Down: 1,
			Left: 2,
			Right: 3,
			Enter: 4
		};
		this.up = {
			type:"up",
			x: 0,
			y: 0,
			hover: false,
			pressed: false,
			rotate: 0
		};
		this.down = {
			type:"down",
			x: 0,
			y: 0,
			hover: false,
			pressed: false,
			rotate: 0
		};
		this.left = {
			type:"left",
			x: 0,
			y: 0,
			hover: false,
			pressed: false,
			rotate: 0
		};
		this.right = {
			type:"right",
			x: 0,
			y: 0,
			hover: false,
			pressed: false,
			rotate: 0
		};
		this.enter = {
			type:"enter",
			x: 0,
			y: 0,
			hover: false,
			pressed: false,
			rotate: 0
		};
		this.arrows = [this.up, this.down, this.left, this.right, this.enter];
		super.setState(state);
	}
	
	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetStickCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetStickHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		for(let i = 0; i < this.arrows.length; ++i) {
			this.arrows[i].hover = false;
			this.arrows[i].pressed = false;
		}
		
		let radius = this.height / 3;
		let radius1 = this.height / 6;
		let radius2 = this.height / 5;
		let centerX = this.aPosX + this.width / 2;
		let centerY = this.aPosY + this.height / 2;
		
		if(Math.sqrt((centerX - x) * (centerX - x) + (centerY - y) * (centerY - y)) <= radius2) {
			Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Enter]);
			this.arrows[4].pressed = true;
			this.arrows[4].hover = true;
		}
		
		for(let i = 0; i < 4; ++i) {
			let c = (Math.pow(-1, Math.round(i * 0.5)) * (Math.pow(-1, i) + 1)) * 0.5;
			let s = (Math.pow(-1, Math.round(i * 0.5)) * (Math.pow(-1, i + 1) + 1)) * 0.5;
			let translate = new Rex.Vector2(centerX + c * radius, centerY + s * radius);
			let min = new Rex.Vector2(translate.x - radius1, translate.y - radius1);
			let max = new Rex.Vector2(translate.x - radius1 + radius, translate.y - radius1 + radius);
			let boundBox = new Rex.BoundBox(min, max);
			
			if(boundBox.inside(new Rex.Vector2(x, y), 0)) {
				this.arrows[4].pressed = false;
				this.arrows[4].hover = false;
				
				switch(i) {
					case 0: {
						Rex.callRpcMethod('Widgets', this.id, this.type, 'press', [this.buttons.Right]);
						this.arrows[3].pressed = true;
						this.arrows[3].hover = true;
						break;
					}
					case 1: {
						Rex.callRpcMethod('Widgets', this.id, this.type, 'press', [this.buttons.Up]);
						this.arrows[0].pressed = true;
						this.arrows[0].hover = true;
						break;
					}
					case 2: {
						Rex.callRpcMethod('Widgets', this.id, this.type, 'press', [this.buttons.Left]);
						this.arrows[2].pressed = true;
						this.arrows[2].hover = true;
						break;
					}
					case 3: {
						Rex.callRpcMethod('Widgets', this.id, this.type, 'press', [this.buttons.Down]);
						this.arrows[1].pressed = true;
						this.arrows[1].hover = true;
						break;
					}
				}
			}
		}
		this.view.update();
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		// Снятие флага нажатия со всех кнопок
		for(let i = 0; i < this.arrows.length; ++i) this.arrows[i].pressed = false;
		this.view.update();
		Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'unpress', []);
	}
	
	keyDown(event) {
		switch(event.which) {
			case 0x25: Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Left]);
				this.arrows[2].pressed = true;
				this.arrows[2].hover = true;
				break;
			case 0x27: Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Right]);
				this.arrows[3].pressed = true;
				this.arrows[3].hover = true;
				break;
			case 0x26: Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Up]);
				this.arrows[0].pressed = true;
				this.arrows[0].hover = true;
				break;
			case 0x28: Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Down]);
				this.arrows[1].pressed = true;
				this.arrows[1].hover = true;
				break;
			default:
				break;
		}
		this.view.update();
	}
	
	keyUp(event) {
		for(let i = 0; i < this.arrows.length; ++i) this.arrows[i].hover = false;
		for(let i = 0; i < this.arrows.length; ++i) this.arrows[i].pressed = false;
		this.view.update();
		Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'unpress', []);
	}
	
	keyPress(event) {
		if(event.charCode == 13 || event.charCode == 32) {
			this.arrows[4].pressed = true;
			this.arrows[4].hover = true;
			this.view.update();
			Rex.callRpcMethod('Widgets', this.id, 'WidgetStick', 'press', [this.buttons.Enter]);
		}
	}
	
}

/**
 * WidgetImage
 */

class WidgetImage extends Widget {
	
	constructor(state) {
		super(state);
		this.imageId = -1;
		this.setState(state);
	}

	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetImageCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetImageHtml(this);
		}
	}

	onGenerateContent(content, docData) {
		const htmlImage = this.view.htmlImage;
		const imageSize = htmlImage.getBoundingClientRect();
		let imgData = getStyle(htmlImage, 'background-image');
		if (imgData.indexOf('url') !== -1) {
			imgData = imgData.substring(5, imgData.length - 2);
		}

		let table = content.table;
		table.widths.push(imageSize.width);
		table.heights.push(imageSize.height);

		table.body.push([{}]);
		//do not draw a hidden element
		if (imageSize.width === 0 || imageSize.height === 0)
			return;

		if (imgData.indexOf('http') !== -1) {
			//TODO: need to draw special image
			return;
		}

		let body = table.body[0][0];
		body.image = imgData;

		let img = new Image();
		img.src = imgData;
		function imageHandler() {
			const size = {
				width : img.width,
				height : img.height
			}

			if (this.position === 0) {
				body.width = imageSize.width;
				body.height = imageSize.height;
			} else {
				body.fit = [size.width / (size.height / imageSize.height), imageSize.height];
				const left = Math.abs((imageSize.width - body.fit[0]) / 2);
				const top = Math.abs((imageSize.height - body.fit[1]) / 2);
				body.margin = [left, top, left, top];
			}

			docData.images.splice(docData.images.indexOf(img), 1);
		}

		img.onload = imageHandler.bind(this);
		docData.images.push(img);
	}
}

/**
 * WidgetList
 */

class WidgetList extends Widget {
	
	constructor(state) {
		super(state);
		this.currentItem = -1;
		this.hoveredItem = -1;
		this.focusedItem = -1;
		this.selected = true;
		this.multiSelect = false;
		this.minContentHeight = 0;
		
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetListCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetListHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y, event);
	}
	
	onMouseWheel(value) {
		this.view.onMouseWheel(value);
	}
	
	setCurrentItem(item) {

		if(!this.multiSelect && this.currentItem === item) {

			this.currentItem = -1;

			Rex.callRpcMethod('Widgets', this.id, this.type, 'removeFromSelection', [item]);

			return;
		}

		this.currentItem = item;

		Rex.callRpcMethod('Widgets', this.id, this.type, 'setCurrentItem', [this.currentItem]);
	}
	
}

/**
 * WidgetToolBox
 */

class WidgetToolBox extends Widget {

	static pageIdCheck(id) {

		return function(element) {

			return element.id == id;
		};
	}

	constructor(state) {

		super(state);

		this.autoHide = false;

		this.needPageIcon = false;
		this.pageShowedIcon = "";
		this.pageHiddenIcon = "";

		this.pages = [];

		if(Rex.undef(state, "state")) return;

		if(state.pages != undefined)
			this.createPages(state.pages);
	}

	setState(state) {

		if(Rex.undef(state, "state")) return;

		super.setState(state);

		if(this.pages == undefined)
			return;

		this.setAutoHide(state.autoHide);
		this.setNeedPageIcon(state.needPageIcon);
		this.setPageShowedIcon(state.pageShowedIcon);
		this.setPageHiddenIcon(state.pageHiddenIcon);
		this.setPages(state.pages);
	}

	createView() {

		this.view = new WidgetToolBoxHtml(this);
	}

	setAutoHide(autoHide) {

		if(this.autoHide == undefined)
			return;

		if(autoHide == undefined)
			return;

		this.autoHide = autoHide;
	}

	setNeedPageIcon(needPageIcon) {

		if(this.needPageIcon == needPageIcon)
			return;

		if(needPageIcon == undefined)
			return;

		this.needPageIcon = needPageIcon;

		let pages = this.pages;

		for(let page of pages)
			page.setNeedIcon(needPageIcon);
	}
	
	setPageShowedIcon(pageShowedIcon) {

		if(this.pageShowedIcon == pageShowedIcon)
			return;

		if(pageShowedIcon == undefined)
			return;

		this.pageShowedIcon = pageShowedIcon;

		let pages = this.pages;

		for(let page of pages)
			page.setShowedIcon(pageShowedIcon);
	}
	
	setPageHiddenIcon(pageHiddenIcon) {

		if(this.pageHiddenIcon == pageHiddenIcon)
			return;

		if(pageHiddenIcon == undefined)
			return;

		this.pageHiddenIcon = pageHiddenIcon;

		let pages = this.pages;

		for(let page of pages)
			page.setHiddenIcon(pageHiddenIcon);
	}

	makePage(pageState) {
		
		if(Rex.undef(pageState, "pageState")) return;
		if(Rex.undefProp(pageState, "id")) return;

		let page = new WidgetToolBox.Page(this, pageState);

		page.setOnMouseDownHandler(()=>{this.onPageMouseDown(pageState.id);});

		page.setNeedIcon(this.needPageIcon);
		page.setShowedIcon(this.pageShowedIcon);
		page.setHiddenIcon(this.pageHiddenIcon);

		return page;
	}

	addPage(pageState) {

		if(Rex.undef(pageState, "pageState")) return;
		if(Rex.undefProp(pageState, "id")) return;

		let pages = this.pages;

		let id = pageState.id;

		if(pages.findIndex(WidgetToolBox.pageIdCheck(id)) > 0) {

			console.error("Page with id %d already exists in %o", id, pages);

			return;
		}

		let page = this.makePage(pageState);

		pages.push(page);

		page.init(pageState);
	}

	createPages(pagesState) {

		if(Rex.undef(pagesState, "pagesState")) return;

		for(let pageState of pagesState)
			this.addPage(pageState);
	}

	deletePages(pagesState) {

		let pages = this.pages;

		if(pagesState == undefined) {

			for(let p of pages)
				this.view.removePage(p.pageHtml);

			this.pages = [];

			return;
		}

		for(let i = pages.length - 1; i >= 0; --i) {

			let id = pages[i].id;

			let stateIndex = pagesState.findIndex(WidgetToolBox.pageIdCheck(id));

			if(stateIndex < 0) {

				this.view.removePage(pages[i].pageHtml);

				pages.splice(i, 1);
			}
		}
	}

	setPages(pagesState) {

		if(this.pages == undefined)
			return;

		this.deletePages(pagesState);

		if(pagesState == undefined)
			return;

		let pages = this.pages;

		for(let i = 0; i < pagesState.length; ++i) {

			let pageState = pagesState[i];

			let index = pages.findIndex(WidgetToolBox.pageIdCheck(pageState.id));

			if(index < 0) {

				let page = this.makePage(pageState);

				pages.splice(i, 0, page);

				page.init(pageState);

			} else {

				pages[index].setState(pageState);
			}
		}
	}

	appendChild(child) {

		if(Rex.undef(child, "child")) return;

		let pages = this.pages;

		for(let page of pages)
			if(page.appendChild(child))
				return;
	}

	onMouseDown(x, y, event) {

		this.view.onMouseDown(x, y, event);
	}

	onPageMouseDown(pageId) {

		if(Rex.undef(pageId, "pageId")) return;

		let pages = this.pages;

		let index = pages.findIndex(WidgetToolBox.pageIdCheck(pageId));

		if(index < 0)
			console.error("Can't find page with id %d in pages %o", pageId, pages);

		let page = pages[index];

		let showed = !page.showed;

		page.setShowing(showed);

		if(this.autoHide && showed)
			for(let p of pages)
				if(p != page)
					p.setShowing(false);

		Rex.callRpcMethod('Widgets', this.id, this.type, 'setPageShowingById', [pageId, showed]);
	}

	onResize() {

		let pages = this.pages;

		for(let page of pages)
			page.onToolboxResize();
	}
	
}

WidgetToolBox.Page = class {

	constructor(toolBox, state) {

		if(Rex.undef(toolBox, "toolBox")) return;
		if(Rex.undef(state, "state")) return;
		if(Rex.undefProp(state, ["id", "pageWidget", "headerLabel", "headerImage", "contentWidget"])) return;

		this.toolBox = toolBox;

		this.id = state.id;

		this.title = "";

		this.showed = false;

		this.pageWidget = state.pageWidget;

		this.headerLabel = null;

		this.headerImage = null;

		this.contentWidget = null;

		this.headerHeight = null;
		this.contentHeight = null;
		this.labelWidth = null;
		this.imageWidth = null;

		this.needIcon = null;
		this.showedIcon = null;
		this.hiddenIcon = null;

		this.onClickHandler = null;

		this.pageHtml = new WidgetToolBoxHtml.Page(toolBox.view);
	}

	init(state) {

		if(state == undefined)
			return;

		this.setHeaderLabel(state.headerLabel);
		this.setHeaderImage(state.headerImage);
		this.setContentWidget(state.contentWidget);

		this.setState(state);
	}

	setState(state) {

		if(state == undefined)
			return;

		this.setTitle(state.title);
		this.setShowing(state.showed);
		this.setHeaderHeight(state.headerHeight);
		this.setContentHeight(state.contentHeight);
		this.setLabelWidth(state.labelWidth);
		this.setImageWidth(state.imageWidth);
	}

	setTitle(title) {

		if(title == undefined)
			return;

		if(this.title == title)
			return

		this.title = title;
	}

	setShowing(showed) {

		if(showed == undefined)
			return;

		if(this.showed == showed)
			return

		this.showed = showed;

		this.pageHtml.setShowing(showed);
	}

	setNeedIcon(value) {

		if(this.needIcon == value)
			return;

		if(value == undefined)
			return;

		this.needIcon = value;

		this.pageHtml.setNeedIcon(value);
	}

	setShowedIcon(icon) {

		if(this.showedIcon == icon)
			return;

		if(icon == undefined)
			return;

		this.showedIcon = icon;

		this.pageHtml.setShowedIcon(icon);
	}

	setHiddenIcon(icon) {

		if(this.hiddenIcon == icon)
			return;

		if(icon == undefined)
			return;

		this.hiddenIcon = icon;

		this.pageHtml.setHiddenIcon(icon);
	}

	setHeaderLabel(headerLabel) {

		if(Rex.undef(headerLabel, "headerLabelId")) return;

		if(this.headerLabel instanceof WidgetLabel)
			return;

		if(this.headerLabel == headerLabel)
			return;

		if(!(headerLabel instanceof WidgetLabel)) {

			let id = headerLabel;

			headerLabel = Rex.widgets && Rex.widgets[id];

			if(headerLabel == undefined) {

				this.headerLabel = id;

				return;
			}
		}

		this.headerLabel = headerLabel;

		this.pageHtml.setHeaderLabel(headerLabel.view);
	}

	setHeaderImage(headerImage) {

		if(Rex.undef(headerImage, "headerImage")) return;

		if(this.headerImage instanceof WidgetImage)
			return;

		if(this.headerImage == headerImage)
			return;

		if(!(headerImage instanceof WidgetImage)) {

			let id = headerImage;

			headerImage = Rex.widgets && Rex.widgets[id];

			if(headerImage == undefined) {

				this.headerImage = id;

				return;
			}
		}

		this.headerImage = headerImage;

		this.pageHtml.setHeaderImage(headerImage.view);
	}

	setContentWidget(contentWidget) {

		if(Rex.undef(contentWidget, "contentWidget")) return;

		if(this.contentWidget instanceof Widget)
			return;

		if(this.contentWidget == contentWidget)
			return;

		if(!(contentWidget instanceof Widget)) {

			let id = contentWidget;

			contentWidget = Rex.widgets && Rex.widgets[id];

			if(contentWidget == undefined) {

				this.contentWidget = id;

				return;
			}
		}

		this.contentWidget = contentWidget;

		this.pageHtml.setContentWidget(contentWidget.view);
	}

	setHeaderHeight(headerHeight) {

		if(Rex.undef(headerHeight, "headerHeight")) return;

		if(this.headerHeight == headerHeight)
			return;

		this.headerHeight = headerHeight;

		this.pageHtml.setHeaderHeight(headerHeight);
	}

	setContentHeight(contentHeight) {

		if(Rex.undef(contentHeight, "contentHeight")) return;

		if(this.contentHeight == contentHeight)
			return;

		this.contentHeight = contentHeight;

		this.pageHtml.setContentHeight(contentHeight);
	}

	setLabelWidth(labelWidth) {

		if(Rex.undef(labelWidth, "labelWidth")) return;

		if(this.labelWidth == labelWidth)
			return;

		this.labelWidth = labelWidth;

		this.pageHtml.setLabelWidth(labelWidth);
	}

	setImageWidth(imageWidth) {

		if(Rex.undef(imageWidth, "imageWidth")) return;

		if(this.imageWidth == imageWidth)
			return;

		this.imageWidth = imageWidth;

		this.pageHtml.setImageWidth(imageWidth);
	}

	appendChild(child) {

		let contentWidget = this.contentWidget;

		let childId = child.id;

		if(this.pageWidget == childId)
			return true;

		if(this.headerLabel == childId) {

			this.setHeaderLabel(child);

			return true;
		}

		if(this.headerImage == childId) {

			this.setHeaderImage(child);

			return true;
		}

		if(!(contentWidget instanceof Widget)) {

			if(contentWidget == childId) {

				this.setContentWidget(child);

				return true;
			}

		} else {

			if(contentWidget == child)
				return true;
		}

		return false;
	}

	setOnMouseDownHandler(handler) {

		if(Rex.undef(handler, "handler")) return;

		this.onClickHandler = handler;

		this.pageHtml.setOnMouseDownHandler(() => {handler();});
	}

	onToolboxResize() {

		this.pageHtml.onToolboxResize();
	}

}

class WidgetToolBoxPage extends Widget {

	constructor(state) {

		super(state);
	}

	createView() {

		this.view = new WidgetToolBoxPageHtml(this);
	}

}

/**
 * Created by prg-30 on 08.02.2017.
 * WidgetPopUpMenu
 * author : infernalBoy@inbox.ru
 */
	//FIXME ОСТОРОЖНО! ВОЗМОЖНО, ПРОЩЕ ЗАЮЗАТЬ МЕНЮ БРАУЗЕРА
class WidgetMenuItem extends Widget {
	
	constructor(state) {
		super(state);
		this.caption = "";
		this.press = false;
		this.iconAlign = 0;
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetMenuItemCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetMenuItemHtml(this);
		}
	}
	
	onCheckInit() {
		return this.children.length == 2;
	}
	
	onInit() {
		this.icon = Rex.widgets[this.children[0]];
		this.label = Rex.widgets[this.children[1]];
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		if(this.isHovered()) {
			this.press = false;
			Rex.callRpcMethod('Widgets', this.id, this.type, 'pressed', []);
		}
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		this.view.update();
		this.press = true;
	}
	
}

//WidgetInvestmentMenuItem
class WidgetInvestmentMenuItem extends Widget {
	
	constructor(state) {
		super(state);
		this.menuId = -1;
		this.caption = "";
		this.setState(state);
		this.press = false;
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetInvestmentMenuItemCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetInvestmentMenuItemHtml(this);
		}
	}
	
	onCheckInit() {
		return this.children.length == 2;
	}
	
	onInit() {
		this.icon = Rex.widgets[this.children[0]];
		this.label = Rex.widgets[this.children[1]];
	}
	
	onMouseUp(x, y, event) {
		let button = Rex.engine.translateMouseButton(event.which);
		if(event.which !== 1) return;
		this.view.onMouseUp(x, y, event);
	}
	
	onMouseDown(x, y, event) {
		let button = Rex.engine.translateMouseButton(event.which);
		if(event.which !== 1) return;
		this.press = true;
		if(Rex.gui === undefined) return;
		this.view.update();
		Rex.gui.reposition(this);
	}
	
	setVisible(v) {
		if(this.visible == v) return;
		this.visible = v;
		if(v === false) {
			let menu = Rex.widgets[this.menuId];
			if(menu === undefined) return;
			menu.setVisible(v);
		}
		Rex.callRpcMethod('Widgets', this.id, 'Widget', 'setVisible', [this.visible]);
	}
	
}

//WidgetPopUpMenu
class WidgetPopUpMenu extends Widget {
	
	constructor(state) {
		super(state);
		this.parentMenuId = -1;
		this.killMeFlag = false;
		
		
		this.itemWidth = 200;
		this.itemHeight = 25;
		if(Rex.gui != null && Rex.gui.menu == null) Rex.gui.menu = this;
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetPopUpMenuCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetPopUpMenuHtml(this);
		}
	}
	
}


/**
 * WidgetSpinBox
 */
	
class WidgetSpinBox extends Widget {
	
	constructor(state) {
		super(state);
		this.value = 0.0;
		this.step = 1.0;
		this.nodp = 0;
		this.oldValue = 0.0;
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetSpinBoxCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetSpinBoxHtml(this);
		}
	}

	onInit() {
		// this.input = Rex.widgets[this.children[0]];
	}

	onGenerateContent(content) {
		let widgetTable = content.table;
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);
		widgetTable.body.push([{margin: [0, 0, 0, 0]}]);

		let headerBody = widgetTable.body[0][0];
		let textBody = widgetTable.body[1][0];

		const html = this.view.htmlElement;
		const htmlSize = html.getBoundingClientRect();
		const headerHtml = this.view.headerElement;
		const headerSize = headerHtml.getBoundingClientRect();
		const textHtml = this.view.inputElement;
		const textSize = textHtml.getBoundingClientRect();

		let bWdith = parseInt(getStyle(html, 'borderWidth'));
		bWdith = isNaN(bWdith) ? 0 : bWdith;

		widgetTable.widths.push(htmlSize.width - bWdith * 2);
		widgetTable.heights.push(headerSize.height - bWdith);
		widgetTable.heights.push(textSize.height - bWdith);

		generateText(headerHtml, headerBody);
		generateText(textHtml, textBody);

		const background = getColorHEX(getStyle(html, 'background-color'));
		
		headerBody.fillColor = background;
		textBody.fillColor = background;
	}
	
	setValue(value) {
		if(value == this.value) return;
		this.value = !isNaN(value) ? value : 0;
		this.oldValue = !isNaN(value) ? value : 0;
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setValue', [this.value]);
	}
	
	keyPress(event) {
		if(event.key == "Enter") Rex.callRpcMethod('Widgets', this.id, this.type, 'setValue', [this.value]);
	}
	
	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y, event);
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp(x, y, event)
	}
	
	onMouseWheel(value) {
		this.view.onMouseWheel(value);
	}
	
}

class WidgetDialog extends Widget {
	
	constructor(state) {
		super(state);
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetDialogCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetDialogHtml(this);
		}
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp(x, y, event);
	}
	
	keyDown(event) {
		if(event.which == 13) { // Enter
			Rex.callRpcMethod('Widgets', this.id, this.type, "onPressButton", ["Enter"]);
		} else if(event.which == 27) { // Escape
			Rex.callRpcMethod('Widgets', this.id, this.type, "onPressButton", ["Escape"]);
		}
	}
	
}

class WidgetHelper extends Widget {
	
	constructor(state) {
		super(state);
		this.text = "";
		this.targetWidget = null;
		this.posXHelper = 300;
		this.posYHelper = 300;
		this.blockPress = true;
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetHelperHtml(this);
		}
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp(x, y, event);
	}
	
	keyDown(event) {
		if(event.which == 13) { // Enter
			Rex.callRpcMethod('Widgets', this.id, this.type, "onPressButton", ["Enter"]);
		} else if(event.which == 27) { // Escape
			Rex.callRpcMethod('Widgets', this.id, this.type, "onPressButton", ["Escape"]);
		}
	}
	
}


let LOCALE_TUT_VAM_NE_ZDES = "ru";

class WidgetDialogClassification extends RexObject {
	
	constructor(state) {
		super(state);
		this.longOID = '';
		this._$header = '';
		this._$showed = 0;
		
		this.view =  {
			draw:function(){},
			checkSelect:function(){},
			destroy:function(){}
		};
		
		this.classificator = new RexClassificatorsController();
		
		if(Rex.webScene == null) {
			Rex.webScene = new WebScene();
			//Rex.webScene.generateConstructor();
		}
		if(Rex.engine == null){
			Rex.engine = new Engine();
		}
		this.setState(state);
	}
	
	setState(state){
		if(state != null){
			// if (state.header) this.header = state.header;
			// if (state.showed) this.showed= state.showed;
			
			Rex.copy(this, state);
		}
	}
	
	set header(value){
		if((value == null) || (this.raw_header == value)) return;
		this.raw_header = value;
		try {
			this._$header = decodeURIComponent(escape(window.atob(value)));
		}
		catch(e) {
			console.log(this.type, "setState->", "Text DecodeError!", e, value);
		}
	}
	
	get header(){
		return this._$header;
	}
	
	set showed(value){
		if(this._$showed == value) return;
		let dialog = new RexClassificationDialog(this, this._$header);
	}
	
	get showed() {
		return this._$showed;
	}
	
	changePage(oid, name) {
		this.longOID = oid;
		Rex.callRpcMethod('Widgets', this.id, this.type, 'onChangePage', [this.longOID, name]);
	}
	
	selected(oid, name){
		this.longOID = oid;
		Rex.callRpcMethod('Widgets', this.id, this.type, 'onSelected', [this.longOID, name]);
	}
	
}

/*
все что ниже - кусок выдернутый из RexWebTop
 */


/** элемент классификации. может ссылаться на другой лист или быть конечным*/
class RexClassificatorItem {
	constructor(list = undefined, item = undefined){
		this.plist = list;
		this.name = "";
		this.numid = "0";
		this.cid = "";
		this._ref_cid = "";
		this.wiki_ref = "";
		this.isLeaf = true;
		this.__$list = undefined;
		
		if(item) this._$load(item);
	}
	_$load(item){
		if(!(item.name)){
			console.error("fail load ClassificatorItem", this.plist, item);
			return;
		}
		
		this.name = item.name;
		if (item.leaf_id){
			this.cid = item.leaf_id.$oid;
			this.isLeaf = true;
		} else {
			this.cid = item.child_id.$oid;
			this.isLeaf = false;
		}
		
		this._ref_cid = item._ref_cid;
	}
	
	get list(){
		if(this.isLeaf) return undefined;
		
		if (!this.__$list) {
			let ret = RexSyncPost("api/category", {local: LOCALE_TUT_VAM_NE_ZDES, _id: this.cid});
			if(ret && ret._id && ret.meta && ret.layer) {
				this.__$list = new RexClassificatorList(this, ret);
			}
		}
		return this.__$list;
	}
	
	get pathId(){
		let ret = "";
		if (this.plist && this.plist.parentItem){
			ret += this.plist.parentItem.pathId + ".";
		}
		return ret + this.cid;
	}
	
}

/** лист классификации. типа одна нода дерева */
class RexClassificatorList {
	constructor(parentItem,file){
		this.parentItem = parentItem;
		this.id = null;
		this.name = null;
		this.layer = [];
		if (file) this._$load(file);
	}
	
	_$load(file){
		if (!(file && file._id && file.meta && Array.isArray(file.layer))) {
			console.error("not valid ClassificatorList", file);
			return;
		}
		this.id = file._id.$oid;
		this.name = file.meta.name;
		for (let item of file.layer){
			this.layer.push(new RexClassificatorItem(this, item));
		}
	}
	
	get childs(){
		return this.layer;
	}
	
	getList(n){
		if (n>=0 && n<this.layer.length){
			return this.layer[n].list;
		}
		return undefined;
	}
	
}

class RexMainClassificator extends RexClassificatorItem{
	constructor(id,name,is_user){
		super(undefined,{id,name,is_user});
	}
	
	_$load(item){
		this.cid = item.id;
		this.name = item.name;
		this.is_user = item.is_user;
		this.isLeaf = false;
	}
}

class RexClassificatorsController extends BaseObject {
	constructor(){
		super();
		this.public = undefined;
		this.private = undefined;
	}
	
	get publicList(){
		if (!this.public){
			this._$loadPublic();
		}
		return this.public;
	}
	
	get privateList(){
		if (!this.private){
			this._$loadPrivate();
		}
		return this.private;
	}
	
	get allList(){
		return this.publicList.concat(this.privateList)
	}
	
	_$loadPublic(){
		this.public = [];
		let ret = RexSyncPost("api/categories", {local : LOCALE_TUT_VAM_NE_ZDES});
		if(Array.isArray(ret)){
			for(let item of ret){
				this.public.push(new RexMainClassificator(item._id,item.name,false));
			}
		}
	}
	
	_$loadPrivate(){
		this.private = [];
		let ret = RexSyncPost("api/categories_test", {local : LOCALE_TUT_VAM_NE_ZDES});
		if(Array.isArray(ret)){
			for(let item of ret){
				if (item._id && item._id.$oid && item.meta && item.meta.name)
					this.private.push(new RexMainClassificator(item._id.$oid,item.meta.name,true));
			}
		}
	}
	
	static getClassificationName(long_id){
		let ret = RexSyncPost("api/category_name", { local : LOCALE_TUT_VAM_NE_ZDES, category : long_id });
		if (ret && Array.isArray(ret) && ret[0] && ret[0].name){
			return ret[0].name;
		}
		return undefined;
	}
	
}

/**
 * диалог добавления классификации.
 */
class RexClassificationDialog extends BaseObject{
	constructor(parent, header){
		super();
		this.parent = parent;
		
		this.list = new WebWidgetScrollArea();
		this.list.setMinHeight(400);
		
		this.htmlElement = WebWidgetDialog.create("select category",this.list,['current','close']);
		this.htmlElement.setAutoClose(false);
		this.connect(this.htmlElement,"onAccept",this.close);
		
		this.htmlElement.setMinMaxGeometry(500,500,600,600);
		
		this.array_id = [];
		
		this.select({cid:null,name:header});
	}
	
	close(btnname,w){
		if(btnname === 'close') this.htmlElement.destroy();
		if(btnname === 'current') this.choose(this.array_id[this.array_id.length-1]);
	}
	
	/**
	 * возвращение назад
	 * @param item на какой уровень назад
	 */
	back(item){
		for (let i = 0; i< this.array_id.length; i++){
			let pitem = this.array_id[i];
			if (item.cid === pitem.cid){
				this.array_id.splice(i, this.array_id.length - i);
				this.select(item);
				return;
			}
		}
	}
	
	/**
	 * переход к выбранному уровню.
	 * если итем.cid нету, то отобразится списк классификаций
	 * @param item
	 */
	select(item){
		if (item === undefined) return;
		this.clear(); //очищаем лист
		this.array_id.push(item); //добавляем итем в историю
		this.createHistory(); //создаем историю
		this.parent.changePage(item.pathId, item.name);
		if(item.cid){
			let list = item.list;
			if (list){
				for (let item of list.childs){
					this.addButton(item);	//накидываем в лист итемов
				}
			}
		}
		else { //если cid нету, создаем список классификаций
			let list = this.parent.classificator.publicList;
			for (let item of list){
				this.addButton(item);
			}
			let list2 = this.parent.classificator.privateList;
			for (let item of list2){
				this.addButton(item);
			}
		}
	}
	
	/**
	 * добавление классификации, закрытие окна
	 * @param item
	 */
	choose(item){
		this.htmlElement.destroy();
		this.parent.selected(item.pathId,item.name);
	}
	
	/**
	 * создание пути до текущего уровня классификации
	 * @private
	 */
	createHistory(){
		let h = new WebWidgetLayoutVertical(this.list.getContentLayout());
		for (let item of this.array_id){
			let a = new WebWidgetButton(h);
			a.setText(item.name);
			a.setMaxHeight(36);
			// a._$label.setTextAlign(WidgetHorizontalAlign.Left);
			// a._$label.setPadding(5,0,0,0);
			this.connect(a,"onPress",(f)=>{
				if(!f) return;
				this.back(item);
			});
		}
	}
	
	/**
	 * добавление итема классификации в текущий лист
	 * @param item
	 * @private
	 */
	addButton(item){
		let a = new WebWidgetButton(this.list.getContentLayout());
		a.setStyleName("WidgetButtonWithoutbackground");
		a.setMaxHeight(36);
		a.setText(item.name);
		// a._$label.setTextAlign(WidgetHorizontalAlign.Left);
		this.connect(a,"onPress",(f)=>{
			if(!f) return;
			if (item.isLeaf) this.choose(item);
			else this.select(item);
		});
	}
	
	clear(){
		this.list.getContentLayout().cleanWidget();
	}
	
}

function RexSyncPost(method, params){
	let request = new XMLHttpRequest();
	request.withCredentials = true;
	request.async = false;
	
	let response = undefined;
	request.onerror = (e)=>{response = e};
	request.onload = (e)=>{response = e};
	request.ontimeout = (e)=>{response = e};
	
	request.open("Post", "http:/" + "/192.168.10.71/"+method, false);
	request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
	
	let data="";
	for(let key in params){
		if(data.length!=0) data+="&";
		data+=`${key}=${params[key]}`;
	}
	request.send(data);
	try {
		response = response.target.response;
		response = JSON.parse(response);
	} catch(e) {
		response = undefined;
	}
	return response;
}

/**
 * WidgetSpacer
 */
	
class WidgetSpacer extends Widget {
	
	constructor(state) {
		super(state);
		this.depress = true;
		this.orientation = 0;
		this.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetSpacerCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetSpacerHtml(this);
		}
	}
	
};


/* eslint-disable no-unused-vars */
/* global Widget ConstructorCanvas WidgetConstructorHtml Rex*/

/**
 * Created by prg-30 on 15.02.2017.
 */

// Вспомогательный класс для контроля координат мыши
class MouseConstructor {
	constructor() {
		
		this.posX = 0;
		this.posY = 0;
		
		this.clearPos();
	}
	
	clearPos() {
		// Последняя позиция при перемещении
		this.oldPosX = null;
		this.oldPosY = null;
		
		// Позиции при нажатии и отжатии
		this.downWPosX = null;
		this.downWPosY = null;
		this.downWW = null;
		this.downWH = null;
		
		this.upWPosX = null;
		this.upWPosY = null;
		this.upWW = null;
		this.upWH = null;
		
		this.fGeoms = [];
		
		this.startAlignX = null;
		this.startAlignY = null;
		
		this.leftButtonPressed = false;
		this.rightButtonPressed = false;
		this.middleButtonPressed = false;
	}
	
	setPos(x, y) {
		this.posX = x;
		this.posY = y;
	}
	
	setOldPos(x, y) {
		this.oldPosX = x;
		this.oldPosY = y;
	}
	
	setDownWPos(posx, posy, w, h, x, y) {
		this.downWPosX = posx;
		this.downWPosY = posy;
		
		this.downWW = w;
		this.downWH = h;
		
		this.pressDiffWidgetX = x - posx;
		this.pressDiffWidgetY = y - posy;
	}
	
	setEvent(event, bool) {
		switch(event.button) {
			case 0:
				this.leftButtonPressed = bool;
				break;
			case 1:
				this.middleButtonPressed = bool;
				break;
			case 2:
				this.rightButtonPressed = bool;
				break;
		}
	}

}

// Вспомогательный класс для области выделения
class SelectionArea {
	constructor() {
		this.removeData();
	}
	
	setPos1(x, y) {
		this.selectAreaX1 = x;
		this.selectAreaY1 = y;
	}
	
	setPos2(x, y) {
		this.selectAreaX2 = x;
		this.selectAreaY2 = y;
	}
	
	removeData() {
		this.selectedArea = false;
		this.selectAreaX1 = 0;
		this.selectAreaY1 = 0;
		this.selectAreaX2 = 0;
		this.selectAreaY2 = 0;
	}
	
	mouseDown(x, y) {
		this.selectedArea = true;
		this.setPos1(x, y);
		this.setPos2(x, y);
	}
}

class Constructor extends Widget {
	
	constructor(state) {
		super(state);
		this.hoveredWidget = undefined;
		this.focusedWidgets = [];
		
		this.mouse = new MouseConstructor();
		this.selectionArea = new SelectionArea();
		
		this.needResize = -1;
		this.cursorType = ["nw-resize", "w-resize", "sw-resize", "ns-resize", "ns-resize", "ne-resize", "e-resize", "nw-resize", "default", "move"];
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new ConstructorCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetConstructorHtml(this);
		}
	}
	
	// Свойство (сохранение позиций)
	get needSavePos(){
		return true
	}
	
	// Перемещение курсора на виджете
	onMouseMove(x, y, event) {
		if(!this.isEditable()) return;
		
		
		let hElem = this.view.htmlElement;
		if(hElem != null) {
			x += hElem.scrollLeft;
			y += hElem.scrollTop;
			
		}
		
		if(this.mouse.oldPosX == x && this.mouse.oldPosY == y) return;
		this.mouse.setPos(x, y);
		
		// Проверка/получение на HOVER
		if(!this.mouse.leftButtonPressed) 
			this.checkHover(x, y, event);
		
		// Изменение области выделения
		if(this.selectionArea.selectedArea) this.selectionArea.setPos2(x, y);
		
		if(this.needResize != -1) {
			// RESIZING WIDGETS
			this.resizeFocusedWidgets(x, y);
		} else {
			// MOVING WIDGETS
			this.movingFocusedWidgets(x, y);
		}
		
		// SAVE OLD POS
		this.mouse.setOldPos(x, y);
		this.view.updateFocusedWidgets();
	}
	
	// Нажатие мыши
	onMouseDown(x, y, event) {
		
		this.mouse_down_pos = [x, y];
		
		if(!this.isEditable()) return;
		
		let hElem = this.view.htmlElement;
		if(hElem != null) {
			x += hElem.scrollLeft;
			y += hElem.scrollTop;
		}
		
		this.mouse.setEvent(event, true);
		
		// Необходимо для перемещения массива виджетов
		this.mouse.setOldPos(x, y);
		
		if (this.view.gridStyle == 1)
			this.view.makeGrid();
		
		// Если курсор не на виджете, начинается выделение области
		if(this.hoveredWidget === undefined) {
			this.focusedWidgets = [];
			this.selectionArea.mouseDown(x, y);
			this.view.updateFocusedWidgets();
			return;
		}
		
		// Выделение одного виджета
		if(this.hoveredWidget !== undefined) {
			this.mouse.setDownWPos(this.hoveredWidget.aPosX, this.hoveredWidget.aPosY, this.hoveredWidget.width, this.hoveredWidget.height, x, y);
			if(this.focusedWidgets.length == 0 || !this.hasInSelectionsWidgets(this.hoveredWidget)) {
				// Формируем массив с индексами виджетов
				this.focusedWidgets = [this.hoveredWidget];
				let arr = [this.hoveredWidget.id];
				Rex.callRpcMethod("Widgets", this.id, this.type, "setFocusedWidgetsById", [JSON.stringify(arr)]);
				this.view.updateFocusedWidgets();
				return;
			}
		}
		
		this.checkResizeFocusedWidgets(event);
		if(this.needResize != -1) {
			// Для изменения размеров - временно сохраняем начальную геометрию
			for(let i = 0; i < this.focusedWidgets.length; ++i) {
				if(this.focusedWidgets[i] == null) continue;
				this.mouse.fGeoms.push([this.focusedWidgets[i].view.posX, this.focusedWidgets[i].view.posY, this.focusedWidgets[i].width, this.focusedWidgets[i].height]);
			}
		}
		
	}
	
	onMouseUp(x, y, event) {
		this.mouse.setEvent(event, false);
		
		let hElem = this.view.htmlElement;
		if(hElem != null) {
			x += hElem.scrollLeft;
			y += hElem.scrollTop;
		}
		
		// Отправка смещения при перемещении
		if(this.needResize == -1) this.sendMovePositions();
		else this.sendResizePositions();
		
		// Очистка временных значений
		this.mouse.clearPos();
		this.view.clearAlignment();
		this.needResize = -1;
		
		if(this.view.gridStyle == 0 || this.view.gridStyle == 1) this.view.removeGrid();
		
		// Проверка на выделение области
		if(this.selectionArea.selectedArea == 1) this.checkSelectionArea();
		
		const property_error = 5
		if (Math.abs(this.mouse_down_pos[0] - x) <= property_error && Math.abs(this.mouse_down_pos[0] - x) <= property_error) {
			Rex.callRpcMethod("Widgets", this.id, this.type, "checkProperty", []);
		}
		
		this.view.updateFocusedWidgets();
	}
	
	// Проверка наведенного виджета
	//TODO FIST SEARCH IN FOCUSED WIDGETS
	checkHover(x, y, event) {
		let hoverWidget = undefined;
		const path = event.path || (event.composedPath && event.composedPath());
		for(let key = this.children.length - 1; key > -1; --key) {
			let w = Rex.widgets[this.children[key]];
			if(w !== undefined) {
				let error = 10;

				event == null;
				if(event != null && path != null) {
					for(let el of path) {
						if(el == null || el.id == null) continue;

						let ID = el.id;
						try {
							if (el.id.indexOf("w") === 0) {
								ID = (el.id.slice(1));
							}
						} catch(e) {}

						let el_id1 = ID.replace("ConstructorHoveredWidget_", "");
						let el_id2 = ID.replace("Border" + this.id + "For", "");
						if(el_id1 == w.id || el_id2 == w.id)
							hoverWidget = w;
					}
					
				} else if (((y - this.aPosY) < (w.posY + w.height) + error) &&
							((y - this.aPosY) > w.posY - error) &&
							((x - this.aPosX) < (w.posX + w.width) + error) &&
							((x - this.aPosX) > w.posX - error)) {
					hoverWidget = w;
				}
				if(hoverWidget !== undefined) {
					this.hoveredWidget = hoverWidget;
					Rex.callRpcMethod("Widgets", this.id, this.type, "setHoveredWidgetById", [hoverWidget.id]);
					return;
				}
			}
		}
		if(hoverWidget === undefined && this.hoveredWidget !== undefined) {
			this.hoveredWidget = undefined;
			Rex.callRpcMethod("Widgets", this.id, this.type, "setHoveredWidgetById", [-1]);
		}
	}
	
	// Обработка выделенной области (выделение виджетов)
	checkSelectionArea() {

		let minSx = Math.min(this.selectionArea.selectAreaX1, this.selectionArea.selectAreaX2) - this.aPosX;
		let minSy = Math.min(this.selectionArea.selectAreaY1, this.selectionArea.selectAreaY2) - this.aPosY;
		let maxSx = Math.max(this.selectionArea.selectAreaX1, this.selectionArea.selectAreaX2) - this.aPosX;
		let maxSy = Math.max(this.selectionArea.selectAreaY1, this.selectionArea.selectAreaY2) - this.aPosY;

		for(let key = this.children.length - 1; key > -1; --key) {
			let w = Rex.widgets[this.children[key]];
			if(w !== undefined) {
				// if(!(minSy > w.posY + w.height || maxSy < w.posY || minSx > w.posX + w.width || maxSx < w.posX)) 
				if(!(minSy > w.view.htmlElement.offsetTop + w.view.htmlElement.clientHeight || 
					maxSy < w.view.htmlElement.offsetTop || 
					minSx > w.view.htmlElement.offsetLeft + w.view.htmlElement.clientWidth || 
					maxSx < w.view.htmlElement.offsetLeft)) 
					this.focusedWidgets.push(w);
			}
		}
		this.selectionArea.removeData();
		
		if(this.focusedWidgets !== undefined && this.focusedWidgets.length > 0) {
			// Формируем массив с индексами виджетов
			let arr = [];
			for(let i = 0; i < this.focusedWidgets.length; i++) arr.push(this.focusedWidgets[i].id);
			// Преобразовываем массив в строку и отправляем на сервер
			Rex.callRpcMethod("Widgets", this.id, this.type, "setFocusedWidgetsById", [JSON.stringify(arr)]);
		}
		else {
			this.needResize = -1;
			Rex.callRpcMethod("Widgets", this.id, this.type, "setFocusedWidgetById", [-1]);
		}
	}
	
	// Проверка наличия виджета в массиве
	hasInSelectionsWidgets(widget) {
		if(widget == null) return false;
		for(let i = 0; i < this.focusedWidgets.length; ++i) {
			if(this.focusedWidgets[i].id == widget.id) 
				return true;
		}
		return false;
	}
	
	getSelectionAlignment(x, y) {
		if(!this.view.alignWidgets) return null;
		
		let W = this.hoveredWidget;
		if(!W) return null;
		
		let align = {};
		
		for(let i = 0; i < this.children.length; ++i) {
			let child = null;
			
			// Если чилды кончились - берем конструктор(границы)
			if(i < this.children.length) child = Rex.widgets[this.children[i]];
			//else child = Rex.widgets[this.id];
			
			if(child == null) continue;
			
			// Проверка на наличие чилда в массиве выделенных виджетов
			// (чтобы выделенные виджеты не выравнивались между собой)
			if(W.id != child.id && !this.hasInSelectionsWidgets(child)) {
				
				let tempAlignV = this.getAlignmentVertical(W, child, x);
				let tempAlignH = this.getAlignmentHorizontal(W, child, y);
				
				// Если еще нет - добавим (Первое найденное выравнивание)
				if(align.V == null && tempAlignV != null) align.V = tempAlignV;
				if(align.H == null && tempAlignH != null) align.H = tempAlignH;
				
				// Выравнивание по Х
				if(tempAlignV != null) {
					if(tempAlignV.alignmentDiff < align.V.alignmentDiff) align.V = tempAlignV;
				}
				// Выравнивание по Y
				if(tempAlignH != null) {
					if(tempAlignH.alignmentDiff < align.H.alignmentDiff) align.H = tempAlignV;
				}
			}
		}
		
		if(align.H == null && align.V == null) return null;
		return align;
	}
	
	// Получение вертикального (ПО ОСИ X) выравнивания между двумя виджетами
	getAlignmentVertical(w1, w2, x) {
		// ПРЕДПОЛАГАЕМО:
		// W1 - перемещаемый виджет (тот что под курсором мыши)
		// W2 - стабильный виджет (тот с кем происходит сравнение)
		
		let w1LeftPosX = w1.posX;
		let w2LeftPosX = w2.posX;
		let w1RightPosX = w1.posX + w1.width;
		let w2RightPosX = w2.posX + w2.width;
		
		let result = {};
		result.w1 = w1;
		result.w2 = w2;
		
		if(x != null) {
			if(((w2LeftPosX - this.view.errorWidgetsAlign) < x) && ((w2LeftPosX + this.view.errorWidgetsAlign) > x)) {
				// Первое условие : начало w1 попадает в начало w2
				result.alignmentPos = w2LeftPosX;
				result.aligned = w1LeftPosX;
				result.alignmentDiff = (w2LeftPosX - w1LeftPosX);
			} else if((((w2RightPosX) - this.view.errorWidgetsAlign) < (x)) && (((w2RightPosX) + this.view.errorWidgetsAlign) > (x))) {
				// Четвертое условие : конец w1 попадает в конец w2
				result.alignmentPos = w2RightPosX;
				result.aligned = w1RightPosX;
				result.alignmentDiff = (w2RightPosX - w1RightPosX);
			}
		} else {
			if(((w2LeftPosX - this.view.errorWidgetsAlign) < w1LeftPosX) && ((w2LeftPosX + this.view.errorWidgetsAlign) > w1LeftPosX)) {
				// Первое условие : начало w1 попадает в начало w2
				result.alignmentPos = w2LeftPosX;
				result.aligned = w1LeftPosX;
				result.alignmentDiff = (w2LeftPosX - w1LeftPosX);
			} else if(((w2LeftPosX - this.view.errorWidgetsAlign) < (w1RightPosX)) && ((w2LeftPosX + this.view.errorWidgetsAlign) > (w1RightPosX))) {
				// Второе условие : конец w1 попадает в начало w2
				result.alignmentPos = w2LeftPosX;
				result.aligned = w1RightPosX;
				result.alignmentDiff = (w2LeftPosX - w1RightPosX);
			} else if(((w2RightPosX - this.view.errorWidgetsAlign) < (w1LeftPosX)) && (((w2RightPosX) + this.view.errorWidgetsAlign) > (w1LeftPosX))) {
				// Третье условие : начало w1 попадает в конец w2
				result.alignmentPos = w2RightPosX;
				result.aligned = w1LeftPosX;
				result.alignmentDiff = (w2RightPosX - w1LeftPosX);
			} else if((((w2RightPosX) - this.view.errorWidgetsAlign) < (w1RightPosX)) && (((w2RightPosX) + this.view.errorWidgetsAlign) > (w1RightPosX))) {
				// Четвертое условие : конец w1 попадает в конец w2
				result.alignmentPos = w2RightPosX;
				result.aligned = w1RightPosX;
				result.alignmentDiff = (w2RightPosX - w1RightPosX);
			}
		}
		
		if(result.alignmentPos != null) return result; 
		else return null;
	}
	
	// Получение горизонтального (ПО ОСИ Y) выравнивания между двумя виджетами
	getAlignmentHorizontal(w1, w2, y) {
		// ПРЕДПОЛАГАЕМО:
		// W1 - перемещаемый виджет (тот что под курсором мыши)
		// W2 - стабильный виджет (тот с кем происходит сравнение)
		
		let w1TopPosY = w1.posY;
		let w2TopPosY = w2.posY;
		let w1BottomPosY = w1.posY + w1.height;
		let w2BottomPosY = w2.posY + w2.height;
		
		let result = {};
		result.w1 = w1;
		result.w2 = w2;
		
		if(y != null) {
			if(((w2TopPosY - this.view.errorWidgetsAlign) < y) && ((w2TopPosY + this.view.errorWidgetsAlign) > y)) {
				// Первое условие : верхняя граница w1 попадает в верхнюю границу w2
				result.alignmentPos = w2TopPosY;
				result.aligned = w1TopPosY;
				result.alignmentDiff = (w2TopPosY - w1TopPosY);
			} else if((((w2BottomPosY) - this.view.errorWidgetsAlign) < (y)) && (((w2BottomPosY) + this.view.errorWidgetsAlign) > (y))) {
				// Четвертое условие : конец w1 попадает в конец w2
				result.alignmentPos = w2BottomPosY;
				result.aligned = w1BottomPosY;
				result.alignmentDiff = (w2BottomPosY - w1BottomPosY);
			}
		} else {
			if(((w2TopPosY - this.view.errorWidgetsAlign) < w1TopPosY) && ((w2TopPosY + this.view.errorWidgetsAlign) > w1TopPosY)) {
				// Первое условие : верхняя граница w1 попадает в верхнюю границу w2
				result.alignmentPos = w2TopPosY;
				result.aligned = w1TopPosY;
				result.alignmentDiff = (w2TopPosY - w1TopPosY);
			} else if(((w2TopPosY - this.view.errorWidgetsAlign) < (w1BottomPosY)) && ((w2TopPosY + this.view.errorWidgetsAlign) > (w1BottomPosY))) {
				// Второе условие : конец w1 попадает в начало w2
				result.alignmentPos = w2TopPosY;
				result.aligned = w1BottomPosY;
				result.alignmentDiff = (w2TopPosY - w1BottomPosY);
			} else if(((w2BottomPosY - this.view.errorWidgetsAlign) < (w1TopPosY)) && (((w2BottomPosY) + this.view.errorWidgetsAlign) > (w1TopPosY))) {
				// Третье условие : начало w1 попадает в конец w2
				result.alignmentPos = w2BottomPosY;
				result.aligned = w1TopPosY;
				result.alignmentDiff = (w2BottomPosY - w1TopPosY);
			} else if((((w2BottomPosY) - this.view.errorWidgetsAlign) < (w1BottomPosY)) && (((w2BottomPosY) + this.view.errorWidgetsAlign) > (w1BottomPosY))) {
				// Четвертое условие : конец w1 попадает в конец w2
				result.alignmentPos = w2BottomPosY;
				result.aligned = w1BottomPosY;
				result.alignmentDiff = (w2BottomPosY - w1BottomPosY);
			}
		}
		
		if(result.alignmentPos != null) return result;
		else return null;
	}
	
	// Проверка на необходимость изменения размера 
	checkResizeFocusedWidgets(event) {
		if(this.hoveredWidget == null) return;
		if(!this.hasInSelectionsWidgets(this.hoveredWidget)) return;
		this.needResize = -1;
		
		let e = 5;
		// let x = this.hoveredWidget.aPosX;
		// let y = this.hoveredWidget.aPosY;
		// let w = this.hoveredWidget.aPosX + this.hoveredWidget.width;
		// let h = this.hoveredWidget.aPosY + this.hoveredWidget.height;

		let x = this.hoveredWidget.view.htmlElement.offsetLeft;
		let y = this.hoveredWidget.view.htmlElement.offsetTop;
		let w = this.hoveredWidget.view.htmlElement.offsetLeft + this.hoveredWidget.view.htmlElement.clientHeight;
		let h = this.hoveredWidget.view.htmlElement.offsetTop + this.hoveredWidget.view.htmlElement.clientHeight;
		
		let Areas = [
			[x - e, y - e, x + e, y + e, 0, "XY"],	//XY
			[w - e, y - e, w + e, y + e, 2, "WY"],	//WY
			[w - e, h - e, w + e, h + e, 4, "WH"],	//WH
			[x - e, h - e, x + e, h + e, 6, "XH"],	//XH
			[x + e, y - e, w - e, y + e, 1, "T"],	//TOP
			[w - e, y + e, w + e, h - e, 3, "R"],	//RIGHT
			[x + e, h - e, w - e, h + e, 5, "B"],	//BOTTOM
			[x - e, y + e, x + e, h - e, 7, "L"]		//LEFT
		];
		const path = event.path || (event.composedPath && event.composedPath());
		for(let i = 0; i < Areas.length; ++i) {
			let x = this.mouse.posX;
			let y = this.mouse.posY;

			if(event != null && path != null) {

				for(let el of path) {
					if(el == null || el.className == null) continue;
					if(el.className == "BorderPoints " + Areas[i][5]) {
						this.needResize = Areas[i][4];
						return;
					}
				}
			} else if((y < Areas[i][3]) && (y > Areas[i][1]) && (x < Areas[i][2]) && (x > Areas[i][0])) {
				this.needResize = Areas[i][4];
				return;
			}
		}
	}
	
	// Изменение размеров
	resizeFocusedWidgets(x, y) {
		if(this.focusedWidgets.length == 0 || !this.mouse.leftButtonPressed || this.needResize == -1)  return;
		if(!this.hasInSelectionsWidgets(this.hoveredWidget)) return;
		
		// ALIGNMENT
		let alignment = this.getSelectionAlignment(x - this.aPosX, y - this.aPosY);
		
		let DX = 0;
		let DY = 0;
		let DWidth = 0;
		let DHeight = 0;
		
		let dG = {x:0, y:0};
		
		// Получение смещения в зависимости от точки
		switch(this.needResize) {
			case 0 : // TOP LEFT
				DX = x - (this.mouse.downWPosX);
				DWidth = -(x - (this.mouse.downWPosX));
				DY = y - (this.mouse.downWPosY);
				DHeight = -(y - (this.mouse.downWPosY));
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + DX), (this.hoveredWidget.view.posY + DY));
				DX -= dG.x;
				DY -= dG.y;
				DWidth 	+= dG.x;
				DHeight += dG.y;
				
				if(alignment != null && alignment.V != null) {
					DX = alignment.V.alignmentPos - (this.mouse.downWPosX - this.hoveredWidget.aPosX + this.hoveredWidget.posX);
					DWidth = -DX;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.removeVerticalAlignment();
				}
				
				if(alignment != null && alignment.H != null) {
					DY = alignment.H.alignmentPos - (this.mouse.downWPosY - this.hoveredWidget.aPosY + this.hoveredWidget.posY);
					DHeight = -DY;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.removeHorizontalAlignment();
				}
				
				break;
			case 1 : // TOP
				
				DY = y - (this.mouse.downWPosY);
				DHeight = -(y - (this.mouse.downWPosY));
				
				dG = this.getDeltaByGrid(0, (this.hoveredWidget.view.posY + DY));
				DY -= dG.y;
				DHeight += dG.y;
				
				if(alignment != null && alignment.H != null) {
					DY = alignment.H.alignmentPos - (this.mouse.downWPosY - this.hoveredWidget.aPosY + this.hoveredWidget.posY);
					DHeight = -DY;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.clearAlignment();
				}
				
				break;
			case 2 : // TOP RIGHT
				DY = y - (this.mouse.downWPosY);
				DHeight = -(y - (this.mouse.downWPosY));
				DWidth = (x - (this.mouse.downWPosX + this.mouse.downWW));
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + this.hoveredWidget.view.width + DWidth), (this.hoveredWidget.view.posY + DY));
				DY -= dG.y;
				DHeight += dG.y;
				DWidth 	-= dG.x;
				
				if(alignment != null && alignment.H != null) {
					DY = alignment.H.alignmentPos - (this.mouse.downWPosY - this.hoveredWidget.aPosY + this.hoveredWidget.posY);
					DHeight = -DY;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.removeHorizontalAlignment();
				}
				
				if(alignment != null && alignment.V != null) {
					DWidth = alignment.V.alignmentPos - this.hoveredWidget.posX - this.mouse.downWW;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.removeVerticalAlignment();
				}
				
				break;
			case 3 : // RIGHT
				DWidth = x - (this.mouse.downWPosX + this.mouse.downWW);
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + this.hoveredWidget.view.width + DWidth), 0);
				DWidth -= dG.x;
				
				if(alignment != null && alignment.V != null) {
					DWidth = alignment.V.alignmentPos - this.hoveredWidget.posX - this.mouse.downWW;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.clearAlignment();
				}
				
				break;
			case 4 : // BOTTOM RIGHT
				DWidth = x - (this.mouse.downWPosX + this.mouse.downWW);
				DHeight = y - (this.mouse.downWPosY + this.mouse.downWH);
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + this.hoveredWidget.view.width + DWidth), (this.hoveredWidget.view.posY + this.hoveredWidget.view.height + DHeight));
				DWidth -= dG.x;
				DHeight -= dG.y;
				
				if(alignment != null && alignment.V != null) {
					DWidth = alignment.V.alignmentPos - this.hoveredWidget.posX - this.mouse.downWW;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.removeVerticalAlignment();
				}
				
				if(alignment != null && alignment.H != null) {
					DHeight = alignment.H.alignmentPos - this.hoveredWidget.posY - this.mouse.downWH;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.removeHorizontalAlignment();
				}
				
				break;
			case 5 : // BOTTOM
				DHeight = y - (this.mouse.downWPosY + this.mouse.downWH);
				
				dG = this.getDeltaByGrid(0, (this.hoveredWidget.view.posY + this.hoveredWidget.view.height + DHeight));
				DHeight -= dG.y;
				
				if(alignment != null && alignment.H != null) {
					DHeight = alignment.H.alignmentPos - this.hoveredWidget.posY - this.mouse.downWH;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.clearAlignment();
				}
				
				break;
			case 6 : // BOTTOM LEFT
				DX = (x - this.mouse.downWPosX);
				DWidth = -(x - this.mouse.downWPosX);
				DHeight = (y - this.mouse.downWPosY - this.mouse.downWH);
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + DX), (this.hoveredWidget.view.posY + this.hoveredWidget.view.height + DHeight));
				DX -= dG.x;
				DWidth += dG.x; 
				DHeight -= dG.y;
				
				if(alignment != null && alignment.V != null) {
					DX = alignment.V.alignmentPos - (this.mouse.downWPosX - this.hoveredWidget.aPosX + this.hoveredWidget.posX);
					DWidth = -DX;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.removeVerticalAlignment();
				}
				
				if(alignment != null && alignment.H != null) {
					DHeight = alignment.H.alignmentPos - this.hoveredWidget.posY - this.mouse.downWH;
					this.view.makeHorizontalAlignment(alignment.H);
				} else {
					this.view.clearAlignment();
				}
				break;
			case 7 : // LEFT
				DX = x - (this.mouse.downWPosX);
				DWidth = -(x - this.mouse.downWPosX);
				
				dG = this.getDeltaByGrid((this.hoveredWidget.view.posX + DX), 0);
				DX -= dG.x;
				DWidth += dG.x;
				
				if(alignment != null && alignment.V != null) {
					DX = alignment.V.alignmentPos - (this.mouse.downWPosX - this.hoveredWidget.aPosX + this.hoveredWidget.posX);
					DWidth = -DX;
					this.view.makeVerticalAlignment(alignment.V);
				} else {
					this.view.clearAlignment();
				}
				
				break;
		}
		
		// Присваивание смещения отображению
		for (let i = 0; i < this.focusedWidgets.length; ++i) {
			let child = this.focusedWidgets[i];
			if(child === undefined) continue;
			
			if(child.view.minWidth < (this.mouse.fGeoms[i][2] + DWidth) && child.view.maxWidth > (this.mouse.fGeoms[i][2] + DWidth)) {
				child.view.posX = this.mouse.fGeoms[i][0] + DX;
				child.view.width = this.mouse.fGeoms[i][2] + DWidth;
			}
			
			 if(child.view.minHeight < (this.mouse.fGeoms[i][3] + DHeight) && child.view.maxHeight > (this.mouse.fGeoms[i][3] + DHeight)) {
				 child.view.posY = this.mouse.fGeoms[i][1] + DY;
				 child.view.height = this.mouse.fGeoms[i][3] + DHeight;
			 }
		 }
		
		this.mouse.upWPosX = this.hoveredWidget.aPosX;
		this.mouse.upWPosY = this.hoveredWidget.aPosY;
		this.mouse.upWW = this.hoveredWidget.width;
		this.mouse.upWH = this.hoveredWidget.height;
	}
	
	// Обработка перемещения виджетов
	movingFocusedWidgets(x, y) {
		if(!this.focusedWidgets.length  || !this.mouse.leftButtonPressed) return;
		
		// Разница между координатами смещения (дельта x y)
		let diffX = x - this.mouse.oldPosX;
		let diffY = y - this.mouse.oldPosY;
		
		// Добавочное смещение в случае выравнивания по наведенному виджету
		let additionX = 0;
		let additionY = 0;
		
		if(!this.hasInSelectionsWidgets(this.hoveredWidget)) return;
		
		// ALIGNMENT
		let alignment = this.getSelectionAlignment(null, null);
		if(alignment != null) {
			
			// ************************OX************************
			if(alignment.V != null) {
				
				// Запоминаем координату при появлении выравнивания 
				if(this.mouse.startAlignX == null) this.mouse.startAlignX = x;
				
				// Если мышь сместилась больше, чем коэффециент выравнивания - возвращаем запоздалое смещение
				if((this.mouse.startAlignX != null) && (Math.abs(this.mouse.startAlignX - x) > this.view.errorWidgetsAlign)) {
					additionX = -(this.mouse.startAlignX - x);
					this.mouse.startAlignX = null;
					this.view.removeVerticalAlignment();
				} else {
					additionX = alignment.V.alignmentDiff;
					diffX = 0;
					this.view.makeVerticalAlignment(alignment.V);
				}
				
			} else {
				this.mouse.startAlignX = null;
				diffX = 0;
				additionX = (x - this.hoveredWidget.aPosX) - this.mouse.pressDiffWidgetX;
				this.view.removeVerticalAlignment();
			}
			
			// ************************OY************************
			
			if(alignment.H != null) {
				
				// Запоминаем координату при появлении выравнивания 
				if(this.mouse.startAlignY == null) this.mouse.startAlignY = y;
				
				// Если мышь сместилась больше, чем коэффециент выравнивания - возвращаем запоздалое смещение
				if((this.mouse.startAlignY != null) && (Math.abs(this.mouse.startAlignY - y) > this.view.errorWidgetsAlign)) {
					additionY = -(this.mouse.startAlignY - y);
					this.mouse.startAlignY = null;
					this.view.removeHorizontalAlignment();
				} else {
					additionY = alignment.H.alignmentDiff;
					diffY = 0;
					this.view.makeHorizontalAlignment(alignment.H);
				}
				
			} else {
				this.mouse.startAlignY = null;
				diffY = 0;
				additionY = (y - this.hoveredWidget.aPosY) - this.mouse.pressDiffWidgetY;
				this.view.removeHorizontalAlignment();
			}
			
		} else {
			this.view.clearAlignment();
			this.mouse.startAlignX = null;
			this.mouse.startAlignY = null;
			diffX = 0;
			diffY = 0;
			additionX = (x - this.hoveredWidget.aPosX) - this.mouse.pressDiffWidgetX;
			additionY = (y - this.hoveredWidget.aPosY) - this.mouse.pressDiffWidgetY;
		}
		
		let gridDelta = this.getDeltaByGrid(this.hoveredWidget.view.posX + additionX + diffX, this.hoveredWidget.view.posY + additionY + diffY);
		if((alignment != null && alignment.V != null)) gridDelta.x = 0;
		if((alignment != null && alignment.H != null)) gridDelta.y = 0;
		
		// Присваивание смещения отображению
		for(let child of this.focusedWidgets) {
			if (child === undefined) continue;
			child.view.posX += ((additionX + diffX) - gridDelta.x);
			child.view.posY += ((additionY + diffY) - gridDelta.y);
		}
		
		this.mouse.upWPosX = this.hoveredWidget.aPosX;
		this.mouse.upWPosY = this.hoveredWidget.aPosY;
	}
	
	// Отправка координат смещения виджетов
	sendMovePositions() {
		if(this.mouse.upWPosX == null || this.mouse.downWPosX == null) return;
		let DX = this.mouse.upWPosX - this.mouse.downWPosX; 
		let DY = this.mouse.upWPosY - this.mouse.downWPosY;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setPositionsWidgets", [parseInt(DX), parseInt(DY)]);
	}
	
	// Отправка изменения геометрии виджетов
	sendResizePositions() {
		// return;
		if(this.mouse.upWPosX == null || this.mouse.downWPosX == null) return;
		let DX = this.mouse.upWPosX - this.mouse.downWPosX; 
		let DY = this.mouse.upWPosY - this.mouse.downWPosY;
		let DW = this.mouse.upWW - this.mouse.downWW;
		let DH = this.mouse.upWH - this.mouse.downWH;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setGeometryWidgets", [parseInt(DX), parseInt(DY), parseInt(DW), parseInt(DH)]);
		
	}
	
	// Получение дополнительного смещения относительно разметки сетки
	getDeltaByGrid(x, y) {
		let delta = {x:0, y:0};
		if(!this.view.gridAlign) return delta;
		delta.x =  x - (Math.round(x / this.view.gridSize) * this.view.gridSize);
		delta.y =  y - (Math.round(y / this.view.gridSize) * this.view.gridSize);
		return delta;
	}
	
	onFocused(f) {
		if(!f) {
			// this.mouse = new MouseConstructor();
			// Rex.callRpcMethod('Widgets', this.id, this.type, 'setFocusedWidgetById', [-1]);
			// Rex.callRpcMethod('Widgets', this.id, this.type, 'setHoveredWidgetById', [-1]);
			//this.needResize = -1;
		}
	}
	
	keyDown(event) {
		if(event.ctrlKey) { // 17
			if(event.which == 68) { // CTRL + D
				event.preventDefault();
				Rex.callRpcMethod("Widgets", this.id, this.type, "duplicate", [this.mouse.posX - this.aPosX, this.mouse.posY - this.aPosY]);
				this.duplicate = 1; // костыль (при дублировании массива виджетов - новые обьекты закрываю старые)
			} else if(event.which == 65) { // CTRL + A
				event.preventDefault();
				this.focusedWidgets = [];
				for(let i = 0; i < this.children.length; ++i) {
					let w = Rex.widgets[this.children[i]];
					if(w === undefined) continue;
					this.focusedWidgets.push(w);
				}
				let arr = [];
				for(let i = 0; i < this.focusedWidgets.length; i++) arr.push(this.focusedWidgets[i].id);
				Rex.callRpcMethod("Widgets", this.id, this.type, "setFocusedWidgetsById", [JSON.stringify(arr)]);
				this.view.updatePosition();
			} else if(event.which == 86) { // CTRL + V
				Rex.callRpcMethod("Widgets", this.id, this.type, "pasteFocusedWidgets", [this.mouse.posX - this.aPosX, this.mouse.posY - this.aPosY]);
			}else if(this.focusedWidgets.length == 0) {
				return;
			} else if(event.which == 67) { // CTRL + C
				Rex.callRpcMethod("Widgets", this.id, this.type, "copyFocusedWidgets", []);
			} else if(event.which == 88) { // CTRL + X
				Rex.callRpcMethod("Widgets", this.id, this.type, "cutFocusedWidgets", []);
			}
		} else if((event.which == 46) && (this.focusedWidgets.length > 0)) {
			Rex.callRpcMethod("Widgets", this.id, this.type, "destroyWidgets", []);
			this.focusedWidgets = [];
			this.view.updatePosition();
		}
	}
	
	getImageData() {
		return this.view.getImageData();
	}
	
	onDrop(e,cPos){
		return {
			posX : cPos.x - this.aPosX,
			posY : cPos.y - this.aPosY
		};
		// 	posX: drugs.posX - this.aPosX,
		// 	posY: drugs.posY - this.aPosY,
		// 	sender: drugs.sender.id,
		// 	data: drugs.data,
		// 	target: this.id
		// };
	}
	onGenerateContent(content, docData) {
		let table = content.table;
		table.widths.push(this.view.htmlElement.clientWidth);

		for (const id of this.children) {
			const child = Rex.widgets[id];
			if (child == null)
				continue;

			let childContent = [];
			child.generateContent(childContent, docData);
			table.body.push(childContent);
		}
	}

}


/* eslint-disable no-unused-vars */
/* global Widget WidgetCalendarCanvas WidgetCalendarHtml Rex*/

/**
 * Created by ALLekSSSanDR on 26.12.2017.
 */
class WidgetCalendar extends Widget {
	
	constructor(state) {
		super(state);
		
		this.holidays = [];
		this.events = [];
		
		this.hoverIndex = -1;
		
		this.positions = [];
		this.years = [];
		
		this.chooseYear = false;
		this.chooseYearData = this.year;
		
		this.monthCode = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];
		this.dayCode = ["ВС", "ПН", "ВТ", "СР", "ЧТ", "ПТ", "СБ"];
		
		this.sizeHeaderW = 0;		// Размер информативного заголовка с горизонтальной ориентацией
		this.sizeHeaderH = 0;		// Размер информативного заголовка с вертикальной ориентацией
		
		this.cellSizeW = 0;			// Ширина отдельной ячейки с числом месяца
		this.cellSizeH = 0;			// Высота отдельной ячейки с числом месяца 
		
		this.paddingCalendar = 20;
		
		this.baseFontSize = 14;		// Базовый размер шрифта
		this.bigFontSize = 30;		// Увеличенный размер шрифта
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetCalendarCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetCalendarHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		if (this.typeView == "html") {
			this.view.onMouseDown(event);
			return;
		}
		// Нажатие на кнопку года
		if(this.comeInRect(x, y, (this.aPosX + this.paddingCalendar), (this.aPosY + 10), (this.aPosX + this.width - this.paddingCalendar), (this.baseFontSize))) {
			this.chooseYear = true;
			this.chooseYearData = this.viewYear;
			this.view.update();
			return;
		}
		// Нажатие на кнопку даты
		if(this.comeInRect(x, y, (this.aPosX + this.paddingCalendar), (this.aPosY + 20 + this.baseFontSize), (this.aPosX + this.width - this.paddingCalendar), (this.bigFontSize))) {
			this.chooseYear = false;
			this.viewMonth = this.month;
			this.viewYear = this.year;
			this.view.update();
			
			return;
		}
		if(this.chooseYear) {
			for(let i = 0; i < this.years.length; ++i) {
				//	comeInRect(x, y , xRec, yRec, wRex, hRec) {
				
				if(this.comeInBox(x, y, this.years[i][0], this.years[i][1], this.cellSizeH / 2)) {
					this.year = this.years[i][2];
					this.viewYear = this.years[i][2];
					Rex.callRpcMethod("Widgets", this.id, this.type, "setYear", [this.year]);
					this.view.update();
					this.chooseYear = false;
					return;
				}
				
			}
		} else {
			// Нажатие на кнопку BACK
			if(this.comeInBox(x, y, (this.aPosX + this.paddingCalendar), (this.aPosY + this.sizeHeaderH + (this.cellSizeH / 2) + this.baseFontSize / 2), (30))) {
				this.remMonth();
				return;
			}
			// Нажатие на кнопку NEXT
			if(this.comeInBox(x, y, (this.aPosX + this.width - this.paddingCalendar), (this.aPosY + this.sizeHeaderH + (this.cellSizeH / 2) + this.baseFontSize / 2), (30))) {
				this.addMonth();
				return;
			}
			// Нажатие на кнопку INDEX
			if(this.comeInRect(x, y,
					(this.aPosX + this.paddingCalendar),
					(this.aPosY + this.sizeHeaderH + this.cellSizeH * 2),
					(this.width - this.paddingCalendar * 2),
					(this.cellSizeH * 7))) {
				for(let i = 0; i < this.positions.length; ++i) {
					if(this.comeInBox(x, y, this.positions[i][0], this.positions[i][1], Math.min(this.cellSizeH, this.cellSizeW) / 2)) {
						if(this.year != this.viewYear) {
							this.year = this.viewYear;
							Rex.callRpcMethod("Widgets", this.id, this.type, "setYear", [this.year]);
						}
						if(this.month != this.viewMonth) {
							this.month = this.viewMonth;
							Rex.callRpcMethod("Widgets", this.id, this.type, "setMonth", [this.month]);
						}
						this.day = (i + 1);
						Rex.callRpcMethod("Widgets", this.id, this.type, "setDay", [this.day]);
						this.view.update();
						return;
					}
					
				}
			}
		}
	}
	
	// Проверка координат на вхождение в область
	comeInRect(x, y, xRec, yRec, wRex, hRec) {
		return (((x > xRec && x < xRec + wRex)) && ((y > yRec && y < yRec + hRec)))
	}
	
	comeInBox(x, y, x0, y0, radius) {
		if(x > x0 + radius || x < x0 - radius) return false;
		if(y > y0 + radius || y < y0 - radius) return false;
		return true;
	}
	
	mouseWheel(value) {
		if (this.typeView == "html") {
			this.view.onMouseWheel(value);
			return;
		}
		
		if (this.typeView == "html") return;
		if(this.chooseYear) {
			if(value == 1) this.chooseYearData++;
			else this.chooseYearData--;
			this.view.update();
		} else {
			if(value == 1) this.addMonth();
			else this.remMonth();
		}
	}
	
	getDayOfTheWeek(day, month, year) {
		let _d = day;
		let _m = month;
		let _y = year;
		if((day === undefined) || (month === undefined) || (year === undefined)) {
			_d = this.day;
			_m = this.month;
			_y = this.year;
		}
		_d = parseInt(_d, 10);
		_m = parseInt(_m, 10);
		_y = parseInt(_y, 10);
		
		let a = parseInt((14 - _m) / 12, 10);
		let y = _y - a;
		let m = _m + 12 * a - 2;
		return parseInt(((_d + y + parseInt(y / 4, 10) - parseInt(y / 100, 10) + parseInt(y / 400, 10) + (31 * m) / 12) % 7), 10);
	}
	
	//[31, (28|29), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	getCountMonthDays(month, year) {
		//return 28 + ((month + Math.floor( / 8)) % 2) + 2 % month + Math.floor((1 + (1 - (year % 4 + 2) % (year % 4 + 1)) * ((year % 100 + 2) % (year % 100 + 1)) + (1 - (year % 400 + 2) % (year % 400 + 1))) / month) + Math.floor(1 / month) - Math.floor(((1 - (year % 4 + 2) % (year % 4 + 1)) * ((year % 100 + 2) % (year % 100 + 1)) + (1 - (year % 400 + 2) % (year % 400 + 1))) / month);
		let data = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		if(month != 2) return data[month - 1];
		else if(year % 4 == 0) return 29;
		return 28;
	}
	
	getCountDataDays(d, m, y) {
		let count = 0;
		for(let i = 1; i < m; ++i) count += this.getCountMonthDays(i, y);
		return count + d;
	}
	
	getNumberWeek(d, m, y) {
		let n = this.getCountDataDays(d, m, y);
		return Math.floor((((n - 1)/7) + 1)); 
	}
	
	getPersonEvent(d, m, y) {
		for(let i = 0; i < this.view.events.length; ++i) {
			let e = this.view.events[i];
			if(e.day == d && e.month == m && e.year == y) return e;
		}
		return null;
	}
	
	isHolidays(day, month, year) {
		for(let i = 0; i < this.view.holidays.length; ++i) {
			let h = this.view.holidays[i];
			if(h.day == day && h.month == month && h.year == year) return true;
		}
		return false;
	}
	
	addMonth() {
		++this.viewMonth;
		++this.month;
		if(this.viewMonth > 12 || this.month > 12) {
			this.viewMonth = 1;
			this.month = 1;
			++this.viewYear;
			++this.year;
		}
		this.view.update();
	}
	
	remMonth() {
		--this.month;
		--this.viewMonth;
		if(this.viewMonth < 1 || this.month < 1) {
			this.viewMonth = 12;
			this.month = 12;
			--this.viewYear;
			--this.year;
		}
		this.view.update();
	}
	
}


/* eslint-disable no-unused-vars */
/* global Widget WidgetTimeCanvas WidgetTimeHtml Rex*/

/**
 * Created by ALLekSSSanDR on 06.01.2018.
 */

class WidgetTime extends Widget {
	
	constructor(state) {
		super(state);
		this.hours = 0;				// Часы
		this.minutes = 0;			// Минуты
		this.seconds = 0;			// Секунды
		
		this.hoverIndex = -1;
		
		this.hoursPositions = [];		// Координаты часов (12)
		this.minutesPositions = [];		// Координаты минут (60)
		
		this.chooseHours = true;
		this.enablePM = true;
		
		this.sizeHeaderW = 0;		// Размер информативного заголовка с горизонтальной ориентацией
		this.sizeHeaderH = 0;		// Размер информативного заголовка с вертикальной ориентацией
		
		this.cellSizeW = 0;			// Ширина отдельной ячейки с числом месяца
		this.cellSizeH = 0;			// Высота отдельной ячейки с числом месяца 
		
		this.paddingPicker = 20;
		
		this.baseFontSize = 15;		// Базовый размер шрифта
		this.bigFontSize = 50;		// Увеличенный размер шрифта
	}
	
	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetTimeCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetTimeHtml(this);
		}
	}
	
	onMouseDown(x, y, event) {
		if (this.typeView == "html") {
			this.view.onMouseDown(event);
			return;
		}
		
		// Нажатие на часы
		if(this.comeInRect(x, y, (this.posX + (this.width / 2) - this.bigFontSize * 2), (this.posY + this.paddingPicker), (this.bigFontSize * 2), (this.bigFontSize))) {
			this.chooseHours = true;
			this.view.update();
			return;
		}
		
		// Нажатие на минуты
		if(this.comeInRect(x, y, (this.posX + (this.width / 2)), (this.posY + this.paddingPicker), (this.bigFontSize *1.4), (this.bigFontSize))) {
			this.chooseHours = false;
			this.view.update();
			return;
		}
		
		// Нажатие на AM
		if(this.comeInRect(x, y, (this.posX + (this.width / 2) + this.bigFontSize * 1.5), (this.posY + this.paddingPicker + this.sizeHeaderH / 4 - this.baseFontSize), (this.baseFontSize * 2), (this.baseFontSize))) {
			this.enablePM = false;
			this.view.update();
			return;
		}
		
		// Нажатие на PM
		if(this.comeInRect(x, y, (this.posX + (this.width / 2) + this.bigFontSize * 1.5), (this.posY + this.paddingPicker + this.sizeHeaderH / 2 - this.baseFontSize), (this.baseFontSize * 2), (this.baseFontSize))) {
			this.enablePM = true;
			this.view.update();
			return;
		}
		
		// Нажатие на кнопку даты
		if(this.chooseHours) {
			for(let i = 0; i < 12; ++i) {
				if(this.comeInBox(x ,y ,
						this.hoursPositions[i][0],
						this.hoursPositions[i][1],
						this.baseFontSize
					)) {
					if(this.enablePM) {
						this.hours = i + 13;
					}
					else {
						this.hours = i + 1;
					}
					
					if(this.hours == 24) {
						this.hours = 0;
					}
					Rex.callRpcMethod("Widgets", this.id, this.type, "setHours", [this.hours]);

					this.view.update();
					return this;
				}
			}
		} else {
			for(let i = 0; i < 60; ++i) {
				if(this.comeInBox(x ,y ,
						this.minutesPositions[i][0],
						this.minutesPositions[i][1],
						this.baseFontSize / 2
					)) {
					this.minutes = i + 1;
					if(this.minutes == 60) this.minutes = 0;
					Rex.callRpcMethod("Widgets", this.id, this.type, "setMinutes", [this.minutes]);
					this.view.update();
					return this;
				}
			}
		}
		
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp();
	}
	
	mouseWheel(value) {
		if (this.typeView == "html") {
			this.view.onMouseWheel(value);
			return;
		}
		
		if(this.chooseHours) {
			// ЧАСЫ
			if(value == 1) {
				this.hours++;
				if(this.hours < 13 && this.enablePM) this.enablePM = false;
				if(this.hours > 12 && !this.enablePM) this.enablePM = true;
				if(this.hours > 23) {
					this.hours = 0;
				}
			} else {
				this.hours--;
				if(this.hours < 13 && this.enablePM) this.enablePM = false;
				if(this.hours == 0 && !this.enablePM) this.enablePM = true;
				if(this.hours < 0) {
					this.hours = 23;
					this.enablePM = true;
				}
			}
			Rex.callRpcMethod("Widgets", this.id, this.type, "setHours", [this.hours]);

		} else {
			// Минуты
			if(value == 1) {
				this.minutes++;
				if(this.minutes > 59) {
					this.minutes = 0;
				}
				
			} else {
				this.minutes--;
				if(this.minutes < 0) {
					this.minutes = 59;
				}
			}
			Rex.callRpcMethod("Widgets", this.id, this.type, "setMinutes", [this.minutes]);
		}
		this.view.update();
	}
	
	
	// Проверка координат на вхождение в область
	comeInRect(x, y , xRec, yRec, wRex, hRec) {
		return (((x > xRec && x < xRec + wRex)) && ((y > yRec && y < yRec + hRec)))
	}
	
	comeInBox(x, y, x0, y0, radius) {
		if(x > x0 + radius || x < x0 - radius) return false;
		if(y > y0 + radius || y < y0 - radius) return false;
		return true;
	}
}


/**
 * WidgetFrame
 */
class WidgetFrame extends Widget {
	
	constructor(state) {
		super(state);
		this.external = false;
		this.src = "";
		this._srcEncode = "";
		this.setState(state);
	};
	
	set srcEncode(value){
		this._srcEncode = value;
		try {
			this.src = decodeURIComponent(escape(window.atob(value)));
		} catch (e) {
			console.error(this.type, " -> setState-> ", state._srcEncode, " DecodeError!");
		}
	}
	
	setState(state) {
		if(state === undefined) return;
		if (state.external !== this.external || state.srcEncode !== this._srcEncode)
			this.view.update();
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "canvas") {
			console.error("can't create");
		} else if(this.typeView === "html") {
			this.view = new WidgetFrameHtml(this);
		}
	}
}


/**
 * WidgetTable
 */
class WidgetTable extends Widget {

	constructor(state) {
		super(state);
		this.data = undefined;
		this.meta = undefined;
		this.needHeadRow = true;
		this.fixHeadRow = false;
		this.needBorder = false;
		this.isNumberSort = false;
		this.needRowsNumber = false;
		this.needResize = false;
		this.canEditable = false;
		this.setState(state);
		this.resizeParams = {};
		this.scrollTop = 0;
	}

	createView() {
		if(this.typeView === "canvas") {
			this.view = new WidgetTableCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetTableHtml(this);
		}
	}

	onCheckInit() {
		for(let i = 0; i < this.children.length; ++i) {
			if(Rex.widgets[this.children[i]] === undefined) return false;
		}
		return true;
	}

	onGenerateContent(content) {
		//WARNING: Тут все на костылях. Сделал, как смог.
		const view = this.view;
		if (view.maxCol == -1 || view.maxRow == -1)
			return;

		const html = view.htmlElement;
		
		let thead = null;
		let tbody = null;

		//get header and body node
		if (this.needHeadRow) {
			if (this.fixHeadRow) {
				thead = html.children[1].children[0].children[0];
				tbody = html.children[1].children[0].children[1];
			} else {
				thead = html.children[0].children[0];
				tbody = html.children[0].children[1];
			}
		} else {
			tbody = html.children[0].children[0];
		}

		let table = content.table;

		const colIndex =  view.maxCol + (this.needRowsNumber ? 2 : 1);
		for (let i = 0; i < view.maxRow + 1; ++i) {
			let rowHtml = null;

			if (thead != null && i !== 0)
				rowHtml = tbody.children[i - 1];
			else if (thead != null && i === 0)
				rowHtml = thead.children[i];
			else rowHtml = tbody.children[i];

			const rowSize = rowHtml.getBoundingClientRect();
			let rowContent = [];
			for (let j = 0; j < colIndex; ++j) {
				const cellHtml = rowHtml.children[j];
				const cellSize = cellHtml.getBoundingClientRect();
				const cellData = this.data[i][this.needRowsNumber ? j - 1 : j];
				if (i == 0) {
					table.widths.push(cellSize.Width);
				}

				if (cellData === '' || cellData == null) {
					rowContent.push({});
					continue;
				}

				const index = cellData.indexOf(':');
				if (index === -1)
					continue;

				const childId = parseInt(cellData.slice(index + 1));
				const childWidget = Rex.widgets[childId];
				if (childWidget == null)
					continue;

				childWidget.generateContent(rowContent);
				let childObject = rowContent[j].table.body[0][0];
				if (childObject.fillColor === '#ffffff' && this.needHeadRow && this.fixHeadRow && i === 0) {
					childObject.fillColor = '#b7b7b7';
				}
			}

			table.heights.push(rowSize.height);
			table.body.push(rowContent);
		}

		if (this.needRowsNumber) {
			for (let i = 0; i < view.maxRow + 1; ++i) {
				let rowHtml = null;

				if (thead != null && i !== 0)
					rowHtml = tbody.children[i - 1];
				else if (thead != null && i === 0)
					rowHtml = thead.children[i];
				else rowHtml = tbody.children[i];

				let bodyCell = table.body[i][0];
				bodyCell.margin = [0, 0, 0, 0];

				let htmlCell = rowHtml.children[0];

				generateText(htmlCell, bodyCell);
			}
		}

		let layout = content.layout;

		function vLineColor (i, node) {
			if (this.needBorder === false) {
				if (i !== 0)
					return '#ffffff';
			}

			return '#969696';
		}

		layout.vLineColor = vLineColor.bind(this);
		layout.hLineColor = '#969696';
		layout.vLineWidth = function() { return 1; };
		layout.hLineWidth = function() { return 1; };

		function fillColor (i, node, j) {
			if (this.needRowsNumber) {
				if (j === 0) {
					if (this.needHeadRow && i === 0)
						return '#b7b7b7';
					return mixColorWithOpacity('#000000', 0.08);
				}
			}

			if (this.needHeadRow && this.fixHeadRow && i === 0) {
				return '#b7b7b7';
			}
			return 'white'
		}

		layout.fillColor = fillColor.bind(this);
	}

	onMouseDown(x, y, event) {
		if(event.target.classList.contains("table-resizer")) {
			this.resizeParams.resizerClassList = event.target.classList;
			this.resizeParams.resizeElement = event.target.parentNode;
			this.resizeParams.nextResizeElement = this.resizeParams.resizeElement.nextElementSibling;
			this.resizeParams.previousResizeElement = this.resizeParams.resizeElement.previousElementSibling;
			this.resizeParams.resizeElementStartWidth = this.resizeParams.resizeElement.offsetWidth;
			this.resizeParams.nextResizeElementStartWidth = this.resizeParams.nextResizeElement ? this.resizeParams.nextResizeElement.offsetWidth : undefined;
			this.resizeParams.previousResizeElementStartWidth = this.resizeParams.previousResizeElement ? this.resizeParams.previousResizeElement.offsetWidth : undefined;
			this.resizeParams.startMovePos = event.pageX;
		}
		if(getParentElementByClass(event.target, "sort-baton")) {
			let sort = getParentElementByClass(event.target, "sort-baton");
			let batons = this.view.htmlElement.querySelectorAll('.sort-baton');
			let indicator = sort.querySelector('.indicator');
			if(this.sort(indicator.classList.contains("indicator-up"), this.needRowsNumber ? getParentElementByTag(sort, 'th').cellIndex - 1 :
					getParentElementByTag(sort, 'th').cellIndex, this.isNumberSort, event.target)) {
				for(let i = 0; i < batons.length; ++i) {
					if(!batons[i].classList.contains('default')) {
						batons[i].classList.toggle('default');
						composeObj(this.meta,joinTextToCompose("rows","0","cols", this.needRowsNumber ? getParentElementByTag(batons[i], 'th').cellIndex - 1 :
							getParentElementByTag(batons[i], 'th').cellIndex, "sort", "default"),"true");
					}
				}
				sort.classList.toggle('default');
				composeObj(this.meta,joinTextToCompose("rows","0","cols", this.needRowsNumber ? getParentElementByTag(sort, 'th').cellIndex - 1 :
					getParentElementByTag(sort, 'th').cellIndex, "sort", "default"),"none");
				indicator.classList.toggle("indicator-up");
				indicator.classList.toggle("indicator-down");
				if(indicator.classList.contains("indicator-up"))
					composeObj(this.meta,joinTextToCompose("rows","0","cols", this.needRowsNumber ? getParentElementByTag(sort, 'th').cellIndex - 1 :
						getParentElementByTag(sort, 'th').cellIndex, "sort", "indicator"),"indicator-up");
				else
					composeObj(this.meta,joinTextToCompose("rows","0","cols", this.needRowsNumber ? getParentElementByTag(sort, 'th').cellIndex - 1 :
						getParentElementByTag(sort, 'th').cellIndex, "sort", "indicator"),"indicator-down");
				Rex.callRpcMethod('Widgets', this.id, this.type, 'setMetaJson', [JSON.stringify(this.meta)]);
			}
		}
	}

	sort(isUp, index, isNumberSort, baton) {
		if(this.meta) {
			if(this.haveColRowSpan("You can't sort merged cells")) {
				baton.style = "pointer-events: none; opacity: 0.4;";
				return false;
			}
		}
		let head = "";
		if(this.needHeadRow) head = this.data.splice(0, 1);
			this.data.sort(function (a, b) {
				let first = a[index];
				let second = b[index];
				let aId = Number.parseInt(a[index].substring("WidgetInTableId:".length));
				if (!isNaN(aId)) {
					first = Rex.widgets[aId];
					if (first) {
						first = first.text;
					} else {
						first = a[index];
					}
				}
				let bId = Number.parseInt(b[index].substring("WidgetInTableId:".length));
				if (!isNaN(bId)) {
					second = Rex.widgets[bId];
					if (second) {
						second = second.text;
					}
					else {
						second = second[index];
					}
				}
				if (first === undefined) {
					if (second === undefined) {
						return 0;
					} else {
						return 1;
					}
				} else {
					if (isNumberSort)
						return isUp ? first - second : second - first;
					else {
						if (first > second) {
							return isUp ? 1 : -1;
						}
						if (first < second) {
							return isUp ? -1 : 1;
						}
						return 0;
					}
				}
			});
		if(this.needHeadRow) this.data.splice(0, 0, head[0]);
		this.view.remake();
		Rex.callRpcMethod('Widgets', this.id, this.type, 'setDataJson', [JSON.stringify(this.data)]);
		return true;
	}

	onMouseMove(x, y, event) {
		if(this.resizeParams.resizeElement) {
			this.resizeTable(this.resizeParams.resizerClassList.contains("table-resizer-right"));
		}
	}

	resizeTable(isRight){
		let resizeElementWidth = this.resizeParams.resizeElementStartWidth +
			(isRight ? event.pageX + (isRight ? - this.resizeParams.startMovePos
				: this.resizeParams.startMovePos)
				: - event.pageX + (isRight ? - this.resizeParams.startMovePos :
				this.resizeParams.startMovePos));
		let difElementWidth = isRight ?
			this.resizeParams.nextResizeElementStartWidth + (isRight ?
			- event.pageX + (isRight ?
			this.resizeParams.startMovePos :
			- this.resizeParams.startMovePos) :
			event.pageX + (isRight ?
			this.resizeParams.startMovePos :
			- this.resizeParams.startMovePos)) :
			this.resizeParams.previousResizeElementStartWidth + (isRight ?
			- event.pageX + (isRight ?
			this.resizeParams.startMovePos :
			- this.resizeParams.startMovePos) :
			event.pageX + (isRight ?
			this.resizeParams.startMovePos :
			- this.resizeParams.startMovePos));
		if(resizeElementWidth > 5 && difElementWidth > 5) {
			this.resizeParams.resizeElement.style.width = resizeElementWidth + 'px';
			isRight ? this.resizeParams.nextResizeElement.style.width = difElementWidth + 'px' : this.resizeParams.previousResizeElement.style.width = difElementWidth + 'px';
			if(this.fixHeadRow) {
				let hiddenRow = this.view.htmlElement.querySelector('.content-container .table-container').firstElementChild.firstElementChild;
				hiddenRow.children[this.resizeParams.resizeElement.cellIndex].style.width = resizeElementWidth + 'px';
				if(isRight){
					hiddenRow.children[this.resizeParams.nextResizeElement.cellIndex].style.width = difElementWidth + 'px';
				} else {
					hiddenRow.children[this.resizeParams.previousResizeElement.cellIndex].style.width = difElementWidth + 'px';
				}
			}
		}
	}

	onMouseUp(x, y, event) {
		if(JSON.stringify(this.resizeParams) !== "{}") {
			let elem = this.resizeParams.resizeElement.querySelector('.table-content');
			let cellIndex = this.needRowsNumber ? elem.parentNode.cellIndex - 1 : elem.parentNode.cellIndex;
			let rowIndex = elem.parentNode.parentNode.rowIndex;
			composeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", cellIndex, "styles", "width"), this.resizeParams.resizeElement.style.width);
			if(this.resizeParams.nextResizeElement) {
				let nextElem = this.resizeParams.nextResizeElement.querySelector('.table-content');
				let cellIndex = this.needRowsNumber ? nextElem.parentNode.cellIndex - 1 : nextElem.parentNode.cellIndex;
				let rowIndex = nextElem.parentNode.parentNode.rowIndex;
				composeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", cellIndex, "styles", "width"), this.resizeParams.nextResizeElement.style.width);
			}
			if(this.resizeParams.previousResizeElement && !this.resizeParams.previousResizeElement.classList.contains('numbers')) {
				let prevElem = this.resizeParams.previousResizeElement.querySelector('.table-content');
				let cellIndex = this.needRowsNumber ? prevElem.parentNode.cellIndex - 1 : prevElem.parentNode.cellIndex;
				let rowIndex = prevElem.parentNode.parentNode.rowIndex;
				composeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", cellIndex, "styles", "width"),  this.resizeParams.previousResizeElement.style.width);
			}
			this.resizeParams = {};
			Rex.callRpcMethod('Widgets', this.id, this.type, 'setMetaJson', [JSON.stringify(this.meta)]);
		}
	}
	
	haveColRowSpan(errorMessage = "") {
		let key;
		let rows = decomposeObj(this.meta, joinTextToCompose("rows"));
		for(key in rows) {
			let key1;
			let cols = decomposeObj(rows, joinTextToCompose(key, "cols"));
			for(key1 in cols) {
				if(decomposeObj(cols, joinTextToCompose(key1, "attributes", "colSpan")) || decomposeObj(cols, joinTextToCompose(key1, "attributes", "rowSpan"))) {
					// Rex.gui.notificationManager.message(errorMessage, "error");
					console.error(errorMessage);
					return true;
				}
			}
		}
		return false;
	}

	onMouseDoubleClick(event) {
		if(this.canEditable) {
			let content
			if(event.target.classList.contains("table-content"))
				content = event.target;
			else if(event.target.firstElementChild.classList.contains("table-content"))
				content = event.target.firstElementChild;
			else if(event.target.parentElement.classList.contains("table-content"))
				content = event.target.parentElement;
			if(!content) return;
			if(content.id.indexOf("t-") !== -1) {
				Rex.gui.notificationManager.message("You can not edit cell with wiget", "error");
				return;
			}
			content.style.display = "none";
			let textArea = document.createElement("textarea");
			textArea.textContent = content.textContent;
			textArea.style.resize = "none";
			textArea.style.width = "100%";
			textArea.style.height = "100%";
			textArea.style.border = "none";
			textArea.style.padding = "0";
			textArea.style.font = "inherit";
			content.parentElement.appendChild(textArea);
			textArea.focus();
			textArea.oninput =(e)=>{
				content.textContent = e.target.value;
				this.data[content.parentElement.parentElement.rowIndex][this.needRowsNumber ? content.parentElement.cellIndex - 1 : content.parentElement.cellIndex] = e.target.value;
			}
			textArea.onblur=()=>{
				let str = JSON.stringify(this.data);
				let re = /\\n/gi;
				Rex.callRpcMethod('Widgets', this.id, this.type, 'setDataJson', [str.replace(re, ' ')]);
				content.style.display = "";
				textArea.remove();
			}
		}
	}
}


/**
 * Created by ALLekSSSanDR on 25.10.2018.
 */

class WidgetGroupBox extends Widget {
	
	constructor(state) {
		super(state);
		
	}
	
	createView() {
		if(this.typeView === "canvas") {
			// this.view = new ConstructorCanvas(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetGroupBoxHtml(this);
		}
	}
	
	onMouseMove(x, y, event) {
		this.view.onMouseMove(x, y, event);
	}
	
	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y, event);
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp(x, y, event);
	}
	
}

/**
 * Created by ALLekSSSanDR on 09.11.2018.
 */

class WidgetColorPicker extends Widget {
	
	constructor(state) {
		super(state);
		this.setState(state);
	};
	
	createView() {
		if(this.typeView === "canvas") {
			// this.view = new ___(this);
		} else if(this.typeView === "html") {
			this.view = new WidgetColorPickerHtml(this);
		}
	}
	
}

/**
 * WidgetDiagram
 */
class DataForDiagram {
	constructor() {
		this.name = '';
		this.value = 0;
	}
}
class WidgetDiagram extends Widget {

	constructor(state) {
		super(state);
		this.setState(state);
	}

	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetDiagramHtml(this);
		}
	}
}

/**
 * WidgetLineDiagram
 */

class WidgetLineDiagram extends WidgetDiagram {

	constructor(state) {
		super(state);
		this.setState(state);
	}

	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetLineDiagramHtml(this);
		}
	}
}

/**
 * WidgetBarDiagram
 *
 */

class WidgetBarDiagram extends WidgetLineDiagram {
	constructor(state) {
		super(state);
		this.setState(state);
	}

	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetBarDiagramHtml(this);
		}
	}
}



/**
 * WidgetCirculDiagram
 */

class WidgetCircularDiagram extends WidgetDiagram {

	constructor(state) {
		super(state);
	}

	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetCircularDiagramHtml(this);
		}
	}
}

/**
 * WidgetSchedule
 */

class WidgetSchedule extends WidgetLineDiagram {
	constructor(state) {
		super(state);
		this.setState(state);
	}

	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetScheduleHtml(this);
		}
	}
}

/**
 * WidgetHint
 */

class WidgetHint extends Widget {

	constructor(state) {

		super(state);

		this.contentWidget = null;

		this.setState(state)
	}

	createView() {

		this.view = new WidgetHintHtml(this);
	}

	appendChild(child) {

		if(Rex.undef(child, "child")) return;

		let contentWidget = this.contentWidget;

		if(contentWidget == child)
			return;

		this.contentWidget = child;

		this.view.setContentView(child.view);
	}

}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetLinkCanvas WidgetLinkHtml*/

/**
 * WidgetLink
 */
	
class WidgetLink extends Widget {
	
	constructor(state) {
		super(state);
		this.setState(state);
	}
	
	createView(){
		if (this.typeView === "canvas") {
			this.view = new WidgetLinkCanvas(this);
		} else if (this.typeView === "html") {
			this.view = new WidgetLinkHtml(this);
		}
	}

}


/* global Widget WidgetJoystickHtml */

// eslint-disable-next-line no-unused-vars
class WidgetJoystick extends Widget {
	
	constructor(state) {
		super(state);
		this.setState(state);
	}
	
	createView() {
		this.view = new WidgetJoystickHtml(this);
	}
	
	onInit() {}
	
	onMouseDown(x, y, event) {
		this.view.onMouseDown(x, y, event);
	}
	
	onMouseMove(x, y, event) {
		this.view.onMouseMove(x, y, event);
	}
	
	onMouseUp(x, y, event) {
		this.view.onMouseUp(x, y, event);
	}
	
}

class WidgetCorrespondentAccount extends Widget {
	
	constructor(state) {
		super(state);

		this.numberAccount = "";
		this.nameAccount = "";
        this.correspondentAccountType = 0;
        this.openingBalance = 0;
        this.openingBalanceTwo = 0;
        this.closingBalance = 0;
        this.closingBalanceTwo = 0;
        this.debitTransactions = [];
        this.creditTransactions = [];
        this.colorLine = "";

        super.setState(state);
    }
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetCorrespondentAccountHtml(this);
		}
	}
	
}

class WidgetMessagesViewer extends Widget {
	
	constructor(state) {
		super(state);
		this.messages = [];
		this.changeStateMessages = [];
		this.backgroundImage = "";
        this.colorIncomingMessages = "#D9EDF7";
        this.colorOutgoingMessages = "#F7F7F9";
        this.colorDate = "transparent";
        this.colorTextMessages = "black";
        this.colorSenderName = "red";
        this.showSendersAvatar = true;
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetMessagesViewerHtml(this);
		}
	}

	sortMessagesByTime() {
        this.messages.sort(function(a,b) {
            return a.date.getTime() - b.date.getTime();
        });
	}
	
}

class WidgetTransactionsHistory extends Widget {
	
	constructor(state) {
		super(state);
		this.transactions = [];
		this.searchParameters = {type : 0};
		this.searchResult = [];
		this.countView = 0;
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetTransactionsHistoryHtml(this);
		}
	}

	sortTransactionsByTime() {
        this.transactions.sort(function(a,b) {
            return b.unixDate.getTime() - a.unixDate.getTime();
        });
	}
	
}

class WidgetTaxiOrders extends Widget {
	
	constructor(state) {
		super(state);
		this.orders = [];
		this.addOrders = [];
		this.deleteOrders = [];
		// this.countView = 0;
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetTaxiOrdersHtml(this);
		}
	}
	
}

class WidgetContactsForTransactions extends Widget {
	
	constructor(state) {
		super(state);
		this.contacts = [];
        this.searchParameters = {type : 0};
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetContactsForTransactionsHtml(this);
		}
	}

	sortContactsByName() {
        this.contacts.sort(function(a, b) {
            if (a.name > b.name) {
                return 1;
            }
            if (a.name < b.name) {
                return -1;
            }
            // a должно быть равным b
            return 0;
        });
	}
	
}

class WidgetContacts extends Widget {
	
	constructor(state) {
		super(state);
		this.contacts = [];
		this.searchParameters = {type : 0};
		this.showStatus = false;
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetContactsHtml(this);
		}
	}

	sortContactsByName() {
        this.contacts.sort(function(a, b) {
            if (a.name > b.name) {
                return 1;
            }
            if (a.name < b.name) {
                return -1;
            }
            // a должно быть равным b
            return 0;
        });
	}
	
}

class WidgetShoppingBasket extends Widget {
	
	constructor(state) {
		super(state);
		this.sellers = [];
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetShoppingBasketHtml(this);
		}
	}
}

class WidgetNewsFeed extends Widget {
	
	constructor(state) {
		super(state);
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetNewsFeedHtml(this);
		}
	}
	
}

class WidgetSideBars extends Widget {
	
	constructor(state) {
		super(state);
		super.setState(state);
	}
	
	createView() {
		if(this.typeView === "html") {
			this.view = new WidgetSideBarsHtml(this);
		}
	}

	onCheckInit() {
		for (let i = 0; i < this.children.length; ++i) {
			if (Rex.widgets[this.children[i]] === undefined) return false;
		}
		return true;
	}
	
}

class WidgetViewCanvas extends WidgetView {
	
	constructor(widget) {
		super(widget);
		this.animation = new WidgetAnimation(this.widget);
		
		this.drawer = new WidgetDrawer(this.widget);
		
		this.firstBuffer = document.createElement("canvas");
		this.firstBufferCtx = this.firstBuffer.getContext("2d");
		
		this.secondBuffer = document.createElement("canvas");
		this.secondBufferCtx = this.secondBuffer.getContext("2d");
	}
	
	setState(state) {
		this.checkStatePositioning(state);
		Rex.copy(this.widget, state);
		if (state.customStyle !== undefined) this.updateStyle();
		if(typeof state.hint !== 'undefined') {
			try { this.widget.hint = decodeURIComponent(escape(window.atob(state.hint))); }
			catch(e) { console.log(this.widget.type, "setState->", "Hint DecodeError!", e, state.hint); }
		}
	}
	
	checkStatePositioning(state) {
		if((typeof state.posX !== 'undefined') ||
			typeof state.posY !== 'undefined' ||
			typeof state.width !== 'undefined' ||
			typeof state.height !== 'undefined' ||
			typeof state.horizontalAlignType !== 'undefined' ||
			typeof state.verticalAlignType !== 'undefined' ||
			typeof state.horizontalSizePolicy !== 'undefined' ||
			typeof state.verticalSizePolicy !== 'undefined' ||
			typeof state.minWidth !== 'undefined' ||
			typeof state.minHeight !== 'undefined' ||
			typeof state.maxWidth !== 'undefined' ||
			typeof state.maxHeight !== 'undefined' ||
			(state.children !== undefined && state.children.length < this.widget.children.length)
		) {
			if((Rex.gui !== undefined) && (Rex.widgets !== undefined)) Rex.gui.reposition(this.widget);
		}
	}
	
	getAPosX() {
		if(Rex.widgets === undefined) return this.widget._posX;
		let parent = Rex.widgets[this.widget.parentId];
		if(parent === undefined) return this.widget._posX;
		this.widget._aposX = parent.view.getAPosX() + this.widget._posX;
		return this.widget._aposX;
	}
	
	getAPosY() {
		if(Rex.widgets === undefined) return this.widget._posY;
		let parent = Rex.widgets[this.widget.parentId];
		if(parent === undefined) return this.widget._posY;
		this.widget._aposY = parent.view.getAPosY() + this.widget._posY;
		return this.widget._aposY;
	}
	
	inside(x, y) {
		if(this.widget.aPosX > x || (this.widget.aPosX + this.widget.width) < x) return false;
		if(this.widget.aPosY > y || (this.widget.aPosY + this.widget.height) < y) return false;
		return true;
	}
	
	checkSelect(x, y) {
		//let mousePos = this.drawer.transformMousePos(x, y);
		//let result = this.onCheckSelect(mousePos.x, mousePos.y);
		return this.onCheckSelect(x, y);
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = this.widget;
			for(let i = this.widget.children.length - 1; i >= 0; --i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				if(!child.isVisible()) continue;
				let childRet = child.view.checkSelect(x, y);
				if(childRet !== undefined) return childRet;
			}
		}
		return ret;
	}
	
	checkSelectCopy(x, y, posX, posY, width, height) {	//FIXME
		let oldParentId = this.widget.parentId;
		let oldX = this.widget.posX;
		let oldY = this.widget.posY;
		this.widget.posX = posX;
		this.widget.posY = posY;
		this.widget.parentId = -1;
		
		let oldWith = this.widget.width;
		let oldHeight = this.widget.height;
		this.widget.width = width;
		this.widget.height = height;
		
		let result = this.onCheckSelect(x, y);
		
		this.widget.parentId = oldParentId;
		this.widget.posX = oldX;
		this.widget.posY = oldY;
		
		this.widget.width = oldWith;
		this.widget.height = oldHeight;
		
		return result;
	}
	
	positioning() {
		if(!this.widget.inited) return;
		this.changeWidgetSizePolicy();
		this.changeWidgetAlign();
		this.onPositioning();
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			child.view.positioning();
		}
		this.updatePosition();
	}
	
	onPositioning() {}
	
	changeWidgetSizePolicy() {
		let parent = undefined;
		if(this.widget.parentId != -1) parent = Rex.widgets[this.widget.parentId];
		
		// Горизонтальная политика размеров
		switch(this.widget.horizontalSizePolicy) {
			case 1: // Minimal
				if(this.widget.minContentWidth !== undefined)
					if(this.widget.minContentWidth > this.widget.minWidth) this.widget.width = this.widget.minContentWidth;
					else this.widget.width = this.widget.minWidth;
				else this.widget.width = this.widget.minWidth;
				break;
			case 2: // FullScreen
				if(parent !== undefined) this.widget.width = parent.width - parent.paddingLeft - parent.paddingRight;
				else this.widget.width = Rex.render.width;	//FIXME REXRENDER
				break;
		}
		
		// Вертикальная политика размеров
		switch(this.widget.verticalSizePolicy) {
			case 1:  // Minimal
				if(this.widget.minContentHeight !== undefined)
					if(this.widget.minContentHeight > this.widget.minHeight) this.widget.height = this.widget.minContentHeight;
					else this.widget.height = this.widget.minHeight;
				else this.widget.height = this.widget.minHeight;
				break;
			case 2: // FullScreen
				if(parent !== undefined) this.widget.height = parent.height - parent.paddingTop - parent.paddingBottom;
				else this.widget.height = Rex.render.height; //FIXME REXRENDER
				break;
		}
	}
	
	//FIXME
	changeWidgetAlign() {
		let parent = undefined;
		if(this.widget.parentId != -1) parent = Rex.widgets[this.widget.parentId];
		
		// Горизонтальное выравнивание
		switch(this.widget.horizontalAlignType) {
			case 1: { //Left
				if(parent !== undefined) this.widget.posX = parent.posX + parent.paddingLeft;
				else this.widget.posX = 0;
				break;
			}
			case 2: { //Center
				if(parent !== undefined) this.widget.posX = (parent.posX + (parent.width / 2)) - (this.widget.width / 2);
				else this.widget.posX = (Rex.render.width / 2) - (this.widget.width / 2); //FIXME REXRENDER
				break;
			}
			case 3: { //Right
				if(parent !== undefined) this.widget.posX = ((parent.posX + parent.width) - (this.widget.width)) - parent.paddingRight;
				else this.widget.posX = Rex.render.width - this.widget.width; //FIXME REXRENDER
				break;
			}
		}
		
		// Вертикальное выравнивание
		switch(this.widget.verticalAlignType) {
			case 1: { //Top
				if(parent !== undefined) this.widget.posY = (parent.posY + parent.paddingTop);
				else this.widget.posY = 0;
				break;
			}
			case 2: { //Center
				if(parent !== undefined) this.widget.posY = ((parent.posY + (parent.height / 2)) - (this.widget.height / 2));
				else this.widget.posY = (Rex.render.height / 2) - (this.widget.height / 2); //FIXME REXRENDER
				break;
			}
			case 3: { //Bottom
				if(parent !== undefined) this.widget.posY = ((parent.posY + parent.height) - this.widget.height) - parent.paddingBottom;
				else this.widget.posY = Rex.render.height - this.widget.height; //FIXME REXRENDER
				break;
			}
		}
	}
	
	onDrag(dragAndDrop) {
		dragAndDrop.grabImage(Rex.render.ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		return true;
	}
	
	drawImage(ctx) {
		if(this.firstBuffer.height === 0 || this.firstBuffer.width === 0 || this.secondBuffer.height === 0 || this.secondBuffer.width === 0) return;
		ctx.drawImage(this.firstBuffer, this.widget.aPosX, this.widget.aPosY);
		ctx.drawImage(this.secondBuffer, this.widget.aPosX, this.widget.aPosY);
	}
	
	refreshCanvas() {
		this.firstBuffer.width = 1;
		this.secondBuffer.width = 1;
		
		this.firstBuffer.width = this.widget.width;
		this.firstBuffer.height = this.widget.height;
		
		this.secondBuffer.width = this.widget.width;
		this.secondBuffer.height = this.widget.height;
	}
	
	refreshBuffer() {
		this.refreshCanvas();
		this.firstBufferCtx.translate(-this.widget.aPosX, -this.widget.aPosY);
		this.secondBufferCtx.translate(-this.widget.aPosX, -this.widget.aPosY);
		this.reDraw(this.firstBufferCtx, this.secondBufferCtx);
		this.firstBufferCtx.translate(0, 0);
		this.secondBufferCtx.translate(0, 0);
	}
	
	reDraw(ctx, ctxTemp) {
		this.onRedraw(ctx, ctxTemp);
	}
	
	onRedraw(ctx, ctxTemp) {}
	
	draw(ctx, ctxTemp) {
		if(!this.widget.inited) return;
		if(!this.widget.visible) return;
		if(ctx !== undefined) ctx.save();
		if(ctxTemp !== undefined) ctxTemp.save();
		if(this.widget.transform[0] != undefined) {
			let fulcrumX = this.widget.aPosX + this.widget.width / 2;
			let fulcrumY = this.widget.aPosY + this.widget.height / 2;
			let dX = (1 - this.widget.transform[0]) * fulcrumX + this.widget.transform[1] * fulcrumY;
			let dY = this.widget.transform[4] * fulcrumX + (1 - this.widget.transform[0]) * fulcrumY;
			ctx.setTransform(this.widget.transform[0], this.widget.transform[1], this.widget.transform[4], this.widget.transform[5], dX, dY);
		}
		if(this.widget.elevation !== 0) {
			this.drawer.onDrawShadow(ctx);
		}
		if(this._needRefresh) {
			this.refreshBuffer();
			this._needRefresh = false;
		}
		this.onDraw(ctx, ctxTemp);
		if(this.widget.isFocused() && Rex.gui.selectWidgets.length == 0 && debugFocus) {
			ctx.strokeStyle = '#ff0000';
			ctx.strokeRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		}
		if(this.widget.isSelected()) {
			ctx.strokeStyle = '#ff0000';
			ctx.strokeRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		}
		
		if(ctx !== undefined) ctx.restore();
		if(ctxTemp !== undefined) ctxTemp.restore();
	}
	
	drawCopy(ctx, ctxTemp, x, y, width, height) {
		if(!this.widget.visible) return;
		if(ctx !== undefined) ctx.save();
		if(ctxTemp !== undefined) ctxTemp.save();
		
		let oldX = this.widget.aPosX;
		let oldY = this.widget.aPosY;
		let oldParentId = this.widget.parentId;
		this.widget.parentId = -1;
		
		this.widget.posX = x;
		this.widget.posY = y;
		
		let oldWith = this.widget.width;
		let oldHeight = this.widget.height;
		
		this.widget.width = width;
		this.widget.height = height;
		
		this.onPositioning();
		this.draw(ctx, ctxTemp);
		
		if(this.widget.isFocused()) {
			ctx.strokeStyle = '#ff0000';
			ctx.strokeRect(x, y, width, height);
		}
		
		this.widget.parentId = oldParentId;
		this.widget.posX = oldX;
		this.widget.posY = oldY;
		
		this.widget.width = oldWith;
		this.widget.height = oldHeight;
		
		if(ctx !== undefined) ctx.restore();
		if(ctxTemp !== undefined) ctxTemp.restore();
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			child.view.draw(ctx, ctxTemp);
		}
	}
	
};

/**
 * WidgetButton
 */
class WidgetButtonCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	};
	
	setState(state) {
		super.setState(state);
		if(state === undefined) return;
		if(!this.widget.inited) return;
		if(state.iconAlign !== undefined) {
			Rex.gui.reposition(this.widget);
		}
		if((state.raisedElevation !== undefined || state.defaultElevation !== undefined) && (this.widget.typeView === "canvas")) {
			this.update();
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.icon.view.draw(ctx, ctxTemp);
		this.widget.label.view.draw(ctx, ctxTemp);
		if(this.widget.isHovered()) {
			this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height,
				this.drawer.getParams("backgroundRadius", 2),
				this.drawer.getParams("hoverColor", "rgba(0, 0, 0, 0.1)"));
		}
		this.drawer.circleAnimation(ctx, ctxTemp, this.drawer.getParams("animationFillColor" ,  "Color(PrimaryLight,0.5)"));
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawer.background(ctx);
	}
	
	onPositioning() {
		this.widget.icon.posX = 0;
		this.widget.icon.posY = 0;
		this.widget.label.posX = 0;
		this.widget.label.posY = 0;
		
		switch(this.widget.iconAlign) {
			case 0:
				this.widget.icon.width = 0;
				this.widget.icon.height = 0;
				
				this.widget.label.width = this.widget.width;
				this.widget.label.height = this.widget.height;
				break;
			case 1:
				this.widget.icon.width = this.widget.width / 3;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.posX = this.widget.icon.width + 15;
				this.widget.label.width = this.widget.width - (this.widget.icon.width + 15);
				this.widget.label.height = this.widget.height;
				break;
			case 2:
				this.widget.icon.width = this.widget.width;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.width = 0;
				this.widget.label.height = 0;
				break;
			case 3:
				this.widget.icon.posX = this.widget.width - this.widget.width / 3;
				this.widget.icon.width = this.widget.width / 3;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.width = this.widget.width - this.widget.icon.width - 15;
				this.widget.label.height = this.widget.height;
				break;
		}
	}
	
	onCheckSelect(x, y) {
		if(this.inside(x, y)) {
			return this.widget;
		}
		return undefined;
	}
	
};


/**
 * WidgetCheckBox
 */

class WidgetCheckBoxCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(state.checked !== undefined || state.iconAlign !== undefined) {
			this.update();
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.icon.view.draw(ctx, ctxTemp);
		this.widget.label.view.draw(ctx, ctxTemp);
		if(this.animation.enable) {
			this.drawer.circleCustomSizeBoundAnimation(ctx, ctxTemp, this.widget.aPosX + 2, this.widget.aPosY +
				this.widget.height / 2 - this.widget.heightCheck / 2, this.widget.widthCheck, this.widget.heightCheck,
				this.drawer.getParams("animationFillColorChecked", "rgba(100,218,202, 0.8)"));
			
			if(this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck,
					this.widget.heightCheck) > (2 * (this.widget.widthCheck + this.widget.heightCheck) / 3)) this.animation.endAnimation();
			
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.widget.checked ? this.drawChecked(ctx, ctxTemp) : this.drawUnChecked(ctx, ctxTemp);
	}
	
	drawChecked(ctx, ctxTemp) {
		ctx.save();
		this.drawer.drawRect(ctx, this.widget.aPosX + 2, this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2,
			this.widget.widthCheck, this.widget.heightCheck, this.drawer.getParams("backgroundRadiusChecked", 3),
			this.drawer.getParams("colorBackgroundChecked", "rgba(207, 0, 0, 1)"));
		this.drawer.strokeTriangleCustom(ctx, this.widget.aPosX + 2, this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2,
			this.widget.widthCheck, this.widget.heightCheck, 2, this.drawer.getParams("colorMarkChecked", "rgb(206,206, 206)"));
		ctx.restore();
	}
	
	drawUnChecked(ctx, ctxTemp) {
		ctx.save();
		this.drawer.drawStrokeRect(ctx, this.widget.aPosX + 2, this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2,
			this.widget.widthCheck, this.widget.heightCheck, this.drawer.getParams("geometricRadiusUnChecked", 3), 0,
			this.drawer.getParams("geometricLineWidth", 2),
			this.drawer.getParams("geometricStrokeColorUnChecked", "rgb(158, 158, 158)"));
		ctx.restore();
	}
	
	startAnimation() {
		this.animation.startAnimation();
	}
	
	onPositioning() {
		let newX = this.widget.widthCheck + 15;
		let newWidth = this.widget.width - this.widget.widthCheck - 15;

		this.widget.icon.posX = newX;
		this.widget.icon.posY = 0;
		this.widget.label.posX = newX;
		this.widget.label.posY = 0;

		switch(this.widget.iconAlign) {
			case 0:
				this.widget.icon.width = 0;
				this.widget.icon.height = 0;

				this.widget.label.width = newWidth;
				this.widget.label.height = this.widget.height;
				break;
			case 1:
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;

				this.widget.label.posX = newX + this.widget.icon.width + 15;
				this.widget.label.width = newWidth - (this.widget.icon.width + 15);
				this.widget.label.height = this.widget.height;
				break;
			case 2:
				this.widget.icon.width = newWidth;
				this.widget.icon.height = this.widget.height;

				this.widget.label.width = 0;
				this.widget.label.height = 0;
				break;
			case 3:
				this.widget.icon.posX = newX + newWidth - newWidth / 3;
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;

				this.widget.label.width = newWidth - this.widget.icon.width - 15;
				this.widget.label.height = this.widget.height;
				break;
		}
	}
	
	onCheckSelect(x, y) {
		return this.inside(x, y) ? this.widget : undefined;
	}
	
}


/**
 * WidgetTree
 */

class TreeItemCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		Rex.copy(this.widget, state);
		if(state.text === undefined) return;
		this.widget.tree.view.update();
		try {
			this.widget.text = decodeURIComponent(escape(window.atob(this.widget.text)));
		}
		catch(e) {
			console.log(this.widget.tree.type, "setState->", "DecodeError, but fucking dances!")
		}
	}
	
	drawText(ctx, ctxTemp) {
		let label = Rex.widgets[this.widget.label];
		if(label === undefined) return;
		Rex.gui.textRender.renderText(ctx, this.widget.textX, this.widget.aPosY - 5,
			label.text,
			this.widget.tree.view.drawer.getParams("fontSize", 16),
			this.widget.tree.view.drawer.getParams("font", "Roboto"),
			this.widget.tree.view.drawer.getParams("textColor", "rgba(255, 0, 0, 1)")
		);
		
	}
	
	drawRect(ctx) {
		if(this.widget.tree.currentItem === null) return;
		if(this.widget.tree.currentItem.id === null) return;
		if(this.widget.tree.currentItem.id == this.widget.id) {
			ctx.save();
			ctx.fillStyle = this.widget.tree.view.drawer.getParams("itemSelectedBackgroundColor", "rgb(37, 165, 154)");
			ctx.fillRect(this.widget.tree.aPosX + this.widget.tree.view.getLeftOffset(), this.widget.aPosY,
				this.widget.tree.width - 2 * this.widget.tree.view.getLeftOffset(), this.widget.tree.view.getHeightItem());
			ctx.restore();
		}
	}
	
	drawIcon(ctx, expand) {
		if(this.widget.children.length == 0) return;
		let h = this.widget.tree.view.getHeightItem() / 2;
		let x = this.widget.tree.aPosX + this.widget.tree.view.getLeftOffset() * (this.widget.depth + 1.4);
		let y = this.widget.aPosY + h / 2;// + this.widget.tree.view.getHeightItem() / 2.0;
		ctx.save();
		if(expand) {
			let iconExpand = Rex.images[this.widget.tree.iconExpandId];
			if (iconExpand !== undefined && iconExpand.image !== undefined) {
				if (!iconExpand.image.complete) {
					iconExpand.image.onload = function() {
						this.update();
					}.bind(this);
				}
				ctx.drawImage(iconExpand.image, x, y, h, h);
			}
		}
		else {
			let iconUnExpand = Rex.images[this.widget.tree.iconUnExpandId];
			if (iconUnExpand !== undefined && iconUnExpand.image !== undefined) {
				if (!iconUnExpand.image.complete) {
					iconUnExpand.image.onload = function() {
						this.update();
					}.bind(this);
				}
				ctx.drawImage(iconUnExpand.image, x, y, h, h);
			}
		}
		ctx.restore();
	}
	
	drawWidget(ctx, ctxTemp) {
		if(this.widget.widgetId == -1) return;
		let widget = Rex.widgets[this.widget.widgetId];
		if(widget === undefined) return;
		widget.view.draw(ctx, ctxTemp);
	}
	
	draw(ctx, ctxTemp) {
		if(this.widget.tree.searchEnable && this.widget.tree.searchFilter != "") {
			if(this.widget.checkSearchFilter()) {
				this.drawWithoutSearch(ctx, ctxTemp);
			} else {
				this.drawWithSearch(ctx, ctxTemp);
			}
		} else {
			this.drawWithoutSearch(ctx, ctxTemp);
		}
	}
	
	drawWithoutSearch(ctx, ctxTemp) {
		this.drawRect(ctx);
		if(this.widget.widgetId == -1) this.drawText(ctx, ctxTemp);
		else this.drawWidget(ctx, ctxTemp);
		
		this.drawIcon(ctx, this.widget.expanded);
		
		if(!this.widget.expanded) return;
		
		for(let i = 0; i < this.widget.children.length; ++i) {
			this.widget.children[i].view.draw(ctx, ctxTemp);
		}
	}
	
	drawWithSearch(ctx, ctxTemp) {
		if(!this.widget.expanded) return;
		for(let i = 0; i < this.widget.children.length; ++i) {
			this.widget.children[i].view.draw(ctx, ctxTemp);
		}
	}
	
	
	
	reposText() {
		let label = Rex.widgets[this.widget.label];
		if(label === undefined) return;
		this.widget.textX = this.widget.tree.aPosX + (this.widget.depth + 3) * this.widget.tree.view.getLeftOffset();
		this.widget.textWidth = Rex.gui.textRender.getText(
			label.text,
			Rex.gui.styleLibrary.getParam(this.widget.styleName, "font", "Roboto"),
			Rex.gui.styleLibrary.getParam(this.widget.styleName, "fontSize", 16)
		).image.width;
	}
	
	reposWidget() {
		if(this.widget.widgetId == -1) return;
		let widget = Rex.widgets[this.widget.widgetId];
		if(widget === undefined) return;
		widget.posX = ((this.widget.depth + 3) * this.widget.tree.view.getLeftOffset());
		widget.posY = this.widget.posY;
		widget.width = Rex.clamp(this.widget.tree.width - ((this.widget.depth + 3) * this.widget.tree.view.getLeftOffset()), widget.minWidth, widget.maxWidth);
		if(widget.minHeight > this.widget.tree.view.getHeightItem()) widget.minHeight = this.widget.tree.view.getHeightItem();
		widget.height = Rex.clamp(this.widget.tree.view.getHeightItem(), widget.minHeight, widget.maxHeight);
	}
	
	repos(y, data) {
		if(this.widget.tree.searchEnable && this.widget.tree.searchFilter != "") {
			if(this.widget.checkSearchFilter()) {
				this.reposWithoutSearch(y, data);
			} else {
				this.reposWithSearch(y, data);
			}
		} else {
			this.reposWithoutSearch(y, data);
		}
	}
	
	reposWithoutSearch(y, data) {
		this.widget.posY = y + (this.widget.tree.view.getHeightItem() + this.widget.tree.view.getSpaceItem()) * data.count;
		this.widget.posX = this.widget.tree.view.getLeftOffset();
		
		if(this.widget.widgetId == -1) this.reposText();
		else this.reposWidget();
		
		this.widget.posXArrow = ((this.widget.depth + 2) * this.widget.tree.view.getLeftOffset()) + this.widget.tree.aPosX - this.widget.tree.view.getHeightItem();
		
		data.count++;
		
		if(!this.widget.expanded) return;
		
		for(let i = 0; i < this.widget.children.length; ++i) {
			this.widget.children[i].view.repos(y, data);
		}
	}
	
	reposWithSearch(y, data) {
		let h = this.widget.tree.view.getHeightItem() + this.widget.tree.view.getSpaceItem();
		y -= h;
		if(!this.widget.expanded) return;
		for(let i = 0; i < this.widget.children.length; ++i) {
			this.widget.children[i].view.repos(y, data);
		}
	}
	
	insideItem(mouseX, mouseY, x, y, width, height) {
		if(x > mouseX || (x + width) < mouseX) return false;
		if(y > mouseY || (y + height) < mouseY) return false;
		return true;
	}
	
	checkSelect(x, y, data) {
		if(this.widget.tree.searchEnable && this.widget.tree.searchFilter != "") {
			if(this.widget.checkSearchFilter()) {
				return this.checkingSelect(x, y, data);
			}
		} else {
			return this.checkingSelect(x, y, data);
		}
	}
	
	checkingSelect(x, y, data) {
		let h = this.widget.tree.view.getHeightItem() + this.widget.tree.view.getSpaceItem();
		
		let itemX = this.widget.tree.aPosX + this.widget.tree.view.getLeftOffset();
		let itemY;
		if(this.widget.tree.input !== undefined) {
			itemY = this.widget.tree.aPosY + this.widget.tree.input.height + this.widget.tree.view.getHeightItem() / 2 + h * data.count;
		} else {
			itemY = this.widget.tree.aPosY + this.widget.tree.view.getHeightItem() / 2 + h * data.count;
		}
		
		let itemWidth = this.widget.tree.width - 2 * this.widget.tree.view.getLeftOffset();
		let itemHeight = h;
		data.count++;
		if(this.insideItem(x, y, itemX, itemY, itemWidth, itemHeight)) {
			return this.widget;
		}
		
		if(!this.widget.expanded) return undefined;
		
		for(let i = 0; i < this.widget.children.length; ++i) {
			let ret = this.widget.children[i].view.checkSelect(x, y, data);
			if(ret !== undefined) return ret;
		}
		
		return undefined;
	}
	
}

class WidgetTreeCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		
		this.tempCanvas = document.createElement("canvas");
		this.tempCtx = this.tempCanvas.getContext("2d");
	}
	
	setState(state) {
		if(state === undefined) return;
		let oldsearch = this.widget.searchFilter;
		super.setState(state);
		
		//флаг, определяющий, произошло ли с деревом что-то такое, после чего его придется пересчитывать
		let needRepos = false;
		
		if(this.widget.searchEnable && state.searchFilter !== undefined && oldsearch !== this.widget.searchFilter) {
			try {
				this.widget.searchFilter = decodeURIComponent(escape(window.atob(this.widget.searchFilter)));
				needRepos = true;
				if(this.widget.searchFilter != "") this.widget.widgetScrollVertical.value = 0;
			} catch(e) {
				console.log(this.widget.type, "setState-> Search filter decodeError!")
			}
		}
		if(this.widget.items === undefined) this.widget.items = {};
		
		this.widget.selectItem = this.widget.items[this.widget.selectedItemId];
		
		if(this.widget.commands === undefined) {
			this.widget.commands = [];
			return;
		}
		
		for(let i = 0; i < this.widget.commands.length; ++i) {
			let command = this.widget.commands[i];
			if(command.hasOwnProperty("add")) {
				let item = new TreeItem();
				if(item === undefined) continue;
				item.setState(command.add);
				if(item.parentId != -1) {
					if(this.widget.items[item.parentId] === undefined) continue;
					this.widget.items[item.parentId].addChild(item);
				}
				item.tree = this.widget;
				item.createView();
				this.widget.items[item.id] = item;
				needRepos = true;
			} else if(command.hasOwnProperty("expand")) {
				if(this.widget.items[command.expand.id] === undefined) continue;
				this.widget.items[command.expand.id].setState(command.expand);
				needRepos = true;
			} else if(command.hasOwnProperty("blockExpand")) {
				if(this.widget.items[command.blockExpand.id] === undefined) continue;
				this.widget.items[command.blockExpand.id].setState(command.blockExpand);
				needRepos = true;
			} else if(command.hasOwnProperty("update")) {
				if(this.widget.items[command.update.id] === undefined) continue;
				this.widget.items[command.update.id].setState(command.update);
			} else if(command.hasOwnProperty("remove")) {
				let item = this.widget.items[command.remove.id];
				if(item === undefined) continue;
				if(item.parentId != -1) {
					if(this.widget.items[item.parentId] === undefined) continue;
					this.widget.items[item.parentId].removeChild(item);
				}
				delete this.widget.items[item.id];
				this.widget.selectItem = undefined;
				needRepos = true;
			}
		}
		this.widget.commands = [];
		
		if(needRepos && Rex.widgets !== undefined) {
			Rex.gui.reposition(this);
			this.update();
		}
		
		if(state.iconUnExpandId !== undefined || state.iconExpandId !== undefined) {
			this.update();
		}
		
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.input !== undefined)
			this.widget.input.view.draw(ctx, ctxTemp);
		
		for(let key in this.widget.items) {
			let item = this.widget.items[key];
			if(this.widget.hoveredItemId === item.id) {
				ctx.save();
				ctx.fillStyle = this.drawer.getParams("itemHoverBackgroundColor", "rgba(158, 158, 158, 0.5)");
				ctx.fillRect(this.widget.aPosX + this.getLeftOffset(), item.aPosY, this.widget.width - 2 * this.getLeftOffset(), this.getHeightItem());
				ctx.restore();
			}
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 2, this.drawer.getParams("backgroundColorTree", "rgba(0, 0, 0, 0)"));
		this.drawTree(ctx, ctxTemp);
	}
	
	drawTree(ctx, ctxTemp) {
		for(let key in this.widget.items) {
			let item = this.widget.items[key];
			if(item.parentId != -1) continue;
			item.view.draw(ctx, ctxTemp);
		}
	}
	
	onMouseDown(mouseX, mouseY, event) {
		if(this.widget.dragging) return;
		if(this.widget.currentItem != null) {
			if(this.widget.currentItem.children.length !== 0) {
				let anchorPos = new Rex.Vector2(this.widget.currentItem.posXArrow, this.widget.currentItem.aPosY);
				let anchorSize = new Rex.Vector2(this.getHeightItem(), this.getHeightItem());
				let mouse = new Rex.Vector2(mouseX, mouseY);
				let min = new Rex.Vector2((anchorPos.x), anchorPos.y);
				let max = new Rex.Vector2((anchorPos.x) + (anchorSize.x), (anchorPos.y) + (anchorSize.y));
				let boundBox = new Rex.BoundBox(min, max);
				if(boundBox.inside(mouse, 0)) {
					if(Rex.engine.translateMouseButton(event.which) == Rex.MouseButtonLeft) this.widget.currentItem.setExpanded(!this.widget.currentItem.expanded);
					return;
				}
			}
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "mouseDownItem", [Rex.engine.translateMouseButton(event.which)]);
			this.update();
		}
	}
	
	onMouseUp(mouseX, mouseY, event) {
		if(this.widget.dragging) {
			this.widget.dragging = false;
			return;
		}
		let button = Rex.engine.translateMouseButton(event.which);
		
		if(this.widget.currentItem !== null) {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "mouseUpItem", [button]);
			
		}
	}
	
	onMouseDoubleClick(event) {
		let button = Rex.engine.translateMouseButton(event.which);
		if(this.widget.currentItem !== null) {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "mouseDoubleClickItem", []);
			if(button == Rex.MouseButtonLeft) this.widget.currentItem.setExpanded(!this.widget.currentItem.expanded);
		}
	}
	
	onPositioning() {
		//минимальная ширина дерева
		let maxWidth = 0;
		for(let id in this.widget.items) {
			let childItem = this.widget.items[id];
			let itemWidth = (childItem.depth + 2) * this.getLeftOffset();
			if(childItem.widgetId != -1) {
				let widget = Rex.widgets[childItem.widgetId];
				if(widget === undefined) continue;
				itemWidth += widget.minWidth;
			}
			else {
				itemWidth += childItem.textWidth;
			}
			if(itemWidth > maxWidth) {
				maxWidth = itemWidth;
			}
		}
		this.widget.minWidth = maxWidth;
		this.widget.heightItems = 0;
		
		//дата - массив итемов, которые нужно считать. собирается рекурсивно. лучше не трогать ее
		var data = {};
		data.count = 0;
		
		//инпут репос
		if(this.widget.input !== undefined) {
			this.widget.input.posY = 0;
			this.widget.input.width = this.widget.width;
			this.widget.input.posX = 0;
			this.widget.input.height = 35;
		}
		//отступ для инпута
		let posY;
		if(this.widget.searchEnable && (this.widget.input !== undefined)) {
			posY = this.widget.input.height;
		} else {
			posY = 0;
		}
		//рекурсивный вызов репоса для всех корневых
		for(let key in this.widget.items) {
			let item = this.widget.items[key];
			if(item.parentId != -1) continue;
			item.view.repos(posY + this.getHeightItem() / 2, data);
		}
		//определение итоговой высоты дерева
		this.widget.heightItems = (data.count + 1) * (this.getHeightItem() + this.getSpaceItem()) + (this.widget.searchEnable ? 35 : 0);
		if(this.widget.height !== this.widget.heightItems) {
			this.widget.height = this.widget.heightItems;
			this.widget.minHeight = this.widget.heightItems;
			this.widget.maxHeight = this.widget.heightItems;
		}
	}
	
	////////////////////////////////////
	///////////////////////////////////
	
	getHeightItem() {
		return Rex.gui.styleLibrary.getParam(this.widget.styleName, "fontSize", 16);
	}
	
	getLeftOffset() {
		return this.getHeightItem() / 1.8;
	}
	
	getSpaceItem() {
		return this.getHeightItem() / 16.0;
	}
	
	checkSelect(x, y) {
		return this.onCheckSelect(x, y);
	}
	
	onCheckSelect(x, y) {
		if(!this.inside(x, y)) return undefined;
		
		let retWidget = this.widget;
		
		for(let key in this.widget.children) {
			let child = Rex.widgets[this.widget.children[key]];
			if(child === undefined) continue;
			if(!child.isVisible()) continue;
			if(child.type == "WidgetLabel") continue;
			let childRet = child.view.checkSelect(x, y);
			if(childRet !== undefined) {
				retWidget = childRet;
				break;
			}
		}
		
		var data = {};
		data.count = 0;
		
		for(let key in this.widget.items) {
			let item = this.widget.items[key];
			if(item.parentId != -1) continue;
			
			let ret = item.view.checkSelect(x, y, data);
			if(ret === undefined) continue;
			
			if(this.widget.currentItem == ret) return retWidget;
			this.widget.currentItem = ret;
			ret.setHovered(true);
			return retWidget;
		}
		
		if(this.widget.currentItem !== null) this.widget.currentItem.setHovered(false);
		this.widget.currentItem = null;
		return retWidget;
	}
	
	onDrag(dragAndDrop) {
		if(this.widget.hoveredItemId == -1) return false;
		var item = this.widget.items[this.widget.hoveredItemId];
	
		dragAndDrop.grabImage(Rex.render.ctx, this.widget.posX + item.posX, item.posY + 1, this.widget.width - 2 * this.getLeftOffset() - 8, this.getHeightItem());
		dragAndDrop.data = {itemId : item.id};
		this.widget.dragging = true;
		this.update();
		return true;
	}
	
}


class WidgetScrollCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.centrPos = 0;
		this.oldPos = 0;
		this.step = 1;
		this.pressedArrows = 0;
		this.colorArrows = "black";
		this.setValueDown = 0;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.scrollType === 0) {
			if(this.widget.isHovered())
				this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.width *
					this.widget.arrowsVisible0or1 * 1.05 + this.widget.value * (this.widget.height -
						this.widget.sizeSlider - this.widget.width * this.widget.arrowsVisible0or1 * 2.1),
					this.widget.width, this.widget.sizeSlider, 0,
					this.drawer.getParams("hoverSliderColor", "rgba(158,158,158,0.2)"));
		}
		else {
			if(this.widget.isHovered())
				this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 *
					1.05 + this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
						this.widget.arrowsVisible0or1 * 2.1), this.widget.aPosY, this.widget.sizeSlider,
					this.widget.height, 0, this.drawer.getParams("hoverSliderColor", "rgba(158, 158, 158, 0.2)"));
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawScroll(ctx, ctxTemp);
	}
	
	drawScroll(ctx, ctxTemp) {
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 0,
			this.drawer.getParams("backgroundColorScroll", "rgb(206,206, 206)"));
		ctx.save();
		if(this.widget.scrollType === 0) {
			this.widget.sizeSlider = (this.widget.height - 2.1 * this.widget.width * this.widget.arrowsVisible0or1) * this.widget.height / this.widget.contentSize;
			if(this.widget.sizeSlider > (this.widget.height - this.widget.arrowsVisible0or1 * 2.1 * this.widget.width))
				this.widget.sizeSlider = this.widget.height - this.widget.arrowsVisible0or1 * 2.1 * this.widget.width;
			if(this.widget.pressedSlider)
				this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.width * this.widget.arrowsVisible0or1 * 1.05 + this.widget.value *
					(this.widget.height - this.widget.sizeSlider - this.widget.width * this.widget.arrowsVisible0or1 * 2.1), this.widget.width, this.widget.sizeSlider, 0,
					this.drawer.getParams("backgroundColorSliderPress", "rgba(110, 110, 110, 1)"));
			else
				this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.width * this.widget.arrowsVisible0or1 * 1.05 + this.widget.value *
					(this.widget.height - this.widget.sizeSlider - this.widget.width * this.widget.arrowsVisible0or1 * 2.1), this.widget.width, this.widget.sizeSlider, 0,
					this.drawer.getParams("backgroundColorSlider", "rgb(158, 158, 158)"));
			this.widget.start = this.widget.aPosY + this.widget.sizeSlider / 2 + this.widget.width * this.widget.arrowsVisible0or1 * 1.05;
			this.widget.length = this.widget.height - this.widget.sizeSlider - this.widget.width * this.widget.arrowsVisible0or1 * 2.1;
			
			if(this.widget.arrowsVisible0or1) {
				if(this.pressedArrows === 1) {
					this.colorArrows = this.drawer.getParams("colorArrowsPress", "rgb(99, 215, 203)");
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.width, 0,
						this.drawer.getParams("backgroundColorArrowPress", "rgb(110, 110, 110"));
				} else {
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.width, 0,
						this.drawer.getParams("backgroundColorScroll", "rgb(206,206, 206)"));
					this.colorArrows = this.drawer.getParams("colorArrows", "rgb(158, 158, 158)");
				}
				ctx.save();
				this.drawer.drawFillTriangle(ctx, this.widget.aPosX + this.widget.width / 2,
					this.widget.aPosY + this.widget.width / 2, this.widget.width / 3,
					this.widget.width / 3, this.colorArrows);
				ctx.restore();
				ctx.save();
				if(this.pressedArrows === 2) {
					this.colorArrows = this.drawer.getParams("colorArrowsPress", "rgb(255, 255, 255)");
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height - this.widget.width, this.widget.width, this.widget.width, 0,
						this.drawer.getParams("backgroundColorArrowPress", "rgba(110, 110, 110, 1)"));
				} else {
					this.colorArrows = this.drawer.getParams("colorArrows", "rgb(158, 158, 158)");
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height - this.widget.width, this.widget.width, this.widget.width, 0,
						this.drawer.getParams("backgroundColorScroll", "rgb(206,206, 206)"));
				}
				this.drawer.drawFillTriangle(ctx, this.widget.aPosX + this.widget.width / 2,
					this.widget.aPosY - this.widget.width / 2 + this.widget.height,
					this.widget.width / 3, -this.widget.width / 3, this.colorArrows);
				ctx.restore();
			}
		}
		else {
			this.widget.sizeSlider = (this.widget.width - 2.1 * this.widget.height * this.widget.arrowsVisible0or1) * this.widget.width / this.widget.contentSize;
			if(this.widget.sizeSlider > (this.widget.width - this.widget.arrowsVisible0or1 * 2.1 * this.widget.height))
				this.widget.sizeSlider = this.widget.width - this.widget.arrowsVisible0or1 * 2.1 * this.widget.height;
			if(this.widget.pressedSlider)
				this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 * 1.05 + this.widget.value *
					(this.widget.width - this.widget.sizeSlider - this.widget.height * this.widget.arrowsVisible0or1 * 2.1), this.widget.aPosY, this.widget.sizeSlider, this.widget.height, 0,
					this.drawer.getParams("backgroundColorSliderPress", "rgba(110, 110, 110, 1)"));
			else
				this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 * 1.05 + this.widget.value *
					(this.widget.width - this.widget.sizeSlider - this.widget.height * this.widget.arrowsVisible0or1 * 2.1), this.widget.aPosY, this.widget.sizeSlider, this.widget.height, 0,
					this.drawer.getParams("backgroundColorSlider", "rgb(158, 158, 158)"));
			
			this.widget.start = this.widget.aPosX + this.widget.sizeSlider / 2 + this.widget.height * this.widget.arrowsVisible0or1 * 1.05;
			this.widget.length = this.widget.width - this.widget.sizeSlider - this.widget.height * this.widget.arrowsVisible0or1 * 2.1;
			
			if(this.widget.arrowsVisible0or1) {
				if(this.pressedArrows === 1) {
					this.colorArrows = this.drawer.getParams("colorArrowsPress", "rgb(255, 255, 255)");
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.height, this.widget.height, 0,
						this.drawer.getParams("backgroundColorArrowPress", "rgba(110, 110, 110, 1)"));
				} else {
					this.colorArrows = this.drawer.getParams("colorArrows", "rgb(158, 158, 158)");
					this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.height, this.widget.height, 0,
						this.drawer.getParams("backgroundColorScroll", "rgb(206,206, 206)"));
				}
				ctx.save();
				this.drawer.drawFillTriangleLateral(ctx, this.widget.aPosX + this.widget.height / 2,
					this.widget.aPosY + this.widget.height / 2, -this.widget.height / 2,
					this.widget.height / 3, this.colorArrows);
				ctx.restore();
				if(this.pressedArrows === 2) {
					this.colorArrows = this.drawer.getParams("colorArrowsPress", "rgb(255, 255, 255)");
					this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.width - this.widget.height, this.widget.aPosY, this.widget.height, this.widget.height, 0,
						this.drawer.getParams("backgroundColorArrowPress", "rgba(110, 110, 110, 1)"));
				} else {
					this.colorArrows = this.drawer.getParams("colorArrows", "rgb(158, 158, 158)");
					this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.width - this.widget.height, this.widget.aPosY, this.widget.height, this.widget.height, 0,
						this.drawer.getParams("backgroundColorScroll", "rgb(206,206, 206)"));
				}
				ctx.save();
				this.drawer.drawFillTriangleLateral(ctx, this.widget.aPosX - this.widget.height / 2 + this.widget.width,
					this.widget.aPosY + this.widget.height / 2, this.widget.height / 2,
					-this.widget.height / 3, this.colorArrows);
				ctx.restore();
			}
		}
		ctx.restore();
	}
	
	onMouseMove(x, y) {
		if(this.widget.pressed) {
			if(!this.pressedArrows) {
				if(this.widget.pressedSlider)
					this.setValue(((this.widget.scrollType === 1 ? x : y) -
					this.oldPos + this.centrPos - this.widget.start) / this.widget.length);
				else {
					this.oldPos = this.widget.scrollType === 1 ? x : y;
					if(this.oldPos > this.centrPos + this.widget.sizeSlider / 2) this.setValueDownBackground(1);
					else if(this.oldPos < this.centrPos - this.widget.sizeSlider / 2) this.setValueDownBackground(-1);
				}
				// При перемещении скролла - перерасчет позиции контента
				if(Rex.gui === undefined) return;
				this.update();
				Rex.gui.reposition(this.widget);
			}
		}
	}
	
	onMouseWheel(event) {
		if(this.widget.sizeSlider >= this.widget.contentSize) return;
		let increment;
		if(this.widget.scrollType === 0) increment = 1 / (this.widget.contentSize - this.widget.height +
			this.widget.arrowsVisible0or1 * this.widget.width * 2.1);
		else increment = 1 / (this.widget.contentSize - this.widget.width + this.widget.arrowsVisible0or1 * this.widget.height * 2.1);
		
		this.setValue(this.widget.mouseScrollingStep * event * increment + this.widget.value);
		
		// При вращении мыши - перерасчет позиции контента
		if(Rex.gui === undefined) return;
		this.update();
		Rex.gui.reposition(this.widget);
	}
	
	onMouseDown(x, y) {
		if(this.widget.sizeSlider >= this.widget.contentSize) return;
		this.widget.pressed = true;
		
		if(Rex.gui === undefined) return;
		
		Rex.gui.reposition(this.widget);
		
		this.update();
		
		if(this.widget.scrollType == 0) {
			let mouse = new Rex.Vector2(x, y);
			let min = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY + this.widget.width *
				this.widget.arrowsVisible0or1 + (this.widget.value * (this.widget.height -
					this.widget.sizeSlider - this.widget.width * this.widget.arrowsVisible0or1 * 2)));
			let max = new Rex.Vector2(this.widget.aPosX + this.widget.width, this.widget.aPosY +
				this.widget.width * this.widget.arrowsVisible0or1 + (this.widget.value *
					(this.widget.height - this.widget.sizeSlider - this.widget.width *
						this.widget.arrowsVisible0or1 * 2)) + this.widget.sizeSlider);
			let boundBox = new Rex.BoundBox(min, max);
			this.centrPos = this.widget.aPosY + this.widget.width * this.widget.arrowsVisible0or1 +
				(this.widget.value * (this.widget.height - this.widget.sizeSlider - this.widget.width *
					this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
			this.oldPos = y;
			if(boundBox.inside(mouse, 0)) {
				this.widget.pressedSlider = true;
				Rex.gui.redraw();
			}
			else {
				if(this.widget.arrowsVisible0or1) {
					let min = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY);
					let max = new Rex.Vector2(this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.width);
					let boundBox = new Rex.BoundBox(min, max);
					if(boundBox.inside(mouse, 0)) {
						this.pressedArrows = 1;
						this.downArrows(-1);
						Rex.gui.redraw();
					}
					else {
						let min = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY + this.widget.height - this.widget.width);
						let max = new Rex.Vector2(this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height);
						let boundBox = new Rex.BoundBox(min, max);
						if(boundBox.inside(mouse, 0)) {
							this.pressedArrows = 2;
							this.downArrows(1);
							Rex.gui.redraw();
						}
						else {
							if(y > this.centrPos) this.step = 1;
							else this.step = -1;
							this.setValueDownBackground(this.step);
						}
					}
				}
				else {
					if(y > this.centrPos) this.step = 1;
					else this.step = -1;
					this.setValueDownBackground(this.step);
				}
			}
		}
		else {
			let mouse = new Rex.Vector2(x, y);
			let min = new Rex.Vector2(this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 +
				(this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
					this.widget.arrowsVisible0or1 * 2)), this.widget.aPosY);
			let max = new Rex.Vector2(this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 +
				(this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
					this.widget.arrowsVisible0or1 * 2)) + this.widget.sizeSlider, this.widget.aPosY + this.widget.height);
			
			let boundBox = new Rex.BoundBox(min, max);
			this.centrPos = this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 +
				(this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
					this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
			this.oldPos = x;
			if(boundBox.inside(mouse, 0)) {
				this.widget.pressedSlider = true;
				Rex.gui.redraw();
			}
			else {
				if(this.widget.arrowsVisible0or1) {
					let min = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY);
					let max = new Rex.Vector2(this.widget.aPosX + this.widget.height, this.widget.aPosY + this.widget.height);
					let boundBox = new Rex.BoundBox(min, max);
					if(boundBox.inside(mouse, 0)) {
						this.pressedArrows = 1;
						this.downArrows(-1);
						Rex.gui.redraw();
					}
					else {
						let min = new Rex.Vector2(this.widget.aPosX + this.widget.width - this.widget.height, this.widget.aPosY);
						let max = new Rex.Vector2(this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height);
						let boundBox = new Rex.BoundBox(min, max);
						if(boundBox.inside(mouse, 0)) {
							this.pressedArrows = 2;
							this.downArrows(1);
							Rex.gui.redraw();
						}
						else {
							if(x > this.centrPos) this.step = 1;
							else this.step = -1;
							this.setValueDownBackground(this.step);
						}
					}
				}
				else {
					if(x > this.centrPos) this.step = 1;
					else this.step = -1;
					this.setValueDownBackground(this.step);
				}
			}
		}
		this.update();
	}
	
	onMouseUp(x, y) {
		this.widget.pressed = false;
		this.pressedArrows = 0;
		if(this.widget.pressedSlider) {
			this.widget.pressedSlider = false;
			Rex.gui.redraw();
		}
		else clearTimeout(this.setValueDown);
		this.update();
	}
	
	downArrows(value) {
		let increment;
		if(this.widget.scrollType === 0)
			increment = 1 / (this.widget.contentSize - this.widget.height + this.widget.arrowsVisible0or1 * this.widget.width * 2.1);
		else
			increment = 1 / (this.widget.contentSize - this.widget.width + this.widget.arrowsVisible0or1 * this.widget.height * 2.1);
		
		this.setValue(this.widget.arrowsScrollingStep * value * increment + this.widget.value);
		let that = this;
		this.setValueDown = setTimeout(function() {
			that.downArrows(value)
		}, 65);
	}
	
	setValueDownBackground(step) {
		var that = this;
		if(step > 0) {
			if(this.widget.value >= 1) return;
			if(this.oldPos > this.centrPos + this.widget.sizeSlider / 2) {
				this.setValue((this.centrPos - this.widget.start + this.widget.sizeSlider) / this.widget.length);
				if(this.widget.scrollType === 0)
					this.centrPos = this.widget.aPosY + this.widget.width * this.widget.arrowsVisible0or1 +
						(this.widget.value * (this.widget.height - this.widget.sizeSlider -
							this.widget.width * this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
				else
					this.centrPos = this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 +
						(this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
							this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
				this.setValueDown = setTimeout(function() {
					that.setValueDownBackground(step)
				}, 100);
			}
		}
		else {
			if(this.widget.value <= 0) return;
			if(this.oldPos < this.centrPos - this.widget.sizeSlider / 2) {
				this.setValue((this.centrPos - this.widget.start - this.widget.sizeSlider) / this.widget.length);
				if(this.widget.scrollType === 0)
					this.centrPos = this.widget.aPosY + this.widget.width * this.widget.arrowsVisible0or1 +
						(this.widget.value * (this.widget.height - this.widget.sizeSlider -
							this.widget.width * this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
				else
					this.centrPos = this.widget.aPosX + this.widget.height * this.widget.arrowsVisible0or1 +
						(this.widget.value * (this.widget.width - this.widget.sizeSlider - this.widget.height *
							this.widget.arrowsVisible0or1 * 2) + this.widget.sizeSlider / 2);
				this.setValueDown = setTimeout(function() {
					that.setValueDownBackground(step)
				}, 100);
			}
		}
	}
	
	setValue(v) {
		if(v > 1) {
			if(this.widget.value < 1) {
				this.widget.value = 1;
				Rex.gui.redraw();
			}
		}
		else if(v < 0) {
			if(this.widget.value > 0) {
				this.widget.value = 0;
				Rex.gui.redraw();
			}
		}
		else {
			this.widget.value = v;
			Rex.gui.redraw();
		}
		this.update();
	}
	
}

/**
 * WidgetLayout
 */

class WidgetLayoutCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	onRedraw(ctx, ctxTemp) {
		let a = this.drawer.getParams("backgroundColorShadow", undefined);
		if(a !== undefined) this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 0, a);
	}
	
	onPositioning() {
		this.expand();
	}
	
	expand() {
		//нужно именно два равно когда мы проверяем айдишники. Так как теперь айдишник может быть строкой.
		if(this.widget.parentId == -1) {
			this.widget.posX = 0;
			this.widget.posY = 0;
			this.widget.width = window.innerWidth;
			this.widget.height = window.innerHeight;
		}
		
		if(this.widget.children.length > 0) {
			this.onExpand();
		} else {
			this.widget.minContentHeight = 0;
			this.widget.minContentWidth = 0;
		}
	}
	
	onExpand() {
		let sumMin = 0;
		let maxSize = 0;
		let lastX = this.widget.paddingLeft;
		let lastY = this.widget.paddingTop;
		
		if(this.baseLayoutOrientation === 1) {
			//просто горизонтальный
			for(let i = 0; i < this.widget.children.length; ++i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				if(child.inited) child.view.onPositioning();
				child.width = Rex.clamp(child.width, child.minWidth, child.maxWidth);
				
				if(maxSize < child.minHeight + child.marginTop + child.marginBottom)
					maxSize = child.minHeight + child.marginTop + child.marginBottom;
				
				sumMin += child.width + child.marginLeft + child.marginRight;
				
				child.posX = lastX + child.marginLeft;
				lastX = child.posX + child.width + child.marginRight;
				
			}
			this.widget.width = sumMin;
			
			for(let i = 0; i < this.widget.children.length; ++i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				child.height = child.minHeight > maxSize ? child.minHeight : this.widget.height;
				child.posY = lastY + ((this.widget.height - this.widget.paddingTop - this.widget.paddingBottom) / 2) - ((child.height - child.marginTop - child.marginBottom) / 2);
			}
			this.widget.minContentWidth = this.widget.width;
			this.widget.minContentHeight = maxSize;
			
		} else {
			//просто вертикальный
			for(let i = 0; i < this.widget.children.length; ++i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				if(child.inited) child.view.onPositioning();
				child.height = Rex.clamp(child.height, child.minHeight, child.maxHeight);
				
				if(maxSize < child.minWidth + child.marginLeft + child.marginRight)
					maxSize = child.minWidth + child.marginLeft + child.marginRight;
				
				sumMin += child.height + child.marginTop + child.marginBottom;
				
				child.posY = lastY + child.marginTop;
				lastY = child.posY + child.height + child.marginBottom;
				
			}
			this.widget.height = sumMin;
			
			for(let i = 0; i < this.widget.children.length; ++i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				child.width = child.minWidth > maxSize ? child.minWidth : this.widget.width;
				child.posX = lastX + ((this.widget.width - this.widget.paddingLeft - this.widget.paddingRight) / 2) - ((child.width - child.marginLeft - child.marginRight) / 2);
			}
			this.widget.minContentWidth = maxSize;
			this.widget.minContentHeight = this.widget.height;
		}
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = undefined;
			for(let i = this.widget.children.length - 1; i >= 0; --i) {
				let child = Rex.widgets[this.widget.children[i]];
				if(child === undefined) continue;
				if(!child.isVisible()) continue;
				let childRet = child.view.checkSelect(x, y);
				if(childRet !== undefined) return childRet;
			}
		}
		return ret;
	}
	
}

/**
 * Created by prg-40 on 18.09.2017.
 */

class WidgetLayoutGridCanvas extends WidgetLayoutCanvas {
	
	constructor(widget) {
		super(widget);
		this.tmpchildren = {};
	}
	
	setState(state) {
		super.setState(state);
		if(!this.widget.inited) return;
		
		if(state.items !== undefined) {
			Rex.gui.reposition(this);
			this.update();
		}
	}
	
	onExpand() {
		this.widget.onExpand();
	}
	
}

/**
 * Created by prg-37 on 17.09.2017.
 */

class WidgetLayoutVerticalCanvas extends WidgetLayoutCanvas {
	
	 constructor(widget) {
		super(widget);
	}
	
	onExpand() {
		let sumMin = 0;
		let tempArray = [];
		let lastY = this.widget.paddingTop;
		let fullArea = this.widget.height - this.widget.paddingTop - this.widget.paddingBottom;
		
		let maxW = 0;
		let spacerCount = 0;
		
		//TODO придумать что нибудь получше
		//это типа создаем копию виджетов, с ними играемся, а потом в конце один раз выкатываем на настоящие виджеты.
		let tmpchildren = [];
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			let tmpchild = {};
			tmpchild.id = child.id;
			tmpchild.posX = child.posX;
			tmpchild.posY = child.posY;
			tmpchild.width = child.width;
			tmpchild.height = child.height;
			tmpchild.minHeight = child.minHeight;
			tmpchild.minWidth = child.minWidth;
			tmpchild.maxHeight = child.maxHeight;
			tmpchild.maxWidth = child.maxWidth;
			tmpchild.marginBottom = child.marginBottom;
			tmpchild.marginTop = child.marginTop;
			tmpchild.marginLeft = child.marginLeft;
			tmpchild.marginRight = child.marginRight;
			tmpchild.type = child.type;
			
			tmpchild.depress = child.depress;
			tmpchild.orientation = child.orientation;
			
			tmpchildren.push(tmpchild);
		}
		
		for(let i = 0; i < tmpchildren.length; ++i) {
			let child = tmpchildren[i];
			sumMin += child.minHeight + child.marginTop + child.marginBottom;
			tempArray.push(child);
			child.height = child.minHeight;
			
			let freeWidth = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight - child.marginLeft - child.marginRight;
			if(child.maxWidth < freeWidth) child.width = child.maxWidth;
			else child.width = freeWidth;
			if((child.width < child.minWidth) || (child.width > freeWidth)) console.error("Child margin or padding wrong! ", child.type, child.id);
			
			child.posY = lastY;
			lastY = child.posY + child.height;
			child.posX = this.widget.paddingLeft + child.marginLeft + (((this.widget.width - this.widget.paddingLeft - this.widget.paddingRight) / 2) - ((child.width + child.marginRight + child.marginLeft) / 2));
			
			if(child.minWidth > maxW) maxW = child.minWidth;
			
			if(child.type == "WidgetSpacer") {
				if((child.depress) && (child.orientation == 0))
					spacerCount++;
			}
			
		}
		
		this.widget.minContentHeight = sumMin;
		this.widget.minContentWidth = maxW;
		
		if(tempArray.length == 0) return;
		
		let isFullFill = sumMin >= fullArea;
		tempArray.sort(sortHeight);
		let skip_index = 0;
		let emptyArea = ((fullArea - sumMin) / tempArray.length);
		
		if(spacerCount > 0) {
			lastY = this.widget.paddingTop;
			let empty = (fullArea - sumMin) / spacerCount;
			for(let i = 0; i < tmpchildren.length; ++i) {
				let child = tmpchildren[i];
				if(child.type == "WidgetSpacer")
					if((child.depress) && (child.orientation == 0))
						child.height = empty;
				child.posY = lastY + child.marginTop;
				lastY = child.posY + child.height + child.marginBottom;
			}
			isFullFill = true;
		}
		while(!isFullFill) {
			sumMin = 0;
			lastY = this.widget.paddingTop;
			
			if((tempArray[skip_index].height >= tempArray[skip_index].maxHeight) && (tempArray[skip_index].maxHeight >= 0)) {
				if((tempArray.length - 1) > skip_index)
					skip_index++;
				else {
					break;
				}
			}
			
			tempArray[skip_index].height++;
			
			for(let i = 0; i < tmpchildren.length; ++i) {
				let child = tmpchildren[i];
				sumMin += child.height + child.marginTop + child.marginBottom;
				child.posY = lastY + child.marginTop + (emptyArea / 2);
				lastY = child.posY + child.height + (emptyArea / 2) + child.marginBottom;
			}
			
			isFullFill = sumMin >= fullArea;
			emptyArea = ((fullArea - sumMin) / tempArray.length);
			tempArray.sort(sortHeight);
		}
		
		for(let i = 0; i < tmpchildren.length; ++i) {
			let tmpchild = tmpchildren[i];
			let child = Rex.widgets[tmpchild.id];
			if(child === undefined) continue;
			child.posX = tmpchild.posX;
			child.posY = tmpchild.posY;
			child.width = tmpchild.width;
			child.height = tmpchild.height;
		}
	}
	
}


/**
 * Created by prg-37 on 17.09.2017.
 */
	


class WidgetLayoutHorizontalCanvas extends WidgetLayoutCanvas {

	constructor(widget) {
		super(widget);
	}
	
	onExpand() {
		let sumMin = 0;
		let tempArray = [];
		let lastX = this.widget.paddingLeft;
		let fullArea = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight;
		
		let maxH = 0;
		let spacerCount = 0;
		
		//TODO придумать что нибудь получше
		//это типа создаем копию виджетов, с ними играемся, а потом в конце один раз выкатываем на настоящие виджеты.
		let tmpchildren = [];
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			let tmpchild = {};
			tmpchild.id = child.id;
			tmpchild.posX = child.posX;
			tmpchild.posY = child.posY;
			tmpchild.width = child.width;
			tmpchild.height = child.height;
			tmpchild.minHeight = child.minHeight;
			tmpchild.minWidth = child.minWidth;
			tmpchild.maxHeight = child.maxHeight;
			tmpchild.maxWidth = child.maxWidth;
			tmpchild.marginBottom = child.marginBottom;
			tmpchild.marginTop = child.marginTop;
			tmpchild.marginLeft = child.marginLeft;
			tmpchild.marginRight = child.marginRight;
			tmpchild.type = child.type;
			
			tmpchild.depress = child.depress;
			tmpchild.orientation = child.orientation;
			
			tmpchildren.push(tmpchild);
		}
		
		for(let i = 0; i < tmpchildren.length; ++i) {
			let child = tmpchildren[i];
			sumMin += child.minWidth + child.marginLeft + child.marginRight;
			tempArray.push(child);
			child.width = child.minWidth;
			
			let freeHeight = this.widget.height - this.widget.paddingTop - this.widget.paddingBottom - child.marginTop - child.marginBottom;
			if(child.maxHeight < freeHeight) child.height = child.maxHeight;
			else child.height = freeHeight;
			if((child.height < child.minHeight) || (child.height > freeHeight)) console.error("Child margin or padding wrong! ", child.type, child.id);
			
			child.posX = lastX;
			lastX = child.posX + child.width;
			child.posY = this.widget.paddingTop + child.marginTop + (((this.widget.height - this.widget.paddingTop - this.widget.paddingBottom) / 2) - ((child.height + child.marginBottom + child.marginTop) / 2));
			
			if(child.minHeight > maxH) maxH = child.minHeight;
			
			if(child.type == "WidgetSpacer") {
				if((child.depress) && (child.orientation == 1))
					spacerCount++;
			}
		}
		this.widget.minContentWidth = sumMin;
		this.widget.minContentHeight = maxH;
		
		if(tempArray.length == 0) return;
		
		let isFullFill = sumMin >= fullArea;
		tempArray.sort(sortWidth);
		let skip_index = 0;
		let emptyArea = ((fullArea - sumMin) / tempArray.length);
		
		if(spacerCount > 0) {
			lastX = this.widget.paddingLeft;
			let empty = (fullArea - sumMin) / spacerCount;
			for(let i = 0; i < tmpchildren.length; ++i) {
				let child = tmpchildren[i];
				if(child.type == "WidgetSpacer")
					if((child.depress) && (child.orientation == 1))
						child.width = empty;
				child.posX = lastX + child.marginLeft;
				lastX = child.posX + child.width + child.marginRight;
			}
			isFullFill = true;
		}
		
		while(!isFullFill) {
			sumMin = 0;
			lastX = this.widget.paddingLeft;
			
			if((tempArray[skip_index].width >= tempArray[skip_index].maxWidth) && (tempArray[skip_index].maxWidth >= 0)) {
				if((tempArray.length - 1) > skip_index)
					skip_index++;
				else {
					break;
				}
			}
			
			tempArray[skip_index].width++;
			
			for(let i = 0; i < tmpchildren.length; ++i) {
				let child = tmpchildren[i];
				sumMin += child.width + child.marginLeft + child.marginRight;
				child.posX = lastX + child.marginLeft + (emptyArea / 2);
				lastX = child.posX + child.width + (emptyArea / 2) + child.marginRight;
			}
			
			isFullFill = sumMin >= fullArea;
			emptyArea = ((fullArea - sumMin) / tempArray.length);
			tempArray.sort(sortWidth);
		}
		
		for(let i = 0; i < tmpchildren.length; ++i) {
			let tmpchild = tmpchildren[i];
			let child = Rex.widgets[tmpchild.id];
			if(child === undefined) continue;
			child.posX = tmpchild.posX;
			child.posY = tmpchild.posY;
			child.width = tmpchild.width;
			child.height = tmpchild.height;
		}
	}
	
}


/**
 * WidgetScrollArea
 */

class WidgetScrollAreaCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.tempCanvas = document.createElement("canvas");
		this.tempCtx = this.tempCanvas.getContext("2d");
		
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawScrollArea(ctx, ctxTemp);
		this.widget.scrollVertical.view.draw(ctx, ctxTemp);
		this.widget.scrollHorizontal.view.draw(ctx, ctxTemp);
	}
	
	drawScrollArea(ctx, ctxTemp) {
		this.tempCanvas.width = Rex.render.width;
		this.tempCanvas.height = Rex.render.height;
		
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		if(this.tempCtx !== undefined) this.tempCtx.clearRect(0, 0, Rex.render.width, Rex.render.height);
		
		this.widget.dataLayout.view.draw(ctxTemp, this.tempCtx);
		
		ctxTemp.save();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	onMouseWheel(value) {
		if(this.widget.scrollVertical.contentSize > this.widget.scrollVertical.sizeSlider &&
			this.widget.scrollVertical.visible) this.widget.scrollVertical.mouseWheel(value);
		else if(this.widget.scrollHorizontal.contentSize > this.widget.scrollHorizontal.sizeSlider &&
			this.widget.scrollHorizontal.visible) this.widget.scrollHorizontal.mouseWheel(value);
		
		if(Rex.gui === undefined) return;
		Rex.gui.reposition(this.widget);
	}
	
	onPositioning() {
		//с позициями скролов все ок
		this.widget.scrollVertical.posX = this.widget.width - this.widget.scrollVertical.width;
		this.widget.scrollVertical.posY = 0;
		this.widget.scrollVertical.height = this.widget.height;
		
		this.widget.scrollHorizontal.posX = 0;
		this.widget.scrollHorizontal.posY = this.widget.height - this.widget.scrollHorizontal.height;
		this.widget.scrollHorizontal.width = this.widget.width - (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0);
		
		//поиск высоты и ширины области скрола
		let dataW = this.widget.width - (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0);
		let dataH = this.widget.height - (this.widget.scrollHorizontal.isVisible() ? this.widget.scrollHorizontal.height : 0);
		
		if(this.widget.dataLayout.inited) {
			this.widget.dataLayout.view.onPositioning();
			this.update();
		}
		else console.error("зови саню, надо решать!");
		
		//высота и ширина контента. если контента меньше, чем область скрола, то считаем размером контента всю область скрола
		let contentW = dataW > this.widget.dataLayout.minContentWidth ? dataW : this.widget.dataLayout.minContentWidth;
		let contentH = dataH > this.widget.dataLayout.minContentHeight ? dataH : this.widget.dataLayout.minContentHeight;
		
		//определяем видимость скрола
		switch(this.widget.verticalScrollShow) {
			case 0:
				this.widget.scrollVertical.visible = false;		//всегда невидим
				break;
			case 1:
				this.widget.scrollVertical.visible = true;			//всегда видим
				break;
			case 2:
				this.widget.scrollVertical.visible = (contentH > dataH + 1);	//видим, только если область контента больше области скрола // +1 - это волшебная чудесная магия! не спрашивайте!
				break;
			default:
				console.error("VerticalScrollShow is undefined", this.widget.id);
				break;
		}
		
		switch(this.widget.horizontalScrollShow) {
			case 0:
				this.widget.scrollHorizontal.visible = false;
				break;
			case 1:
				this.widget.scrollHorizontal.visible = true;
				this.widget.scrollHorizontal.width = this.widget.width - (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0);
				break;
			case 2:
				if(contentW <= dataW + 1) {
					this.widget.scrollHorizontal.visible = false;
				}
				else {
					this.widget.scrollHorizontal.visible = true;
					this.widget.scrollHorizontal.width = this.widget.width - (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0);
				}
				break;
			default:
				console.error("HorizontalScrollShow is undefined", this.widget.id);
				break;
		}
		
		//передаем скролам инфу о том, насколько им придется скролиться
		this.widget.scrollVertical.contentSize = contentH;
		this.widget.scrollHorizontal.contentSize = contentW;
		
		//  Если скроллы невидимы (нет необходимости ресайза) - позиции лайоута становятся на исходные
		if(!this.widget.scrollVertical.visible) {
			this.widget.dataLayout.posX = 0;
			this.widget.dataLayout.posY = 0;
			this.widget.dataLayout.height = this.widget.height;
		}
		if(!this.widget.scrollHorizontal.visible) {
			this.widget.dataLayout.posX = 0;
			this.widget.dataLayout.posY = 0;
			this.widget.dataLayout.width = this.widget.width - (this.widget.scrollVertical.visible ? this.widget.scrollVertical.width : 0);
		}
		
		// комент от сани. пока оставьте, это может где-то нехватать
		//this.widget.dataLayout.posY = this.widget.aPosY;
		//this.widget.dataLayout.posX = this.widget.aPosX;
		
		//непосредственно прокручивание
		if(this.widget.scrollHorizontal.visible) {
			this.widget.dataLayout.posX = -this.widget.scrollHorizontal.value * (contentW - this.widget.width + (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0));
			this.widget.dataLayout.width = (contentW < (this.widget.width - this.widget.scrollVertical.width) ? this.widget.width - (this.widget.scrollVertical.isVisible() ? this.widget.scrollVertical.width : 0) : contentW);
		}
		if(this.widget.scrollVertical.visible) {
			this.widget.dataLayout.posY = -this.widget.scrollVertical.value * (contentH - this.widget.height + (this.widget.scrollHorizontal.isVisible() ? this.widget.scrollHorizontal.height : 0));
			this.widget.dataLayout.height = (contentH < (this.widget.height - (this.widget.scrollHorizontal.isVisible() ? this.widget.scrollHorizontal.height : 0)) ? this.widget.height - this.widget.scrollHorizontal.height : contentH);
		}
	}
}


/**
 * Created by prg-30 on 10.06.2017.
 */

class WidgetInputCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.offset = 4;
		this._anchorPos = undefined;
		this.widthObject = {};
		this.anchorPos = new Rex.Vector2(this.widget.posX, this.widget.posY);
		
		this.zoomFactor = 1;
		this.maxZoomFactor = 1;
		this.minZoomFactor = 0.778;
		this.Nsteps = 25;
		this.coeffHeight = 12 / 24;
		this.coeffFont = 9 / 24;
		this.coeffPosY = 5 / 12;
		this.coeffCursorHeight = 12 / 24;
		this.lineAnimationFlag = false;
		
		this.cursorWidth = 2;
		this.enabled = false;
		this.widthText = [];
		this.countWidth = true;
		this.anchorPoint = -1;
		this.offsetLeft = 0;
		this.offsetRight = 0;
		this.textTemp = '';
		this.mv = false; //передвижение стрелками(true)/(false) добавление символов
		this.caretPosition = 0; //позиция каретки
		this.caretWidth = 6;
		this.delete = false; //если удаляем символы, позицианирование текста в поле
		this.needMove = false;
		this.charLength = 8;
		//выделенный текст
		this.left = false;
		this._showCursor = false;
		
		this.specSymbols = {
			SHIFT: 0x10,
			DELETE: 0x2E,
			BACKSPACE: 0x08,
			ENTER: 0x0D,
			CTRL: 0x11,
			ALT: 0x12,
			LEFT_ARROW: 0x25,
			UP_ARROW: 0x26,
			RIGHT_ARROW: 0x27,
			DOWN_ARROW: 0x28,
			A: 0x41,
			ESC: 0x1B
		};
		
		this.radius = 1;
		
		this.refreshCanvas();
		this.updateEnable();
		this._headerPos = new Rex.Vector2();
		this._headerPos.y = (this.widget.text === "" || this.widget.text === undefined) ? this.widget.height * this.coeffPosY : 0; //FIXME pls
		this.headerAnim = false;
		this.space = 10;
		
	}
	
	setState(state) {
		if(state === undefined) return;
		let old = this.widget.text;
		let oldh = this.widget.header;
		let nText = "";
		let nHeader = "";
		super.setState(state);
		if(typeof state.Ctext !== 'undefined') {
			try { nText = decodeURIComponent(escape(window.atob(state.Ctext))); }
			catch(e) { console.error(this.widget.type, "setState->", "Text DecodeError!") }
			if(old != nText) {
				this.widget.text = nText;
				this.widget.str = this.widget.text;
			}
		}
		if(typeof state.Cheader !== 'undefined') {
			try { nHeader = decodeURIComponent(escape(window.atob(state.Cheader))); }
			catch(e) { console.error(this.widget.type, "setState->", "Header DecodeError!") }
			if(oldh != nHeader) {
				this.widget.header = nHeader;
			}
		}
		if(typeof state.regularExp !== 'undefined') {
			try { this.widget.regularExp = decodeURIComponent(escape(window.atob(state.regularExp))); }
			catch(e) { console.error(this.widget.type, "setState->", "regularExp DecodeError!") }
		}
	}
	
	get showCursor() {
		return this._showCursor;
	}
	
	set showCursor(value) {
		if(value === this._showCursor) return;
		this._showCursor = value;
		this.update();
	}
	
	get anchorPos() {
		return this._anchorPos;
	}
	
	set anchorPos(value) {
		if(!this._anchorPos) {
			this._anchorPos = value;
			return;
		}
		if(this.anchorPos.x === value.x && this.anchorPos.y === value.y) return;
		this._anchorPos = value;
	}
	
	onChangeCursorPosition(value) {
		if(value > this.caretPosition + this.caretWidth) {
			this.caretPosition = value - this.caretWidth;
			this.update();
		}
		else if(value < this.caretPosition) {
			this.caretPosition = value;
			this.update();
		}
	}
	
	recalcCaretWidth() {
		let w = 0;
		let i = 0;
		let index = this.caretPosition + 1;
		while(w < this.widget.width) {
			w = this.widthText[index] - this.widthText[this.caretPosition];
			i++;
			index++;
			if(index > this.widget._text.length - 1) {
				
				if(--this.caretPosition < 0) {
					this.caretPosition = 0;
					if(w < this.widget.width) i = (this.widget.text.length <= 3) ? 3 : this.widget.text.length;
					break;
				}
				index = this.caretPosition + 1;
				i = 0;
				w = 0;
			}
			
		}
		
		w = this.widthText[index] - this.widthText[this.caretPosition];
		if(w > this.widget.width) i--;
		this.caretWidth = i;
		
		this.onChangeCursorPosition(this.widget.cursorPosition); //так надо! Для oбновления позиции каретки!
	}
	
	recalcWidths(ctx) {
		this.widthText = [];
		this.widthObject = {};
		for(let i = 0; i < this.widget._text.length + 1; ++i) {
			let width = Math.round(ctx.measureText(this.widget._text.substr(0, i)).width);
			let offset1 = Math.round(this.offset);
			this.widthText.push(width + offset1);
			let delta = (i === 0) ? 0 : width - Math.round(ctx.measureText(this.widget.str.substr(0, i - 1)).width);
			for(let j = 0; j < delta; ++j) {
				this.widthObject[offset1 + width - delta + j] = i - 1;
			}
		}
	}
	
	getCustomSizeRadiusAnimation(ctx, width, height) {
		if(this === undefined) {
			console.error("this.widget === undefined");
			return 1000;
		}
		
		if(this.animation.enable) Rex.gui.redraw();
		let w = width / Rex.render.width;
		let h = height / Rex.render.height;
		
		let maxRadius = width + height;			// Радиус анимации (как далеко отрисовывается)
		
		let speed = 5.0 * w;								// Скорость анимации
		let animation = (ctx !== undefined);
		let time = (Rex.render.time - this.animation.time);						// Текущее время анимации
		
		if((time * speed) > maxRadius) {
			
			if(animation) {
				this.animation.endAnimation();
			}
			return maxRadius;
		}
		return (Rex.render.time - this.animation.time) * speed;
	}
	
	drawImage(ctx) {
		ctx.drawImage(this.firstBuffer, this.widget.aPosX, this.widget.aPosY);
		ctx.drawImage(this.secondBuffer, 0, 0, this.secondBuffer.width, this.secondBuffer.height,
			this.widget.aPosX, this.widget.aPosY, this.widget.width * this.zoomFactor, this.widget.height * this.zoomFactor);
	}
	
	onRedraw(ctx, ctxTemp) {
		ctx.save();
		this.drawer.background(ctx);
		ctx.textBaseline = "top";
		ctx.font = `${this.coeffFont * this.widget.height}px ${this.drawer.getParams("font", "Roboto")}`;
		ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
		this.recalcWidths(ctx);
		this.recalcCaretWidth();
		ctx.fillText(this.widget.text.substr(this.caretPosition, this.caretPosition + this.caretWidth + 1),
			this.widget.aPosX + this.space, this.widget.aPosY + this.widget.height * this.coeffPosY);
		this.drawCursor(ctx, this.widget.aPosX + this.space, this.widget.aPosY, this.widget.width);
		
		ctx.restore();
		this.drawHeader(ctx, ctxTemp);
		this.drawSelect(ctx, this.widget.aPosX + this.space, this.widget.aPosY);
		if(this.widget.cursorPosition > this.widget.str.length) {
			console.error("this is not validate");
			this.widget.cursorPosition = this.widget.str.length;
		}
	}
	
	drawHeader(ctx, ctxTemp) {
		if(this.widget.header === "") return;
		ctxTemp.font = `${this.coeffFont * this.widget.height}px ${(this.drawer.getParams("font", "Roboto"))}`;
		ctxTemp.textBaseline = "top";
		let tmp = this.widget.header;
		this.stmp = tmp;
		
		while(ctxTemp.measureText(this.stmp).width > this.widget.width - this.space) {
			if(!tmp.length) break;
			tmp = tmp.substr(0, tmp.length - 1);
			this.stmp = tmp + "...";
		}
		if(this.widget.valid) ctxTemp.fillStyle = this.drawer.getParams("headerColor", "rgb(158, 158, 158)");
		else ctxTemp.fillStyle = this.drawer.getParams("lineAndTextColorInvalid", "rgba(255, 0, 0, 0.4)");
		ctxTemp.fillText(this.stmp, this.widget.aPosX + this.space, this.widget.aPosY + this._headerPos.y);
	}
	
	drawCursor(ctx, x, y, width) {
		if(this.showCursor && this.widget.isFocused()) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("cursorColor", "rgb(158, 158, 158)");
			ctx.fillRect(x + ctx.measureText(this.widget.text.substr(this.caretPosition, this.widget.cursorPosition - this.caretPosition)).width,
				y + this.widget.height * this.coeffPosY, this.cursorWidth, this.coeffCursorHeight * this.widget.height);
			ctx.restore();
		}
	}
	
	drawSelect(ctx, x, y) {
		if(this.widget.selectPosition === -1) return;
		let temp = document.createElement("canvas");
		let tctx = temp.getContext("2d");
		let startSelect = this.widthText[this.widget.cursorPosition] - this.widthText[this.caretPosition];
		let width = this.widthText[this.widget.selectPosition] - startSelect - this.widthText[this.caretPosition];
		temp.width = width;
		temp.height = this.widget.height;
		//if(startSelect < 0) startSelect = 0;
		//if(startSelect > this.widget.width) startSelect = this.widget.width;
		//if(width < 0) width = 0;
		//if(width > this.widget.width) width = this.widget.width;
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("colorSelection", "rgba(99, 215, 203, 0.3)");
		ctx.fillRect(x + startSelect, y + this.widget.height * this.coeffPosY, width, this.coeffCursorHeight * this.widget.height);
		ctx.restore();
		//ctx.drawImage(temp, 0, 0, this.widget.width, this.widget.height, x + startSelect , y, this.widget.width , this.widget.height);
	}
	
	headerUp() {
		if(this.headerAnim) return;
		this.headerAnim = true;
		let T = Math.round(Math.abs(this.widget.posY - (this.widget.posY + this.widget.height * this.coeffPosY)));
		let step = T / this.Nsteps;
		for(let i = this.Nsteps; i >= 0; --i) {
			setTimeout(function() {
				if(!this.headerAnim) return;
				this._headerPos.y -= step;
				this.zoomFactor -= (this.maxZoomFactor - this.minZoomFactor) / this.Nsteps;
				if((0 == i) && this.widget.isFocused()) {
					this._headerPos.y = 0;
					this.zoomFactor = this.minZoomFactor;
					this.headerAnim = false;
					this.update();
					return;
				}
				if(this._headerPos.y <= 0) {
					this._headerPos.y = 0;
					this.zoomFactor = this.minZoomFactor;
					this.headerAnim = false;
					this.update();
					return;
				}
				this.update();
			}.bind(this, i, step), 10 * (this.Nsteps - i));
		}
	}
	
	headerDown() {
		if(this.widget.text !== "") return;
		if(this.headerAnim) return;
		this.headerAnim = true;
		let T = Math.round(Math.abs(this.widget.posY - (this.widget.posY + this.widget.height * this.coeffPosY)));
		let step = T / this.Nsteps;
		for(let i = this.Nsteps; i >= 0; --i) {
			if(!this.headerAnim) return;
			setTimeout(function() {
				this._headerPos.y += step;
				this.zoomFactor += (this.maxZoomFactor - this.minZoomFactor) / this.Nsteps;
				if(((0 === i) && (this.text === "")) && (!this.widget.isFocused())) {
					this._headerPos.y = this.widget.height * this.coeffPosY;
					this.zoomFactor = this.maxZoomFactor;
					this.headerAnim = false;
					this.update();
					return;
				}
				if(this._headerPos.y >= this.widget.height * this.coeffPosY) {
					this.headerAnim = false;
					this.zoomFactor = this.maxZoomFactor;
					this._headerPos.y = this.widget.height * this.coeffPosY;
					this.update();
					return;
				}
				this.update();
			}.bind(this, i, step), 10 * (this.Nsteps - i));
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		
		if(this.widget.valid)
			this.drawer.drawLine(ctx, this.widget.aPosX,
				this.widget.aPosY + this.widget.height, this.widget.aPosX + this.widget.width,
				this.widget.aPosY + this.widget.height, 1, 1,
				this.drawer.getParams("lineColor", "rgba(110," + " 110, 110, 1)"));
		else
			this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height,
				this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height, 1, 1,
				this.drawer.getParams("lineAndTextColorInvalid", "rgba(255, 0, 0, 0.6)"));
		
		
		if(this.animation.enable) {
			this.drawer.inputLineAnimation(ctx, ctxTemp, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
			if(this.getCustomSizeRadiusAnimation(ctx, this.widget.width, 2) > this.widget.width) this.animation.endAnimation();
		}
		else if(this.widget.isFocused()) {
			if(this.widget.valid)
				this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height,
					this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height, 2, 2,
					this.drawer.getParams("lineColor", "rgba(110, 110, 110, 1)"));
			else
				this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height,
					this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height, 2, 2,
					this.drawer.getParams("lineAndTextColorInvalid", "rgba(255, 0, 0, 0.6)"));
		}
	}
	
	keyDown(event) {
		switch(event.which) {
			case this.specSymbols.BACKSPACE:
				this.deleteChar(event.which);
				break;
			case this.specSymbols.DELETE:
				this.deleteChar(event.which);
				break;
			case this.specSymbols.LEFT_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.RIGHT_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.A:
				this.ctrlA(event);
				break;
			case this.specSymbols.ESC:
				this.Esc(event);
				break;
			case this.specSymbols.ENTER :
				this.widget.pressEnter(true);
				break;
			default:
				break;
		}
	}
	
	Esc(specSymbol) {
		if(specSymbol.which === this.specSymbols.ESC) {
			if(this.widget.text.length !== 0) {
				if(this.widget.selectPosition !== -1) {
					this.clearSelect(true);
					this.widget.updateParameters();
				}
			}
		}
	}
	
	ctrlA(specSymbol) {
		if(specSymbol.which === this.specSymbols.A && specSymbol.ctrlKey) {
			if(this.widget.text.length !== 0) {
				this.widget.selectPosition = 0;
				this.widget.cursorPosition = this.widget.text.length;
				this.mv = true;
				this.widget.updateParameters();
			}
		}
	}
	
	keyUp(event) {
		if(event.which === this.specSymbols.ENTER) this.widget.pressEnter(false);
	}
	
	keyPress(event) {
		if(event.charCode !== 13) {
			if(this.widget.cursorPosition === 0 && this.widget.str.length === 0) {
				this.widget.str += this.getChar(event);
				this.widget.cursorPosition++;
				this.countWidth = true;
			}
			else if(this.widget.selectPosition !== -1) {
				this.widget.str = this.widget.str.slice(0, this.getSelectionStart()) + this.getChar(event) +
					this.widget.str.slice(this.getSelectionEnd(), this.widget.str.length);
				this.widget.cursorPosition = this.widget.str.slice(0, this.getSelectionStart()).length + 1;
				this.countWidth = true;
				this.delete = true;
				this.clearSelect(false);
			}
			else {
				this.widget.str = this.widget.str.slice(0, this.widget.cursorPosition) + this.getChar(event) +
					this.widget.str.slice(this.widget.cursorPosition, this.widget.str.length);
				this.widget.cursorPosition++;
				this.countWidth = true;
				this.delete = false;
			}
			this.mv = false;
			this.widget.updateParameters();
		}
		
	}
	
	deleteChar(specSymbol) {
		if(this.widget.selectPosition !== -1) {
			this.widget.str = this.widget.str.substring(0, this.getSelectionStart()) +
				this.widget.str.substring(this.getSelectionEnd(), this.widget.str.length);
			this.widget.cursorPosition = this.widget.str.substring(0, this.getSelectionStart()).length;
			this.clearSelect(true);
			this.countWidth = true;
			this.delete = true;
			this.mv = true;
			return;
		}
		if(specSymbol === this.specSymbols.BACKSPACE) {
			if(this.widget.cursorPosition === 0) return;
			this.widget.cursorPosition--;
			this.widget.str = this.widget.str.slice(0, this.widget.cursorPosition) +
				this.widget.str.slice(this.widget.cursorPosition + 1, this.widget.str.length);
			this.countWidth = true;
		}
		else if(specSymbol === this.specSymbols.DELETE) {
			if(this.widget.cursorPosition === this.widget.str.length) return;
			this.widget.str = this.widget.str.slice(0, this.widget.cursorPosition) +
				this.widget.str.slice(this.widget.cursorPosition + 1, this.widget.str.length);
			this.countWidth = true;
		}
		this.delete = true;
		this.mv = true;
		this.widget.updateParameters();
	}
	
	moveChar(specSymbol) {
		if(specSymbol.which === this.specSymbols.LEFT_ARROW) {
			if(this.widget.cursorPosition !== 0) {
				if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1)
					this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.cursorPosition--;
				
				if(specSymbol.ctrlKey) {
					for(let i = this.widget.cursorPosition; i >= 0; --i) {
						if(specSymbol.shiftKey && this.widget.selectPosition === -1) {
							this.widget.selectPosition = this.widget.cursorPosition + 1;
						}
						if(i - 1 === 0) {
							this.widget.cursorPosition = i - 1;
							this.widget.updateParameters();
							return;
						}
						if(!this.isNotAlpha(this.widget.str[i]) && this.isNotAlpha(this.widget.str[i - 1])) {
							this.widget.updateParameters();
							return;
						}
						this.widget.cursorPosition = i - 1;
					}
					
				}
				this.mv = true;
				this.needchange = false;
				this.widget.updateParameters();
			}
		}
		else if(specSymbol.which === this.specSymbols.RIGHT_ARROW) {
			if(this.widget.cursorPosition !== this.widget.str.length) {
				if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1) this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.cursorPosition++;
				
				if(specSymbol.ctrlKey) {
					for(this.widget.cursorPosition; this.widget.cursorPosition <= this.widget.str.length; ++this.widget.cursorPosition) {
						if(specSymbol.shiftKey && this.widget.selectPosition === -1) this.widget.selectPosition = this.widget.cursorPosition - 1;
						if(this.widget.cursorPosition === this.widget.str.length) {
							this.widget.updateParameters();
							return;
						}
						if(!this.isNotAlpha(this.widget.str[this.widget.cursorPosition - 1]) && this.isNotAlpha(this.widget.str[this.widget.cursorPosition])) {
							this.widget.updateParameters();
							return;
						}
					}
				}
				this.mv = true;
				this.widget.updateParameters();
			}
		}
		if(!specSymbol.shiftKey && this.widget.selectPosition !== -1) this.clearSelect(true);
	}
	
	cut(event) {
		event.clipboardData.setData('text/plain', this.getSelectionText());
		this.widget.str = this.widget.str.substring(0, this.getSelectionStart()) + this.widget.str.substring(this.getSelectionEnd(), this.widget.str.length);
		this.cursorPosition = this.widget.str.substring(0, this.getSelectionStart()).length;
		this.clearSelect(true);
		this.countWidth = true;
		event.preventDefault();
	}
	
	copy(event) {
		event.clipboardData.setData('text/plain', this.getSelectionText());
		event.preventDefault();
	}
	
	paste(event) {
		if(event.clipboardData.types.indexOf('text/plain') > -1) {
			if(this.widget.selectPosition !== -1) {
				this.widget.str = this.widget.str.slice(0, this.getSelectionStart()) +
					event.clipboardData.getData('text/plain') + this.widget.str.slice(this.getSelectionEnd(), this.widget.str.length);
				this.cursorPosition = this.widget.text.slice(0, this.getSelectionEnd()).length;
				this.clearSelect(false);
			}
			else {
				this.widget.str = this.widget.str.slice(0, this.widget.cursorPosition) +
					event.clipboardData.getData('text/plain') + this.widget.str.slice(this.widget.cursorPosition, this.widget.str.length);
				this.widget.cursorPosition = this.widget.str.slice(0, event.clipboardData.getData('text/plain').length + this.widget.cursorPosition).length;
			}
			this.widget.updateParameters();
			event.preventDefault();
			this.countWidth = true;
		}
	}
	
	getSelectionStart() {
		return Math.min(this.widget.selectPosition, this.widget.cursorPosition);
	}
	
	getSelectionEnd() {
		return Math.max(this.widget.selectPosition, this.widget.cursorPosition);
	}
	
	getSelectionText() {
		return this.widget.str.substring(this.getSelectionStart(), this.getSelectionEnd());
	}
	
	getChar(event) {
		if(event.which !== 0 && event.charCode !== 0) { // все кроме IE
			if(event.which < 32) return null; // спец. символ
			return String.fromCharCode(event.which); // остальные
		}
		return null; // спец. символ
	}
	
	isNotAlpha(letter) {
		let symbols = /[\.\,\+\-\*/=\ _\[\]\{\}\(\)\<\>:;\\'"\|!@#\$%\^&\?]/;
		return symbols.test(letter);
	}
	
	clearSelect(needSend) {
		this.widget.selectPosition = -1;
		if(needSend) this.widget.updateParameters();
	}
	
	updateEnable() {
		setInterval(function() {
			this.enabled = !this.enabled;
		}.bind(this), 500);
	}
	
	onFocused(focused) {
		if(!focused) {
			if(this.headerAnim) {
				let timeId;
				timeId = setInterval(function() {
					if(this.headerAnim) return;
					this.headerDown();
					clearInterval(timeId);
				}.bind(this, timeId), 10);
			}
			else this.headerDown();
			this.clearSelect(true);
			this.update();
			this.widget.updateParameters();
			if(this.splashInterval !== undefined) clearInterval(this.splashInterval);
		}
		else {
			if(this.headerAnim) {
				let timeId;
				timeId = setInterval(function() {
					if(this.headerAnim) return;
					this.headerUp();
					clearInterval(timeId);
				}.bind(this, timeId), 10);
			}
			else this.headerUp();
			this.animation.startAnimation();
			this.splashInterval = setInterval(function() {
				this.showCursor = !this.showCursor;
			}.bind(this), 500);
		}
		setTimeout(function() {
			this.headerAnim = false;
			
		}.bind(this), 10 * (this.Nsteps + 1));
	}
	
	getCharIndex(x) {
		let nx = Math.round(x - this.widget.aPosX + this.widthText[this.caretPosition]);
		let index = this.widthObject[nx];
		if(index === undefined) index = (nx > 0) ? this.widget.text.length : 0;
		if(nx > ((this.widthText[index] + this.widthText[index + 1]) / 2)) ++index;
		return index;
	}
	
	onMouseMove(x, y) {
		if(!this.needMove) return;
		let index = this.getCharIndex(x); //FIXME возвращает 0
		this.widget.cursorPosition = index;
		this.widget.selectPosition = this.anchorPoint;
		this.mv = true;
		this.widget.updateParameters();
		this.update();
	}
	
	onMouseDown(x, y) {
		let index = this.getCharIndex(x);
		this.widget.cursorPosition = index;
		this.widget.selectPosition = -1;
		this.anchorPoint = index;
		this.needMove = true;
		this.mv = false;
		this.clearSelect(true);
		this.widget.updateParameters();
	}
	
	onMouseUp(x, y) {
		this.needMove = false;
		this.anchorPoint = -1;
		this.widget.updateParameters();
	}
	
	onOffsetLeft(ctx, x, width) {
		if(ctx.measureText(this.widget.text).width + this.offset + this.widthCaret < width || this.widget.cursorPosition === 0 || this.widget.cursorPosition < 3) {
			this.offsetLeft = 0;
		}
		else if(ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width + this.offset + this.widthCaret > width && !this.mv) {
			//когда курсор в конце текста
			if(this.widget.cursorPosition === this.widget.text.length) {
				this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width - width + width * 0.02;
			}
			else
			//если курсор между началом и концом текста
			if(this.widget.cursorPosition > 0 && this.widget.cursorPosition < this.widget.text.length && this.caretPosition + this.widthCaret > width + x && !this.delete) {
				this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width + width * 0.02 - width;
			}
			//передвижение каретки, без ввода символов
		}
		else if(this.mv && (this.caretPosition > x + width - this.widthCaret || this.caretPosition < x + this.widthCaret)) {
			if(this.caretPosition < x + this.widthCaret) {
				this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width;
			}
			else if(this.caretPosition > width + x - this.widthCaret) {
				this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width - width + width * 0.02;
			}
			
		}
		else if(this.mv && (this.caretPosition > x - this.widthCaret && this.caretPosition < x + width + this.widthCaret)) {
			if(this.caretPosition + ctx.measureText(this.widget.text.substr(this.widget.cursorPosition)).width < width + x) {
				if(this.widget.text.length === this.widget.cursorPosition) {
					this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width - width + width * 0.02;
				}
				else if(this.widget.cursorPosition > 0 && this.widget.cursorPosition < this.widget.text.length) {
					this.offsetLeft = ctx.measureText(this.widget.text.substr(0, this.widget.cursorPosition)).width -
						width + width * 0.02 + ctx.measureText(this.widget.text.substr(this.widget.cursorPosition)).width;
				}
			}
		}
	}
}


/**
 * WidgetTab
 */

class WidgetTabCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if((state.currentTab !== undefined) && (state.currentTab != this.widget.oldCurrentTab)) {
			this.update();
		}
		if (Rex.widgets !== undefined) {
			if (this.widget.headerLayoutId !== -1) {
				this.widget.headerLayout = Rex.widgets[this.widget.headerLayoutId];
			}
			if (this.widget.currentTabId !== -1) {
				this.widget.mainLayout = Rex.widgets[this.widget.currentTabId];
			}
			else {
				this.widget.mainLayout = undefined;
				this.widget.oldCurrentTab = -1;
				this.widget.currentTab = -1;
			}
		}
	}
	
	onPositioning() {
		//Проверка очень нужна!!! НЕ УДАЛЯТЬ!!!!!!!
		if(this.widget.mainLayout === undefined && this.widget.onCheckInit()) this.widget.onInit();
		
		this.widget.headerLayout.posX = this.widget.paddingLeft + this.widget.headerLayout.marginLeft;
		this.widget.headerLayout.posY = this.widget.paddingTop + this.widget.headerLayout.marginTop;
		this.widget.headerLayout.width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight - this.widget.headerLayout.marginLeft - this.widget.headerLayout.marginRight;
		this.widget.headerLayout.height = 50;
		
		for(let i = 0; i < this.widget.headerLayout.children.length; i++) {
			let mainLayout = Rex.widgets[this.widget.children[i + 1]];
			if(mainLayout == null) continue;
			mainLayout.posX = this.widget.paddingLeft + mainLayout.marginLeft;
			mainLayout.posY = this.widget.headerLayout.height + this.widget.headerLayout.marginBottom + mainLayout.marginTop;
			mainLayout.width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight - mainLayout.marginLeft - mainLayout.marginRight;
			mainLayout.height = this.widget.height - this.widget.headerLayout.height - this.widget.headerLayout.marginTop -
				this.widget.headerLayout.marginBottom - mainLayout.marginTop - mainLayout.marginBottom - this.widget.paddingBottom - this.widget.paddingTop;
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.headerLayout.view.draw(ctx, ctxTemp);
		
		let currentItemID = this.widget.headerLayout.children[this.widget.currentTab];
		if(currentItemID === undefined) return;
		let currentItem = Rex.widgets[currentItemID];
		if(currentItem === undefined) return;
		
		if((this.widget.currentTab !== this.widget.oldCurrentTab) && (this.widget.oldCurrentTab !== -1) && (Rex.widgets[this.widget.headerLayout.children[this.widget.oldCurrentTab]] !== undefined)) {
			let oldCurrTabID = this.widget.headerLayout.children[this.widget.oldCurrentTab];
			if(oldCurrTabID === undefined) return;
			let oldCurrentItem = Rex.widgets[oldCurrTabID];
			if(oldCurrentItem === undefined) return;
			if(this.animation.enable === false) this.animation.startAnimation();
			this.drawer.tabLineAnimation(ctx, ctxTemp, oldCurrentItem, currentItem);
			if(this.animation.enable === false) this.widget.oldCurrentTab = this.widget.currentTab;
		}
		else {
			this.drawer.drawLine(ctx, currentItem.aPosX, currentItem.aPosY + currentItem.height, currentItem.aPosX + currentItem.width, currentItem.aPosY + currentItem.height,
				this.drawer.getParams("lineWidth", 3), this.drawer.getParams("lineWidth", 3), this.drawer.getParams("underLine", "Color(PrimaryDark)"));
			this.widget.oldCurrentTab = this.widget.currentTab;
		}
		//Проверка очень нужна!!! НЕ УДАЛЯТЬ!!!!!!!
		if(this.widget.mainLayout === undefined) return;
		this.widget.mainLayout.view.draw(ctx, ctxTemp);
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawer.background(ctx);
		this.drawer.drawHeaderBackground(ctx);
		
	}
	
}

/**
 * WidgetComboBox
 */

class WidgetComboBoxCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		if(state === undefined) return;
		super.setState(state);
		if(!this.widget.inited) return;
		// Как только прилетел стейт с итемом(чувак выбрал что то) - прячем лист во избежании хуевого срабатываения
		// onCheckSelect и в следствии onMouseDown у листа
		if(state.currentItem !== undefined) {
			Rex.gui.permamentWidget = undefined;
			//Rex.gui.focusWidget = this;
			this.update();
		}
		
		if(state.expanded !== undefined) {
			if(!state.expanded) Rex.gui.permamentWidget = undefined;
			this.update();
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		// SET LIST base parameters
		if(this.widget.items === undefined) return;
		this.widget.items.selected = true;
		
		// DRAW LIST
		if(this.widget.expanded || (this.widget.scrollVertical.isFocused()) || (this.widget.scrollHorizontal.isFocused())) {
			Rex.gui.permamentWidget = this.widget.items;
			this.widget.items.view.draw(ctx, ctxTemp);
		}
		else if(Rex.gui.permamentWidget === this.widget) Rex.gui.permamentWidget = undefined;
	}
	
	drawComboBox(ctx, ctxTemp) {
		this.drawer.background(ctx);
		this.widget.widthArrow = this.widget.width / 10;
		if(this.widget.widthArrow > this.widget.maxWidthArrow) this.widget.widthArrow = this.widget.maxWidthArrow;
		if(this.widget.widthArrow < this.widget.minWidthArrow) this.widget.widthArrow = this.widget.minWidthArrow;
		let arrow = Math.min(this.widget.widthArrow / 2, this.widget.height);
		this.drawer.drawFillTriangle(ctx, this.widget.aPosX + this.widget.width - this.widget.widthArrow / 2, this.widget.aPosY + this.widget.height / 2, arrow / 2, -arrow / 2,
			this.drawer.getParams("colorArrow", "rgba(110, 110, 110, 1)"));
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawComboBox(ctx, ctxTemp);
		
		// COPY CURRENT
		if((this.widget.currentItem !== -1) && (!this.widget.expanded)) {
			if(this.widget.layout === undefined) return;
			let child = Rex.widgets[this.widget.layout.children[this.widget.currentItem]];
			if(child !== undefined) child.view.drawCopy(ctx, ctxTemp,
				this.widget.aPosX, this.widget.aPosY, this.widget.width - this.widget.widthArrow, this.widget.height);
		}
	}
	
	onPositioning() {
		// Положение листа относительно комбобокса
		this.widget.items.posX = 0;
		this.widget.items.posY = 0;
		this.widget.items.width = this.widget.width;
		// Корректировка позиций в случае экспанда.
		if(this.widget.expanded || this.widget.scrollVertical !== undefined || this.widget.scrollHorizontal !== undefined)
			if(this.widget.expanded || this.widget.scrollVertical.isFocused() || this.widget.scrollHorizontal.isFocused()) {
				this.widget.heightChilds = this.widget.layout.children.length * this.widget.height;
				for(let i = 0; i < this.widget.layout.children.length; ++i) {
					let child = Rex.widgets[this.widget.layout.children[i]];
					child.minHeight = this.widget.height;
					child.maxHeight = this.widget.height;
				}
				this.widget.items.posX = 0;
				if(this.widget.expandedHeight === -1) this.widget.expandedHeight = this.widget.height * 5;
				if(this.widget.heightChilds > this.widget.expandedHeight) this.widget.items.height = this.widget.expandedHeight;
				else this.widget.items.height = this.widget.heightChilds;
				let indentList = Rex.gui.styleLibrary.getParam(this.widget.styleName, "indentList", 10);
				if(this.widget.aPosY - indentList + this.widget.items.height > Rex.render.height)
					this.widget.items.posY = this.widget.height + indentList - this.widget.items.height;
				else this.widget.items.posY = -indentList;
				this.widget.items.width = this.widget.width;
			}
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) ret = this.widget;
		if(this.widget.expanded || this.widget.scrollVertical.isFocused() || this.widget.scrollHorizontal.isFocused()) {
			let itemsCheck = this.widget.items.view.checkSelect(x, y);
			if(itemsCheck !== undefined) return itemsCheck;
			let scrollHCheck = this.widget.scrollHorizontal.view.checkSelect(x, y);
			if(scrollHCheck !== undefined) return scrollHCheck;
			let scrollVCheck = this.widget.scrollVertical.view.checkSelect(x, y);
			if(scrollVCheck !== undefined) return scrollVCheck;
		} else {
			// Блок кода, необходымый для нажатия на выбранный виджет: //еFIXME тут еще надо this.widget пропатчить.
			// если кому нибудь надо вообще
			//if(this.currentItem != -1) {
			//  if(this.items === undefined) return ret;
			//  let layout = Rex.widgets[this.scroll.children[0]];        // LAYOUT
			//  let child = Rex.widgets[layout.children[this.currentItem]];      // CHILD
			//  if(child === undefined) return ret;
			//  let item = child.view.checkSelectCopy(x, y, this.posX, this.posY, this.width - this.widthArrow, this.height);
			//  if(item !== undefined) ret = item;
			//}
		}
		return ret;
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		let min = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY);
		let max = new Rex.Vector2(this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height);
		let boundBox = new Rex.BoundBox(min, max);
		if(boundBox.inside(new Rex.Vector2(x, y), 0)) {
			this.widget.setExpand(!this.widget.expanded);
		}
	}
	
	onMouseWheel(value) {
		this.widget.items.onMouseWheel(value);
	}
	
};


/**
 * WidgetWindow
 */

class WidgetWindowCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(typeof state['titleText'] !== 'undefined') {
			try {
				this.widget.titleText = decodeURIComponent(escape(window.atob(this.widget.titleText)));
			}
			catch(e) {
				console.log(this.widget.type, " -> setState -> \"titleText\" DecodeError!")
			}
		}
		if(state.enableHeader !== undefined) this.update();
		
		if(!this.widget.inited) return;
		if(state.horizontalAlignType !== undefined || state.verticalAlignType !== undefined) {
			this.changeWidgetAlign();
			Rex.callRpcMethod('Widgets', this.widget.id, 'Widget', 'setPos', [this.widget.posX, this.widget.posY]);
		}
	}
	
	onPositioning() {
		if(this.widget.width < this.widget.paddingLeft + this.widget.paddingRight) this.widget.width = this.widget.paddingLeft + this.widget.paddingRight;
		if(this.widget.height < this.widget.paddingTop + this.widget.paddingBottom) this.widget.height = this.widget.paddingTop + this.widget.paddingBottom;
		
		this.widget.layout.posX = this.widget.paddingLeft;
		this.widget.layout.posY = this.widget.paddingTop;
		this.widget.layout.width = this.widget.width - this.widget.paddingRight - this.widget.paddingLeft;
		this.widget.layout.height = this.widget.height - this.widget.paddingBottom - this.widget.paddingTop;
	}
	
	onDraw(ctx, ctxTemp) {
		
		let tempCanvas = document.createElement("canvas");
		let tempCtx = tempCanvas.getContext("2d");
		
		tempCanvas.width = Rex.render.width;
		tempCanvas.height = Rex.render.height;
		
		this.drawImage(ctx);
		this.widget.resizer.draw(ctx, ctxTemp);
		
		ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		
		ctxTemp.save();
		this.widget.layout.view.draw(ctxTemp, tempCtx);
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawer.background(ctx);
		if(this.widget.enableHeader) {
			this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + 20, this.widget.aPosX + this.widget.width, this.widget.aPosY + 20, 1, 0,
				this.drawer.getParams("geometricStrokeColor", "Color(Primary)"));
			ctx.fillText(this.widget.titleText, this.widget.aPosX + 5, this.widget.aPosY + 16);
		}
	}
	
	onMouseDown(x, y, event) {}
	onMouseUp(x, y, event) {}
	onMouseMove(x, y, event) {}
	
}

/**
 * WidgetSlider
 */

class WidgetSliderCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.anchorValue = 0;
		this.newX = this.getAPosX;
		this.newY = this.getAPosY;
		this.newHeight = this.widget.height;
		this.newWidth = this.widget.width;
	}
	
	setState(state) {
		super.setState(state);
		if(state.value !== undefined || state.step !== undefined || state.secondaryValueStart !== undefined
			|| state.secondaryValueEnd !== undefined || state.minValue !== undefined
			|| state.maxValue !== undefined || state.valueReal !== undefined || state.sliderType !== undefined || state.double !== undefined) {
			this.update();
		}
	}
	
	onPositioning() {
		if(this.widget.sliderType === 0) {
			let radiusInside = Math.min(5, this.widget.height, this.widget.width);
			let radiusExternal = Math.min(2, this.widget.height, this.widget.width);
			this.newY = this.widget.aPosY + this.drawer.getParams("fontSize", 16) + radiusInside + radiusExternal;
			this.newHeight = this.widget.height - (this.newY - this.widget.aPosY) * 2;
		}
		else {
			let leftPadding = this.drawer.getParams("leftPadding", 12);
			this.newX = this.widget.aPosX + leftPadding;
			this.newWidth = this.widget.width - (this.drawer.getParams("rightPadding", 12)) - leftPadding;
		}
	}
	
	onCheckSelect(x, y) {
		if(!this.inside(x, y)) return undefined;
		return this.widget;
	}
	
	getWidthString(ctx, str) {
		if(str === undefined) return 0;
		let widthStr = 0;
		for(let i = 0; i < str.length; ++i) {
			widthStr += ctx.measureText(str[i]).width;
		}
		return widthStr;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		switch(this.widget.sliderType) {
			case 0:
				this.drawTooltipAndLimitsVertical(ctx);
				break;
			case 1:
				this.drawTooltipAndLimitsHorizontal(ctx);
				break;
		}
		
	}
	
	onRedraw(ctx, ctxTemp) {
		switch(this.widget.sliderType) {
			case 0:
				this.drawVerticalSlider(ctx, ctxTemp);
				break;
			case 1:
				this.drawHorizontalSlider(ctx, ctxTemp);
				break;
		}
	}
	
	customBackgroundSliderHorizontal(ctx, x, y, width, height, value, firstColor, secondColor, pointColor) {
		ctx.save();
		ctx.fillStyle = firstColor;
		ctx.fillRect(x + value, y, width - value, height);
		if(this.widget.step !== 0) {
			let k = (this.widget.step / (this.widget.maxValue - this.widget.minValue)) * this.newWidth;
			ctx.fillStyle = pointColor;
			for(let i = k; i < width; i += k) {
				ctx.fillRect(this.newX + i, y, height, height);
			}
		}
		ctx.fillStyle = secondColor;
		ctx.fillRect(x, y, value, height);
		ctx.restore();
	}
	
	customBackgroundSliderVertical(ctx, x, y, width, height, value, firstColor, secondColor, pointColor) {
		ctx.save();
		ctx.fillStyle = firstColor;
		ctx.fillRect(x, y, width, height - value);
		if(this.widget.step !== 0) {
			let k = (this.widget.step / (this.widget.maxValue - this.widget.minValue)) * this.newHeight;
			ctx.fillStyle = pointColor;
			for(let i = this.newHeight - k; i > 0; i -= k) {
				ctx.fillRect(x, y + i, width, width);
			}
		}
		ctx.fillStyle = secondColor;
		ctx.fillRect(x, y + (height - value), width, value);
		ctx.restore();
	}
	
	drawHorizontalSlider(ctx, ctxTemp) {
		let firstColor = this.drawer.getParams("firstColor", "rgb(158, 158, 158)");
		let secondaryColor = this.drawer.getParams("secondColor", "rgb(37, 165, 154)");
		let pointColor = this.drawer.getParams("pointColor", "rgba(110, 110, 110, 1)");
		let fontSize = this.drawer.getParams("fontSize", 16);
		let font = this.drawer.getParams("font", "Roboto");
		
		if(this.anchorValue !== this.widget.value) this.anchorValue = this.widget.value;
		let radiusInside = Math.min(5, this.widget.height, this.widget.width);
		let radiusExternal = Math.min(2, this.widget.height, this.widget.width);
		
		if(this.widget.value === 0)
			this.customBackgroundSliderHorizontal(ctx, this.newX + radiusInside + radiusExternal / 2,
				this.widget.aPosY + this.widget.height / 2 - 1, this.newWidth - (radiusInside + radiusExternal / 2),
				2, this.anchorValue * this.newWidth, firstColor, secondaryColor, pointColor);
		else
			this.customBackgroundSliderHorizontal(ctx, this.newX, this.widget.aPosY + this.widget.height / 2 - 1,
				this.newWidth, 2, this.anchorValue * this.newWidth, firstColor, secondaryColor, pointColor);
		
		if(this.widget.secondaryValueStart !== 1000000000 && this.widget.secondaryValueEnd === 1000000000)
			this.widget.secondaryValueEnd = this.widget.maxValue;
		
		if(this.widget.secondaryValueEnd !== 1000000000 && this.widget.secondaryValueStart === 1000000000)
			this.widget.secondaryValueStart = this.widget.minValue;
		
		let limitA = 0;
		let limitB = 0;
		
		if(this.widget.minValue >= 0) {
			limitA = ((this.newWidth / (this.widget.maxValue - this.widget.minValue)) * (this.widget.secondaryValueStart - this.widget.minValue) + this.newX);
			limitB = ((this.newWidth / (this.widget.maxValue - this.widget.minValue)) * (this.widget.secondaryValueEnd - this.widget.minValue) + this.newX);
		}
		else {
			limitA = ((this.newWidth / (this.widget.maxValue + Math.abs(this.widget.minValue))) *
				Math.abs(this.widget.secondaryValueStart + Math.abs(this.widget.minValue))) + this.newX;
			limitB = ((this.newWidth / (this.widget.maxValue + Math.abs(this.widget.minValue))) *
				Math.abs(this.widget.secondaryValueEnd + Math.abs(this.widget.minValue))) + this.newX;
		}
		
		if(this.widget.secondaryValueStart === this.widget.minValue && this.widget.value === 0)
			this.drawer.drawRect(ctx, this.newX + radiusInside + radiusExternal / 2,
				this.widget.aPosY + this.widget.height / 2 - 1, limitB - limitA, 1, 0,
				this.drawer.getParams("backgroundSecondValueColor", "rgb(100,218,202)"));
		else
			this.drawer.drawRect(ctx, limitA, this.widget.aPosY + this.widget.height / 2 - 1, limitB - limitA, 1, 0,
				this.drawer.getParams("backgroundSecondValueColor", "rgb(100,218,202)"));
		
		if(((this.widget.valueReal >= this.widget.secondaryValueStart) && (this.widget.valueReal <= this.widget.secondaryValueEnd))) {
			this.drawKnob(ctx, this.newX + this.anchorValue * this.newWidth,
				this.widget.aPosY + this.widget.height / 2, firstColor,
				this.drawer.getParams("colorMarkerCircleSelectedArea", "rgb(100,218,202)"));
		}
		else {
			this.drawKnob(ctx, this.newX + this.anchorValue * this.newWidth,
				this.widget.aPosY + this.widget.height / 2, firstColor,
				this.drawer.getParams("colorMarkerCircle", "rgb(37, 165, 154)"));
		}
		
		if(this.widget.showLimits) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("colorSignatures", "rgb(0, 0, 0)");
			ctx.font = fontSize + "px " + font;
			
			let maxValue = this.widget.maxValue + "";
			let widthStrMax = this.getWidthString(ctx, maxValue);
			
			ctx.fillText(this.widget.minValue, this.widget.aPosX + 2, this.widget.aPosY + this.widget.height / 2 +
				fontSize + (radiusInside + radiusExternal / 2));
			ctx.fillText(this.widget.maxValue, this.widget.aPosX + this.widget.width - widthStrMax - 2,
				this.widget.aPosY + this.widget.height / 2 + fontSize + (radiusInside + radiusExternal / 2));
			
			if(this.widget.secondaryValueEnd !== 1000000000) {
				let secondaryStart = parseInt(this.widget.secondaryValueStart) + "";
				let widthStrStart = this.getWidthString(ctx, secondaryStart);
				let secondaryEnd = parseInt(this.secondaryValueEnd) + "";
				let widthStrEnd = this.getWidthString(ctx, secondaryEnd);
				if(this.widget.secondaryValueStart !== this.widget.minValue)
					ctx.fillText(parseInt(this.widget.secondaryValueStart), limitA - widthStrStart / 2,
						this.widget.aPosY + this.widget.height / 2 + fontSize + (radiusInside + radiusExternal / 2));
				
				if(this.widget.secondaryValueEnd !== this.widget.maxValue)
					ctx.fillText(parseInt(this.widget.secondaryValueEnd), limitB - widthStrEnd / 2,
						this.widget.aPosY + this.widget.height / 2 + fontSize + (radiusInside + radiusExternal / 2));
			}
			ctx.restore();
		}
	}
	
	drawVerticalSlider(ctx, ctxTemp) {
		let firstColor = this.drawer.getParams("firstColor", "rgb(158, 158, 158)");
		let secondaryColor = this.drawer.getParams("secondColor", "rgb(37, 165, 154)");
		let pointColor = this.drawer.getParams("pointColor", "rgba(110, 110, 110, 1)");
		let fontSize = this.drawer.getParams("fontSize", 16);
		let font = this.drawer.getParams("font", "Roboto");
		
		if(this.anchorValue !== this.widget.value) this.anchorValue = this.widget.value;
		let radiusInside = Math.min(5, this.widget.height, this.widget.width);
		let radiusExternal = Math.min(2, this.widget.height, this.widget.width);
		
		if(this.widget.value === 0) this.customBackgroundSliderVertical(ctx,
			this.widget.aPosX + this.widget.width / 2 - 1, this.newY, 2,
			this.newHeight - (radiusInside + radiusExternal / 2),
			this.anchorValue * this.newHeight, firstColor, secondaryColor, pointColor);
		else this.customBackgroundSliderVertical(ctx, this.widget.aPosX + this.widget.width / 2 - 1, this.newY,
			2, this.newHeight, this.anchorValue * this.newHeight, firstColor, secondaryColor,
			pointColor);
		
		if(this.widget.secondaryValueStart !== 1000000000 && this.widget.secondaryValueEnd === 1000000000)
			this.widget.secondaryValueEnd = this.widget.maxValue;
		
		if(this.widget.secondaryValueEnd !== 1000000000 && this.widget.secondaryValueStart === 1000000000)
			this.widget.secondaryValueStart = this.widget.minValue;
		
		let limitA = 0;
		let limitB = 0;
		
		if(this.widget.minValue >= 0) {
			limitA = this.newHeight - ((this.newHeight / (this.widget.maxValue - this.widget.minValue)) *
				(this.widget.secondaryValueStart - this.widget.minValue));
			limitB = this.newHeight - ((this.newHeight / (this.widget.maxValue - this.widget.minValue)) *
				(this.widget.secondaryValueEnd - this.widget.minValue));
		} else {
			limitA = this.newHeight - ((this.newHeight / (this.widget.maxValue +
				Math.abs(this.widget.minValue))) * Math.abs(this.widget.secondaryValueStart +
				Math.abs(this.widget.minValue)));
			limitB = this.newHeight - ((this.newHeight / (this.widget.maxValue +
				Math.abs(this.widget.minValue))) * Math.abs(this.widget.secondaryValueEnd +
				Math.abs(this.widget.minValue)));
		}
		
		if(this.widget.secondaryValueStart === this.widget.minValue && this.widget.value === 0 && this.widget.secondaryValueEnd !== 0) {
			this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.width / 2, limitB + this.newY, 2,
				limitA - limitB - (radiusInside + radiusExternal / 2), 0,
				this.drawer.getParams("backgroundSecondValueColor", "rgb(100,218,202)"));
		} else {
			this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.width / 2, limitB + this.newY, 2,
				limitA - limitB, 0, this.drawer.getParams("backgroundSecondValueColor", "rgb(100,218,202)"));
		}
		
		if(((this.widget.valueReal >= this.widget.secondaryValueStart) && (this.widget.valueReal <= this.widget.secondaryValueEnd))) {
			this.drawKnob(ctx, this.widget.aPosX + this.widget.width / 2,
				this.newY + (this.newHeight - this.anchorValue * this.newHeight),
				firstColor, this.drawer.getParams("colorMarkerCircleSelectedArea", "rgb(100,218,202)"));
		} else {
			this.drawKnob(ctx, this.widget.aPosX + this.widget.width / 2,
				this.newY + (this.newHeight - this.anchorValue * this.newHeight),
				firstColor, this.drawer.getParams("colorMarkerCircle", "rgb(37, 165, 154)"));
		}
		
		if(this.widget.showLimits) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("colorSignatures", "rgb(0, 0, 0)");
			ctx.font = fontSize + "px " + font;
			let maxValue = this.widget.maxValue + "";
			let widthStrMax = this.getWidthString(ctx, maxValue);
			let minValue = this.widget.minValue + "";
			let widthStrMin = this.getWidthString(ctx, minValue);
			ctx.fillText(this.widget.minValue, this.widget.aPosX + this.widget.width / 2 - 1 - widthStrMin / 2,
				this.widget.aPosY + this.widget.height - 1);
			ctx.fillText(this.widget.maxValue, this.widget.aPosX + this.widget.width / 2 - 1 - widthStrMax / 2,
				this.widget.aPosY + fontSize);
			ctx.restore();
		}
	}
	
	drawTooltipAndLimitsVertical(ctx) {
		let fontSize = this.drawer.getParams("fontSize", 16);
		let font = this.drawer.getParams("font", "Roboto");
		let radiusInside = Math.min(5, this.widget.height, this.widget.width);
		let radiusExternal = Math.min(2, this.widget.height, this.widget.width);
		let limitA = 0;
		let limitB = 0;
		
		if(this.widget.minValue >= 0) {
			limitA = this.newHeight - ((this.newHeight / (this.widget.maxValue - this.widget.minValue)) *
				(this.widget.secondaryValueStart - this.widget.minValue));
			limitB = this.newHeight - ((this.newHeight / (this.widget.maxValue - this.widget.minValue)) *
				(this.widget.secondaryValueEnd - this.widget.minValue));
		} else {
			limitA = this.newHeight - ((this.newHeight / (this.widget.maxValue +
				Math.abs(this.widget.minValue))) * Math.abs(this.widget.secondaryValueStart +
				Math.abs(this.widget.minValue)));
			limitB = this.newHeight - ((this.newHeight / (this.widget.maxValue +
				Math.abs(this.widget.minValue))) * Math.abs(this.widget.secondaryValueEnd +
				Math.abs(this.widget.minValue)));
		}
		
		if(((this.widget.valueReal >= this.widget.secondaryValueStart) && (this.widget.valueReal <= this.widget.secondaryValueEnd))) {
			if(this.widget.showTooltip)
				this.drawTooltip(ctx, this.widget.aPosX + this.widget.width / 2 + 5,
					this.newY + (this.newHeight - this.anchorValue * this.newHeight),
					(this.drawer.getParams("colorTooltipSelectedArea", "rgb(100,218,202)")));
		}
		else {
			if(this.widget.showTooltip)
				this.drawTooltip(ctx, this.widget.aPosX + this.widget.width / 2 + 5,
					this.newY + (this.newHeight - this.anchorValue * this.newHeight),
					(this.drawer.getParams("colorTooltip", "rgb(37, 165, 154)")));
		}
		
		if(this.widget.showLimits) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("colorSignatures", "rgb(0, 0, 0)");
			ctx.font = fontSize + "px " + font;
			
			if(this.widget.secondaryValueEnd !== 1000000000) {
				let secondaryValueStart = parseInt(this.widget.secondaryValueStart) + "";
				let widthStrStartSecondary = this.getWidthString(ctx, secondaryValueStart);
				let secondaryValueEnd = parseInt(this.widget.secondaryValueEnd) + "";
				let widthStrEndSecondary = this.getWidthString(ctx, secondaryValueEnd);
				
				if(this.widget.secondaryValueStart !== this.widget.minValue)
					ctx.fillText(parseInt(this.widget.secondaryValueStart),
						this.widget.aPosX + this.widget.width / 2 - (radiusInside + radiusExternal / 2) -
						widthStrStartSecondary - 3, limitA + this.newY + fontSize / 4);
				
				if(this.widget.secondaryValueEnd !== this.maxValue)
					ctx.fillText(parseInt(this.widget.secondaryValueEnd),
						this.widget.aPosX + this.widget.width / 2 - (radiusInside + radiusExternal / 2) -
						widthStrEndSecondary - 3, limitB + this.newY + fontSize / 4);
			}
			ctx.restore();
		}
	}
	
	drawTooltipAndLimitsHorizontal(ctx) {
		if(((this.widget.valueReal >= this.widget.secondaryValueStart) && (this.widget.valueReal <= this.widget.secondaryValueEnd))) {
			if(this.widget.showTooltip)
				this.drawTooltip(ctx, this.newX + this.anchorValue * this.newWidth,
					this.widget.aPosY + this.widget.height / 2 - 5,
					(this.drawer.getParams("colorTooltipSelectedArea", "rgb(100,218,202)")));
		}
		else {
			if(this.widget.showTooltip)
				this.drawTooltip(ctx, this.newX + this.anchorValue * this.newWidth,
					this.widget.aPosY + this.widget.height / 2 - 5,
					(this.drawer.getParams("colorTooltip", "rgb(37, 165, 154)")));
		}
	}
	
	drawKnob(ctx, x, y, firstColor, secondColor) {
		let radiusInside = Math.min(5, this.widget.height, this.widget.width);
		if(this.widget.value > 0.0) this.drawer.circle(ctx, x, y, radiusInside, radiusInside / 2, secondColor, secondColor);
		if(this.widget.value === 0) this.drawer.circle(ctx, x, y, radiusInside, 2, firstColor, "rgba(0, 0, 0, 0)");
		
		if(this.widget.pressed) this.drawer.circle(ctx, x, y, 7, 2, secondColor, secondColor);
		if(this.widget.value > 0.0 && this.widget.pressed) this.drawer.circle(ctx, x, y, 7, 2, secondColor, secondColor);
	}
	
	drawTooltip(ctx, x, y, color) {
		if(this.widget.pressed) {
			let fontSize = this.drawer.getParams("fontSize", 16);
			let font = this.drawer.getParams("font", "Roboto");
			if(this.widget.sliderType === 0) {
				this.blub(ctx, x + 5, y, 0.75, color, 1);
				ctx.save();
				ctx.font = fontSize + "px " + font;
				ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
				ctx.textAlign = "left";
				ctx.fillText(this.widget.valueReal.toFixed(this.widget.numeralAfterPoint), x + 15, y + 4);
				ctx.restore();
			}
			else {
				this.blub(ctx, x, y - 5, 0.75, color);
				ctx.save();
				ctx.font = fontSize + "px " + font;
				ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
				ctx.textAlign = "center";
				ctx.fillText(this.widget.valueReal.toFixed(this.widget.numeralAfterPoint), x - 1, y - 25);
				ctx.restore();
			}
		}
	}
	
	blub(ctx, x, y, koeff, color, direction = 0) {
		ctx.save();
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.translate(x, y);
		ctx.rotate(direction * Math.PI / 2);
		ctx.moveTo(0, 0);
		ctx.arcTo(-25 * koeff, -50 * koeff, 0, -50 * koeff, 15 * koeff);
		ctx.arcTo(25 * koeff, -50 * koeff, 0, 0, 15 * koeff);
		ctx.lineTo(0, 0);
		ctx.fill();
		ctx.restore();
	}
	
	setValue(x, y) {
		let val = 0;
		let factor = 0;
		
		if(this.widget.sliderType === 0) {
			factor = ((y - this.newY) / (this.newHeight / 100)) / 100;
			factor = 1.0 - factor;
			if(y <= this.newY) factor = 1.0;
			if(y >= (this.newHeight + this.newY)) factor = 0.0;
		}
		else {
			factor = ((x - this.newX) / (this.newWidth / 100)) / 100;
			if(x <= this.newX) factor = 0;
			if(x >= (this.newWidth + this.newX)) factor = 1.0;
		}
		
		if(this.widget.step === 0) {
			val = factor;
			if(this.widget.value === val) return;
			this.widget.setValue(val);
		}
		else {
			let k = this.widget.step / (this.widget.maxValue - this.widget.minValue);
			val = factor;
			let i = Math.floor(val / k);
			val = k * i;
			if(this.widget.value === val) return;
			this.widget.setValue(val);
		}
		this.anchorValue = this.widget.value;
		
		this.update();
	}
	
	mouseMove(x, y) {
		if(this.widget.pressed) this.setValue(x, y);
	}
	
	mouseDown(x, y, event) {
		if(event.which !== 1) return;
		this.setValue(x, y);
		this.widget.pressed = true;
	}
	
	mouseUp(x, y, event) {
		if(event.which !== 1) return;
		this.widget.pressed = false;
		this.update();
	}
	
}

/**
 * WidgetTextArea
 */

class WidgetTextAreaCanvas extends WidgetViewCanvas {
	
	constructor(state) {
		super(state);
		this.lines = [];		// Текст в виде строк для корректной отрисовки
		this.transferLines = [];
		
		this.zoomFactor = 1;
		this.maxZoomFactor = 1;
		this.minZoomFactor = 0.778;
		this.Nsteps = 25;
		
		this.lineCount = 0;
		this.anchorPos = new Rex.Vector2(this.getAPosX(), this.getAPosY() + this.widget.fontSize);
		this.anchorSize = new Rex.Vector2(this.widget.width, this.widget.height - this.widget.fontSize);
		this.headerPos = new Rex.Vector2();
		this.headerPos.y = (this.widget.text === "") ? this.anchorPos.y : this.anchorPos.y - this.widget.fontSize;
		this.headerAnim = false;
		this.heightCaret = this.widget.fontSize / 14 + (this.widget.fontSize / 14 / 3);
		//курсор
		this.widthCaret = 2;
		this.enabled = false;
		this.anchorPoint = new Rex.Vector2();
		this.needChange = false;
		this.offsetDown = 0;
		this.caretPosition = 0;
		
		this.pasteText = false;
		
		this.needMove = false;
		this.needResize = false;
		this.needChangePosition = false;
		this.charLength = 0;
		
		this.ctx = undefined;
		this.ctxTemp = undefined;
		
		
		this.wheel = false;
		this.needValueChange = false;
		this.style = '';
		//старые параметры для проверки на ресайз
		this.oldStyle = {
			bold: this.widget.bold,
			italic: this.widget.italic
		};
		this.oldFontSize = this.widget.fontSize;
		this.oldFont = Rex.gui.styleLibrary.getParam(this.widget.styleName, "font", "Arial");
		this.oldCoords = new Rex.Vector2(this.widget.width, this.widget.height);
		this.oldPosition = new Rex.Vector2(this.getAPosX(), this.getAPosY());
		this.oldLineHeight = this.widget.lineHeight;
		
		//выделенный текст
		this.specSymbols = {
			SHIFT: 0x10,
			DELETE: 0x2E,
			BACKSPACE: 0x08,
			ENTER: 0x0D,
			CTRL: 0x11,
			ALT: 0x12,
			LEFT_ARROW: 0x25,
			UP_ARROW: 0x26,
			RIGHT_ARROW: 0x27,
			DOWN_ARROW: 0x28,
			A: 0x41,
			ESC: 0x1B
		};
		this.radius = 1;
		
		this.updateInterval()
		//window.addEventListener("resize",(function(){this.needResize = true;}).bind(this)); //ПОДВОПРОСОМ!
	}
	
	setState (state) {
		if(state === undefined) return;
		super.setState(state);
		if(typeof state.text !== 'undefined') {
			try {this.widget.text = decodeURIComponent(escape(window.atob(state.text)));}
			catch(e) {console.log(this.widget.type, " -> setState-> \"text\" DecodeError!")}
			this.widget.textDraw = this.widget.text;
		}
		if(state.text !== undefined || state.cursorPosition !== undefined || state.selectPosition !== undefined || state.cursorLine !== undefined ||
			state.selectLine !== undefined || state.fontSize !== undefined || state.textAlign !== undefined  || state.lineHeight !== undefined
			|| state.bold !== undefined || state.italic !== undefined) this.update();
	}
	
	onPositioning() {
		this.widget.scroll.posX = this.widget.width - 12;
		this.widget.scroll.posY = 0;
		this.widget.scroll.width = 12;
		this.widget.scroll.height = this.widget.height;
	}
	
	changePositionHeader() {
		this.headerPos.y = (this.widget.text === "") ? this.anchorPos.y : this.anchorPos.y - this.widget.fontSize;
		this.needChangePosition = false;
		this.update();
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawTextArea(ctx, ctxTemp);
	}
	
	drawTextArea(ctx, ctxTemp) {
		let font = this.drawer.getParams("font", "Roboto");
		this.drawer.background(ctx);
		if(this.widget.isFocused())
			this.drawer.drawStrokeRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height,
				this.drawer.getParams("borderRadius", 5), 0,
				this.drawer.getParams("borderLineWidth", 1) + 1,
				this.drawer.getParams("borderColor", "rgba(110, 110, 110, 1)"));
		else
			this.drawer.drawStrokeRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height,
				this.drawer.getParams("borderRadius", 5), 0,
				this.drawer.getParams("borderLineWidth", 1),
				this.drawer.getParams("borderColor", "rgba(110, 110, 110, 1)"));
		this.anchorPos = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY + this.widget.fontSize);
		this.anchorSize = new Rex.Vector2(this.widget.width, this.widget.height - this.widget.fontSize);
		this.heightCaret = this.widget.fontSize + (this.widget.fontSize / 3);
		
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		this.textStyle();
		ctxTemp.save();
		ctxTemp.font = `${this.style}${this.widget.fontSize}px ${font}`;
		this.charLength = ctxTemp.measureText("8").width;
		if(this.oldFontSize != this.widget.fontSize) {
			this.needResize = true;
			this.oldFontSize = this.widget.fontSize;
		}
		if(this.oldCoords.x != this.anchorSize.x || this.oldCoords.y != this.anchorSize.y) {
			this.oldCoords = this.anchorSize;
			this.needResize = true;
		}
		if(this.oldStyle.bold !== this.widget.bold || this.oldStyle.italic !== this.widget.italic) {
			this.needResize = true;
			this.oldStyle.bold = this.widget.bold;
			this.oldStyle.italic = this.widget.italic;
		}
		if(this.oldFont != font) {
			this.needResize = true;
			this.oldFont = font;
		}
		if(this.oldLineHeight != this.widget.lineHeight) {
			this.oldLineHeight = this.widget.lineHeight;
			this.needResize = true;
		}
		if(this.oldPosition.x != this.widget.aPosX || this.oldPosition.y != this.widget.aPosY) {
			this.oldPosition.x = this.widget.aPosX;
			this.oldPosition.y = this.widget.aPosY;
			this.needChangePosition = true;
		}
		if(this.needResize) this.changeSize(ctxTemp, this.widget.textDraw,
			this.anchorSize.x * .9);
		if(this.pasteText || this.delete || this.needChange)
			this.changeText(this.widget.textDraw, ctxTemp, this.anchorSize.x * .9);
		this.toLinesText(this.widget.textDraw, ctxTemp);
		
		let offsetDown = this.onOffsetDown(ctxTemp, this.anchorPos.y,
			this.anchorSize.y, this.widget.fontSize, this.widget.cursorLine,
			this.lineCount, this.heightCaret, this.caretPosition, this.widget.lineHeight);
		if(offsetDown !== undefined) this.offsetDown = offsetDown;
		
		this.caretPosition = this.anchorPos.y + this.widget.cursorLine *
			this.widget.fontSize + this.widget.lineHeight * (this.widget.cursorLine + 1) - this.offsetDown;
		
		if(this.animation.getRadiusAnimation() > this.anchorSize.x && !this.widget.isFocused())
			this.animation.endAnimation();
		
		this.drawSelectTextArea(ctxTemp, this.anchorPos.x, this.anchorPos.y,
			this.anchorSize.x, this.widget.fontSize + (this.widget.fontSize / 3));
		this.drawCursorAndText(ctxTemp, this.anchorPos.x, this.anchorPos.y,
			this.anchorSize.x);
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(this.anchorPos.x, this.anchorPos.y, this.anchorSize.x,
			this.anchorSize.y);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		
		if((this.widget.fontSize + this.widget.lineHeight) * this.lineCount > this.anchorSize.y - this.widget.fontSize / 3) {
			this.widget.scroll.contentSize = (this.widget.fontSize + this.widget.lineHeight) * this.lineCount;
			if(this.widget.scroll.pressed) {
				this.offsetDown = this.widget.scroll.value * (this.lineCount *
					(this.widget.fontSize + this.widget.lineHeight) - this.anchorSize.y + this.widget.fontSize / 3);
				this.wheel = true;
			}
			else if(this.needValueChange) {
				this.onSetScrollValue();
			}
			this.widget.scroll.visible = true;
			
			if(this.widget.scroll.isVisible()) {
				this.widget.scroll.view.draw(ctx, ctxTemp);
			}
		}
		if(this.needChangePosition === true) {
			this.changePositionHeader();
		}
		this.drawHeaderTextArea(ctx);
		ctxTemp.restore();
	}
	
	drawCursorAndText(ctx, x, y, width) {
		//calculate cursor coordinate
		switch(this.widget.textAlign) {
			case 'right' :
				this.drawRight(ctx, x, y, width);
				break;
			case 'center' :
				this.drawCenter(ctx, x, y, width);
				break;
			default :
				this.drawLeft(ctx, x, y, width);
				break;
		}
	}
	
	drawSelectTextArea(ctx, x, y, width, height) {
		switch(this.widget.textAlign) {
			case 'right' :
				this.drawSelectRight(ctx, x, y, width, height);
				break;
			case 'center' :
				this.drawSelectCenter(ctx, x, y, width, height);
				break;
			default :
				this.drawSelectLeft(ctx, x, y, width, height);
				break;
		}
		
	}
	
	drawLeft(ctx, x, y, width) {
		if(this.lines.length <= this.widget.cursorLine)
			this.widget.cursorLine = this.lines.length - 1;
		if(this.lines === undefined || this.lines[this.widget.cursorLine] === undefined || this.lines.length <= 0) return;
		let cursor = x + ctx.measureText(this.lines[this.widget.cursorLine].substring(0, this.widget.cursorPosition)).width + this.widthCaret + 1;
		//draw text
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
		ctx.textAlign = this.widget.textAlign;
		for(let i = 0; i < this.lines.length; ++i) {
			let line = '';
			for(let j = 0; j < this.lines[i].length; ++j) {
				line += this.lines[i][j];
			}
			ctx.fillText(line, x + width * 0.05, y + (i + 1) * (this.widget.fontSize + this.widget.lineHeight) - this.offsetDown);
		}
		if(this.widget.isFocused() && this.enabled) {
			ctx.fillStyle = this.drawer.getParams("textAreaCursorColor", "rgb(0, 121, 106)");
			ctx.fillRect(cursor + width * 0.05 * .9, this.caretPosition, this.widthCaret, this.heightCaret);
		}
		this.headerPos.x = x + width * 0.05;
		ctx.restore();
	}
	
	drawRight(ctx, x, y, width) {
		if(this.lines.length <= this.widget.cursorLine)
			this.widget.cursorLine = this.lines.length - 1;
		if(this.lines === undefined || this.lines[this.widget.cursorLine] === undefined || this.lines.length <= 0) return;
		let cursor = x + ctx.measureText(this.lines[this.widget.cursorLine].substring(0, this.widget.cursorPosition)).width
			- ctx.measureText(this.lines[this.widget.cursorLine]).width - this.widthCaret + 1;
		//draw text
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
		ctx.textAlign = this.widget.textAlign;
		for(let i = 0; i < this.lines.length; ++i) {
			//ctx.fillStyle = "black";
			let line = '';
			for(let j = 0; j < this.lines[i].length; ++j) {
				line += this.lines[i][j];
			}
			ctx.fillText(line, x + width * 0.95, y + (i + 1) * (this.widget.fontSize + this.widget.lineHeight) - this.offsetDown);
		}
		if(this.widget.isFocused() && this.enabled) {
			ctx.fillStyle = this.drawer.getParams("textAreaCursorColor", "rgb(0, 121, 106)");
			ctx.fillRect(cursor + width * 0.95, this.caretPosition, this.widthCaret, this.heightCaret);
		}
		this.headerPos.x = x + width * 0.95;
		ctx.restore();
	}
	
	drawCenter(ctx, x, y, width) {
		if(this.lines.length <= this.widget.cursorLine) this.widget.cursorLine = this.lines.length - 1;
		if(this.lines === undefined || this.lines[this.widget.cursorLine] === undefined || this.lines.length <= 0) return;
		let cursor = x + ctx.measureText(this.lines[this.widget.cursorLine].substring(0, this.widget.cursorPosition)).width
			- ctx.measureText(this.lines[this.widget.cursorLine]).width / 2 - this.widthCaret + 1;
		//draw text
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textColor", "rgb(0, 0, 0)");
		ctx.textAlign = this.widget.textAlign;
		for(let i = 0; i < this.lines.length; ++i) {
			//ctx.fillStyle = "black";
			let line = '';
			for(let j = 0; j < this.lines[i].length; ++j) {
				line += this.lines[i][j];
			}
			ctx.fillText(line, x + width / 2, y + (i + 1) * (this.widget.fontSize + this.widget.lineHeight) - this.offsetDown);
		}
		if(this.widget.isFocused() && this.enabled) {
			ctx.fillStyle = this.drawer.getParams("textAreaCursorColor", "rgb(0, 121, 106)");
			ctx.fillRect(cursor + width / 2, this.caretPosition, this.widthCaret, this.heightCaret);
		}
		this.headerPos.x = x + width / 2;
		ctx.restore();
	}
	
	drawSelectLeft(ctx, x, y, width, height) {
		if(this.widget.selectPosition == -1) return;
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textAreaSelectColor", "rgb(100,218,202)");
		if(this.widget.selectLine == this.widget.cursorLine) {
			let from = this.getSelectionStart();
			let to = this.getSelectionEnd();
			let startSelect = x + 3 + ctx.measureText(this.lines[this.widget.selectLine].slice(0, from)).width;
			ctx.fillRect(startSelect + width * 0.05 * .9, y + this.widget.selectLine * (this.widget.fontSize +
				this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown,
				ctx.measureText(this.lines[this.widget.selectLine].substring(from, to)).width, height);
		}
		else {
			let from_line;
			let to_line;
			let from;
			let to;
			if(this.widget.selectLine < this.widget.cursorLine) {
				from_line = this.widget.selectLine;
				to_line = this.widget.cursorLine;
				from = this.widget.selectPosition;
				to = this.widget.cursorPosition;
			}
			else {
				from_line = this.widget.cursorLine;
				to_line = this.widget.selectLine;
				from = this.widget.cursorPosition;
				to = this.widget.selectPosition;
			}
			let startSelect = 0;
			for(let line = from_line; line <= to_line; line++) {
				if(line == from_line) {
					startSelect = x + 3 + ctx.measureText(this.lines[line].slice(0, from)).width;
					ctx.fillRect(startSelect + width * 0.05 * .9, y + line * (this.widget.fontSize +
						this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(from, this.lines[line].length)).width, height);
				}
				else if(line == to_line) {
					startSelect = x + 3 + ctx.measureText(this.lines[line].slice(0, 0)).width;
					ctx.fillRect(startSelect + width * 0.05 * .9, y + line * (this.widget.fontSize +
						this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown, ctx.measureText(this.lines[line].substring(0, to)).width, height);
				}
				else {
					startSelect = x + 3 + ctx.measureText(this.lines[line].slice(0, 0)).width;
					ctx.fillRect(startSelect + width * 0.05 * .9, y + line * (this.widget.fontSize +
						this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(0, this.lines[line].length)).width, height);
				}
			}
		}
		ctx.restore();
	}
	
	drawSelectCenter(ctx, x, y, width, height) {
		if(this.widget.selectPosition == -1) return;
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textAreaSelectColor", "rgb(100,218,202)");
		if(this.widget.selectLine == this.widget.cursorLine) {
			let from = this.getSelectionStart();
			let to = this.getSelectionEnd();
			let startSelect = x + ctx.measureText(this.lines[this.widget.selectLine].slice(0, from)).width
				- ctx.measureText(this.lines[this.widget.selectLine]).width / 2;
			ctx.fillRect(startSelect + width / 2, y + this.widget.selectLine * (this.widget.fontSize +
				this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown,
				ctx.measureText(this.lines[this.widget.selectLine].substring(from, to)).width, height);
		}
		else {
			let from_line;
			let to_line;
			let from;
			let to;
			if(this.widget.selectLine < this.widget.cursorLine) {
				from_line = this.widget.selectLine;
				to_line = this.widget.cursorLine;
				from = this.widget.selectPosition;
				to = this.widget.cursorPosition;
			}
			else {
				from_line = this.widget.cursorLine;
				to_line = this.widget.selectLine;
				from = this.widget.cursorPosition;
				to = this.widget.selectPosition;
			}
			let startSelect = 0;
			for(let line = from_line; line <= to_line; line++) {
				if(line == from_line) {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, from)).width -
						ctx.measureText(this.lines[line]).width / 2;
					ctx.fillRect(startSelect + width / 2, y + line * (this.widget.fontSize + this.widget.lineHeight) +
						this.widget.lineHeight - this.offsetDown, ctx.measureText(this.lines[line].substring(from, this.lines[line].length)).width, height);
				}
				else if(line == to_line) {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, 0)).width -
						ctx.measureText(this.lines[line]).width / 2;
					ctx.fillRect(startSelect + width / 2, y + line * (this.widget.fontSize + this.widget.lineHeight) +
						this.widget.lineHeight - this.offsetDown, ctx.measureText(this.lines[line].substring(0, to)).width, height);
				}
				else {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, 0)).width -
						ctx.measureText(this.lines[line]).width / 2;
					ctx.fillRect(startSelect + width / 2, y + line * (this.widget.fontSize + this.widget.lineHeight)
						+ this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(0, this.lines[line].length)).width, height);
				}
			}
		}
		ctx.restore();
	}
	
	drawSelectRight(ctx, x, y, width, height) {
		if(this.widget.selectPosition == -1) return;
		ctx.save();
		ctx.fillStyle = this.widget.textAreaSelectColor;
		if(this.widget.selectLine == this.widget.cursorLine) {
			let from = this.getSelectionStart();
			let to = this.getSelectionEnd();
			let startSelect = x + ctx.measureText(this.lines[this.widget.selectLine].slice(0, from)).width -
				ctx.measureText(this.lines[this.widget.selectLine]).width;
			ctx.fillRect(startSelect + width * 0.95, y + this.widget.selectLine * (this.widget.fontSize +
				this.widget.lineHeight) + this.widget.lineHeight - this.offsetDown,
				ctx.measureText(this.lines[this.widget.selectLine].substring(from, to)).width, height);
		}
		else {
			let from_line;
			let to_line;
			let from;
			let to;
			if(this.widget.selectLine < this.widget.cursorLine) {
				from_line = this.widget.selectLine;
				to_line = this.widget.cursorLine;
				from = this.widget.selectPosition;
				to = this.widget.cursorPosition;
			}
			else {
				from_line = this.widget.cursorLine;
				to_line = this.widget.selectLine;
				from = this.widget.cursorPosition;
				to = this.widget.selectPosition;
			}
			let startSelect = 0;
			for(let line = from_line; line <= to_line; line++) {
				if(line == from_line) {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, from)).width -
						ctx.measureText(this.lines[line]).width;
					ctx.fillRect(startSelect + width * 0.95, y + line * (this.widget.fontSize + this.widget.lineHeight)
						+ this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(from, this.lines[line].length)).width, height);
				}
				else if(line == to_line) {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, 0)).width -
						ctx.measureText(this.lines[line]).width;
					ctx.fillRect(startSelect + width * 0.95, y + line * (this.widget.fontSize + this.widget.lineHeight)
						+ this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(0, to)).width, height);
				}
				else {
					startSelect = x + ctx.measureText(this.lines[line].slice(0, 0)).width -
						ctx.measureText(this.lines[line]).width;
					ctx.fillRect(startSelect + width * 0.95, y + line * (this.widget.fontSize + this.widget.lineHeight)
						+ this.widget.lineHeight - this.offsetDown,
						ctx.measureText(this.lines[line].substring(0, this.lines[line].length)).width, height);
				}
			}
		}
		ctx.restore();
	}
	
	drawHeaderTextArea(ctx) {
		ctx.save();
		if(this.widget.header == "") return;
		ctx.font = `${this.style}${this.widget.fontSize * this.zoomFactor}px ${(this.drawer.getParams("font", "Roboto"))}`;
		ctx.textBaseline = "top";
		ctx.textAlign = this.widget.textAlign;
		let tmp = this.widget.header;
		this.stmp = tmp;
		
		while(ctx.measureText(this.stmp).width > 3 * this.widget.width / 4) {
			if(!tmp.length) break;
			tmp = tmp.substr(0, tmp.length - 1);
			this.widget.stmp = tmp + "...";
		}
		ctx.fillStyle = this.drawer.getParams("headerTextColor", "rgb(158, 158, 158)");
		ctx.fillText(this.stmp, this.headerPos.x, this.headerPos.y);
		ctx.restore();
	}
	
	Esc(specSymbol) {
		if(specSymbol.which === this.specSymbols.ESC) {
			if(this.widget.textDraw.length !== 0) {
				if(this.widget.selectPosition !== -1) {
					this.clearSelect(true);
					this.widget.updateParameters();
				}
			}
		}
	}
	
	ctrlA(specSymbol) {
		if(specSymbol.which === this.specSymbols.A && specSymbol.ctrlKey) {
			if(this.widget.textDraw.length !== 0) {
				this.widget.selectLine = 0;
				this.widget.selectPosition = 0;
				this.widget.cursorPosition = this.lines[this.lineCount - 1].length;
				this.widget.cursorLine = this.lineCount - 1;
				this.mv = true;
				this.wheel = false;
				this.widget.updateParameters();
			}
		}
	}
	
	keyDown(event) {
		this.needValueChange = true;
		switch(event.which) {
			case this.specSymbols.BACKSPACE:
				this.deleteChar(event.which);
				break;
			case this.specSymbols.DELETE:
				this.deleteChar(event.which);
				break;
			case this.specSymbols.LEFT_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.RIGHT_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.UP_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.DOWN_ARROW:
				this.moveChar(event);
				break;
			case this.specSymbols.ENTER:
				this.addNewLine();
				break;
			case this.specSymbols.A:
				this.ctrlA(event);
				break;
			case this.specSymbols.ESC:
				this.Esc(event);
				break;
			default:
				this.needValueChange = false;
				break;
		}
		
	}
	
	keyPress(event) {
		//13 = enter!
		if(this.widget.isFocused() && event.charCode !== 13) {
			if(this.widget.cursorPosition === 0 && this.widget.text.length === 0) {
				this.widget.text += this.getChar(event);
				this.widget.cursorPosition++;
				this.needChange = true;
			} else if(this.widget.selectPosition !== -1) {
				let start = Math.min(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
				let end = Math.max(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
				this.widget.text = this.widget.text.slice(0, start) + this.getChar(event) + this.widget.text.slice(end, this.widget.text.length);
				if(this.widget.cursorLine > this.widget.selectLine) this.widget.cursorLine = this.widget.selectLine;
				this.widget.cursorPosition = this.widget.text.slice(0, start).length + 1;
				this.clearSelect(false);
				this.needChange = true;
				this.delete = true;
			} else {
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition()) + this.getChar(event) +
					this.widget.text.slice(this.getGlobalCaretPosition(), this.widget.text.length);
				this.widget.cursorPosition++;
				this.needChange = true;
			}
			this.mv = false;
			this.widget.updateParameters();
		}
	}
	
	deleteChar(specSymbol) {
		if(this.widget.selectPosition !== -1) {
			let start = Math.min(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
			let end = Math.max(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
			this.widget.text = this.widget.text.substring(0, start) + this.widget.text.substring(end, this.widget.text.length);
			this.widget.cursorPosition = this.getSelectionStart();
			if(this.widget.cursorLine > this.widget.selectLine) this.widget.cursorLine = this.widget.selectLine;
			this.needChange = true;
			this.delete = true;
			this.mv = true;
			this.wheel = false;
			this.clearSelect(true);
			this.update();
			return;
		}
		if(specSymbol === this.specSymbols.BACKSPACE) {
			if(this.widget.cursorPosition === 0) {
				if(this.widget.cursorLine === 0) return;
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition() - 1) + this.widget.text.slice(this.getGlobalCaretPosition(), this.widget.text.length);
				this.widget.cursorLine--;
				this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
			} else {
				this.widget.cursorPosition--;
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition()) + this.widget.text.slice(this.getGlobalCaretPosition() + 1, this.widget.text.length);
			}
			this.needChange = true;
			this.delete = true;
			this.wheel = false;
			this.widget.updateParameters();
		} else if(specSymbol === this.specSymbols.DELETE) {
			if(this.widget.cursorPosition === this.widget.text.length) {
				if(this.widget.cursorLine === 0) return;
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition()) + this.widget.text.slice(this.getGlobalCaretPosition() + 1, this.widget.text.length);
				this.widget.cursorLine--;
			} else {
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition()) + this.widget.text.slice(this.getGlobalCaretPosition() + 1, this.widget.text.length);
			}
			this.needChange = true;
			this.delete = true;
			this.mv = true;
			this.wheel = false;
			this.widget.updateParameters();
		}
	}
	
	moveChar(specSymbol) {
		if(specSymbol.which === this.specSymbols.LEFT_ARROW) {
			this.moveLeft(specSymbol);
		} else if(specSymbol.which === this.specSymbols.RIGHT_ARROW) {
			this.moveRight(specSymbol);
		} else if(specSymbol.which === this.specSymbols.UP_ARROW) {
			this.moveUp(specSymbol);
		} else if(specSymbol.which === this.specSymbols.DOWN_ARROW) {
			this.moveDown(specSymbol);
		}
		if(!specSymbol.shiftKey && this.widget.selectPosition !== -1) this.clearSelect(true);
	}
	
	moveLeft(specSymbol) {
		if(this.widget.cursorPosition !== 0) {
			if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1) {
				this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.globalSelectPosition = this.getGlobalCaretPosition();
				this.widget.selectLine = this.widget.cursorLine;
			}
			this.widget.cursorPosition--;
			if(specSymbol.ctrlKey) {
				for(let i = this.widget.cursorPosition; i >= 0; --i) {
					if(specSymbol.shiftKey && this.widget.selectPosition === -1) {
						this.widget.selectPosition = this.widget.cursorPosition + 1;
						this.widget.globalSelectPosition = this.getGlobalCaretPosition() + 1;
						this.widget.selectLine = this.widget.cursorLine;
					}
					if(i === 0) {
						this.widget.cursorPosition = i;
						this.widget.updateParameters();
						return;
					}
					if(!this.isNotAlpha(this.widget.text[i]) && this.isNotAlpha(this.widget.text[i - 1])) {
						this.widget.updateParameters();
						return;
					}
					this.widget.cursorPosition = i - 1;
				}
			}
		} else {
			if(this.widget.cursorLine === 0) return;
			this.widget.cursorLine--;
			this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
		}
		this.mv = true;
		this.wheel = false;
		this.widget.updateParameters();
	}
	
	moveRight(specSymbol) {
		if(this.widget.cursorPosition !== this.lines[this.widget.cursorLine].length) {
			if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1) {
				this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.globalSelectPosition = this.getGlobalCaretPosition();
				this.widget.selectLine = this.widget.cursorLine;
			}
			this.widget.cursorPosition++;
			if(specSymbol.ctrlKey) {
				for(this.widget.cursorPosition; this.widget.cursorPosition <= this.lines[this.widget.cursorLine].length; ++this.widget.cursorPosition) {
					if(specSymbol.shiftKey && this.widget.selectPosition === -1) {
						this.widget.selectPosition = this.widget.cursorPosition - 1;
						this.widget.globalSelectPosition = this.getGlobalCaretPosition() - 1;
						this.widget.selectLine = this.widget.cursorLine;
					}
					if(this.widget.cursorPosition === this.lines[this.widget.cursorLine].length) {
						this.widget.updateParameters();
						return;
					}
					if(!this.isNotAlpha(this.lines[this.widget.cursorLine][this.widget.cursorPosition - 1]) &&
						this.isNotAlpha(this.lines[this.widget.cursorLine][this.widget.cursorPosition])) {
						this.widget.updateParameters();
						return;
					}
				}
			}
		} else {
			if(this.widget.cursorLine === this.lines.length - 1) return;
			this.widget.cursorLine++;
			this.widget.cursorPosition = 0;
		}
		this.mv = true;
		this.wheel = false;
		this.widget.updateParameters();
	}
	
	moveUp(specSymbol) {
		if(specSymbol.ctrlKey) {
			if(specSymbol.shiftKey && this.widget.selectPosition === -1) {
				this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.globalSelectPosition = this.getGlobalCaretPosition();
				this.widget.selectLine = this.widget.cursorLine;
			}
			this.widget.cursorLine = 0;
			this.widget.cursorPosition = 0;
			return;
		}
		if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1) {
			this.widget.selectPosition = this.widget.cursorPosition;
			this.widget.globalSelectPosition = this.getGlobalCaretPosition();
			this.widget.selectLine = this.widget.cursorLine;
		}
		if(this.widget.cursorLine === 0) this.widget.cursorPosition = 0;
		else this.widget.cursorLine--;
		this.mv = true;
		this.wheel = false;
		if(this.widget.cursorPosition > this.lines[this.widget.cursorLine].length) this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
		this.widget.updateParameters();
	}
	
	moveDown(specSymbol) {
		if(specSymbol.ctrlKey) {
			if(specSymbol.shiftKey && this.widget.selectPosition === -1) {
				this.widget.selectPosition = this.widget.cursorPosition;
				this.widget.globalSelectPosition = this.getGlobalCaretPosition();
				this.widget.selectLine = this.widget.cursorLine;
			}
			this.widget.cursorLine = this.lines.length - 1;
			this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
			this.update();
			return;
		}
		if(specSymbol.shiftKey && !specSymbol.ctrlKey && this.widget.selectPosition === -1) {
			this.widget.selectPosition = this.widget.cursorPosition;
			this.widget.globalSelectPosition = this.getGlobalCaretPosition();
			this.widget.selectLine = this.widget.cursorLine;
		}
		if(this.widget.cursorLine >= this.lines.length - 1) this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
		else this.widget.cursorLine++;
		this.mv = true;
		this.wheel = false;
		if(this.widget.cursorPosition > this.lines[this.widget.cursorLine].length) this.widget.cursorPosition = this.lines[this.widget.cursorLine].length;
		this.widget.updateParameters();
	}
	
	cut(event) {
		if(this.widget.selectPosition === -1) return;
		event.clipboardData.setData('text/plain', this.getSelectionText());
		let start = Math.min(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
		let end = Math.max(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
		this.widget.text = this.widget.text.slice(0, start) + this.widget.text.slice(end, this.widget.text.length);
		this.widget.cursorPosition = this.getSelectionStart();
		if(this.widget.cursorLine > this.widget.selectLine) this.widget.cursorLine = this.widget.selectLine;
		this.clearSelect(true);
		event.preventDefault();
	}
	
	copy(event) {
		event.clipboardData.setData('text/plain', this.getSelectionText());
		event.preventDefault();
	}
	
	paste(event) {
		if(event.clipboardData.types.indexOf('text/plain') > -1) {
			if(this.widget.selectPosition !== -1) {
				let start = Math.min(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
				let end = Math.max(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
				this.widget.text = this.widget.text.slice(0, start) + event.clipboardData.getData('text/plain') + this.widget.text.slice(end, this.widget.text.length);
				this.widget.cursorPosition = this.lines[this.widget.cursorLine].slice(0, this.getSelectionEnd()).length;
				this.clearSelect(false);
				this.pasteText = true;
				this.wheel = false;
			} else {
				this.widget.text = this.widget.text.slice(0, this.getGlobalCaretPosition()) +
					event.clipboardData.getData('text/plain') + this.widget.text.slice(this.getGlobalCaretPosition(), this.widget.text.length);
				let line = event.clipboardData.getData('text/plain').split('\n');
				this.widget.cursorLine += line.length - 1;
				this.widget.cursorPosition += line[line.length - 1].length;
				this.pasteText = true;
				this.wheel = false;
				if(this.lines[this.widget.cursorLine] === undefined) {
					this.widget.cursorPosition = line[line.length - 1].length;
					this.pasteText = true;
					this.wheel = false;
					this.widget.updateParameters();
					event.preventDefault();
					return;
				}
			}
			this.wheel = false;
			this.widget.updateParameters();
			event.preventDefault();
		}
	}
	
	addNewLine() {
		this.widget.text = this.widget.text.substr(0, this.getGlobalCaretPosition()) + `\n` + this.widget.text.substr(this.getGlobalCaretPosition(), this.widget.text.length);
		this.lineCount++;
		this.widget.cursorLine++;
		this.widget.cursorPosition = 0;
		this.wheel = false;
		this.widget.updateParameters();
	}
	
	getGlobalCaretPosition() {
		if(this.lines === undefined || this.lines.length <= 0) return 0;
		
		let correctValue = 0;
		let globalCaretPosition = 0;
		for(let i = 0; i < this.widget.cursorLine; ++i) {
			globalCaretPosition += this.lines[i].length + 1;
		}
		for(let i1 = 0; i1 <= this.widget.cursorLine; ++i1) {
			if(this.transferLines !== undefined)
				if(this.transferLines[i1] !== undefined)
					correctValue += this.transferLines[i1];
		}
		return globalCaretPosition + this.widget.cursorPosition - correctValue;
	}
	
	getGlobalSelectPosition() {
		if(this.lines === undefined || this.lines.length <= 0) return 0;
		let correctValue = 0;
		let globalSelectPosition = 0;
		for(let i = 0; i < this.widget.selectLine; ++i) {
			globalSelectPosition += this.lines[i].length + 1;
		}
		
		for(let i1 = 0; i1 <= this.widget.cursorLine; ++i1) {
			if(this.transferLines !== undefined)
				if(this.transferLines[i1] !== undefined)
					correctValue += this.transferLines[i1];
		}
		
		return globalSelectPosition + this.widget.selectPosition - correctValue;
	}
	
	getSelectionStart() {
		return Math.min(this.widget.selectPosition, this.widget.cursorPosition);
	}
	
	getSelectionEnd() {
		return Math.max(this.widget.selectPosition, this.widget.cursorPosition);
	}
	
	getSelectionText() {
		let start = Math.min(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
		let end = Math.max(this.widget.globalSelectPosition, this.getGlobalCaretPosition());
		return this.widget.text.substring(start, end);
	}
	
	getChar(event) {
		if(event.which !== 0 && event.charCode !== 0) { // все кроме IE
			if(event.which < 32) return null; // спец. символ
			return String.fromCharCode(event.which); // остальные
		}
		return null; // спец. символ
	}
	
	isNotAlpha(letter) {
		let symbols = /[\.\,\+\-\*/= _\[\]\{\}\(\)\<\>:;\\'"\|!@#\$%\^&\?]/;
		return symbols.test(letter);
	}
	
	clearSelect(needSend) {
		this.widget.selectPosition = -1;
		this.widget.globalSelectPosition = -1;
		this.widget.selectLine = 0;
		if(needSend) this.widget.updateParameters();
	}
	
	updateInterval() {
		setInterval(function() {
			this.enabled = !this.enabled;
		}.bind(this), 500);
	}
	
	
	onFocused(focused) {
		if(!focused) {
			this.clearSelect(true);
			if(this.headerAnim) {
				let timeId;
				timeId = setInterval(function() {
					if(this.headerAnim) return;
					this.headerDown();
					clearInterval(timeId);
				}.bind(this, timeId), 10);
			}
			else this.headerDown();
		} else {
			this.animation.startAnimation();
			if(this.headerAnim) {
				let timeId;
				timeId = setInterval(function() {
					if(this.headerAnim) return;
					this.headerUp();
					clearInterval(timeId);
				}.bind(this, timeId), 10);
			}
			else this.headerUp();
		}
	}
	
	onOffsetDown(ctx, y, height, fontSize, cursorLine, linesCount, heightCaret, caretPosition, lineHeight) {
		if(!this.wheel) {
			if(linesCount * (fontSize + lineHeight) < height || cursorLine == 0) {
				return 0;
			} else if((cursorLine + 1) * (fontSize + lineHeight) + heightCaret > height && !this.mv) {
				if(cursorLine + 1 == linesCount) {
					return (cursorLine) * (fontSize + lineHeight) - height + heightCaret;
				} else if(cursorLine > 0 && cursorLine < linesCount && caretPosition + (fontSize + lineHeight) + heightCaret > height + y) {
					return (cursorLine + 1) * (fontSize + lineHeight) - height + heightCaret;
				}
			} else if(this.mv && (caretPosition + (fontSize + lineHeight) + heightCaret > height + y || caretPosition - (fontSize + lineHeight) + heightCaret < y)) {
				if(caretPosition - heightCaret + (fontSize + lineHeight) < y) {
					return cursorLine * (fontSize + lineHeight);
				}
				if(caretPosition + fontSize > height + y) {
					return cursorLine * (fontSize + lineHeight) - height + heightCaret;
				}
			} else if(this.mv && caretPosition + (fontSize + lineHeight) - heightCaret < height + y && caretPosition - (fontSize + lineHeight) + heightCaret > y) {
				if(caretPosition + (linesCount - cursorLine) * (fontSize + lineHeight) < height + y) {
					if(cursorLine + 1 == linesCount) {
						return cursorLine * (fontSize + lineHeight) - height + heightCaret;
					} else if(cursorLine > 0 && cursorLine < linesCount) {
						return cursorLine * (fontSize + lineHeight) - height + heightCaret + (linesCount - cursorLine - 1) * (fontSize + lineHeight);
					}
				}
			} else return undefined;
		}
		
	}
	
	changeSize(ctx, text, width) {
		this.changeText(this.widget.text, ctx, width);
		this.needResize = false;
		this.needChange = true;
		this.wheel = false;
		this.needValueChange = true;
		this.pasteText = false;
		this.delete = false;
		this.widget.updateParameters();
		Rex.gui.redraw();
	}
	
	changeText(text, ctx, width) {
		if(this.ctxFunc("W", width, ctx)) return;
		if(this.ctxFunc(text, width, ctx)) {
			let arr = text.split('\n');
			if(this.transferLines.length !== arr.length) {
				for(let i = 0; i < arr.length; i++) {
					this.transferLines[i] = 0;
				}
			}
			
			if(this.pasteText || this.needChange || this.delete) {
				for(let i = 0; i < arr.length; i++) {
					
					// Текущая строка
					let z = arr[i];
					
					// Если текущая строка больше ширины виджета
					if(this.ctxFunc(z, width, ctx)) {
						
						// Проба взятия слова
						let end = z.length;
						let text1 = '';
						
						while(end > 0) {
							// substr - взятия подстроки нач. позиция и кол-во символов
							let lastSymbol = z.substr(0, end).charAt(end - 1);
							if(!this.ctxFunc(z.substr(0, end), width, ctx) && (lastSymbol == " ")) {
								text1 = z.substr(0, end);
								break;
							} else {
								--end;
							}
						}
						
						// Условие с возможностью перести слово (найден пробел)
						if(z.length != text1.length && text1.length > 0 && !this.ctxFunc(text1, width, ctx)) {
							
							arr[i] = text1;
							arr.splice(i + 1, 0, z.substr(end));
							this.transferLines[i + 1] = 1;
							
							if(i === this.widget.cursorLine && !this.pasteText) {
								if(this.widget.cursorPosition == z.length) {
									this.widget.cursorPosition = z.substr(end).length;
									this.widget.cursorLine++;
								}
							}
							
							// Иначе перенос по символам
						} else {
							
							end = z.length;
							text1 = '';
							
							while(end > 0) {
								if(!this.ctxFunc(z.substr(0, end), width, ctx)) {
									text1 = z.substr(0, end);
									break;
								} else {
									--end;
								}
								
							}
							
							arr[i] = text1;
							arr.splice(i + 1, 0, z.substr(end));
							this.transferLines[i + 1] = 1;
							
							
							if(i === this.widget.cursorLine && !this.pasteText) {
								if(this.widget.cursorPosition == z.length) {
									this.widget.cursorPosition = z.substr(end).length;
									this.widget.cursorLine++;
								}
							}
						}
					}
				}
			}
			this.widget.textDraw = arr.join('\n');
			this.widget.updateParameters();
		}
		else this.update();
		this.needChange = false;
		this.pasteText = false;
		this.delete = false;
	}
	
	toLinesText(text, ctx) {
		this.lines = text.split('\n');
		this.lineCount = this.lines.length;
		this.widthText = [];
		for(let i = 0; i < this.lines.length; i++) {
			this.widthText[i] = [];
			let z;
			switch(this.widget.textAlign) {
				case 'right':
					z = this.anchorSize.x * 0.95 - ctx.measureText(this.lines[i]).width;
					break;
				case 'center':
					z = this.anchorSize.x / 2 - ctx.measureText(this.lines[i]).width / 2;
					break;
				default:
					z = this.anchorSize.x * 0.05;
					break;
			}
			if(this.lines[i].length === 0) {
				(this.widthText[i]).push(z);
			} else {
				for(let j = 0; j < this.lines[i].length + 1; ++j) {
					this.widthText[i].push(ctx.measureText(this.lines[i].substr(0, j)).width + z);
				}
			}
		}
	}
	
	onMouseWheel(event) {
		if(this.lineCount * (this.widget.fontSize + this.widget.lineHeight) > this.anchorSize.y) {
			this.changeOffset(event);
			this.widget.scroll.mouseScrollingStep = this.widget.fontSize;
			this.widget.scroll.mouseWheel(event);
			this.update();
		}
	}
	
	onMouseDown(x, y) {
		if(this.widget.isFocused()) {
			this.changeY(y);
			this.changeX(x);
			this.clearSelect(true);
			this.widget.updateParameters();
		}
	}
	
	onMouseMove(x, y) {
		if(!this.needMove) return;
		if(this.widthText[this.widget.cursorLine].length > 0) {
			this.moveX(x);
			this.moveY(y);
			this.widget.globalSelectPosition = this.getGlobalSelectPosition();
			this.needValueChange = true;
			this.onSetScrollValue();
			this.widget.updateParameters();
		}
	}
	
	onMouseUp(x, y) {
		this.needMove = false;
		this.anchorPoint.x = 0;
		this.anchorPoint.y = 0;
		this.widget.updateParameters();
	}
	
	moveX(x) {
		if(this.anchorPoint.x !== 0 && (this.widthText[this.widget.cursorLine].length > 1)) {
			if(x <= ((this.anchorPos.x) + this.widthText[this.widget.cursorLine][this.widthText[this.widget.cursorLine].length - 1]) && x >= this.anchorPos.x + this.widthText[this.widget.cursorLine][0]) {
				let delta = x - (this.widthText[this.widget.cursorLine][this.widget.cursorPosition] + this.anchorPos.x);
				if(Math.abs(delta) > this.charLength * .95) {
					if(this.widget.selectPosition === -1) {
						this.widget.selectPosition = this.widget.cursorPosition;
						this.widget.selectLine = this.widget.cursorLine;
					}
					this.widget.cursorPosition += Math.round(delta / this.charLength);
					this.mv = false;
				}
			}
			if(x > ((this.anchorPos.x) + this.widthText[this.widget.cursorLine][this.widthText[this.widget.cursorLine].length - 1])) this.widget.cursorPosition = this.widthText[this.widget.cursorLine].length - 1;
			if(x < this.anchorPos.x) this.widget.cursorPosition = 0;
		}
	}
	
	moveY(y) {
		if(this.anchorPoint.y !== 0 && this.lineCount > 1 && this.offsetDown === 0) {
			if(y >= this.anchorPos.y && y <= (this.lineCount - 1) * (this.widget.fontSize + this.widget.lineHeight) + this.anchorPos.y) {
				let delta = y - (this.widget.cursorLine) * (this.widget.fontSize + this.widget.lineHeight) - this.anchorPos.y;
				if(Math.abs(delta) > (this.widget.fontSize + this.widget.lineHeight) * .9) {
					if(this.widget.selectPosition === -1) {
						this.widget.selectLine = this.widget.cursorLine;
						this.widget.selectPosition = this.widget.cursorPosition;
					}
					this.widget.cursorLine += Math.round(delta / (this.widget.fontSize + this.widget.lineHeight));
					this.mv = false;
					this.wheel = false;
				}
			}
			if(y < this.anchorPos.y) {
				this.widget.cursorLine = 0;
			}
			if(y > (this.lineCount - 1) * (this.widget.fontSize + this.widget.lineHeight) + this.anchorPos.y) this.widget.cursorLine = this.lineCount - 1;
		}
		else if(this.anchorPoint.y != 0 && this.lineCount > 1 && this.offsetDown != 0) {
			if(y >= this.anchorPos.y - this.offsetDown && y <= this.anchorPos.y + this.anchorSize.y) {
				let delta = y - (this.widget.cursorLine) * (this.widget.fontSize + this.widget.lineHeight) - this.anchorPos.y + this.offsetDown;
				if(Math.abs(delta) > (this.widget.fontSize + this.widget.lineHeight) * .9) {
					if(this.widget.selectPosition == -1) {
						this.widget.selectLine = this.widget.cursorLine;
						this.widget.selectPosition = this.widget.cursorPosition;
					}
					this.widget.cursorLine += Math.round(delta / ((this.widget.fontSize + this.widget.lineHeight)));
					if(this.widget.cursorLine >= this.lineCount) this.widget.cursorLine = this.lineCount - 1;
					this.mv = true;
					this.wheel = false;
				}
			}
			if(y < this.anchorPos.y - this.offsetDown) {
				this.widget.cursorLine = 0;
			}
			if(y > this.anchorPos.y + this.anchorSize.y) this.widget.cursorLine = this.lineCount - 1;
		}
		if(this.widget.cursorPosition >= this.widthText[this.widget.cursorLine].length)
			this.widget.cursorPosition = this.widthText[this.widget.cursorLine].length - 1;
	}
	
	changeX(x) {
		if(this.widget.cursorLine == this.lineCount) {
			this.widget.cursorLine--;
			this.widget.cursorPosition = this.widthText[this.widget.cursorLine].length - 1;
		}
		else if(this.widthText[this.widget.cursorLine].length > 1) {
			let begin = (this.anchorPos.x) + this.widthText[this.widget.cursorLine][0];
			let end = (this.anchorPos.x + this.widthText[this.widget.cursorLine][this.widthText[this.widget.cursorLine].length - 1]) - (this.widthText[this.widget.cursorLine][this.widthText[this.widget.cursorLine].length - 1] - this.widthText[this.widget.cursorLine][this.widthText[this.widget.cursorLine].length - 2]) * 0.4;
			if((x >= this.anchorPos.x) && (x <= begin)) {
				this.widget.cursorPosition = 0;
				this.widget.selectPosition = -1;
			} else if((x >= begin) && (x < end)) {
				for(let i = 0; i < this.widthText[this.widget.cursorLine].length; i++) {
					let l = (this.anchorPos.x) + (this.widthText[this.widget.cursorLine][i + 1] - this.widthText[this.widget.cursorLine][i]) * 0.4 + this.widthText[this.widget.cursorLine][i];
					let r = (this.anchorPos.x) + (this.widthText[this.widget.cursorLine][i + 2] - this.widthText[this.widget.cursorLine][i + 1]) * 0.6 + this.widthText[this.widget.cursorLine][i + 1];
					if(x > l && x < r) {
						this.widget.cursorPosition = i + 1;
						this.widget.selectPosition = -1;
						break;
					}
				}
			} else if(x >= end) {
				this.widget.cursorPosition = this.widthText[this.widget.cursorLine].length - 1;
				this.widget.selectPosition = -1;
			}
		}
		this.anchorPoint.x = x;
		this.mv = false;
		this.needMove = true;
	}
	
	changeY(y) {
		if(this.lineCount != 0 && this.offsetDown == 0) {
			let begin = this.anchorPos.y + (this.widget.fontSize + this.widget.lineHeight);
			let end = (this.lineCount) * ((this.widget.fontSize + this.widget.lineHeight)) + this.anchorPos.y;
			if(y >= this.anchorPos.y && y <= begin) {
				this.widget.cursorLine = 0;
			} else if((y >= begin) && (y < end)) {
				for(let i = 0; i < this.lineCount; i++) {
					let l = (this.anchorPos.y) + i * (this.widget.fontSize + this.widget.lineHeight);
					let r = (this.anchorPos.y) + (i + 1) * (this.widget.fontSize + this.widget.lineHeight);
					if(y > l && y < r) {
						this.widget.cursorLine = i;
						break;
					}
				}
			} else if(y >= (this.lineCount) * (this.widget.fontSize + this.widget.lineHeight) + this.anchorPos.y && y <= this.anchorPos.y + this.anchorSize.y) {
				this.widget.cursorLine = this.lineCount;
			}
			
		} else if(this.offsetDown != 0) {
			for(let i = 0; i < this.lineCount; i++) {
				let l = (this.anchorPos.y) + i * (this.widget.fontSize + this.widget.lineHeight) - this.offsetDown;
				let r = (this.anchorPos.y) + (i + 1) * (this.widget.fontSize + this.widget.lineHeight) - this.offsetDown;
				if(y > l && y < r) {
					this.widget.cursorLine = i;
					break;
				}
			}
			if(y >= this.caretPosition && y < (this.anchorSize.y + this.anchorPos.y) && this.widget.cursorLine == this.lineCount) {
				this.widget.cursorLine = this.lineCount - 1;
			}
		}
		this.anchorPoint.y = y;
		this.mv = false;
		this.needMove = true;
	}
	
	ctxFunc(a, b, ctx) {
		return ctx.measureText(a).width > b;
	}
	
	changeOffset(event) {
		if(this.widget.isFocused()) {
			this.wheel = true;
			this.offsetDown += event * this.lineCount;
			if(this.offsetDown < 0) this.offsetDown = 0;
			if(this.offsetDown > (this.lineCount * (this.widget.fontSize + this.widget.lineHeight) - this.anchorSize.y + this.widget.fontSize / 3))
				this.offsetDown = this.lineCount * (this.widget.fontSize + this.widget.lineHeight) - this.anchorSize.y + this.widget.fontSize / 3;
			let v = this.offsetDown / (this.lineCount * (this.widget.fontSize + this.widget.lineHeight) - this.anchorSize.y + this.widget.fontSize / 3);
			this.onSetScrollValue(v);
		}
	}
	
	onSetScrollValue(v = -100) {
		let z;
		if(v != -100) z = v;
		else if(this.needValueChange) {
			if(this.widget.cursorLine != 0 && this.widget.cursorLine != this.lineCount - 1 && this.widget.cursorLine != this.lineCount) {
				z = this.offsetDown / (this.lineCount * (this.widget.fontSize + this.widget.lineHeight) - this.anchorSize.y + this.widget.fontSize / 3);
			} else {
				z = this.widget.cursorLine == 0 ? 0 : 1;
			}
		}
		this.needValueChange = false;
		this.widget.scroll.arrowsScrollingStep = this.widget.fontSize;
		this.widget.scroll.setValue(z);
	}
	
	textStyle() {
		let style = '';
		if(this.widget.italic) style += 'italic ';
		if(this.widget.bold) style += 'bold ';
		this.style = style;
	}
	
	headerUp() {
		if(this.headerAnim) return;
		this.headerAnim = true;
		let T = Math.round(Math.abs(this.widget.aPosY - this.anchorPos.y));
		let step = T / this.Nsteps;
		for(let i = this.Nsteps; i >= 0; --i) {
			setTimeout(function() {
				if(!this.headerAnim) return;
				this.update();
				this.headerPos.y -= step;
				this.zoomFactor -= (this.maxZoomFactor - this.minZoomFactor) / this.Nsteps;
				if((0 == i) && this.widget.isFocused()) {
					this.headerPos.y = this.anchorPos.y - this.widget.fontSize;
					this.zoomFactor = this.minZoomFactor;
					this.headerAnim = false;
					Rex.gui.redraw();
					return;
				}
				if(this.headerPos.y <= this.anchorPos.y - this.widget.fontSize) {
					this.headerPos.y = this.anchorPos.y - this.widget.fontSize;
					this.zoomFactor = this.minZoomFactor;
					this.headerAnim = false;
					Rex.gui.redraw();
					return;
				}
				Rex.gui.redraw();
			}.bind(this, i, step), 10 * (this.Nsteps - i));
			
		}
	}
	
	headerDown() {
		if(this.widget.text != "") return;
		if(this.headerAnim) return;
		this.headerAnim = true;
		let T = Math.round(Math.abs(this.widget.aPosY - this.anchorPos.y));
		let step = T / this.Nsteps;
		for(let i = this.Nsteps; i >= 0; --i) {
			if(!this.headerAnim) return;
			setTimeout(function() {
				this.update();
				this.headerPos.y += step;
				this.zoomFactor += (this.maxZoomFactor - this.minZoomFactor) / this.Nsteps;
				if(((0 == i) && (this.widget.text == "")) && (!this.widget.isFocused())) {
					this.headerPos.y = this.anchorPos.y;
					this.zoomFactor = this.maxZoomFactor;
					this.headerAnim = false;
					Rex.gui.redraw();
					return;
				}
				if(this.headerPos.y >= this.anchorPos.y) {
					this.headerAnim = false;
					this.zoomFactor = this.maxZoomFactor;
					this.headerPos.y = this.anchorPos.y;
					Rex.gui.redraw();
					return;
				}
				Rex.gui.redraw();
			}.bind(this, i, step), 10 * (this.Nsteps - i));
		}
	}
}

/**
 * WidgetLabel
 */

class WidgetLabelCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.lines = [];
		this.style = '';
		this.sizeFont = -1;
	}
	
	setState(state) {
		super.setState(state);
		if(typeof state.text !== 'undefined') {
			let temp;
			try {
				temp = decodeURIComponent(escape(window.atob(state.text)));
			} catch (e) {
				console.error(this.widget.type, " -> setState-> ", state.text, " DecodeError!");
			}
			try {
				if(this.widget.text !== temp) {
					this.update();
					this.widget.text = temp;
				}
			} catch (e) {
				console.error(this.widget.type, " -> setState-> Can't refresh buffer ", e);
			}
		}
		if(state.fontSize !== undefined || state.autoFontSize !== undefined || state.boldFont !== undefined || state.italicFont !== undefined || state.autoHeight !== undefined || state.colorText !== undefined || state.textAlign !== undefined) {
			this.update();
		}
	}
	
	textStyle() {
		let style = '';
		if(this.widget.italicFont) style += 'italic ';
		if(this.widget.boldFont) style += 'bold ';
		this.style = style;
	}
	
	getWidthStr(ctx, str) {
		if(str === undefined) return 0;
		let widthStr = 0;
		for(let i = 0; i < str.length; ++i) {
			widthStr += ctx.measureText(str[i]).width;
		}
		return widthStr;
	}
	
	renderText(ctx, text, width) {
		this.lines = [];
		let arr = text.split('\\n');
		let count = 0;
		for(let i = 0; i < arr.length; ++i) {
			if(this.getWidthStr(ctx, arr[i]) > width) {
				let words = arr[i].split(" ");
				let countWords = words.length;
				let line = words[0];
				for(let n = 1; n < countWords; n++) {
					line += " ";
					let testLine = line + words[n];
					let testWidth = this.getWidthStr(ctx, testLine);
					if(testWidth > width) {
						this.lines[count] = line;
						line = words[n];
						count++;
					}
					else {
						line = testLine;
					}
				}
				this.lines[count] = line;
				count++;
			}
			else {
				this.lines[count] = arr[i];
				count++;
			}
		}
		if(this.widget.autoHeight) Rex.gui.reposition(this.widget);
	}
	
	addThreeDots(ctx, str, width, dots) {
		if((this.getWidthStr(ctx, str)) > width) {
			let line = "";
			for(let i = 0; i < str.length; i++) {
				if(this.getWidthStr(ctx, line + "...") > width) {
					return str = line + "...";
				}
				line += str[i];
			}
		}
		else {
			let s = dots ? dots : '';
			return str + s;
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawLabel(ctx, ctxTemp);
	}
	
	drawLabel(ctx, ctxTemp) {
		if(this.widget.text.length === 0) return;
		let font = this.drawer.getParams("font", "Roboto");
		if(this.widget.fontSize === -1) this.sizeFont = this.drawer.getParams("fontSize", 16);
		else this.sizeFont = this.widget.fontSize;
		let minFontSize = this.drawer.getParams("minFontSize", 10);
		let maxFontSize = this.drawer.getParams("maxFontSize", 100);
		
		this.textDraw = this.widget.text;		// Форматированный текст для формирования строк и отрисовки
		this.lines = [];							// Текст в виде строк для корректной отрисовки
		
		this.textStyle();
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("textColor", "rgba(255, 0, 0, 1)");
		ctx.textAlign = this.widget.textAlign;
		
		let y = 0;
		if(this.widget.autoFontSize) {
			this.sizeFont = this.getAutoFontSize(ctx, minFontSize, maxFontSize, font);
			y = this.widget.aPosY + (this.widget.height / 2) - (this.sizeFont / 2);
			ctx.save();
			ctx.font = `${this.style}${this.sizeFont}px ${font}`;
			let str = this.addThreeDots(ctx, this.textDraw, this.widget.width * 0.9);
			ctx.restore();
			this.drawLineText(ctx, y, str);
		}
		else {
			if(minFontSize > this.sizeFont)
				this.sizeFont = minFontSize;
			if(maxFontSize < this.sizeFont)
				this.sizeFont = maxFontSize;
			
			ctx.font = `${this.style}${this.sizeFont}px ${font}`;
			
			//разбиваем текст на строки
			this.renderText(ctx, this.textDraw, this.widget.width * 0.7);
			
			if(this.lines === undefined || this.lines.length <= 0) return;
			
			let str = '';
			let countStr = 0;
			if(!this.widget.autoHeight) {
				//считаем сколько строк войдет по высоте
				countStr = parseInt((this.widget.height) / (this.sizeFont + 5));
				//проверка: вместятся ли все строки
				if(countStr >= this.lines.length) {
					countStr = this.lines.length;
				}
				// если нет, то обрезаем и добавляем "."
				else {
					if(countStr === 0) {
						str = "...";
						this.lines[0] = str;
					}
					else {
						str = this.addThreeDots(ctx, this.lines[countStr - 1], this.widget.width * 0.7, "...");
						this.lines[countStr - 1] = str;
					}
				}
			}
			else {
				countStr = this.lines.length;
			}
			
			y = this.widget.aPosY + (this.widget.height / 2) - ((countStr * (this.sizeFont + 5)) / 2);
			for(let i = 0; i < countStr; ++i) {
				let line = '';
				for(let j = 0; j < this.lines[i].length; ++j) {
					line += this.lines[i][j];
				}
				line = this.addThreeDots(ctx, line, this.widget.width * 0.7);
				this.drawLineText(ctx, y, line);
				y += this.sizeFont + 5;
			}
		}
		ctx.restore();
	}
	
	drawLineText(ctx, y, text) {
		let font = this.drawer.getParams("font", "Arial");
		let textColor = (this.widget.colorText === "" || this.widget.colorText.length === 0) ? this.drawer.getParams("textColor", "rgba(255, 0, 0, 1)") : this.widget.colorText;
		switch(this.widget.textAlign) {
			case 1 :
				this.drawer.drawTextLeft(ctx, this.widget.aPosX, y, text, this.sizeFont, font, textColor, this.style);
				break;
			case 2 :
				this.drawer.drawTextCenter(ctx, this.widget.aPosX + this.widget.width / 2, y, text, this.sizeFont, font, textColor, this.style);
				break;
			case 3 :
				this.drawer.drawTextRight(ctx, this.widget.aPosX + this.widget.width, y, text, this.sizeFont, font, textColor, this.style);
				break;
		}
	}

	getAutoFontSize(ctx, minFontSize, maxFontSize, font) {
		let sizeFont = this.widget.height * 0.65 > maxFontSize ? maxFontSize : this.widget.height * 0.65;
		ctx.save();
		ctx.font = `${this.style}${sizeFont}px ${font}`;
		let widthText = this.getWidthStr(ctx, this.textDraw);
		while(widthText > this.widget.width * 0.7 && sizeFont > minFontSize) {
			ctx.save();
			--sizeFont;
			ctx.font = `${this.style}${sizeFont}px ${font}`;
			widthText = this.getWidthStr(ctx, this.textDraw);
			ctx.restore();
		}
		ctx.restore();
		return sizeFont;
	}
	
	onPositioning() {
		if(this.widget.autoHeight) {
			if (this.widget.minHeight !== (this.sizeFont + 5) * this.lines.length) {
				this.widget.minHeight = (this.sizeFont + 5) * this.lines.length;
				if (this.widget.minHeight > this.widget.height) {
					this.widget.height = this.widget.minHeight;
				}
			}
		}
	}
	
}


class WidgetLoaderCanvas extends WidgetButtonCanvas {
	
	constructor(widget) {
		super(widget);
		this.input = document.createElement("INPUT");
		this.input.setAttribute("type", "file");
		this.input.multiple = true;
		this.eventSystem = new EventSystem();
		this.eventSystem.add(this.input, "change", this.widget.loadFile.bind(this.widget));
	}
	
	onMouseDown() {
		this.input.value = '';
		this.input.click();
	}
	
}

/**
 * WidgetSwitch
 */

class WidgetSwitchCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(state.enable !== undefined) this.update();
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.pressed) this.animation.startAnimation();
		this.drawer.circleBoundAnimation(ctx, ctxTemp, this.widget.width * 0.5, this.widget.height * 0.5,
			this.drawer.getParams("animationFillColor", "rgba(158, 158, 158, 0.5)"));
		if(this.animation.getRadiusAnimation() > (this.widget.width) && !this.widget.pressed) this.animation.endAnimation();
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawSwitch(ctx, ctxTemp);
	}
	
	drawSwitch(ctx, ctxTemp) {
		
		//TODO hover
		
		let deltaPosX = this.widget.aPosX + this.widget.width / 2;
		let deltaPosY = this.widget.aPosY + this.widget.height / 2;
		
		let radiusMain = Math.min(this.widget.width, this.widget.height) * 0.9;
		
		ctx.save();
		this.drawer.circle(ctx, deltaPosX, deltaPosY, radiusMain / 2, 1,
			this.drawer.getParams("outerCircleStrokeStyle", "rgb(206,206, 206)"),
			this.drawer.getParams("outerCircleFillStyle", "rgb(158, 158, 158)"));
		if(this.widget.enable) {
			if(this.widget.pressed) {
				this.drawer.circle(ctx, deltaPosX, deltaPosY, radiusMain / 2.8, 1,
					this.drawer.getParams("innerCircleEnabledStrokeStyle", "rgb(0, 121, 106)"),
					this.drawer.getParams("outerCircleFillStyle", "rgb(158, 158, 158)"));
			} else {
				this.drawer.circle(ctx, deltaPosX, deltaPosY, radiusMain / 2.5, 1,
					this.drawer.getParams("innerCircleEnabledStrokeStyle", "rgb(0, 121, 106)"),
					this.drawer.getParams("outerCircleFillStyle", "rgb(158, 158, 158)"));
			}
			
			ctx.textAlign = "center";
			ctx.textBaseline = 'middle';
			ctx.fillStyle = this.drawer.getParams("switchEnabledTextColor", "rgb(0, 121, 106)");
			ctx.fillText(this.widget.textOn, deltaPosX, deltaPosY);
		}
		else {
			if(this.widget.pressed) {
				this.drawer.circle(ctx, deltaPosX, deltaPosY, radiusMain / 2.8, 1,
					this.drawer.getParams("innerCircleDisabledStrokeStyle", "rgba(110, 110, 110, 1)"),
					this.drawer.getParams("outerCircleFillStyle", "rgb(158, 158, 158)"));
			} else {
				this.drawer.circle(ctx, deltaPosX, deltaPosY, radiusMain / 2.5, 1,
					this.drawer.getParams("innerCircleDisabledStrokeStyle", "rgba(110, 110, 110, 1)"),
					this.drawer.getParams("outerCircleFillStyle", "rgb(158, 158, 158)"));
			}
			ctx.textAlign = "center";
			ctx.textBaseline = 'middle';
			ctx.fillStyle = this.drawer.getParams("switchDisabledTextColor", "rgba(110, 110, 110, 1)");
			ctx.fillText(this.widget.textOff, deltaPosX, deltaPosY);
		}
		ctx.restore();
	}
}

/**
 * WidgetSwitch
 */

class WidgetStickCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState (state) {
		super.setState(state);
		if(state.currentButton !== undefined) this.update();
	}
	
	onCheckSelect(x, y) {
		for(let i = 0; i < this.widget.arrows.length; ++i) {
			this.widget.arrows[i].hover = false;
		}
		if(!this.inside(x, y)) return undefined;
		let radius = this.widget.height / 3;
		let radius1 = this.widget.height / 6;
		let radius2 = this.widget.height / 5;
		let centerX = this.widget.aPosX + this.widget.width / 2;
		let centerY = this.widget.aPosY + this.widget.height / 2;
		let min = new Rex.Vector2(centerX - radius2, centerY - radius2);
		let max = new Rex.Vector2((centerX - radius2) + (centerX + radius2) / 2, (centerY - radius2) + (centerX + radius2) / 2);
		let boundBox = new Rex.BoundBox(min, max);
		if(boundBox.inside(new Rex.Vector2(x, y), 0)) {
			this.widget.arrows[0].color = Rex.gui.styleLibrary.getParam(this.styleName, "arrowHoveredColor", "Color(Secondary)");
			this.widget.arrows[0].hover = true;
		}
		for(let i = 0; i < 4; ++i) {
			let c = (Math.pow(-1, Math.round(i * 0.5)) * (Math.pow(-1, i) + 1)) * 0.5;
			let s = (Math.pow(-1, Math.round(i * 0.5)) * (Math.pow(-1, i + 1) + 1)) * 0.5;
			let translate = new Rex.Vector2(centerX + c * radius, centerY + s * radius);
			let min = new Rex.Vector2(translate.x - radius1, translate.y - radius1);
			let max = new Rex.Vector2(translate.x - radius1 + radius, translate.y - radius1 + radius);
			let boundBox = new Rex.BoundBox(min, max);
			if(boundBox.inside(new Rex.Vector2(x, y), 0)) {
				this.widget.arrows[4].hover = false;
				switch(i) {
					case 0: {
						this.widget.arrows[3].color = "rgb(50, 50, 50)";
						this.widget.arrows[3].hover = true;
						this.widget.arrows[0].hover = false;
						this.widget.arrows[1].hover = false;
						this.widget.arrows[2].hover = false;
						break;
					}
					case 1: {
						this.widget.arrows[0].color = "rgb(50, 50, 50)";
						this.widget.arrows[0].hover = true;
						this.widget.arrows[2].hover = false;
						this.widget.arrows[1].hover = false;
						this.widget.arrows[3].hover = false;
						break;
					}
					case 2: {
						this.widget.arrows[2].color = "rgb(50, 50, 50)";
						this.widget.arrows[2].hover = true;
						this.widget.arrows[0].hover = false;
						this.widget.arrows[1].hover = false;
						this.widget.arrows[3].hover = false;
						break;
					}
					case 3: {
						this.widget.arrows[1].color = "rgb(50, 50, 50)";
						this.widget.arrows[1].hover = true;
						this.widget.arrows[0].hover = false;
						this.widget.arrows[2].hover = false;
						this.widget.arrows[3].hover = false;
						break;
					}
				}
			}
		}
		return this.widget;
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawStick(ctx, ctxTemp);
	}
	
	drawStick(ctx, ctxTemp) {
		let radius1 = Math.min(this.widget.width, this.widget.height) / 2;
		let radius2 = Math.min(this.widget.width, this.widget.height) / 5;
		let centerX = this.widget.aPosX + this.widget.width / 2;
		let centerY = this.widget.aPosY + this.widget.height / 2;
		this.drawer.circle(ctx, centerX, centerY, radius1, 1,
			this.drawer.getParams("outerCircleStrokeStyle", "rgb(158, 158, 158)"),
			this.drawer.getParams("outerCircleFillStyle", "rgb(206,206, 206)"));
		
		// Анимация нажатия кнопки
		this.drawPress(ctx, centerX, centerY);
		
		if(this.widget.arrows[4].pressed) {
			this.drawer.circle(ctx, centerX, centerY, radius2, 1,
				this.drawer.getParams("innerCircleStrokeStyle", "rgb(158, 158, 158)"),
				this.drawer.getParams("stickUnhoveredTextColor", "rgb(0, 121, 106)"));
		}
		else {
			this.drawer.circle(ctx, centerX, centerY, radius2, 1,
				this.drawer.getParams("innerCircleStrokeStyle", "rgb(158, 158, 158)"),
				this.drawer.getParams("innerCircleFillStyle", "rgba(110, 110, 110, 1)"));
		}
		ctx.save();
		ctx.textAlign = "center";
		ctx.textBaseline = 'middle';
		
		if(this.widget.arrows[4].press) ctx.fillStyle = this.getParams("stickHoveredTextColor", "rgb(0, 0, 0))");
		else ctx.fillStyle = this.drawer.outerCircleStrokeStyle;
		ctx.fillText("OK", centerX, centerY);
		
		let angle = (Math.PI / 4) + (Math.PI / 2) * 3;
		let cos = Math.cos(angle);
		let sin = Math.sin(angle);
		this.drawer.drawLine(ctx, centerX + cos * radius1, centerY + sin * radius1, centerX + cos * radius2, centerY + sin * radius2, 1, this.drawer.getParams("geometricPadding", 1),
			this.drawer.getParams("radialLinesColor", "rgb(158, 158, 158)"));
		// RIGHT
		angle = (Math.PI / 4) + (Math.PI / 2) * 0;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		this.drawer.drawLine(ctx, centerX + cos * radius1, centerY + sin * radius1, centerX + cos * radius2, centerY + sin * radius2, 1, this.drawer.getParams("geometricPadding", 1),
			this.drawer.getParams("radialLinesColor", "rgb(158, 158, 158)"));
		// DOWN
		angle = (Math.PI / 4) + (Math.PI / 2) * 1;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		this.drawer.drawLine(ctx, centerX + cos * radius1, centerY + sin * radius1, centerX + cos * radius2, centerY + sin * radius2, 1, this.drawer.getParams("geometricPadding", 1),
			this.drawer.getParams("radialLinesColor", "rgb(158, 158, 158)"));
		// LEFT
		angle = (Math.PI / 4) + (Math.PI / 2) * 2;
		cos = Math.cos(angle);
		sin = Math.sin(angle);
		this.drawer.drawLine(ctx, centerX + cos * radius1, centerY + sin * radius1, centerX + cos * radius2, centerY + sin * radius2, 1, this.drawer.getParams("geometricPadding", 1),
			this.drawer.getParams("radialLinesColor", "rgb(158, 158, 158)"));
		
		this.drawArrows(ctx, centerX, centerY);
		ctx.restore();
	}
	
	drawArrows(ctx, centerX, centerY) {
		let radius3 = Math.min(this.widget.width, this.widget.height) / 3;
		for(let i = 0; i < this.widget.arrows.length; ++i) {
			switch(this.widget.arrows[i].type) {
				case "up": {
					let c = (Math.pow(-1, Math.round(1 * 0.5)) * (Math.pow(-1, 1) + 1)) * 0.5;
					let s = (Math.pow(-1, Math.round(1 * 0.5)) * (Math.pow(-1, 1 + 1) + 1)) * 0.5;
					this.widget.arrows[i].x = centerX + c * radius3;
					this.widget.arrows[i].y = centerY + s * radius3;
					this.widget.arrows[i].rotate = (1 + 1) * 90;
					
					if(this.widget.arrows[i].hover)
						this.drawer.drawFillTriangle(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, this.widget.height / 30, this.widget.arrows[i].color);
					else
						this.drawer.drawFillTriangle(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, this.widget.height / 30, this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
					break;
				}
				case "right": {
					let c = (Math.pow(-1, Math.round(0 * 0.5)) * (Math.pow(-1, 0) + 1)) * 0.5;
					let s = (Math.pow(-1, Math.round(0 * 0.5)) * (Math.pow(-1, 0 + 1) + 1)) * 0.5;
					this.widget.arrows[i].x = centerX + c * radius3;
					this.widget.arrows[i].y = centerY + s * radius3;
					this.widget.arrows[i].rotate = (0 + 1) * 90;
					
					if(this.widget.arrows[i].hover)
						this.drawer.drawFillTriangleLateral(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, this.widget.height / 15, this.widget.arrows[i].color);
					else
						this.drawer.drawFillTriangleLateral(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, this.widget.height / 15, this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
					break;
				}
				case "down": {
					let c = (Math.pow(-1, Math.round(3 * 0.5)) * (Math.pow(-1, 3) + 1)) * 0.5;
					let s = (Math.pow(-1, Math.round(3 * 0.5)) * (Math.pow(-1, 3 + 1) + 1)) * 0.5;
					this.widget.arrows[i].x = centerX + c * radius3;
					this.widget.arrows[i].y = centerY + s * radius3;
					this.widget.arrows[i].rotate = (3 + 1) * 90;
					
					if(this.widget.arrows[i].hover)
						this.drawer.drawFillTriangle(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, -this.widget.height / 30, this.widget.arrows[i].color);
					else
						this.drawer.drawFillTriangle(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, this.widget.height / 15, -this.widget.height / 30, this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
					break;
				}
				case "left": {
					let c = (Math.pow(-1, Math.round(2 * 0.5)) * (Math.pow(-1, 2) + 1)) * 0.5;
					let s = (Math.pow(-1, Math.round(2 * 0.5)) * (Math.pow(-1, 2 + 1) + 1)) * 0.5;
					this.widget.arrows[i].x = centerX + c * radius3;
					this.widget.arrows[i].y = centerY + s * radius3;
					this.widget.arrows[i].rotate = (2 + 1) * 90;
					
					if(this.widget.arrows[i].hover)
						this.drawer.drawFillTriangleLateral(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, -this.widget.height / 15, this.widget.height / 15, this.widget.arrows[i].color);
					else
						this.drawer.drawFillTriangleLateral(ctx, this.widget.arrows[i].x, this.widget.arrows[i].y, -this.widget.height / 15, this.widget.height / 15, this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
					break;
				}
			}
		}
	}
	
	drawPress(ctx, centerX, centerY) {
		let radius = Math.min(this.widget.width, this.widget.height) / 2;
		for(let i = 0; i < this.widget.arrows.length; ++i) {
			if(this.widget.arrows[i].pressed) {
				switch(this.widget.arrows[i].type) {
					// UP
					case "right": {
						let angle = (Math.PI / 4) + (Math.PI / 2) * 3;
						let angle2 = (Math.PI / 4) + (Math.PI / 2) * 0;
						this.drawer.arc(ctx, centerX, centerY, radius, angle, angle2, 2,
							this.drawer.getParams("color", "rgba(110, 110, 110, 1)"),
							this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
						break;
					}
					// RIGHT
					case "down": {
						let angle = (Math.PI / 4) + (Math.PI / 2) * 0;
						let angle2 = (Math.PI / 4) + (Math.PI / 2) * 1;
						this.drawer.arc(ctx, centerX, centerY, radius, angle, angle2, 2,
							this.drawer.getParams("color", "rgba(110, 110, 110, 1)"),
							this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
						break;
					}
					// DOWN
					case "left": {
						let angle = (Math.PI / 4) + (Math.PI / 2) * 1;
						let angle2 = (Math.PI / 4) + (Math.PI / 2) * 2;
						this.drawer.arc(ctx, centerX, centerY, radius, angle, angle2, 2,
							this.drawer.getParams("color", "rgb(110, 110, 110, 1)"),
							this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
						break;
					}
					// LEFT
					case "up": {
						let angle = (Math.PI / 4) + (Math.PI / 2) * 2;
						let angle2 = (Math.PI / 4) + (Math.PI / 2) * 3;
						this.drawer.arc(ctx, centerX, centerY, radius, angle, angle2, 2,
							this.drawer.getParams("color", "rgba(110, 110, 110, 1)"),
							this.drawer.getParams("arrowUnhoveredColor", "rgb(37, 165, 154)"));
						break;
					}
				}
			}
		}
	}
	
}

/**
 * WidgetImage
 */

class WidgetImageCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(this.widget.inited) {
			if(state.imageId !== undefined || state.position !== undefined) {
				this.update();
			}
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		let im = Rex.images[this.widget.imageId];
		if(im !== undefined && im.image !== undefined) {
			if(!im.image.complete) {
				im.image.onload = function() {
					this.update();
				}.bind(this);
			}
			this.drawPicture(ctx, ctxTemp, im);
		}
	}
	
	drawPicture(ctx, ctxTemp, image) {
		if(image.image === undefined) return;
		if(this.widget.isIcon) {
			this.drawIcon(ctx, ctxTemp, image.image);
			return;
		}
		switch(this.widget.position) {
			case 0 :
				this.drawStretchToWidget(ctx, ctxTemp, image.image);
				break;
			case 1 :
				this.drawCenteredWidget(ctx, ctxTemp, image.image);
				break;
			case 2 :
				this.drawFillingInWidget(ctx, ctxTemp, image.image);
				break;
			case 3 :
				this.drawToSizeInWidget(ctx, ctxTemp, image.image);
				break;
		}
	}
	
	drawIcon(ctx, ctxTemp, image) {
		let buffer = document.createElement('canvas');
		buffer.ctx = buffer.getContext('2d');
		
		let posX = this.widget.aPosX + this.widget.paddingLeft;
		let posY = this.widget.aPosY + this.widget.paddingTop;
		let width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight;
		let height = this.widget.height - this.widget.paddingTop - this.widget.paddingBottom;
		
		let aspectRatioImage = image.width / image.height;
		if(width >= height) {
			if(image.width <= image.height) {
				let newWidthImage = aspectRatioImage * height;
				let w = newWidthImage;
				let h = height;
				buffer.ctx.canvas.width = w;
				buffer.ctx.canvas.height = h;
				buffer.ctx.drawImage(image, 0, 0, w, h);
				buffer.ctx.globalCompositeOperation = "source-in";
				buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
				buffer.ctx.fillRect(0, 0, w, h);
				ctx.drawImage(buffer, posX + width / 2 - newWidthImage / 2, posY, newWidthImage, height);
			}
			else {
				let newHeightImage = width / aspectRatioImage;
				if(newHeightImage > height) {
					let w = height * aspectRatioImage;
					let h = height;
					buffer.ctx.canvas.width = w;
					buffer.ctx.canvas.height = h;
					buffer.ctx.drawImage(image, 0, 0, w, h);
					buffer.ctx.globalCompositeOperation = "source-in";
					buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
					buffer.ctx.fillRect(0, 0, w, h);
					ctx.drawImage(buffer, posX + width / 2 - (height * aspectRatioImage) / 2, posY, height * aspectRatioImage, height);
				}
				else {
					let w = width;
					let h = newHeightImage;
					buffer.ctx.canvas.width = w;
					buffer.ctx.canvas.height = h;
					buffer.ctx.drawImage(image, 0, 0, w, h);
					buffer.ctx.globalCompositeOperation = "source-in";
					buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
					buffer.ctx.fillRect(0, 0, w, h);
					ctx.drawImage(buffer, posX, posY + height / 2 - newHeightImage / 2, width, newHeightImage);
				}
			}
		}
		else {
			if(image.width >= image.height) {
				let newHeightImage = width / aspectRatioImage;
				let w = width;
				let h = newHeightImage;
				buffer.ctx.canvas.width = w;
				buffer.ctx.canvas.height = h;
				buffer.ctx.drawImage(image, 0, 0, w, h);
				buffer.ctx.globalCompositeOperation = "source-in";
				buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
				buffer.ctx.fillRect(0, 0, w, h);
				ctx.drawImage(buffer, posX, posY + height / 2 - newHeightImage / 2, width, newHeightImage);
			}
			else {
				let newWidthImage = aspectRatioImage * height;
				if(newWidthImage > width) {
					let w = width;
					let h = width / aspectRatioImage;
					buffer.ctx.canvas.width = w;
					buffer.ctx.canvas.height = h;
					buffer.ctx.drawImage(image, 0, 0, w, h);
					buffer.ctx.globalCompositeOperation = "source-in";
					buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
					buffer.ctx.fillRect(0, 0, w, h);
					ctx.drawImage(buffer, posX, posY + height / 2 - (width / aspectRatioImage) / 2, width, width / aspectRatioImage);
				}
				else {
					let w = newWidthImage;
					let h = height;
					buffer.ctx.canvas.width = w;
					buffer.ctx.canvas.height = h;
					buffer.ctx.drawImage(image, 0, 0, w, h);
					buffer.ctx.globalCompositeOperation = "source-in";
					buffer.ctx.fillStyle = this.drawer.getParams("iconColor", "rgb(255, 255, 255)");
					buffer.ctx.fillRect(0, 0, w, h);
					ctx.drawImage(buffer, posX + width / 2 - newWidthImage / 2, posY, newWidthImage, height);
				}
			}
		}
	}
	
	drawStretchToWidget(ctx, ctxTemp, image) {
		ctx.drawImage(image, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
	}
	
	drawCenteredWidget(ctx, ctxTemp, image) {
		let sw = 0;
		let sh = 0;
		let sx = 0;
		let sy = 0;
		let dw = 0;
		let dh = 0;
		let dx = 0;
		let dy = 0;
		if(this.widget.width < image.width) {
			if(this.widget.height < image.height) {
				sx = image.width / 2 - this.widget.width / 2;
				sw = this.widget.width;
				sy = image.height / 2 - this.widget.height / 2;
				sh = this.widget.height;
				dx = this.widget.aPosX;
				dy = this.widget.aPosY;
				dw = this.widget.width;
				dh = this.widget.height;
			}
			else {
				sx = image.width / 2 - this.widget.width / 2;
				sw = this.widget.width;
				sy = 0;
				sh = image.height;
				dx = this.widget.aPosX;
				dy = this.widget.aPosY + this.widget.height / 2 - image.height / 2;
				dw = this.widget.width;
				dh = image.height;
			}
		}
		else {
			if(this.widget.height < image.height) {
				sx = 0;
				sw = image.width;
				sy = image.height / 2 - this.widget.height / 2;
				sh = this.widget.height;
				dx = this.widget.aPosX + this.widget.width / 2 - image.width / 2;
				dy = this.widget.aPosY;
				dw = image.width;
				dh = this.widget.height;
			}
			else {
				sx = 0;
				sw = image.width;
				sy = 0;
				sh = image.height;
				dx = this.widget.aPosX + this.widget.width / 2 - image.width / 2;
				dy = this.widget.aPosY + this.widget.height / 2 - image.height / 2;
				dw = image.width;
				dh = image.height;
			}
		}
		ctx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
	}
	
	drawFillingInWidget(ctx, ctxTemp, image) {
		let sw = 0;
		let sh = 0;
		let sx = 0;
		let sy = 0;
		let aspectRatioWidget = this.widget.width / this.widget.height;
		let aspectRatioImage = image.width / image.height;
		if(this.widget.width > this.widget.height) {
			if(image.width > image.height) {
				let newWidthImage = this.widget.height * aspectRatioImage;
				if(newWidthImage > this.widget.width) {
					sh = image.height;
					sw = image.height * aspectRatioWidget;
					sx = image.width / 2 - sw / 2;
					sy = 0;
				}
				else {
					sh = image.width / aspectRatioWidget;
					sw = image.width;
					sx = 0;
					sy = image.height / 2 - sh / 2;
				}
			}
			else {
				sh = image.width / aspectRatioWidget;
				sw = image.width;
				sx = 0;
				sy = image.height / 2 - sh / 2;
			}
		}
		else {
			if(image.width > image.height) {
				sh = image.height;
				sw = image.height * aspectRatioWidget;
				sx = image.width / 2 - sw / 2;
				sy = 0;
			}
			else {
				let newHeightImage = this.widget.width / aspectRatioImage;
				if(newHeightImage > this.widget.height) {
					sh = image.width / aspectRatioWidget;
					sw = image.width;
					sx = 0;
					sy = image.height / 2 - sh / 2;
				}
				else {
					sh = image.height;
					sw = image.height * aspectRatioWidget;
					sx = image.width / 2 - sw / 2;
					sy = 0;
				}
			}
		}
		ctx.drawImage(image, sx, sy, sw, sh, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
	}
	
	drawToSizeInWidget(ctx, ctxTemp, image) {
		let aspectRatioImage = image.width / image.height;
		if(this.widget.width >= this.widget.height) {
			if(image.width <= image.height) {
				let newWidthImage = aspectRatioImage * this.widget.height;
				ctx.drawImage(image, this.widget.aPosX + this.widget.width / 2 - newWidthImage / 2, this.widget.aPosY, newWidthImage, this.widget.height);
			}
			else {
				let newHeightImage = this.widget.width / aspectRatioImage;
				if(newHeightImage > this.widget.height) {
					ctx.drawImage(image, this.widget.aPosX + this.widget.width / 2 - (this.widget.height * aspectRatioImage) / 2, this.widget.aPosY, this.widget.height * aspectRatioImage, this.widget.height);
				}
				else ctx.drawImage(image, this.widget.aPosX, this.widget.aPosY + this.widget.height / 2 - newHeightImage / 2, this.widget.width, newHeightImage);
			}
		}
		else {
			if(image.width >= image.height) {
				let newHeightImage = this.widget.width / aspectRatioImage;
				ctx.drawImage(image, this.widget.aPosX, this.widget.aPosY + this.widget.height / 2 - newHeightImage / 2, this.widget.width, newHeightImage);
			}
			else {
				let newWidthImage = aspectRatioImage * this.widget.height;
				if(newWidthImage > this.widget.width) {
					ctx.drawImage(image, this.widget.aPosX, this.widget.aPosY + this.widget.height / 2 - (this.widget.width / aspectRatioImage) / 2, this.widget.width, this.widget.width / aspectRatioImage);
				}
				else ctx.drawImage(image, this.widget.aPosX + this.widget.width / 2 - newWidthImage / 2, this.widget.aPosY, newWidthImage, this.widget.height);
			}
		}
	}
	
}

/**
 * WidgetList
 */

class WidgetListCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(!this.widget.inited) return;
		if(state.currentItem !== undefined || state.multiSelect !== undefined || state.selected !== undefined
			|| state.selection !== undefined) this.update();
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.scrollArea.view.draw(ctx, ctxTemp);
		this.drawHoverListItem(ctx, ctxTemp);
	}
	
	drawList(ctx, ctxTemp) {
		this.drawer.background(ctx);
		if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
		
		// Отрисовка скролла и всех чилдов
		if(this.widget.children.length > 0) {
			
			if((this.widget.scrollArea.children.length > 0) && (this.widget.selected)) {
				for(let i = 0; i < this.widget.layout.children.length; ++i) {
					let child = Rex.widgets[this.widget.layout.children[i]];
					if(child === undefined) continue;
					if(this.widget.currentItem == i) {
						ctx.save();
						ctx.fillStyle = this.drawer.getParams("colorCurrentWidget", "rgb(37, 165, 154)");
						ctx.fillRect(child.aPosX, child.aPosY, child.width, child.height);
						ctx.restore();
					}
					if(this.widget.selection !== undefined) {
						if(this.widget.selection.indexOf(i) != -1) {
							ctx.save();
							ctx.fillStyle = this.drawer.getParams("colorSelectionWidget", "rgb(37, 165, 154)");
							ctx.fillRect(child.aPosX, child.aPosY, child.width, child.height);
							ctx.restore();
						}
					}
				}
			}
		}
	}
	
	drawHoverListItem(ctx, ctxTemp) {
		// Отрисовка hovered
		if(this.widget.children.length > 0) {
			if((this.widget.scrollArea.children.length > 0) && (this.widget.selected)) {
				for(let i = 0; i < this.widget.layout.children.length; ++i) {
					let child = Rex.widgets[this.widget.layout.children[i]];
					if(child === undefined) continue;
					if(this.widget.hoveredItem == i) {
						ctxTemp.save();
						ctxTemp.fillStyle = this.drawer.getParams("colorHoveredWidget", "rgba(50, 50, 50,0.5)");
						ctxTemp.fillRect(child.aPosX, child.aPosY, child.width, child.height);
						
						ctxTemp.globalCompositeOperation = 'destination-in';
						ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
						ctx.drawImage(ctxTemp.canvas, 0, 0);
						ctxTemp.restore();
					}
				}
			}
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawList(ctx, ctxTemp);
	}
	
	onPositioning() {
		// scrollArea
		this.widget.scrollArea.posX = this.widget.paddingLeft;
		this.widget.scrollArea.posY = this.widget.paddingTop;
		this.widget.scrollArea.width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight;
		this.widget.scrollArea.height = this.widget.height - this.widget.paddingTop - this.widget.paddingBottom;
		// layout
		this.widget.layout.posX = this.widget.paddingLeft;
		this.widget.layout.posY = this.widget.paddingTop;
		this.widget.layout.width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight;
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = this.widget;
			
			// SCROLL S
			let checkScrollV = this.widget.scrollV.view.checkSelect(x, y);
			if(checkScrollV !== undefined) return checkScrollV;
			let checkScrollH = this.widget.scrollH.view.checkSelect(x, y);
			if(checkScrollH !== undefined) return checkScrollH;
			
			// LAYOUT
			for(let i = 0; i < this.widget.layout.children.length; ++i) {
				let child = Rex.widgets[this.widget.layout.children[i]];
				if(!child.isVisible()) continue;
				let checkChild = child.view.checkSelect(x, y);
				if(checkChild !== undefined) {
					this.widget.hoveredItem = i;
					Rex.gui.redraw();
					if(this.widget.selected) return ret;
					else return checkChild;
				}
			}
			this.widget.hoveredItem = -1;
			this.widget.focusedItem = -1;
		}
		this.widget.focusedItem = -1;
		return ret;
	}
	
	onMouseDown(x, y, event) {
		if(!this.widget.selected) return;
		this.widget.focusedItem = this.widget.hoveredItem;
		if(event.which != 1) return;
		this.widget.setCurrentItem(this.widget.focusedItem);
		this.update();
	}
	
	onMouseWheel(value) {
		if(this.widget.scrollH.isVisible() || this.widget.scrollV.isVisible()) {
			if(this.widget.children.length > 0) {
				let scroll = Rex.widgets[this.widget.children[0]];
				if(scroll === undefined) return;
				scroll.mouseWheel(value);
			}
		}
	}
	
}

/**
 * WidgetToggle
 */
	
class WidgetToggleCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.widthSnag = 35;
		this.heightSnag = 15;
		this.radiusCircle = 10;
	}
	
	setState (state) {
		super.setState(state);
		if(state.checked !== undefined) {
			this.update();
		}
	}
	
	onPositioning() {
		let newX = this.widget.widthCheck + 15;
		let newWidth = this.widget.width - this.widget.widthCheck - 15;
		
		this.widget.icon.posX = newX;
		this.widget.icon.posY = 0;
		this.widget.label.posX = newX;
		this.widget.label.posY = 0;
		
		switch(this.widget.iconAlign) {
			case 0:
				this.widget.icon.width = 0;
				this.widget.icon.height = 0;
				
				this.widget.label.width = newWidth;
				this.widget.label.height = this.widget.height;
				break;
			case 1:
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.posX = newX + this.widget.icon.width + 15;
				this.widget.label.width = newWidth - (this.widget.icon.width + 15);
				this.widget.label.height = this.widget.height;
				break;
			case 2:
				this.widget.icon.width = newWidth;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.width = 0;
				this.widget.label.height = 0;
				break;
			case 3:
				this.widget.icon.posX = newX + newWidth - newWidth / 3;
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;
				
				this.widget.label.width = newWidth - this.widget.icon.width - 15;
				this.widget.label.height = this.widget.height;
				break;
		}
	}
	
	onCheckSelect(x, y) {
		return this.inside(x, y) ? this.widget : undefined;
	}
	
	onDraw(ctx, ctxTemp) {
		if(this.animation.enable) {
			this.toggleAnimation(this.firstBufferCtx, this.secondBufferCtx, this.widget.checked, this.radiusCircle);
			if(this.animation.getCustomSizeRadiusAnimation(this.firstBufferCtx, this.secondBufferCtx, this.widget.widthCheck,
					this.widget.heightCheck) > (this.widget.widthCheck / 4)) this.animation.endAnimation();
		}
		this.drawImage(ctx);
		this.widget.icon.view.draw(ctx, ctxTemp);
		this.widget.label.view.draw(ctx, ctxTemp);
		if((this.radiusCircle < this.widget.widthCheck) && this.animation.enable) {
			ctxTemp.save();
			ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
			ctxTemp.lineWidth = 1;
			ctxTemp.fillStyle = "rgba(75, 75, 75, 0.3)";
			ctxTemp.beginPath();
			if(this.widget.checked)
				ctxTemp.arc(this.widget.aPosX + 2 + this.widget.widthCheck / 2 + this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp,
					this.widget.widthCheck, this.widget.heightCheck),
					this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2 + this.widget.heightCheck / 2,
					this.radiusCircle * 2.5, 0, 2 * Math.PI, false);
			else ctxTemp.arc(this.widget.aPosX + 2 + this.widget.widthCheck / 2 - this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp,
				this.widget.widthCheck, this.widget.heightCheck),
				this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2 + this.widget.heightCheck / 2,
				this.radiusCircle * 2.5, 0, 2 * Math.PI, false);
			ctxTemp.fill();
			ctx.drawImage(ctxTemp.canvas, 0, 0);
			ctxTemp.restore();
		}
	}
	
	drawToggle(ctx, ctxTemp) {
		let y = this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2;
		let x = this.widget.aPosX + 2;
		if(this.widget.checked) {
			this.snag(ctx, x, y, this.widget.widthCheck, this.widget.heightCheck, this.widget.view.widthSnag, this.widget.view.heightSnag,
				this.drawer.getParams("snagCheckedFillStyle", "rgb(100,218,202)"));
			if(!this.animation.enable) {
				this.drawer.circle(ctx, x + this.widget.widthCheck - this.widget.view.radiusCircle, y + this.widget.heightCheck / 2, this.widget.view.radiusCircle, 1,
					this.drawer.getParams("knobCheckedStrokeStyle", "rgb(37, 165, 154)"),
					this.drawer.getParams("knobCheckedFillStyle", "rgb(37, 165, 154)"));
			}
		}
		else {
			this.snag(ctx, x, y, this.widget.widthCheck, this.widget.heightCheck, this.widget.view.widthSnag, this.widget.view.heightSnag,
				this.drawer.getParams("snagUncheckedFillStyle", "rgb(158, 158, 158)"));
			if(!this.widget.view.animation.enable) {
				this.drawer.circle(ctx, x + this.widget.view.radiusCircle, y + this.widget.heightCheck / 2, this.widget.view.radiusCircle, 1,
					this.drawer.getParams("knobUncheckedStrokeStyle", "rgb(158, 158, 158)"),
					this.drawer.getParams("knobUncheckedFillStyle", "rgb(206,206, 206)"));
			}
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawToggle(ctx, ctxTemp);
	}
	
	toggleAnimation(ctx, ctxTemp, direction, radius) {
		let x = this.widget.aPosX + 2;
		let y = this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2;
		let w = this.widget.widthCheck;
		let h = this.widget.heightCheck;
		if(direction) {
			if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
			if(this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck, this.widget.heightCheck) > w) this.animation.getCustomSizeRadiusAnimation = w;
			ctxTemp.save();
			ctxTemp.lineWidth = 1;
			ctxTemp.fillStyle = this.drawer.getParams("knobCheckedAnimationColor", "rgb(37, 165, 154)");
			ctxTemp.beginPath();
			ctxTemp.arc(x + w / 2 + this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck, this.widget.heightCheck), y + h / 2, radius, 0, 2 * Math.PI, false);
			ctxTemp.fill();
			ctx.drawImage(ctxTemp.canvas, 0, 0);
			ctxTemp.restore();
		}
		else {
			if(ctxTemp !== undefined) ctxTemp.clearRect(0, 0, Rex.render.width, Rex.render.height);
			if(this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck, this.widget.heightCheck) > w) this.animation.getCustomSizeRadiusAnimation = w;
			ctxTemp.save();
			ctxTemp.lineWidth = 1;
			ctxTemp.fillStyle = this.drawer.getParams("knobUncheckedAnimationColor", "rgb(206,206, 206)");
			ctxTemp.beginPath();
			ctxTemp.arc(x + w / 2 - this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck, this.widget.heightCheck), y + h / 2, radius, 0, 2 * Math.PI, false);
			ctxTemp.fill();
			ctx.drawImage(ctxTemp.canvas, 0, 0);
			ctxTemp.restore();
		}
	}
	
	snag(ctx, x, y, width, height, widthSnag, heightSnag, color) {
		ctx.save();
		ctx.beginPath();
		ctx.fillStyle = color;
		ctx.arc(x + heightSnag / 2, y + height / 2, heightSnag / 2, Math.PI / 2, -Math.PI / 2);
		ctx.arc(x + width - heightSnag / 2, y + height / 2, heightSnag / 2, -Math.PI / 2, Math.PI / 2);
		//		ctx.moveTo(x + 5, y + height / 2 - heightSnag / 2);
		//		ctx.lineTo(x + widthSnag - 10, y + height / 2 - heightSnag / 2);
		ctx.fill();
		ctx.restore();
	}
	
	startAnimation() {
		this.animation.startAnimation();
	}
	
}


/**
 * WidgetRadioButton
 */

class WidgetRadioButtonCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(state.checked !== undefined) {
			this.update();
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.icon.view.draw(ctx, ctxTemp);
		this.widget.label.view.draw(ctx, ctxTemp);
		if(this.widget.checked) {
			if(this.animation.enable) {
				this.drawer.circleCustomSizeBoundAnimation(ctx, ctxTemp, this.widget.aPosX + 3, this.widget.aPosY +
					this.widget.height / 2 - this.widget.heightCheck / 2, this.widget.widthCheck, this.widget.heightCheck,
					this.drawer.getParams("animationFillColorChecked", "rgba(100,218,202,0.8)"));
				if(this.animation.getCustomSizeRadiusAnimation(ctx, ctxTemp, this.widget.widthCheck,
						this.widget.heightCheck) > (2 * (this.widget.widthCheck + this.widget.heightCheck) / 3)) this.animation.endAnimation();
			}
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawRadioButton(ctx, ctxTemp);
	}
	
	onPositioning() {
		let newX = this.widget.widthCheck + 15;
		let newWidth = this.widget.width - this.widget.widthCheck - 15;

		this.widget.icon.posX = newX;
		this.widget.icon.posY = 0;
		this.widget.label.posX = newX;
		this.widget.label.posY = 0;

		switch(this.widget.iconAlign) {
			case 0:
				this.widget.icon.width = 0;
				this.widget.icon.height = 0;

				this.widget.label.width = newWidth;
				this.widget.label.height = this.widget.height;
				break;
			case 1:
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;

				this.widget.label.posX = newX + this.widget.icon.width + 15;
				this.widget.label.width = newWidth - (this.widget.icon.width + 15);
				this.widget.label.height = this.widget.height;
				break;
			case 2:
				this.widget.icon.width = newWidth;
				this.widget.icon.height = this.widget.height;

				this.widget.label.width = 0;
				this.widget.label.height = 0;
				break;
			case 3:
				this.widget.icon.posX = newX + newWidth - newWidth / 3;
				this.widget.icon.width = newWidth / 3;
				this.widget.icon.height = this.widget.height;

				this.widget.label.width = newWidth - this.widget.icon.width - 15;
				this.widget.label.height = this.widget.height;
				break;
		}
	}
	
	onCheckSelect(x, y) {
		return this.inside(x, y) ? this.widget : undefined;
	}
	
	drawRadioButton(ctx, ctxTemp) {
		let x = this.widget.aPosX;
		let y = this.widget.aPosY + this.widget.height / 2 - this.widget.heightCheck / 2;
		let radiusCircle = this.widget.widthCheck / 2;
		ctx.save();
		if(this.widget.checked) {
			this.drawer.circle(ctx, x + this.widget.widthCheck / 2 + 3, y + this.widget.heightCheck / 2, radiusCircle / 2, 1,
				this.drawer.getParams("colorContourInsideCircle", "rgb(37, 165, 154)"),
				this.drawer.getParams("colorInsideCircle", "rgb(0, 121, 106)"));
			ctx.strokeStyle = this.drawer.getParams("colorContourCheckedCircle", "rgb(37, 165, 154)");
			ctx.beginPath();
			ctx.lineWidth = 2;
			ctx.arc(x + this.widget.widthCheck / 2 + 3, y + this.widget.heightCheck / 2, radiusCircle, 0, 2 * Math.PI, false);
			ctx.stroke();
		}
		else {
			ctx.strokeStyle = this.drawer.getParams("colorContourUnCheckedCircle", "rgb(158, 158, 158)");
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.arc(x + this.widget.widthCheck / 2 + 3, y + this.widget.heightCheck / 2, radiusCircle, 0, 2 * Math.PI, false);
			ctx.stroke();
		}
		ctx.restore();
	}
	
	startAnimation() {
		this.animation.startAnimation();
	}
}


/**
 * WidgetToolBox
 */

class WidgetToolBoxCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawer.background(ctx);
	}
	
	onPositioning() {
		this.widget.widgetScrollArea.posX = 0;
		this.widget.widgetScrollArea.posY = 0;
		this.widget.widgetScrollArea.width = this.widget.width;
		this.widget.widgetScrollArea.height = this.widget.height;
		this.widget.internallayout.posX = this.widget.paddingLeft;
		this.widget.internallayout.posY = this.widget.paddingTop;
		this.widget.internallayout.width = this.widget.width - this.widget.paddingLeft - this.widget.paddingRight;
		this.widget.internallayout.height = this.widget.height - this.widget.paddingTop - this.widget.paddingBottom;
	}
	
}

/**
 * Created by prg-30 on 08.02.2017.
 * WidgetPopUpMenu
 * author : infernalBoy@inbox.ru
 */

class WidgetMenuItemCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.press = false;
	}
	
	setState(state) {
		super.setState(state);
		if(state === undefined) return;
		if(!this.widget.inited) return;
		if(state.iconAlign !== undefined) {
			Rex.gui.reposition(this);
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.isHovered())
			this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 0,
				this.drawer.getParams("hoverColor", "rgba(0, 0, 0, 0.1)"));
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawMenuItem(ctx, ctxTemp);
	}
	
	drawMenuItem(ctx, ctxTemp) {
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("backgroundColor", "rgba(207, 207, 207, 1)");
		ctx.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		ctx.fillStyle = this.drawer.getParams("textColor", "rgba(255, 0, 0, 1)");
		ctx.textBaseline = "middle";
		ctx.font = (this.drawer.getParams("fontSize", 16)) + "px " + (this.drawer.getParams("font", "Roboto"));
		ctx.fillText(this.widget.label.text, this.widget.aPosX + 5, this.widget.aPosY + this.widget.height / 2, this.widget.width);
		ctx.restore();
		if(this.widget.press === true) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("selectedItemColor", "rgba(158,158,158,0.4)");
			ctx.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
			ctx.restore();
		}
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		if(this.isHovered()) {
			this.press = false;
			Rex.callRpcMethod('Widgets', this.id, this.type, 'Pressed', []); //FIXME 
		}
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		this.update();
		this.press = true;
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = this.widget;
		}
		return ret;
	}
	
}

//WidgetInvestmentMenuItem
class WidgetInvestmentMenuItemCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(state === undefined) return;
		if(!this.widget.inited) return;
		if(state.iconAlign !== undefined) {
			Rex.gui.reposition(this.widget);
		}
	}
	
	onPositioning() {
		let menu = Rex.widgets[this.widget.menuId];
		if(menu === undefined) return;
		menu.posX = this.widget.aPosX + this.widget.width - 2;
		menu.posY = this.widget.aPosY;
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		if(this.widget.isHovered() && this.widget.menuId != -1) {
			this.widget.press = false;
			let menu = Rex.widgets[this.widget.menuId];
			if(menu === undefined) return;
			if(menu.visible === true) {
				menu.setVisible(false);
				return;
			}
			let h = menu.children.length * menu.itemHeight;
			let posX = this.widget.aPosX + this.widget.width - 2;
			let posY = this.widget.aPosY;
			if(this.widget.aPosX + this.widget.width * 2 > Rex.render.width) {
				posX = this.widget.aPosX - this.widget.width + 2;
			}
			if(h + this.widget.aPosY > Rex.render.height) {
				posY = this.widget.aPosY - h + menu.itemHeight;
			}
			menu.view.pop(posX, posY);
		}
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.isHovered())
			this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 0,
				this.drawer.getParams("hoverColor", "rgba(0, 0, 0, 0.1)"));
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawMenuItem(ctx, ctxTemp);
	}
	
	drawMenuItem(ctx, ctxTemp) {
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("backgroundColor", "rgba(207, 207, 207, 1)");
		ctx.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		ctx.fillStyle = this.drawer.getParams("textColor", "rgba(255, 0, 0, 1)");
		ctx.textBaseline = "middle";
		ctx.font = (this.drawer.getParams("fontSize", 16)) + "px " + (this.drawer.getParams("font", "Roboto"));
		ctx.fillText(this.widget.label.text, this.widget.aPosX + 5, this.widget.aPosY + this.widget.height / 2, this.widget.width);
		ctx.restore();
		if(this.widget.press === true) {
			ctx.save();
			ctx.fillStyle = this.drawer.getParams("selectedItemColor", "rgba(158,158,158,0.4)");
			ctx.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
			ctx.restore();
		}
		ctx.save();
		this.drawer.drawFillTriangleLateral(ctx, this.widget.aPosX - this.widget.height / 2 + this.widget.width, this.widget.aPosY + this.widget.height / 2, this.widget.height / 3, -this.widget.height / 4,
			this.drawer.getParams("colorArrows", "rgb(158, 158, 158)"));
		ctx.restore();
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = this.widget;
		}
		return ret;
	}
	
}

//WidgetPopUpMenu
class WidgetPopUpMenuCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		if(!this.widget.inited) return;
		if(state.children !== undefined) {
			this.update();
			Rex.gui.reposition(this);
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawPopUpMenu(ctx, ctxTemp);
	}
	
	pop(x, y) {
		this.widget.setPos(x, y);
		this.widget.setVisible(true);
		Rex.gui.updateFocused(this.widget);
	}
	
	onPositioning() {
		
		if(this.widget.children.length == 0) {
			this.widget.posX = -10;
			this.widget.posY = -10;
			this.widget.width = 0;
			this.widget.height = 0;
			return;
		}
		
		if(this.widget.parentMenuId != -1) {
			// В случае отсутствия чилдов - убираем геометрию за экран
			let parentMenu = Rex.widgets[this.widget.parentMenuId];
			if(parentMenu === undefined) return;
		}
		this.widget.width = this.widget.itemWidth;
		if(this.widget.posX + this.widget.width > Rex.render.width) this.widget.posX -= this.widget.width;
		
		let yPos = 0;
		let h = this.widget.children.length * this.widget.itemHeight;
		if(h + this.widget.aPosY > Rex.render.height) this.widget.posY = -h;
		
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			child.posX = 0;
			child.posY = yPos;
			child.width = this.widget.itemWidth;
			child.height = this.widget.itemHeight;
			yPos += this.widget.itemHeight;
		}
		this.widget.height = yPos;
	}
	
	onCheckSelect(x, y) {
		let ret = undefined;
		if(this.inside(x, y)) {
			ret = this.widget;
			for(let key in this.widget.children) {
				let child = Rex.widgets[this.widget.children[key]];
				if(child === undefined) continue;
				if(!child.isVisible()) continue;
				let childRet = child.view.checkSelect(x, y);
				if(childRet !== undefined) {
					this.widget.killMeFlag = false;
					return childRet;
				}
			}
		}
		this.widget.killMeFlag = (ret === undefined);
		return ret;
	}
	
	isKill() {
		return this.widget.killMeFlag;
	}
	
	drawPopUpMenu(ctx, ctxTemp) {
		if(this.widget.children.length === 0) {
			return;
			this.widget.onFocused(false);
			Rex.gui.redraw();
		}
		ctx.save();
		this.drawer.drawStrokeRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 0, 0,
			this.drawer.getParams("borderLineWidth", 1),
			this.drawer.getParams("borderColor", "rgba(158,158,158,0.5)"));
		ctx.restore();
	}
	
}


/**
 * WidgetSpinBox
 */

class WidgetSpinBoxCanvas extends WidgetViewCanvas {
	
	constructor(state) {
		super(state);
		this.anchorPos = new Rex.Vector2();
		this.anchorSize = new Rex.Vector2();
		this.maxWidthArrowsBox = 50;
		this.minWidthArrowsBox = 15;
		this.pressedArrows = 0;
		this.arrowColor = "grey";
	}
	
	setState (state) {
		super.setState(state);
		if(state.value !== undefined && state.value !== this.oldValue) this.update();
	}
	
	onPositioning() {
		this.widget.input.posY = 0;
		this.widget.input.posX = 0;
		this.widget.input.width = this.widget.width - ((this.widget.typeView === "canvas") ? Rex.clamp(Math.min(this.widget.width / 6, this.widget.height / 2), this.minWidthArrowsBox, this.maxWidthArrowsBox) : 0);
		this.widget.input.height = this.widget.height;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		this.widget.input.view.draw(ctx, ctxTemp);
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawSpinBox(ctx, ctxTemp);
	}
	
	drawSpinBox(ctx, ctxTemp) {
		let arrowColor = this.drawer.getParams("arrowColor", "rgb(158, 158, 158)");
		let arrowColorPress = this.drawer.getParams("arrowColorPress", "rgb(110, 110, 110)");
		
		this.drawer.background(ctx);
		
		this.anchorPos = new Rex.Vector2(this.widget.aPosX, this.widget.aPosY);
		this.anchorSize = new Rex.Vector2(this.widget.width, this.widget.height);
		
		let widthArrowsBox = Rex.clamp(Math.min(this.widget.width / 6, this.widget.height / 2), this.minWidthArrowsBox, this.maxWidthArrowsBox);
		
		ctx.save();
		this.drawer.drawRect(ctx, this.widget.aPosX + this.widget.width - widthArrowsBox, this.widget.aPosY, widthArrowsBox, this.widget.height,
			this.drawer.getParams("backgroundRadius", 2),
			this.drawer.getParams("backgroundColor", "rgba(207, 207, 207, 1)"));
		this.drawer.drawStrokeRect(ctx, this.widget.aPosX + this.widget.width - widthArrowsBox, this.widget.aPosY + 2, widthArrowsBox, this.widget.height / 2 - 2, 0, 0,
			this.drawer.getParams("borderLineWidth", 1),
			this.drawer.getParams("borderColor", "rgba(158,158,158,0.3)"));
		this.drawer.drawStrokeRect(ctx, this.widget.aPosX + this.widget.width - widthArrowsBox, this.widget.aPosY + 2 + (this.widget.height / 2 - 2), widthArrowsBox, this.widget.height / 2 - 4, 0, 0,
			this.drawer.getParams("borderLineWidth", 1),
			this.drawer.getParams("borderColor", "rgba(158,158,158,0.3)"));
		
		let offset = this.widget.height / 3;
		let arrow = Math.min(widthArrowsBox / 2, this.widget.height / 2);
		if(this.pressedArrows === 1) {
			this.arrowColor = arrowColorPress;
		}
		else {
			this.arrowColor = arrowColor;
		}
		this.drawer.drawFillTriangle(ctx, this.widget.aPosX + this.widget.width - widthArrowsBox / 2, this.widget.aPosY + offset * 2, arrow / 2, -arrow / 2, this.arrowColor);
		
		if(this.pressedArrows === 2) {
			this.arrowColor = arrowColorPress;
		}
		else {
			this.arrowColor = arrowColor;
		}
		this.drawer.drawFillTriangle(ctx, this.widget.aPosX + this.widget.width - widthArrowsBox / 2, this.widget.aPosY + offset, -arrow / 2, arrow / 2, this.arrowColor);
		ctx.restore();
		this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + this.widget.height, this.widget.aPosX + this.widget.width, this.widget.aPosY + this.widget.height, 2, 1,
			this.drawer.getParams("colorUnderline", "rgb(206,206, 206)"));
	}
	
	onMouseDown(x, y, event) {
		if(event.which !== 1) return;
		let mouse = new Rex.Vector2(x, y);
		let min = new Rex.Vector2((this.anchorPos.x) + (this.anchorSize.x) / 1.5, this.anchorPos.y);
		let max = new Rex.Vector2((this.anchorPos.x) + (this.anchorSize.x), (this.anchorPos.y) + (this.anchorSize.y) / 2);
		let boundBox = new Rex.BoundBox(min, max);
		if(boundBox.inside(mouse, 0)) {
			this.pressedArrows = 2;
			this.widget.setValue(this.widget.value + this.widget.step);
		}
		min = new Rex.Vector2((this.anchorPos.x) + (this.anchorSize.x) / 1.5, (this.anchorPos.y) + (this.anchorSize.y) / 2);
		max = new Rex.Vector2((this.anchorPos.x) + (this.anchorSize.x), (this.anchorPos.y) + (this.anchorSize.y));
		boundBox = new Rex.BoundBox(min, max);
		if(boundBox.inside(mouse, 0)) {
			this.pressedArrows = 1;
			this.update();
			this.widget.setValue(this.widget.value - this.widget.step);
		}
		
	}
	
	onMouseUp(x, y, event) {
		if(event.which !== 1) return;
		this.pressedArrows = 0;
		this.update();
	}
	
	onMouseWheel(value) {
		if(this.widget.input !== Rex.gui.hoveredWidget) return;
		this.widget.setValue(this.widget.value - this.widget.step * value);
		this.update();
	}
	
	
}

class WidgetBaseDialogCanvas extends WidgetWindowCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	onRedraw(ctx, ctxTemp) {
		this.drawDialog(ctx, ctxTemp);
	}
	
	drawDialog(ctx, ctxTemp) {
		if(this.widget.modal) return;
		this.drawer.background(ctx);
		if(this.widget.enableHeader) {
			this.drawer.drawLine(ctx, this.widget.aPosX, this.widget.aPosY + 20, this.widget.aPosX + this.widget.width, this.widget.aPosY + 20, 1, 0,
				this.drawer.getParams("geometricStrokeColor", "rgb(158, 158, 158)"));
			ctx.fillText(this.widget.titleText, this.widget.aPosX + 5, this.widget.aPosY + 16);
		}
	}
	
}

class WidgetDialogCanvas extends WidgetBaseDialogCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
}

class WidgetDialogTextCanvas extends WidgetBaseDialogCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
}

class WidgetDialogInputCanvas extends WidgetBaseDialogCanvas {
	
	constructor(state) {
		super(state);
	}
	
}

/**
 * WidgetSpacer
 */
	
class WidgetSpacerCanvas extends WidgetViewCanvas {

	constructor(state) {
		super(state);
	}

};


/**
 * Created by prg-30 on 15.02.2017.
 */

class ConstructorCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
		this.tempCanvas = document.createElement("canvas");
		this.tempCtx = this.tempCanvas.getContext("2d");
		
	}
	
	setState(state) {
		super.setState(state);
		if(Rex.widgets === undefined) return;
		this.widget.hoveredWidget = (state.hovered != -1) ? Rex.widgets[state.hovered] : undefined;
		this.widget.needUpdate = true;
	}
	
	onPositioning() {
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			child._aposX = child.view.getAPosX();
			child._aposY = child.view.getAPosY();
		}
	}
	
	onCheckSelect(x, y) {
		if(this.inside(x, y)) {
			if(this.widget.isEditable()) {
				return super.onCheckSelect(x, y);
			}
			return this.widget;
		}
		return undefined;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctxTemp);
		this.drawConstructor(ctx, ctxTemp);
	}
	
	onRedraw(ctx, ctxTemp) {
		this.tempCanvas.width = Rex.render.width;
		this.tempCanvas.height = Rex.render.height;
		this.drawer.drawRect(ctxTemp, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height,
			0, this.drawer.getParams("bs", "rgb(50, 50, 50)"));
	}
	
	drawConstructor(ctx, ctxTemp) {
		// Отрисовка чилдов
		for(let i = 0; i < this.widget.children.length; ++i) {
			let child = Rex.widgets[this.widget.children[i]];
			if(child === undefined) continue;
			child.view.draw(ctxTemp, this.tempCtx);
		}
		
		//Отрисовка области выделения
		if(this.widget.selectionArea.selectedArea == 1) {
			ctxTemp.save();
			let x = Math.min(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2);
			let y = Math.min(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2);
			let width = Math.max(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2) - Math.min(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2);
			let height = Math.max(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2) - Math.min(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2);
			
			ctxTemp.strokeStyle = this.drawer.getParams("selectedWidgetsStrokeStyle", "rgb(37, 165, 154)");
			ctxTemp.fillStyle = this.drawer.getParams("selectedWidgetsFillStyle", "rgba(37, 165, 154, 0.5)");
			ctxTemp.fillRect(x, y, width, height);
			ctxTemp.strokeRect(x, y, width, height);
			ctxTemp.restore();
		}
		
		// Отрисовка выделенных виджетов
		if(this.widget.focusedWidgets !== undefined && this.widget.focusedWidgets.length > 0) {
			for(let i = 0; i < this.widget.focusedWidgets.length; i++) {
				let Px = this.widget.focusedWidgets[i].aPosX;
				let Py = this.widget.focusedWidgets[i].aPosY;
				let Pw = this.widget.focusedWidgets[i].width;
				let Ph = this.widget.focusedWidgets[i].height;
				ctxTemp.save();
				ctxTemp.strokeStyle = this.drawer.getParams("selectedLine", "rgb(100,218,202)");
				ctxTemp.strokeRect(Px, Py, Pw, Ph);
				this.drawRpoints(ctxTemp, this.widget.focusedWidgets[i]);
				ctxTemp.restore();
			}
		}
		
		if(this.widget.hoveredWidget !== undefined) {
			let Px = this.widget.hoveredWidget.aPosX;
			let Py = this.widget.hoveredWidget.aPosY;
			let Pw = this.widget.hoveredWidget.width;
			let Ph = this.widget.hoveredWidget.height;
			ctxTemp.save();
			ctxTemp.strokeStyle = this.drawer.getParams("pointsFillStyle", "rgb(206,206, 206)");
			ctxTemp.strokeRect(Px, Py, Pw, Ph);
			ctxTemp.restore();
		}
		if(this.widget.aligment !== undefined) {
			if(this.widget.hoveredWidget !== undefined) {
				if(this.widget.aligment.x !== undefined) {
					let x = this.widget.aligment.x;
					this.drawer.drawLine(ctxTemp, x, this.widget.aPosY, x, this.widget.aPosY + this.widget.height, 1, 0,
						this.drawer.getParams("geometricStrokeColor", "rgb(158, 158, 158)"));
				}
				if(this.widget.aligment.y !== undefined) {
					let y = this.widget.aligment.y;
					this.drawer.drawLine(ctxTemp, this.widget.aPosX, y, this.widget.aPosX + this.widget.width, y, 1, 0,
						this.drawer.getParams("geometricStrokeColor", "rgb(158, 158, 158)"));
				}
			}
		}
		
		ctxTemp.save();
		ctxTemp.globalCompositeOperation = 'destination-in';
		ctxTemp.fillRect(this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height);
		ctx.drawImage(ctxTemp.canvas, 0, 0);
		ctxTemp.restore();
	}
	
	drawRpoints(ctx, widget) {
		let wgt = widget;
		if(widget === undefined) return;
		let pw = 8;
		let hpw = pw * 0.5;
		let dpw = pw * 2;
		let px = wgt.aPosX;
		let py = wgt.aPosY;
		let w = wgt.width;
		let h = wgt.height;
		ctx.save();
		let c = -1;
		//          XY  X                     XH           Y                     H                     WY           W                     WH
		let PtsX = [px, px, px, px + (w * 0.5) - hpw, px + (w * 0.5) - hpw, px + w - pw, px + w - pw, px + w - pw];
		let PtsY = [py, py + (h * 0.5) - hpw, py + h - pw, py, py + h - pw, py, py + (h * 0.5) - hpw, py + h - pw];
		for(let i = 0; i < PtsX.length; ++i) {
			if(this.widget.mouse.posX > PtsX[i] && this.widget.mouse.posX < PtsX[i] + pw && this.widget.mouse.posY > PtsY[i] && this.widget.mouse.posY < PtsY[i] + pw) {
				ctx.fillStyle = this.drawer.getParams("pointsFillStyle", "rgba(37, 165, 154, 0.5)");
				c = i;
			} else {
				ctx.fillStyle = this.drawer.getParams("pointsFillStyle", "rgb(100,218,202)");
			}
			ctx.fillRect(PtsX[i], PtsY[i], pw, pw);
		}
		if(c > -1) document.body.style.cursor = document.body.style.cursor = this.widget.cursorType[c];
		else document.body.style.cursor = document.body.style.cursor = this.widget.cursorType[8];
		ctx.restore();
	}
	
	getImageData() {
		let VC = document.createElement("canvas");
		VC.width = this.widget.width;
		VC.height = this.widget.height;
		let VCTX = VC.getContext("2d");
		let RVC = document.createElement("canvas");
		RVC.width = this.widget.width;
		RVC.height = this.widget.height;
		let TVCTX = RVC.getContext("2d");
		VCTX.translate(-this.widget.posX, -this.widget.posY);
		TVCTX.translate(-this.widget.posX, -this.widget.posY);
		
		let draw = function(w) {
			VCTX.drawImage(w.firstBuffer, w.widget.posX, w.widget.posY);
			for(let key in w.widget.children) {
				let c = Rex.widgets[w.widget.children[key]];
				if(!c) continue;
				if(c.widget.type == "WidgetLine") {
					c.widget.view.draw(VCTX, TVCTX);
				} else draw(c);
			}
		};
		draw(this);
		//this.draw(VCTX, TVCTX);
		VCTX.translate(0, 0);
		TVCTX.translate(0, 0);
		//this.posX = oldX;
		//this.posY = oldY;
		//this.width = oldW;
		//this.height = oldH;
		return VC.toDataURL("image/png");
	}
	
}

/**
 * Created by ALLekSSSanDR on 26.12.2017.
 */

/**
 * WidgetCalendarCanvas
 */
class WidgetCalendarCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		
		if(state.day !== undefined || state.month !== undefined || state.year || state.holidays !== undefined) {
			this.widget.viewMonth = this.widget.month;
			this.widget.viewYear = this.widget.year;
			
			this.update();
		}
		
	}
	
	onPositioning() {
		this.widget.cellSizeW = Math.round((this.widget.width - this.widget.paddingCalendar * 2) / 7);
		this.widget.cellSizeH = Math.round((this.widget.height / 2) / 6);
		
		this.widget.sizeHeaderW = -1;
		this.widget.sizeHeaderH = this.widget.height / 5.1;
	}
	
	onCheckSelect(x, y) {
		this.widget.hoverIndex = -1;
		if(this.inside(x, y)) {
			if(this.widget.chooseYear) {
				
			} else {
				if(this.widget.comeInRect(x, y,
						(this.widget.aPosX + this.widget.paddingCalendar),
						(this.widget.aPosY + this.widget.sizeHeaderH + this.widget.cellSizeH * 2),
						(this.widget.width - this.widget.paddingCalendar * 2),
						(this.widget.cellSizeH * 7))) {
					for(let i = 0; i < this.widget.positions.length; ++i) {
						if(this.widget.comeInBox(x, y, this.widget.positions[i][0], this.widget.positions[i][1], Math.min(this.widget.cellSizeH, this.widget.cellSizeH) / 2)) {
							this.widget.hoverIndex = (i + 1);
							this.update();
							return this.widget;
						}
					}
					this.widget.hoverIndex = -1;
					return this.widget;
				}
			}
			return this.widget;
		}
		return undefined;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		// TODO animation ???
		
		if(!this.widget.chooseYear && this.widget.hoverIndex > 0) {
			this.drawer.circle(ctx,
				this.widget.positions[this.widget.hoverIndex - 1][0],
				this.widget.positions[this.widget.hoverIndex - 1][1] - this.widget.baseFontSize / 2,
				Math.min(this.widget.cellSizeH, this.widget.cellSizeH) / 2,
				0,
				this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"),
				this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"));
			
			this.drawCalendarTextCenter(ctx, (this.widget.positions[this.widget.hoverIndex - 1][0]), (this.widget.positions[this.widget.hoverIndex - 1][1]), this.widget.hoverIndex,
				this.drawer.getParams("fontSize", 14),
				this.drawer.getParams("font", "Roboto"),
				this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)"),
				""
			);
			
		}
	}
	
	onRedraw(ctx, ctxTemp) {
		// Фон
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 2, this.drawer.getParams("background", "rgb(255,255,255)"));
		
		// Хидер
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height / 5, 0, this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
		
		this.drawPanel(ctx, ctxTemp);				// Заголовочная панель
		
		if(this.widget.chooseYear) {
			this.drawYears(ctx, ctxTemp);
		} else {
			this.drawMonthSwitch(ctx, ctxTemp);		// Слайдер месяцев
			this.drawDaysOfTheWeek(ctx, ctxTemp);	// Строка с днями недели
			this.drawCalendarGrid(ctx, ctxTemp);	// Числа месяца
			// Выбранный элемент
			if(this.widget.month == this.widget.viewMonth && this.widget.year == this.widget.viewYear) {
				
				this.drawer.circle(ctx,
					this.widget.positions[this.widget.day - 1][0],
					this.widget.positions[this.widget.day - 1][1] - this.widget.baseFontSize / 2,
					Math.min(this.widget.cellSizeH, this.widget.cellSizeH) / 2,
					2,
					this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"),
					this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
				
				this.drawCalendarTextCenter(ctx, (this.widget.positions[this.widget.day - 1][0]), (this.widget.positions[this.widget.day - 1][1]), this.widget.day,
					this.drawer.getParams("fontSize", 14),
					this.drawer.getParams("font", "Roboto"),
					this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)"),
					""
				);
			}
		}
	}
	
	drawPanel(ctx, ctxTemp) {
		//Текст заголовка
		ctx.save();
		
		// ГОД
		if(this.widget.chooseYear) ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else ctx.fillStyle = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		ctx.font = this.widget.baseFontSize + "px " + this.drawer.getParams("font", "Roboto");
		ctx.fillText(this.widget.year, this.widget.aPosX + this.widget.paddingCalendar, this.widget.aPosY + 10 + this.widget.baseFontSize);
		
		// ДАТА
		if(!this.widget.chooseYear) ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else ctx.fillStyle = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		ctx.font = this.widget.bigFontSize + "px " + this.drawer.getParams("font", "Roboto");
		ctx.fillText(this.widget.dayCode[this.widget.getDayOfTheWeek()] + "," + " " +	// День недели
			this.widget.monthCode[this.widget.month - 1] + " " +						// Месяц
			(this.widget.day),															// Число
			this.widget.aPosX + this.widget.paddingCalendar,
			this.widget.aPosY + 20 + this.widget.baseFontSize + this.widget.bigFontSize);
		
		ctx.restore();
	}
	
	drawMonthSwitch(ctx, ctxTemp) {
		// Левая стрелочка
		this.drawCalendarArrowLeft(
			ctx,
			this.widget.aPosX + this.widget.paddingCalendar,
			this.widget.aPosY + this.widget.sizeHeaderH + (this.widget.cellSizeH / 2) + this.widget.baseFontSize / 2,
			8, 		//Height
			2);		//Thickness
		
		// Правая стрелочка
		this.drawCalendarArrowRight(
			ctx,
			this.widget.aPosX + this.widget.width - this.widget.paddingCalendar,
			this.widget.aPosY + this.widget.sizeHeaderH + (this.widget.cellSizeH / 2) + this.widget.baseFontSize / 2,
			8,
			2);
		
		this.drawCalendarTextCenter(
			ctx,
			(this.widget.aPosX + this.widget.width / 2),
			(this.widget.aPosY + this.widget.sizeHeaderH + (this.widget.cellSizeH / 2) + this.widget.baseFontSize),
			this.widget.monthCode[this.widget.viewMonth - 1] + " " + this.widget.viewYear,
			this.widget.baseFontSize,
			this.drawer.getParams("font", "Roboto"),
			this.drawer.getParams("textColorPrimary", "rgb(0, 0, 0)"),
			""
		);
		
	}
	
	drawDaysOfTheWeek(ctx, ctxTemp) {
		ctx.save();
		ctx.fillStyle = this.drawer.getParams("colorDaysOfTheWeek", "rgb(158, 158, 158)");
		ctx.font = this.drawer.getParams("fontSize", 14) + "px " + this.drawer.getParams("font", "Roboto");
		for(let i = 0; i < this.widget.dayCode.length; ++i) {
			this.drawCalendarTextCenter(
				ctx,
				(this.widget.aPosX + this.widget.paddingCalendar + (this.widget.cellSizeW * i) + (this.widget.cellSizeW / 2)),
				(this.widget.aPosY + this.widget.sizeHeaderH + this.widget.cellSizeH * 2),
				this.widget.dayCode[i],
				this.drawer.getParams("fontSize", 14),
				this.drawer.getParams("font", "Roboto"),
				this.drawer.getParams("colorDaysOfTheWeek", "rgb(158, 158, 158)"),
				""
			);
		}
		ctx.restore();
		
	}
	
	drawCalendarGrid(ctx, ctxTemp) {
		this.widget.positions = [];
		
		let countDays = this.widget.getCountDay(this.widget.viewMonth, this.widget.viewYear);
		let weekDay = this.widget.getDayOfTheWeek(1, this.widget.viewMonth, this.widget.viewYear);
		
		let indexDay = 0;
		
		for(let i = 0; i < 6; ++i) {
			let j = 0;
			if(i == 0) j = weekDay - 1;
			for(j; j < 7; ++j) {
				if(indexDay > countDays) continue;
				if(indexDay != 0) {
					
					let pX = (this.widget.aPosX + this.widget.paddingCalendar + this.widget.cellSizeW * j + (this.widget.cellSizeW / 2));
					let pY = (this.widget.aPosY + this.widget.sizeHeaderH + this.widget.cellSizeH * 3 + this.widget.cellSizeH * (i));
					
					this.widget.positions.push([pX, pY]);
					
					if(indexDay == this.widget.todayDay && this.widget.todayMonth == this.widget.viewMonth && this.widget.todayYear == this.widget.viewYear) {
						this.drawCalendarTextCenter(ctx, (pX), (pY), indexDay,
							this.drawer.getParams("fontSize", 14),
							this.drawer.getParams("font", "Roboto"),
							this.drawer.getParams("backgroundSecondary", "rgb(0, 150, 136)"),
							""
						);
					} else if(j == 0) {
						this.drawCalendarTextCenter(ctx, (pX), (pY), indexDay,
							this.drawer.getParams("fontSize", 14),
							this.drawer.getParams("font", "Roboto"),
							this.drawer.getParams("textRed", "rgb(200, 0, 0)"),
							""
						);
					} else if(this.widget.isHolidays(indexDay, this.widget.viewMonth, this.widget.viewYear)) {
						this.drawCalendarTextCenter(ctx, (pX), (pY), indexDay,
							this.drawer.getParams("fontSize", 14),
							this.drawer.getParams("font", "Roboto"),
							this.drawer.getParams("textRed", "rgb(200, 0, 0)"),
							""
						);
					} else {
						this.drawCalendarTextCenter(ctx, (pX), (pY), indexDay,
							this.drawer.getParams("fontSize", 14),
							this.drawer.getParams("font", "Roboto"),
							this.drawer.getParams("textColorPrimary", "rgb(0, 0, 0)"),
							""
						);
					}
				}
				++indexDay;
			}
		}
	}
	
	drawCalendarArrowLeft(ctx, x, y, height, thickness) {
		ctx.save();
		
		ctx.fillStyle = this.drawer.getParams("arrowsColor", "rgb(117, 117, 117)");
		ctx.beginPath();
		ctx.moveTo(x + Math.sin(45) * height, y - Math.sin(45) * height);
		ctx.lineTo(x, y);
		ctx.lineTo(x + Math.sin(45) * height, y + Math.sin(45) * height);
		ctx.lineTo((x + Math.sin(45) * height) + Math.sin(45) * thickness, y + Math.sin(45) * height - Math.sin(45) * thickness);
		ctx.lineTo(x + thickness + (Math.sin(45) * thickness) / 2, y);
		ctx.lineTo((x + Math.sin(45) * height) + Math.sin(45) * thickness, y - (Math.sin(45) * height) + Math.sin(45) * thickness);
		ctx.fill();
		
		ctx.restore();
		
	}
	
	drawCalendarArrowRight(ctx, x, y, height, thickness) {
		ctx.save();
		
		ctx.fillStyle = this.drawer.getParams("arrowsColor", "rgb(117, 117, 117)");
		ctx.beginPath();
		ctx.moveTo(x - Math.sin(45) * height, y - Math.sin(45) * height);
		ctx.lineTo(x, y);
		ctx.lineTo(x - Math.sin(45) * height, y + Math.sin(45) * height);
		ctx.lineTo((x - Math.sin(45) * height) - Math.sin(45) * thickness, y + Math.sin(45) * height - Math.sin(45) * thickness);
		ctx.lineTo(x - thickness - (Math.sin(45) * thickness) / 2, y);
		ctx.lineTo((x - Math.sin(45) * height) - Math.sin(45) * thickness, y - (Math.sin(45) * height) + Math.sin(45) * thickness);
		ctx.fill();
		
		ctx.restore();
		
	}
	
	drawCalendarTextCenter(ctx, x, y, text, fontSize, font, color, fontStyle) {
		ctx.save();
		ctx.imageSmoothingEnabled = true;
		ctx.font = (fontStyle ? fontStyle : "") + fontSize + "px " + font;
		ctx.textBaseline = "bottom";
		if(color !== undefined) ctx.fillStyle = color;
		let w = ctx.measureText(text).width;
		ctx.fillText(text, x - w / 2, y);
		ctx.restore();
	}
	
	drawYears(ctx, ctxTemp) {
		this.widget.years = [];
		
		for(let i = 0; i < 7; ++i) {
			
			let pX = (this.widget.aPosX + this.widget.width / 2);
			let pY = (this.widget.aPosY + this.widget.sizeHeaderH + this.widget.cellSizeH * (i + 1));
			let val = this.widget.chooseYearData - 3 + i;
			
			if(this.widget.year == val) {
				this.widget.years.push([pX, pY, val]);
				this.drawCalendarTextCenter(ctx, (pX), (pY), val,
					this.drawer.getParams("fontBig", 30),
					this.drawer.getParams("font", "Roboto"),
					this.drawer.getParams("backgroundSecondary", "rgb(0, 150, 136)"),
					""
				);
			} else {
				this.widget.years.push([pX, pY, val]);
				this.drawCalendarTextCenter(ctx, (pX), (pY), val,
					this.drawer.getParams("fontSize", 14),
					this.drawer.getParams("font", "Roboto"),
					this.drawer.getParams("textColorPrimary", "rgb(0, 0, 0)"),
					""
				);
			}
		}
	}
	
}

/**
 * Created by ALLekSSSanDR on 06.01.2018.
 */


/**
 * WidgetTimeCanvas
 */
class WidgetTimeCanvas extends WidgetViewCanvas {
	
	constructor(widget) {
		super(widget);
	}
	
	setState(state) {
		super.setState(state);
		
		if(state.hours !== undefined || state.minutes !== undefined) {
			if(state.hours > 12) this.widget.enablePM = true;
			if(state.hours < 13) this.widget.enablePM = false;
			this.update();
		}
	}
	
	onPositioning() {
		this.widget.cellSizeW = Math.round((this.widget.width - this.widget.paddingCalendar * 2) / 7);
		this.widget.cellSizeH = Math.round((this.widget.height / 2) / 6);
		
		this.widget.sizeHeaderW = -1;
		this.widget.sizeHeaderH = this.widget.height / 5.1;
		
		this.widget.hoursPositions = [];
		this.widget.minutesPositions = [];
		// Координаты отрисовки часов
		for(let i = 0; i < 12; ++i) {
			this.widget.hoursPositions.push([this.widget.aPosX + this.widget.width / 2 + (Math.cos((i * 30 - 60) * (Math.PI / 180)) * Math.min(this.widget.width, this.widget.height * 0.75) * 0.40) ,
				this.widget.aPosY + this.widget.height / 2 + (this.widget.height / 20) + (Math.sin((i * 30 - 60) * (Math.PI / 180)) * Math.min(this.widget.width, this.widget.height * 0.75) * 0.40)]);
			
		}
		// Координаты отрисовки минут
		for(let i = 0; i < 60; ++i) {
			this.widget.minutesPositions.push([this.widget.posX + this.widget.width / 2 + (Math.cos((i * 6 - 84) * (Math.PI / 180)) * Math.min(this.widget.width, this.widget.height * 0.75) * 0.40) ,
				this.widget.posY + this.widget.height / 2 + (this.widget.height / 20) + (Math.sin((i * 6 - 84) * (Math.PI / 180)) * Math.min(this.widget.width, this.widget.height * 0.75) * 0.40)]);
		}
		
	}
	
	onCheckSelect(x, y) {
		this.widget.hoverIndex = -1;
		
		if(this.inside(x, y)) {
			
			if(this.widget.chooseHours) {
				for(let i = 0; i < 12; ++i) {
					if(this.widget.comeInBox(x ,y ,
							this.widget.hoursPositions[i][0],
							this.widget.hoursPositions[i][1],
							this.widget.baseFontSize
						)) {
						this.widget.hoverIndex = i;
						Rex.gui.redraw();
						return this.widget;
					}
				}
			} else {
				for(let i = 0; i < 60; ++i) {
					if(this.widget.comeInBox(x ,y ,
							this.widget.minutesPositions[i][0],
							this.widget.minutesPositions[i][1],
							this.widget.baseFontSize / 2
						)) {
						this.widget.hoverIndex = i;
						Rex.gui.redraw();
						return this.widget;
					}
				}
			}
			this.widget.hoverIndex = -1;
			return this.widget;
		}
		return undefined;
	}
	
	onDraw(ctx, ctxTemp) {
		this.drawImage(ctx);
		if(this.widget.hoverIndex >= 0) {
			
			if(this.widget.chooseHours) {
				if(!this.widget.enablePM && ((this.widget.hoverIndex + 1) == this.widget.hours)) return;
				if(this.widget.enablePM && ((this.widget.hoverIndex + 1) == (this.widget.hours - 12))) return;
				this.drawer.circle(ctx,
					this.widget.hoursPositions[this.widget.hoverIndex][0],
					this.widget.hoursPositions[this.widget.hoverIndex][1],
					this.widget.baseFontSize,
					0,
					this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"),
					this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"));
			} else {
				if(this.widget.hoverIndex + 1 == this.widget.minutes) return;
				if((this.widget.hoverIndex + 1) % 5 == 0) {
					this.drawer.circle(ctx,
						this.widget.minutesPositions[this.widget.hoverIndex][0],
						this.widget.minutesPositions[this.widget.hoverIndex][1],
						this.widget.baseFontSize,
						0,
						this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"),
						this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"));
				} else {
					this.drawer.circle(ctx,
						this.widget.minutesPositions[this.widget.hoverIndex][0],
						this.widget.minutesPositions[this.widget.hoverIndex][1],
						this.widget.baseFontSize / 2,
						0,
						this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"),
						this.drawer.getParams("hoverColor", "rgba(0,150,136, 0.5)"));
					
					ctx.font = "bold " + this.widget.baseFontSize * 0.8 + "px " + this.drawer.getParams("font", "Roboto");
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
					ctx.fillText(this.widget.hoverIndex + 1, this.widget.minutesPositions[this.widget.hoverIndex][0], this.widget.minutesPositions[this.widget.hoverIndex][1]);
				}
			}
		}
		
	}
	
	onRedraw(ctx, ctxTemp) {
		// Фон
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height, 2, this.drawer.getParams("background", "rgb(255,255,255)"));
		
		// Хидер
		this.drawer.drawRect(ctx, this.widget.aPosX, this.widget.aPosY, this.widget.width, this.widget.height / 5, 0, this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
		
		// Фон циферблата
		this.drawer.circle(ctx,
			this.widget.aPosX + this.widget.width / 2,
			this.widget.aPosY + this.widget.height / 2 + (this.widget.height / 20),
			Math.min(this.widget.width * 0.45, this.widget.height * 0.7 * 0.45),
			0,
			this.drawer.getParams("backgroundCircle", "rgba(238,238,238, 1)"),
				this.drawer.getParams("backgroundCircle", "rgba(238,238,238, 1)"));
		
		// Центр циферблата
		this.drawer.circle(ctx,
			this.widget.aPosX + this.widget.width / 2,
			this.widget.aPosY + this.widget.height / 2 + (this.widget.height / 20),
			this.widget.baseFontSize / 4,
			0,
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"),
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
		
		this.drawPanel(ctx, ctxTemp);				// Заголовочная панель
		this.drawDigits(ctx, ctxTemp);				// Циферблат
		
		if(this.widget.chooseHours) this.drawArrowHours(ctx, ctxTemp);
		else  this.drawArrowMinutes(ctx, ctxTemp);
		
	}
	
	drawPanel(ctx, ctxTemp) {
		let colorDraw = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		// ЧАСЫ
		if(this.widget.chooseHours) colorDraw = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else colorDraw = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		this.drawer.drawTextRight(ctx,
			this.widget.aPosX + this.widget.width / 2,
			this.widget.aPosY + this.widget.paddingPicker,
			(this.widget.hours < 10) ? "0" + this.widget.hours + " " : this.widget.hours + " ",
			this.widget.bigFontSize,
			this.drawer.getParams("font", "Roboto"),
			colorDraw,
			""
		);
		
		// Двоеточие
		this.drawer.drawTextCenter(ctx,
			this.widget.aPosX + this.widget.width / 2,
			this.widget.aPosY + this.widget.paddingPicker,
			":",
			this.widget.bigFontSize,
			this.drawer.getParams("font", "Roboto"),
			this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)"),
			""
		);
		
		
		// МИНУТЫ
		if(!this.widget.chooseHours) colorDraw = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else colorDraw = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		this.drawer.drawTextLeft(ctx,
			this.widget.aPosX + this.widget.width / 2,
			this.widget.aPosY + this.widget.paddingPicker,
			(this.widget.minutes < 10) ? " 0" + this.widget.minutes : " " + this.widget.minutes,
			this.widget.bigFontSize,
			this.drawer.getParams("font", "Roboto"),
			colorDraw,
			""
		);
		
		// AM
		if(this.widget.chooseHours && !this.widget.enablePM) ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else ctx.fillStyle = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		ctx.font = this.widget.baseFontSize + "px " + this.drawer.getParams("font", "Roboto");
		ctx.fillText("AM",
			this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5,
			this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 4);
		
		// PM
		if(this.widget.chooseHours && this.widget.enablePM) ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		else ctx.fillStyle = this.drawer.getParams("textColorSecondaryAlpha", "rgba(255, 255, 255, 0.7)");
		
		ctx.font = this.widget.baseFontSize + "px " + this.drawer.getParams("font", "Roboto");
		ctx.fillText("PM",
			this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5,
			this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 2);
		
		// ПОДЧЕРКИВАНИЯ
		ctx.strokeStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		if(this.widget.chooseHours) {
			ctx.lineWidth = 3;
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(this.widget.aPosX + this.widget.width / 2  - this.widget.bigFontSize / 3,
				this.widget.aPosY + this.widget.paddingPicker + this.widget.bigFontSize * 1.1);
			ctx.lineTo( this.widget.aPosX + this.widget.width / 2 - this.widget.bigFontSize * 1.2,
				this.widget.aPosY + this.widget.paddingPicker + this.widget.bigFontSize * 1.1);
			ctx.stroke();
			ctx.restore();
			
			if(this.widget.enablePM) {
				ctx.lineWidth = 2;
				ctx.save();
				ctx.beginPath();
				ctx.moveTo(	this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5,
					this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 2 + this.widget.baseFontSize * 0.2);
				ctx.lineTo(	this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5 + this.widget.baseFontSize * 1.5,
					this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 2 + this.widget.baseFontSize * 0.2);
				ctx.stroke();
				ctx.restore();
			} else {
				ctx.lineWidth = 2;
				ctx.save();
				ctx.beginPath();
				ctx.moveTo(this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5,
					this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 4 + this.widget.baseFontSize * 0.2);
				ctx.lineTo(this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.5 + this.widget.baseFontSize * 1.5,
					this.widget.aPosY + this.widget.paddingPicker + this.widget.sizeHeaderH / 4 + this.widget.baseFontSize * 0.2);
				ctx.stroke();
				ctx.restore();
			}
			
		} else {
			ctx.lineWidth = 3;
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize / 3,
				this.widget.aPosY + this.widget.paddingPicker + this.widget.bigFontSize * 1.1);
			ctx.lineTo(this.widget.aPosX + this.widget.width / 2 + this.widget.bigFontSize * 1.3,
				this.widget.aPosY + this.widget.paddingPicker + this.widget.bigFontSize * 1.1);
			ctx.stroke();
			ctx.restore();
		}
		
	}
	
	drawDigits(ctx, ctxTemp) {
		
		for(let i = 0; i < 12; ++i) {
			
			ctx.fillStyle = this.drawer.getParams("textColorPrimary", "rgb(0, 0, 0)");
			ctx.font = "bold " + this.widget.baseFontSize + "px " + this.drawer.getParams("font", "Roboto");
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			
			let value = 0;
			if(this.widget.chooseHours) {
				if(this.widget.enablePM) {
					value = i + 1 + 12;
					if(value == 24) value = "00";
				} else {
					value = i + 1;
				}
				
			} else {
				value = (i + 1) * 5;
				if(value == 60) value = "00";
			}
			
			ctx.fillText(value,
				this.widget.hoursPositions[i][0],
				this.widget.hoursPositions[i][1])
		}
	}
	
	drawArrowHours(ctx, ctxTemp) {
		if(this.widget.enablePM && this.widget.hours < 13 && this.widget.hours != 0) return;
		if(!this.widget.enablePM && this.widget.hours > 12) return;
		
		let index = (this.widget.hours > 12) ? this.widget.hours - 13 : this.widget.hours - 1;
		if(index < 0) index = 11;
		
		let xPos = this.widget.hoursPositions[index][0];
		let yPos = this.widget.hoursPositions[index][1];
		
		ctx.strokeStyle = this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)");
		ctx.lineWidth = 3;
		ctx.save();
		ctx.beginPath();
		
		// Смещение в центр
		ctx.moveTo(	this.widget.aPosX + this.widget.width / 2, this.widget.aPosY + this.widget.height / 2 + (this.widget.height / 20));
		
		// Линия к позиции числа
		ctx.lineTo( xPos, yPos);
		ctx.stroke();
		ctx.restore();
		
		// Окружность выбранного числа
		this.drawer.circle(ctx,
			xPos,
			yPos,
			this.widget.baseFontSize,
			0,
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"),
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
		
		// Текст числа
		let drawValue = this.widget.hours;
		if(drawValue == 0) drawValue = "00";
		ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		ctx.fillText(drawValue, xPos, yPos);
	}
	
	drawArrowMinutes(ctx, ctxTemp) {
		let index = this.widget.minutes - 1;
		if(index < 0) index = 59;
		
		let xPos = this.widget.minutesPositions[index][0];
		let yPos = this.widget.minutesPositions[index][1];
		
		ctx.strokeStyle = this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)");
		ctx.lineWidth = 3;
		ctx.save();
		ctx.beginPath();
		// Смещение в центр
		ctx.moveTo(	this.widget.aPosX + this.widget.width / 2,
					this.widget.aPosY + this.widget.height / 2 + (this.widget.height / 20));
		
		// Линия к позиции числа
		ctx.lineTo( xPos, yPos);
		
		ctx.stroke();
		ctx.restore();
		
		// Окружность выбранного числа
		this.drawer.circle(ctx,
			 xPos,
			 yPos,
			this.widget.baseFontSize,
			0,
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"),
			this.drawer.getParams("backgroundSecondary", "rgb(0,150,136)"));
		
		// Текст числа
		let drawValue = this.widget.minutes;
		if(drawValue == 0) drawValue = "00";
		ctx.fillStyle = this.drawer.getParams("textColorSecondary", "rgb(255, 255, 255)");
		ctx.fillText(drawValue, xPos, yPos);
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml WidgetView AttributeManager Rex*/

class WidgetViewHtml extends WidgetView {
	
	constructor(widget) {
		super(widget);
		this.container = "container1";
		this.htmlElement = undefined;
		this.attributeManager = new AttributeManager(this);
		this.hover = false;
		this._$oldParentID = undefined;
		this.setpositionabsoluteautomatic = null;
	}
	
	createDomElement(element) {
		this.htmlElement = document.createElement(element);
		this.htmlElement.id = "w" + this.widget.id;
		this.htmlElement.style.visibility = "hidden";
		this.htmlElement.ondragover = (e) => e.preventDefault();
		
	}

	onDrop (e,cPos) {
		return {};
	}

	init() {
		if(this.widget.parentId != -1) this.setParent(this.widget.parentId);
		
		// Когда я родитель - проверить все ли чилды знают о нем
		// (сделано для того случая, когда родитель прилетает позже инициаизации чилда)
		for(let id of this.children) {
			let c = Rex.widgets[id];
			if(c == null) continue;
			c.view.setParent(this.widget.id);
		}
		
		this.horizontalSizePolicy = this.horizontalSizePolicy;
		this.verticalSizePolicy = this.verticalSizePolicy;
		
		this.posX = this.posX;
		this.posY = this.posY;
		
		Rex.gui.redraw();
		this.onInit();
		if(this.widget.visible) this.htmlElement.style.visibility = null;
		if(this.checkPosition()){
			if(this.widget.horizontalAlignType == 0) this.htmlElement.style.left = this.posX + "px";
			if(this.widget.verticalAlignType == 0) this.htmlElement.style.top = this.posY + "px";
		}
		this.customStyle = this.customStyle;
		// Rex.callRpcMethod("Widgets", this.widget.id, "Widget", "onViewInit", []);
	}

	checkPosition() {
		if(Rex.widgets == undefined) return false;
		if (this.widget.parentId == -1 || (Rex.widgets[this.widget.parentId] && Rex.widgets[this.widget.parentId].needSavePos)) {
			return true;
		}
		return false; 
	}

	contains(node) {
		return this.htmlElement === node.parentNode;
	}
	
	appendChild(child) {
		if(!this.contains(child)) this.htmlElement.appendChild(child);
	}
	
	cloneNode(withChild) {
		return this.htmlElement.cloneNode(withChild);
	}
	
	removeChild(child) {
		if(this.contains(child)) return this.htmlElement.removeChild(child);
	}
	
	setParent(id) {
		//FIXME причесать.
		//В идеальной ситуации метод должен отработать только
		//у виджета у которого нет родителя или если родителя сменили.
		//В остальных случаях должен отработать метод appendChild.
		
		// Если к нам приходит тот же родитель. То ничего не делаем.
		//if(this.widget.parentId == id) return;
		let containerElement = document.getElementById(this.container);
		
		//если родителя нет, значит он в сцене. надо установить ему positionabsolute.
		//однако, если он попал в сцену временно, и у него какой-то свой особенный посишн, то надо его не прое..ть
		//поэтому мы сохраняем предыдущее взначение в setpositionabsoluteautomatic. когда же придет истиный отец - возвращаем ему то, что было до этого.
		//ЗЫ может бомбануть, если мы будем один виджет часто перекидывать со сцены в чилды кому нибудь и обратно, при этом меняя посишн самостоятельно.
		//короче, кук бомбанет, зовите будем решать, а пока меня это заебало.
		if(id == -1) {
			if (this.setpositionabsoluteautomatic == null)
				this.setpositionabsoluteautomatic = this.htmlElement.style.position;
			this.htmlElement.style.position = "absolute";
		}
		else {
			this.htmlElement.style.position = this.setpositionabsoluteautomatic;
		}
		
		// Если к нам пришел id родителя в первый раз (-2 это то самое). То мы его сеттим.
		// Если он еще и к тому же равен -1, то мы его сразу ложим в контейнер.
		// Ну и собственно это будет являться первой инициализацией. Потому return.
		if(this.widget.parentId == -2 && !this.widget.inited) {
			this.widget.parentId = id;
			if(this.widget.parentId == -1) {
				containerElement.appendChild(this.htmlElement);
				return;
			}
		}
		
		// Если виджет не готов к работе. То рано нам обрабатывать html элемент.
		// Так как нашего родителя может здесь вовсе и не быть еще.
		// И в таком случае этот метод должен не вызваться.
		// Однако элемент добавиться когда придет родитель и засетит себе сам этот элемент в чилды.
		if(!this.widget.inited) return;
		
		// Ситуации которые могут возникнуть: -1 -> 1/ 1 -> -1/ 1 -> 2
		// Достаем старого родителя. Достаем нового родителя.
		let oldParentWidget = Rex.widgets[this._$oldParentID];
		let newParentWidget = Rex.widgets[id];
		
		let oldParent = null;
		let newParent = null;
		
		if(oldParentWidget != null) oldParent = oldParentWidget.view;
		if(newParentWidget != null) newParent = newParentWidget.view;
		
		//Убеждаемся, а не контейнер ли теперь будет нашим родителем.
		if((newParent == null) && (id == -1)) newParent = containerElement;
		
		if(newParentWidget == null && id !== -1) return;
		
		//если тут бомбануло, настоло время переписать этот метод с нуля!
		if (this._$oldParentID != -2) {
			
			//Разбираемся кто был прежним родителем.
			//Если так то это точно был контейнер.
			if((oldParent == null) && (this._$oldParentID == -1)) oldParent = containerElement;
			
			//Такое вообще вряд ли когда произойдет. Но это же GlobeXY.
			if(oldParent == newParent) {
				if(newParent.contains(this.htmlElement)) {
					console.error("Ну епта. Такого быть не может.");
					return;
				}
			}
			//Осталось лишь теперь забрать и добавить его куда надо.
			//однако с забором все не так просто. вмето вьюшки в олдпаренете может оказаться конструктор.
			//а контейнс ОКАЗЫВАЕТСЯ проверяет не на прямого чилда, а на любого потомка. поэтому костыльнули доппроверочку.
			if((oldParent.contains(this.htmlElement) && oldParentWidget != null) || (this.htmlElement.parentNode == oldParent)) {
				this.htmlElement = oldParent.removeChild(this.htmlElement)
			}
		}
		newParent.appendChild(this.htmlElement);
		this.widget.parentId = id;
	}
	
	/**
	 *  State for widget and html element
	 * @param state
	 */
	
	setState(state) {
		if(state.parentId != null) this.parentId = state.parentId;
		if(state != null) Rex.copy(this, state);
		this.onSetState(state);
		if(state.customStyle !== undefined){
			this.customStyle = state.customStyle;
		}
	}
	
	onSetState(state) {}
	
	/**
	 * All setter and getter set value to widget and htmlelement.
	 * @param value
	 */
	
	set id(value) {
		// if(this.widget.id == value) return;
		this.widget.id = value;
		this.htmlElement.id = "w" + value;
	}
	
	get id() {
		return this.widget.id;
	}
	
	set type(value) {
		if(this.widget.type == value) return;
		this.widget.type = value;
		this.addClassName(value);
	}
	
	get type() {return this.widget.type;}
	
	set name(value) {this.widget.name = value;}
	get name() {return this.widget.name;}
	
	set hint(value) {
		if((value == null) || (this.widget.hint == value)) return;
		try {
			let hint = decodeURIComponent(escape(window.atob(value)));
			this.widget.hint = hint;
			this.htmlElement.title = hint;
		}
		catch(e) { console.log(this.widget.type, "setState->", "Hint DecodeError!", e, value); }
	}
	
	get hint() {return this.widget.hint;}
	
	set posX(value) {
		// if(this.widget.posX == value) return;
		this.widget.posX = value;
		if((this.horizontalAlignType == null || this.horizontalAlignType == 0) && this.checkPosition()) this.htmlElement.style.left = value + "px";
		else this.horizontalAlignType = this.horizontalAlignType;
	}
	
	get posX() {return this.widget.posX;}
	
	set posY(value) {
		// if(this.widget.posY == value) return;
		this.widget.posY = value;
		if((this.verticalAlignType == null || this.verticalAlignType == 0) && this.checkPosition()) this.htmlElement.style.top = value + "px";
		else this.verticalAlignType = this.verticalAlignType;
		
	}
	
	get posY() {return this.widget.posY;}
	
	set width(value) {
		if(this.widget.width == value) return;
		if(!isNaN(value)) {
			this.widget.width = value;
			if(this.horizontalSizePolicy == null || this.horizontalSizePolicy == 0 || this.horizontalSizePolicy == 3) this.htmlElement.style.width = value + "px";
			else {
				this.horizontalSizePolicy = this.horizontalSizePolicy;
				this.horizontalAlignType = this.horizontalAlignType;
			}
		}
		else {
			if(value === undefined) value = null;
			if(this.horizontalSizePolicy == null || this.horizontalSizePolicy == 0 || this.horizontalSizePolicy == 3) this.htmlElement.style.width = value;
			else {
				this.horizontalSizePolicy = this.horizontalSizePolicy;
				this.horizontalAlignType = this.horizontalAlignType;
			}
		}
		this.posX = this.posX;
	}
	
	get width() {return this.widget.width;}
	
	set height(value) {
		if(this.widget.height == value) return;
		if(!isNaN(value)) {
			this.widget.height = value;
			if(this.verticalSizePolicy == null || this.verticalSizePolicy == 0 || this.verticalSizePolicy == 3) this.htmlElement.style.height = value + "px";
			else {
				this.verticalSizePolicy = this.verticalSizePolicy;
				this.verticalAlignType = this.verticalAlignType;
			}
		} else {
			if(value === undefined) value = null;
			if(this.verticalSizePolicy == null || this.verticalSizePolicy == 0 || this.verticalSizePolicy == 3) this.htmlElement.style.height = value;
			else {
				this.verticalSizePolicy = this.verticalSizePolicy;
				this.verticalAlignType = this.verticalAlignType;
			}
		}
	}
	
	get height() {return this.widget.height;}
	
	set elevation(value) {
		if((value == null) || (this.widget.elevation == value)) return;
		this.widget.elevation = value;
		this.htmlElement.style.boxShadow = `var(--elevation-${value})`;
	}
	
	get elevation() {return this.widget.elevation;}
	
	set minWidth(value) {
		if(!isNaN(value)) {
			this.widget.minWidth = value;
			this.htmlElement.style.minWidth  = value + "px";
			this.horizontalSizePolicy = this.horizontalSizePolicy;
			this.horizontalAlignType = this.horizontalAlignType;
		} else {
			if(value === undefined) value = null;
			this.htmlElement.style.minWidth = value;
			this.horizontalSizePolicy = this.horizontalSizePolicy;
			this.horizontalAlignType = this.horizontalAlignType;
		}
		this.posX = this.posX;
	}
	
	get minWidth() {return this.widget.minWidth;}
	
	set minHeight(value) {
		if(!isNaN(value)) {
			this.widget.minHeight = value;
			this.htmlElement.style.minHeight  = value + "px";
			this.verticalSizePolicy = this.verticalSizePolicy;
			this.verticalAlignType = this.verticalAlignType;
		} else {
			if(value === undefined) value = null;
			this.htmlElement.style.minHeight = value;
			this.verticalSizePolicy = this.verticalSizePolicy;
			this.verticalAlignType = this.verticalAlignType;
		}
	}
	
	get minHeight() {return this.widget.minHeight;}
	
	set maxWidth(value) {
		if(!isNaN(value)) {
			this.widget.maxWidth = value;
			this.htmlElement.style.maxWidth  = value + "px";
			this.horizontalSizePolicy = this.horizontalSizePolicy;
			this.horizontalAlignType = this.horizontalAlignType;
		} else {
			if(value === undefined) value = null;
			this.htmlElement.style.maxWidth = value;
			this.horizontalSizePolicy = this.horizontalSizePolicy;
			this.horizontalAlignType = this.horizontalAlignType;
		}
		this.posX = this.posX;
	}
	
	get maxWidth() {return this.widget.maxWidth;}
	
	set maxHeight(value) {
		if(!isNaN(value)) {
			this.widget.maxHeight = value;
			this.htmlElement.style.maxHeight  = value + "px";
			this.verticalSizePolicy = this.verticalSizePolicy;
			this.verticalAlignType = this.verticalAlignType;
		} else {
			if(value === undefined) value = null;
			this.htmlElement.style.maxHeight = value;
			this.verticalSizePolicy = this.verticalSizePolicy;
			this.verticalAlignType = this.verticalAlignType;
		}
	}
	
	get maxHeight() {return this.widget.maxHeight;}
	
	set paddingLeft(value) {
		if(this.widget.paddingLeft == value) return;
		this.widget.paddingLeft = value;
		this.htmlElement.style.paddingLeft  = value + "px";
	}
	
	get paddingLeft() {return this.widget.paddingLeft;}
	
	set paddingRight(value) {
		if(this.widget.paddingRight == value) return;
		this.widget.paddingRight = value;
		this.htmlElement.style.paddingRight  = value + "px";
	}
	
	get paddingRight() {return this.widget.paddingRight;}
	
	set paddingTop(value) {
		if(this.widget.paddingTop == value) return;
		this.widget.paddingTop = value;
		this.htmlElement.style.paddingTop  = value + "px";
	}
	
	get paddingTop() {return this.widget.paddingTop;}
	
	set paddingBottom(value) {
		if(this.widget.paddingBottom == value) return;
		this.widget.paddingBottom = value;
		this.htmlElement.style.paddingBottom  = value + "px";
	}
	
	get paddingBottom() {return this.widget.paddingBottom;}
	
	set marginLeft(value) {
		if(this.widget.marginLeft == value) return;
		this.widget.marginLeft = value;
		this.htmlElement.style.marginLeft  = value + "px";
	}
	
	get marginLeft() {return this.widget.marginLeft;}
	
	set marginRight(value) {
		if(this.widget.marginRight == value) return;
		this.widget.marginRight = value;
		this.htmlElement.style.marginRight  = value + "px";
	}
	
	get marginRight() {return this.widget.marginRight;}
	
	set marginTop(value) {
		if(this.widget.marginTop == value) return;
		this.widget.marginTop = value;
		this.htmlElement.style.marginTop  = value + "px";
	}
	
	get marginTop() {return this.widget.marginTop;}
	
	set marginBottom(value) {
		if(this.widget.marginBottom == value) return;
		this.widget.marginBottom = value;
		this.htmlElement.style.marginBottom  = value + "px";
	}
	
	get marginBottom() {return this.widget.marginBottom;}
	
	set order(value) {
		if(this.widget.order == value) return;
		this.widget.order = value;
		if (value == 0) {
			this.htmlElement.style.zIndex  = null;
			return;
		}
		this.htmlElement.style.zIndex  = value;
	}
	
	get order() {return this.widget.order;}
	
	set visible(value) {
		this.widget.visible = value;
		if(!value) this.htmlElement.style.visibility = "hidden";
		else this.htmlElement.style.visibility = null;
	}
	
	get visible() {return this.widget.visible;}
	
	set editable(value) {
		if(this.widget.editable == value) return;
		this.widget.editable = value;
		if(!value) this.htmlElement.contentEditable = value;
	}
	
	get editable() {return this.widget.editable;}
	
	set transform(value) {
		if(this.widget.transform == value) return;
		this.widget.transform = value;
		if(value != null) this.htmlElement.style.transform = `matrix(${value[0]}, ${value[1]}, ${value[4]}, ${value[5]}, 0, 0)`;
		else this.htmlElement.style.transform = null;
	}
	
	get transform() {return this.widget.transform;}
	
	set parentId(value) {
		if(this.widget.parentId == value) return;
		this._$oldParentID = this.widget.parentId;
		this.setParent(value);
	}
	
	get parentId() {return this.widget.parentId;}
	
	set styleName(value) {
		if(this.widget.styleName == value) return;
		
		if(this.htmlElement != null && this.widget.styleName != "") {
			if(this.widget.styleName != this.widget.type) this.htmlElement.classList.remove(this.widget.styleName);
		}
		try {
			if((this.htmlElement != null) && (value != "")) this.htmlElement.classList.add(value);
		} catch(e) {
			console.log("Вы творите ДИЧЬ!!!!");
		}
		this.widget.styleName = value;
	}
	
	get styleName() {return this.widget.styleName;}
	
	set customStyle(value) {
		this.widget.customStyle = value;
		for( let name in value ){
			let v = value[name];
			if (document.body.style[name]!==undefined || (name.substr(0,2)==="--")) {
				this.htmlElement.style.setProperty(name, v);
				continue;
			}
			this.htmlElement.setAttribute(name,v);
		}
	}
	
	get customStyle() {return this.widget.customStyle;}
	
	set backgroundColor(value) {

		try{
			value = decodeURIComponent(escape(window.atob(value)));
		}catch(e) {
			// error
		}
		
		this.widget._backgroundColor = value;
		
		this.htmlElement.style.background = value;
		if(value.indexOf("contain") != -1) {
			value = value.replace(/contain/g, "")
			this.htmlElement.style.background = value;
			this.htmlElement.style.backgroundPositionX = "center";
			this.htmlElement.style.backgroundPositionY = "center";
			this.htmlElement.style.backgroundSize = "contain";
		}
		
	}
	
	get backgroundColor() {
		return this.widget._backgroundColor;
	}
	
	set textColor(value) {
		if(this.widget._textColor == value) return;
		this.widget._textColor = value;
		this.htmlElement.style.color = value;
	}
	
	get textColor() {
		return this.widget._textColor;
	}
	
	set borderColor(value) {
		if(this.widget._borderColor == value) return;
		this.widget._borderColor = value;
		this.htmlElement.style.borderColor = value;
	}
	
	get borderColor() {
		return this.widget._borderColor;
	}
	
	set borderSize(value) {
		if(this.widget._borderSize == value) return;
		this.widget._borderSize = value;
		this.htmlElement.style.borderWidth = value;
		if(this.htmlElement.style.borderWidth != value) {
			this.htmlElement.style.borderWidth = parseInt(value) + "px";
		}
	}
	
	get borderSize() {
		return this.widget._borderSize;
	}
	
	set borderRadius(value) {
		if(this.widget._borderRadius == value) return;
		this.widget._borderRadius = value;
		this.htmlElement.style.borderRadius = value;
		if(this.htmlElement.style.borderRadius != value) {
			this.htmlElement.style.borderRadius = parseInt(value) + "px";
		}
	}
	
	get borderRadius() {
		return this.widget._borderRadius;
	}
	
	set borderType(value) {
		if(this.widget._borderType == value) return;
		this.widget._borderType = value;
		let type = "";
		switch(parseInt(value)) {
			case 0: { type = ""; break;}
			case 1: { type = "solid"; break;}
			case 2: { type = "dotted"; break;}
			case 3: { type = "dashed"; break;}
			case 4: { type = "double"; break;}
			case 5: { type = "groove"; break;}
			case 6: { type = "ridge"; break;}
			case 7: { type = "inset"; break;}
			case 8: { type = "outset"; break;}
			case 9: { type = "hidden"; break;}
		}
		this.htmlElement.style.borderStyle = type;
	}
	
	get borderType() {
		return this.widget._borderType;
	}
	
	set activated(value) {
		if(this.widget.activated == value) return;
		this.widget.activated = value;
		this.htmlElement.disabled = !value;
		if(!value) this.htmlElement.classList.add("Disabled");
		else this.htmlElement.classList.remove("Disabled");
	}
	get activated() {
		return this.widget.activated;
	}
	
	set fontFamily(value) {
		if(this.widget.fontFamily == value) return;
		this.widget.fontFamily = value;
		this.htmlElement.style.fontFamily = value;
	}
	
	get fontFamily() {
		return this.widget.fontFamily;
	}
	
	set fontSize(value) {
		if(this.widget.fontSize == value) return;
		this.widget.fontSize = value;
		
		if(!isNaN(value)) {
			if(value.indexOf("px") != -1) this.htmlElement.style.fontSize = parseInt(value) + "px";
			else if(value.indexOf("%") != -1) this.htmlElement.style.fontSize = parseInt(value) + "%";
			else this.htmlElement.style.fontSize = parseInt(value) + "px";
		} else {
			if(value == null) value = null;
			this.htmlElement.style.fontSize = value;
		}
	}
	
	get fontSize() {
		return this.widget.fontSize;
	}
	
	set fontItalic(value) {
		if(this.widget.fontItalic == value) return;
		this.widget.fontItalic = value;
		if(value) this.htmlElement.style.fontStyle = "italic";
		else this.htmlElement.style.fontStyle = "";
	}
	
	get fontItalic() {
		return this.widget.fontItalic;
	}
	
	set fontBold(value) {
		if(this.widget.fontBold == value) return;
		this.widget.fontBold = value;
		if(value) this.htmlElement.style.fontWeight = "bold";
		else this.htmlElement.style.fontWeight = "";
	}
	
	get fontBold() {
		return this.widget.fontBold;
	}
	
	set textDecoration(value) {
		if(this.widget.textDecoration == value) return;
		this.widget.textDecoration = value;
		let type = "none";
		switch(parseInt(value)) {
			case 1: { type = "overline"; break;}
			case 2: { type = "line-through"; break;}
			case 3: { type = "underline"; break;}
		}
		this.widget.textDecorationType = type;
		this.htmlElement.style.textDecoration = type;
	}
	
	get textDecoration() {
		this.widget.textDecoration;
	}
	
	set textAlign(value) {
		if(this.widget.textAlign == value) return;
		this.widget.textAlign = value;
		switch(value) { //justify-content: center;
			case 1:
				this.htmlElement.style.justifyContent = "flex-start";
				break;
			case 2:
				this.htmlElement.style.justifyContent = "center";
				break;
			case 3:
				this.htmlElement.style.justifyContent = "flex-end";
				break;
		}
	}
	
	get textAlign() {
		return this.widget.textAlign;
	}
	
	set textShadow(value) {
		this.widget.textShadow = value;
		this.htmlElement.style.textShadow = value;
	}
	
	get textShadow() {
		return this.widget.textShadow;
	}
	
	set horizontalAlignType(value) {
		// if(this.horizontalAlignType == value) return;
		this.widget.horizontalAlignType = value;
		if(value == 0 && this.htmlElement.style.left != "") {
			this.htmlElement.style.left = this.posX + "px";
			return;
		}
		// if(Rex.widgets == null) return;
		switch(value) {
			case 1: { //Left
				this.htmlElement.style.left = 0 + "px";
				break;
			}
			case 2: { //Center
				// this.htmlElement.style.left = "calc(50% - " + this.htmlElement.offsetWidth / 2 + "px)";
				this.htmlElement.style.left = "calc(50% - " + this.width / 2 + "px)";
				break;
			}
			case 3: { //Right
				// this.htmlElement.style.left = "calc(100% - " + this.htmlElement.offsetWidth + "px)";
				this.htmlElement.style.left = "calc(100% - " + this.width + "px)";
				break;
			}
		}
	}
	
	get horizontalAlignType() { return this.widget.horizontalAlignType}
	
	set verticalAlignType(value) {
		// if(this.horizontalAlignType == value) return;
		this.widget._verticalAlignType = value;
		
		if(value == 0 && this.htmlElement.style.top != "") {
			this.htmlElement.style.top = this.posY + "px";
			return;
		}
		switch(value) {
			case 1: { //Left
				this.htmlElement.style.top = 0 + "px";
				break;
			}
			case 2: { //Center
				// this.htmlElement.style.top = "calc(50% - " + this.htmlElement.offsetHeight / 2 + "px)";
				this.htmlElement.style.top = "calc(50% - " + this.height / 2 + "px)";
				break;
			}
			case 3: { //Right
				// if (this.widget.parentId == -1) this.posY = window.innerHeight - this.height;
				// this.htmlElement.style.top = "calc(100% - " + this.htmlElement.offsetHeight + "px)";
				this.htmlElement.style.top = "calc(100% - " + this.height + "px)";
				break;
			}
		}
	}
	
	get verticalAlignType() {return this.widget._verticalAlignType;}
	
	set horizontalSizePolicy(value) {
		// if(this.horizontalSizePolicy == value) return;
		this.widget._horizontalSizePolicy = value;
		
		if((value == 0 || value == 3) && this.htmlElement.style.width != "") { // DEFAULT
			this.htmlElement.style.width = this.width + "px";
		}
		
		switch(value) {
			case 1: { //Minimal
				this.htmlElement.style.width = this.minWidth + "px";
				break;
			}
			case 2: { //FullScreen
				this.htmlElement.style.width = "100%";
				break;
			}
		}
	}
	
	get horizontalSizePolicy() {return this.widget._horizontalSizePolicy;}
	
	set verticalSizePolicy(value) {
		// if(this.horizontalSizePolicy == value) return;
		this.widget.verticalSizePolicy = value;
		
		if((value == 0 || value == 3) && this.htmlElement.style.height != "") { // DEFAULT
			this.htmlElement.style.height = this.height + "px";
		}
		switch(value) {
			case 1: { //Minimal
				this.htmlElement.style.height = this.minHeight + "px";
				break;
			}
			case 2: { //FullScreen
				if(Rex.widgets == null) return;
				let parent = Rex.widgets[this.widget.parentId];
				if(parent == null) this.htmlElement.style.height = window.innerHeight + "px";
				else this.htmlElement.style.height = "100%";
				break;
			}
		}
	}
	
	get verticalSizePolicy() {return this.widget.verticalSizePolicy;}
	
	set children(value) {
		if(this.widget.children == value) return;
		this.widget.children = value;
		//TODO
	}
	
	get children() {return this.widget.children;}
	
	set draggable(value) {
		this.widget.draggable = value;
		if(value) this.htmlElement.draggable = value;
		else this.htmlElement.draggable = null;
	}

	get draggable() {return this.widget.draggable;}

	set dragImage(value) {

		// this.widget.dragImage = value;
		
		let im = new Image();
		im.src = value;
		this.widget.dragImage = im;

	}

	get dragImage() {
		return this.widget.dragImage;
	}
	
	set filterType(value) {
		if(this.widget.filterType == value) return;
		this.widget.filterType = value;
		this.updateFilterCSS();
	}
	
	get filterType() {
		return this.widget.filterType;
	}
	
	set filterValue(value) {
		if(this.widget.filterValue == value) return;
		this.widget.filterValue = value;
		this.updateFilterCSS();
	}
	
	get filterValue() {
		return this.widget.filterValue;
	}
	
	updateFilterCSS() {
		switch(this.widget.filterType) {
			case 0: { // None
				this.htmlElement.style.filter = "";
				break;
			}
			case 1: { // Blur
				this.htmlElement.style.filter = "blur(" + parseInt(this.widget.filterValue) + "px)";
				break;
			}
			case 2: { // Brightness
				this.htmlElement.style.filter = "brightness(" + this.widget.filterValue + ")";
				break;
			}
			case 3: { // Contrast
				this.htmlElement.style.filter = "contrast(" + this.widget.filterValue + ")";
				break;
			}
			case 4: { // Grayscale 0 - 1
				this.htmlElement.style.filter = "grayscale(" + this.widget.filterValue + ")";
				break;
			}
			case 5: { // Saturate 0 - 
				this.htmlElement.style.filter = "saturate(" + this.widget.filterValue + ")";
				break;
			}
			case 6: { // Sepia 0 -1
				this.htmlElement.style.filter = "sepia(" + this.widget.filterValue + ")";
				break;
			}
			case 7: { // HueRotate 0 - 360deg
				this.htmlElement.style.filter = "hue-rotate(" + Math.round(this.widget.filterValue) + "deg)";
				break;
			}
			case 8: { // Invert 0 - 1
				this.htmlElement.style.filter = "invert(" + this.widget.filterValue + ")";
				break;
			}
			case 9: { // Opacity 0 - 1
				this.htmlElement.style.filter = "opacity(" + this.widget.filterValue + ")";
				break;
			}
		}
	}
	
	set cssData(value) {
		
		try {
			this._cssData = decodeURIComponent(escape(window.atob(value)));
		} catch (e) {
			// error
		}
		
		if (this._cssSheet) {
			this._cssSheet.remove();
			this._cssSheet = null;
		}
		
		const minLengthCSS = 4;
		if (this._cssData.length <= minLengthCSS) {
			return;
		}
		
		let sheet = document.createElement("style")
		sheet.innerHTML = this._cssData;
		document.body.appendChild(sheet);
		
		this._cssSheet = sheet;
		
	}
	
	get cssData() {
		return this._cssData;
	}
	
	recursiveHover() {
		this.hover = true;
		Rex.gui._hoveredWidgets.push(this);
		let parent = Rex.widgets[this.widget.parentId];
		if(!parent) return;
		parent.view.recursiveHover(this.widget.id);
	}
	
	checkSelect(event, parentId) {
		const path = event.path || (event.composedPath && event.composedPath());
		let pathElement = path[path.length - 1];
		let widget = Rex.widgets[pathElement];
		if (widget == null) return this.hover ? this.widget : null;
		if (widget.parentId !== parentId) return this.hover ? this.widget : null;
		let ret = widget.view.checkSelect(event, path.pop());
		if (ret != null) return ret;
		return this.hover ? this.widget : null;
	}
	
	inside(x, y) {
		if(this.widget.aPosX > x || (this.widget.aPosX + this.widget.width) < x) return false;
		if(this.widget.aPosY > y || (this.widget.aPosY + this.widget.height) < y) return false;
		return true;
	}
	
	addClassName(value) {
		if(this.htmlElement == null) return;
		this.htmlElement.classList.add(value);
	}

	removeClassName(value){
		if(this.htmlElement == null) return;
		this.htmlElement.classList.remove(value);
	}

	updateFocus() {
		if(Rex.gui === undefined) return;
		if(Rex.gui.focusWidget === this.widget) {
			Rex.gui.updateHovered(undefined);
			Rex.gui.updateFocused(undefined);
			return;
		}
		if(Rex.gui.hoverWidget === this.widget) {
			Rex.gui.updateHovered(undefined);
			return;
		}
		for(let id of this.widget.children) {
			let widget = Rex.widgets[id];
			if(widget === undefined) continue;
			widget.view.updateFocus();
		}
	}
	
	destroy() {
		if(this.htmlElement == null) return;
		let parent = this.htmlElement.parentElement;
		if(parent == null) return;
		parent.removeChild(this.htmlElement);
		this.onDestroy();
		this.updateFocus();
	}
	
	getAPosX() {
		return this.htmlElement.getBoundingClientRect().left;
	}
	
	getAPosY() {
		return this.htmlElement.getBoundingClientRect().top;
	}
	
	onDestroy() {}
	

	
}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml*/

/**
 * WidgetButton
 */
class WidgetButtonHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetButton");
		
		this.htmlText = document.createElement("div");
		this.htmlText.classList.add("WidgetButtonText");
		
		this.htmlIcon = document.createElement("div");
		this.htmlIcon.classList.add("MaterialIcon");
		this.ripples = [];
		try {
			new ResizeObserver(this.controlFontSize.bind(this)).observe(this.htmlElement);
		}
		catch(e) {
		}
	}
	
	onSetState(state) {
		if(state.pressed != null) this.widget.pressed = state.pressed;
		if(state.raisedElevation != null) this.widget.raisedElevation = state.raisedElevation;
		if(state.defaultElevation != null) this.widget.defaultElevation = state.defaultElevation;
		if(state.lessHundred != null) this._lessHundred = state.lessHundred;
		if(state.autoFontSize != null) this.autoFontSize = state.autoFontSize;
		
		if(state.activated != null) {
			if(this.htmlElement != null) {
				if(!state.activated) this.htmlElement.classList.add("WidgetButtonDisable"); else this.htmlElement.classList.remove("WidgetButtonDisable")
			}
		}
		
		if(state.text != null) this.controlText(state.text);
		if(state.iconName != null) this.controlIconName(state.iconName);
		if(state.fontSize != null) this.controlFontSize(state.fontSize);
		if(state.fontFamily != null) this.controlFontFamily(state.fontFamily);
		if(state.verticalTextAlign != null) this.controlVerticalTextAlign(state.verticalTextAlign);
		if(state.horizontalTextAlign != null) this.controlHorizontalTextAlign(state.horizontalTextAlign);

		if(state.visible != null && state.visible == false) {
			for(let c of this.ripples) {
				if(null == c) continue;
				c.remove();
			}
		}
		
	}
	
	controlText(stateText) {
		let text = decodeURIComponent(escape(window.atob(stateText)));
		this.widget.text = text;
		this.htmlText.innerText = text;
		
		if(stateText == "") {
			if(this.htmlElement.contains(this.htmlText)) {
				this.htmlElement.removeChild(this.htmlText);
			}
		} else {
			if(!this.htmlElement.contains(this.htmlText)) this.htmlElement.appendChild(this.htmlText);
			this.htmlText.innerText = this.widget.text;
		}
	}
	
	controlIconName(stateIconName) {
		if(this.widget.iconName == stateIconName) return;
		this.widget.iconName = stateIconName;
		this.htmlIcon.innerText = this.widget.iconName;
		this.controlVerticalTextAlign(this.verticalTextAlign);
		this.controlHorizontalTextAlign(this.horizontalTextAlign);
	}
	
	controlVerticalTextAlign(stateTextAlign) {
		if(this.widget.verticalTextAlign == stateTextAlign) return;
		this.widget.verticalTextAlign = stateTextAlign;
		switch (stateTextAlign) {
			case 1: // TEXT TOP
				this.htmlText.style.alignItems = "flex-start";
				this.htmlIcon.style.alignItems = "flex-start";
				break;
			case 2: // TEXT CENTER
				this.htmlText.style.alignItems = "center";
				this.htmlIcon.style.alignItems = "center";
				break;
			case 3: // TEXT BOTTOM
				this.htmlText.style.alignItems = "flex-end";
				this.htmlIcon.style.alignItems = "flex-end";
				break;
		}
	}
	
	controlHorizontalTextAlign(stateTextAlign) {
		if(stateTextAlign == 0) this.htmlText.innerText = "";
		else this.htmlText.innerText = this.widget.text;

		this.widget.textAlign = stateTextAlign;
		
		switch(stateTextAlign) { //justify-content: center;
			case 0: // TEXT NONE
				this.htmlIcon.style.width = "100%";
				if(this.htmlElement.contains(this.htmlText))
					this.htmlElement.removeChild(this.htmlText);

				if(!this.htmlElement.contains(this.htmlIcon))
					this.htmlElement.appendChild(this.htmlIcon);

				break;
			case 1: // TEXT LEFT
				this.htmlIcon.style.width = "30%";
				this.htmlText.style.width = "70%";
				if (this.htmlIcon.innerText.length === 0) {
					this.htmlIcon.style.width = null;
					this.htmlText.style.width = "100%";
					this.htmlText.style.justifyContent = "flex-start";
				}
				this.htmlText.style.textAlign = "left";
				if(this.htmlElement.contains(this.htmlText))
					this.htmlElement.removeChild(this.htmlText);

				if(this.htmlElement.contains(this.htmlIcon))
					this.htmlElement.removeChild(this.htmlIcon);

				if(this.htmlText.innerText.length !== 0)
					this.htmlElement.appendChild(this.htmlText);

				if(this.htmlIcon.innerText.length !== 0)
					this.htmlElement.appendChild(this.htmlIcon);

				break;
			case 2: // TEXT CENTER
				this.htmlText.style.width = "100%";
				this.htmlText.style.justifyContent = "center";
				this.htmlText.style.textAlign = "center";

				if(this.htmlElement.contains(this.htmlIcon))
					this.htmlElement.removeChild(this.htmlIcon);
				
				if(!this.htmlElement.contains(this.htmlText) &&
					this.htmlText.innerText.length !== 0)
				{
					this.htmlElement.appendChild(this.htmlText);
				}
				break;
			case 3: // TEXT RIGHT
				this.htmlIcon.style.width = "30%";
				this.htmlText.style.width = "70%";
				if (this.htmlIcon.innerText.length === 0) {
					this.htmlIcon.style.width = null;
					this.htmlText.style.width = "100%";
					this.htmlText.style.justifyContent = "flex-end";
				}
				this.htmlText.style.textAlign = "right";
				if(this.htmlElement.contains(this.htmlText))
					this.htmlElement.removeChild(this.htmlText);

				if(this.htmlElement.contains(this.htmlIcon))
					this.htmlElement.removeChild(this.htmlIcon);

				if(this.htmlIcon.innerText.length !== 0)
					this.htmlElement.appendChild(this.htmlIcon);
				if(this.htmlText.innerText.length !== 0)
					this.htmlElement.appendChild(this.htmlText);
				break;
		}
	}
	
	controlFontSize() {
		if(!this.autoFontSize) {
			this.htmlElement.style.fontSize = this.fontSize + "px";
			return;
		}
		let html = this.htmlElement;
		const ratio = html.clientWidth < html.clientHeight ? html.clientWidth / html.clientHeight :
			html.clientHeight / html.clientWidth;
		const side = Math.max(html.clientWidth, html.clientHeight);
		const fontSize = side * ratio * 2;

		if (fontSize < 100 && !this._lessHundred) html.style.fontSize = "100%";
		else html.style.fontSize = (fontSize) + "%";
	}
	
	controlFontFamily(stateFontFamily) {
		this.htmlText.style.fontFamily = stateFontFamily;
	}
	
	checkSelect() {
		return this.hover ? this.widget : undefined;
	}
	
	onMouseDown(x, y, event) {
		this.startAnimation(event)
	}
	
	startAnimation(event) {
		let rippleSize = Math.max(this.width, this.height) * 4;
		let delay = 100;
		let	posX = event.clientX;
		let posY = event.clientY;
		
		let dx = posX - this.widget.aPosX;
		let dy = posY - this.widget.aPosY;
		
		let containerRipple = document.createElement("div");
		containerRipple.style.width = this.htmlElement.clientWidth + "px";
		containerRipple.style.height = this.htmlElement.clientHeight + "px";
		containerRipple.style.overflow = "hidden";
		containerRipple.style.position = "absolute";
		this.ripples.push(containerRipple);
		
		let ripple = document.createElement("div");
		ripple.style.left = (dx - (rippleSize / 2)) + "px";
		ripple.style.top = (dy - (rippleSize / 2)) + "px";
		ripple.style.height = (rippleSize) + "px";
		ripple.style.width = (rippleSize) + "px";
		ripple.style.borderRadius = (rippleSize) + "px";
		ripple.classList.add("RippleAnimation");
		this.htmlElement.appendChild(containerRipple);
		containerRipple.appendChild(ripple);
		
		setTimeout(function () {
			ripple.style["-webkit-transform"] = "scale(1)";
			ripple.style["-moz-transform"] = "scale(1)";
			ripple.style.transform = "scale(1)";
			ripple.style.opacity = 0;
		}, delay);
		
		let remove = this.widget.pressed;
		setTimeout(function () {
			if(containerRipple != null && !remove) containerRipple.remove();
		}, 2000);
	}

	set autoFontSize(value) {
		if (value == null) return;
		this.widget._autoFontSize = value;
		if (!value)
			this.htmlElement.style.fontSize = this.fontSize + "px";
		else this.controlFontSize();
	}
	
	get autoFontSize() {
		return this.widget._autoFontSize;
	}

	onDestroy() {
		for(let c of this.ripples) {
			if(null == c) continue;
			c.remove();
		}
	}
	
}


/**
 * WidgetCheckBox
 */

class WidgetCheckBoxHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.htmlElement.className = "WidgetCheckBox";

		this.htmlContainer = document.createElement("div"); //Контейнер, в котором находятся все элементы виджета(CheckBox, Text, Icon)
		this.htmlContainer.classList.add("Content");
		this.htmlCheckContainer = document.createElement("div"); //Контейнер, в котором находятся все элементы CheckBox'a (Input, Label)

		this.inputElement = document.createElement("input");
		this.inputElement.type = "checkbox";
		this.inputElement.value = "None";
		this.inputElement.name = "check";
		this.inputElement.disabled = true;

		this.labelElement = document.createElement("label");

		this.htmlText = document.createElement("div");
		this.htmlText.classList.add("WidgetCheckBoxText");

		this.htmlElement.appendChild(this.htmlContainer);
		this.htmlContainer.appendChild(this.htmlCheckContainer);

		this.htmlCheckContainer.appendChild(this.inputElement);
		this.htmlCheckContainer.appendChild(this.labelElement);

		this.htmlContainer.appendChild(this.htmlText);

		try {
			new ResizeObserver(function (event) {
				this.htmlText.style.width = "calc(" + 90 + "% - " + this.widget._checkerSize+"px)";
				this.controlFontSize();
			}.bind(this)).observe(this.htmlElement);
		} catch(e) {
		}

	}

	onSetState(state) {
		if(state.checked != null) this.checked = state.checked;
		if(state.styleType != null) this.controlStyle(state.styleType);
		if(state.checkerSize != null) this.controlCheckerSize(state.checkerSize);
		if(state.orderType != null) this.controlOrder(state.orderType);
		if(state.lineHeight != null) this.widget.lineHeight = state.lineHeight;

		if(state.activated != null) {
			if(this.htmlElement != null) {
				if(!state.activated) {
					this.htmlElement.classList.remove("Disabled");
					this.htmlElement.classList.add("WidgetCheckBoxDisabled");

					if (this.htmlCheckContainer.classList.contains("CheckBox")) {
						this.htmlCheckContainer.classList.add("CheckBoxDisabled");
					} else if (this.htmlCheckContainer.classList.contains("RadioButton")) {
						this.htmlCheckContainer.classList.add("RadioButtonDisabled");
					} else if (this.htmlCheckContainer.classList.contains("Toggle")) {
						this.htmlCheckContainer.classList.add("ToggleDisabled");
					} else if (this.htmlCheckContainer.classList.contains("ClassicCheckBox")) {
						this.htmlCheckContainer.classList.add("ClassicCheckBoxDisabled");
					} else if (this.htmlCheckContainer.classList.contains("ClassicToggle")) {
						this.htmlCheckContainer.classList.add("ClassicToggleDisabled");
					} else if (this.htmlCheckContainer.classList.contains("ClassicRadioButton")) {
						this.htmlCheckContainer.classList.add("ClassicRadioButtonDisabled");
					}
				}
				else {
					this.htmlElement.classList.remove("WidgetCheckBoxDisabled");

					if (this.htmlCheckContainer.classList.contains("CheckBox")) {
						this.htmlCheckContainer.classList.remove("CheckBoxDisabled");
					} else if (this.htmlCheckContainer.classList.contains("RadioButton")) {
						this.htmlCheckContainer.classList.remove("RadioButtonDisabled");
					} else if (this.htmlCheckContainer.classList.contains("Toggle")) {
						this.htmlCheckContainer.classList.remove("ToggleDisabled");
					} else if (this.htmlCheckContainer.classList.contains("ClassicCheckBox")) {
						this.htmlCheckContainer.classList.remove("ClassicCheckBoxDisabled");
					}   else if (this.htmlCheckContainer.classList.contains("ClassicToggle")) {
						this.htmlCheckContainer.classList.remove("ClassicToggleDisabled");
					} else if (this.htmlCheckContainer.classList.contains("ClassicRadioButton")) {
						this.htmlCheckContainer.classList.remove("ClassicRadioButtonDisabled");
					}
				}
			}
		}

		if(state.text != null) this.controlText(state.text);
		if(state.iconName != null) this.controlIconName(state.iconName);
		if(state.fontFamily != null) this.controlFontFamily(state.fontFamily);
		if(state.verticalTextAlign != null) this.controlVerticalTextAlign(state.verticalTextAlign);
		if(state.horizontalTextAlign != null) this.controlHorizontalTextAlign(state.horizontalTextAlign);
		if(state.lessHundred != null) this._lessHundred = state.lessHundred;
		if(state.fontSize != null) this.controlFontSize();
	}

	controlText(stateText) {
		let text = "";
		try { text = decodeURIComponent(escape(window.atob(stateText)));}
		catch(e) {console.log(this.widget.type, "setState->", "Text DecodeError!", e, stateText); return;}

		this.widget.text = text;
		if(this.widget.iconName == "")
			this.htmlText.innerText = text;
	}

	controlVerticalTextAlign(stateTextAlign) {
		if(this.widget.verticalTextAlign == stateTextAlign) return;
		this.widget.verticalTextAlign = stateTextAlign;
		switch (stateTextAlign) {
			case 1: // TEXT TOP
				this.htmlContainer.style.alignItems = "flex-start";
				break;
			case 2: // TEXT CENTER
				this.htmlContainer.style.alignItems = "center";
				break;
			case 3: // TEXT BOTTOM
				this.htmlContainer.style.alignItems = "flex-end";
				break;
		}
	}
	
	controlHorizontalTextAlign(stateTextAlign) {
		// if (stateTextAlign === 0) this.htmlText.innerText = "";
		// else this.htmlText.innerText = this.widget.text;
		switch (stateTextAlign) {
			case 0: // NONE 
				this.htmlText.style.textAlign = null;
				break;
			case 1: // TEXT LEFT
				this.htmlText.style.textAlign = "left";
				break;
			case 2: // TEXT CENTER
				this.htmlText.style.textAlign = "center";
				break;
			case 3: // TEXT RIGHT
				this.htmlText.style.textAlign = "right";
				break;
		}
	}

	controlIconName(stateIconName) {
		if(this.widget.iconName == stateIconName) return;
		this.widget.iconName = stateIconName;

		if(this.widget.iconName == "") {
			this.htmlText.textContent = this.widget.text;
			this.htmlText.classList.remove("MaterialIcon");
			this.htmlText.classList.remove("MaterialIconOffset");
		} else {
			this.htmlText.textContent = stateIconName;
			this.htmlText.classList.add("MaterialIcon");
			this.htmlText.classList.add("MaterialIconOffset");
			this.htmlText.innerText = this.widget.iconName;
		}
	}
	
	controlFontSize() {
		if(!this.autoFontSize) {
			this.htmlElement.style.fontSize = this.fontSize + 'px';
			return;
		}
		
		let html = this.htmlElement;
		const ratio = html.clientWidth < html.clientHeight ? html.clientWidth / html.clientHeight :
			html.clientHeight / html.clientWidth;
		const side = Math.max(html.clientWidth, html.clientHeight);
		const fontSize = side * ratio;
		
		if (fontSize < 100 && !this._lessHundred) html.style.fontSize = "100%";
		else html.style.fontSize = (fontSize) + '%';
		
		const newCheckerSize = fontSize / 3;
		if (newCheckerSize < this.widget._checkerSize) this.controlCheckerSize(this.widget._checkerSize);
		else this.controlCheckerSize(newCheckerSize, false);
	}
	
	controlFontFamily(stateFontFamily) {
		this.htmlText.style.fontFamily = stateFontFamily;
	}

	controlStyle(stateStyle) {
		if (this.widget._checkerStyle === stateStyle) return;
		this.widget._checkerStyle = stateStyle;

		switch (stateStyle) {
			case 0:
				this.widgetStyleType = "CheckBox";
				this.widget._isRadioButton = false;
				break;
			case 1:
				this.widgetStyleType = "Toggle";
				this.widget._isRadioButton = false;
				break;
			case 2:
				this.widgetStyleType = "RadioButton";
				this.widget._isRadioButton = true;
				break;
			case 3:
				this.widgetStyleType = "ClassicCheckBox";
				this.widget._isRadioButton = false;
				break;
			case 4:
				this.widgetStyleType = "ClassicToggle";
				this.widget._isRadioButton = false;
				break;
			case 5:
				this.widgetStyleType = "ClassicRadioButton";
				this.widget._isRadioButton = true;
				break;
			default:
				return;
		}
		this.controlCheckerSize(this.widget._checkerSize);
	}

	controlOrder(stateOrder) {
		this.widget._widgetOrder = stateOrder;
		switch (stateOrder) {
			case 0:
				this.htmlCheckContainer.style.order = "0";
				this.htmlText.style.order = "1";
				this.htmlCheckContainer.style.left = "3%";
				this.htmlText.style.left = "7%";

				this.htmlCheckContainer.style.right = null;
				this.htmlText.style.right = null;
				break;
			case 1:
				this.htmlCheckContainer.style.order = "1";
				this.htmlText.style.order = "0";
				this.htmlCheckContainer.style.left = "3%";
				this.htmlText.style.left = "3%";
				break;
			default:
				return;
		}
	}

	controlCheckerSize(value, needSave = true) {
		if (needSave)
			this.widget._checkerSize = value;

		switch(this.widget._checkerStyle) {
			case 0:
			case 2:
			case 3:
			case 5:
				this.htmlCheckContainer.style.minWidth = value + "px";
				this.htmlCheckContainer.style.minHeight = value + "px";
				this.htmlCheckContainer.style.maxWidth = value + "px";
				this.htmlCheckContainer.style.maxHeight = value + "px";
				this.widget._styleSizes = value;
				break;
			case 1:
				this.htmlCheckContainer.style.minWidth = value + "px";
				this.htmlCheckContainer.style.minHeight = value / 5 + "px";
				this.htmlCheckContainer.style.maxWidth = value + "px";
				this.htmlCheckContainer.style.maxHeight = value / 5 + "px";
				break;
			case 4:
				this.htmlCheckContainer.style.minWidth = value + "px";
				this.htmlCheckContainer.style.minHeight = value / 2 + "px";
				this.htmlCheckContainer.style.maxWidth = value + "px";
				this.htmlCheckContainer.style.maxHeight = value / 2 + "px";
		}


		if (this.widget._checkerStyle === 0 || this.widget._checkerStyle === 3) {
		} else if (this.widget._checkerStyle === 1) {
			this.widget._styleSizes = value;
		} else if (this.widget._checkerStyle === 3) {
		}
	}

	set checked(value) {
		this.inputElement.checked = value;
		this.widget.checked = value;

		if (value) {
			if (this.htmlCheckContainer.classList.contains("ClassicToggle")) {
				this.htmlCheckContainer.classList.add("ClassicToggleChecked");
			}
		} else {
			if (this.htmlCheckContainer.classList.contains("ClassicToggle")) {
				this.htmlCheckContainer.classList.remove("ClassicToggleChecked");
			}
		}
	}

	get checked() {return this.widget.checked;}

	set id(value) {
		if(this.widget.id == value) return;
		this.widget.id = value;
		this.htmlElement.id = "div"+value;
	}

	set widgetStyleType(value) {
		if (!value) return;
		if (value.length === 0) return;

		this.htmlCheckContainer.className = value;
		this.inputElement.id = value;
		this.labelElement.htmlFor = value;
	}
	
	set autoFontSize(value) {
		if (value == null) return;
		this.widget._autoFontSize = value;
		if (!value) {
			this.htmlElement.style.fontSize = this.fontSize + "px";
			this.controlCheckerSize(this.widget._checkerSize);
		}
		else this.controlFontSize();
	}
	
	get autoFontSize() {
		return this.widget._autoFontSize;
	}
	
	checkSelect() {
		return this.hover ? this.widget : undefined;
	}
}


class WidgetTreeHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		
		//все treeItems по ключам
		this.listItems = {};
		//самый главный treeItem
		this.rootId = undefined;
		this.rootItem = undefined;
		//на сколько смещать
		this.padding = 15;
		//высота итема
		// this.heightItem = 40;
		//текущий выбранный
		this.selectId = -1;
		this.styleSelect = undefined;
		//текущий выделенный
		this.hoverId = -1;
		this.styleHover = undefined;
		//дефолтный стиль
		this.lineStyle = {
			color : 'var(--main-color)',
			width : '1px'
		};
		this.defaultLStyle = undefined;
		this.defaultNStyle = undefined;
		
		//рисовать ли линии
		this.drawLine = true;
		//запускать ли анимацию
		this.animate = true;
		
		//cooridnates up left 
		this.myPos = {x : undefined, y : undefined, width : undefined, height : undefined}
		
		this.animationId = 0;
		this.areaAnimates = [];
		this.animationItems = [];
		this.linesAnimate = [];
		this.animationLines = [];
		
		this.createDomElement("div");
		this.htmlElement.style.position = 'relative';
		this.addClassName("WidgetTree");
	}
	
	//подписаться на onchangepos
	setItemsState (items) {
		for (let index in items){
			let itemState = items[index];
			let itemId = itemState.id;
			let treeItem = this.listItems[itemId];
			if (treeItem == undefined){
				let type = itemState.type;
				//создаем листик =)
				if (type == 'leaf') this.listItems[itemId] = new TreeLeafHtml(this, itemState);
				//создаем палку =0
				else if(type == 'node') this.listItems[itemId] = new TreeNodeHtml(this, itemState);
			}
			else {
				//если мы больше не листик =(
				if (itemState.type != undefined && itemState.type != treeItem.getType())
					this.changeTypeItem(treeItem,itemState.type);

				treeItem.setState(itemState);
			}
			//костылик на систему новых стейтов =)
			if (this.rootItem == undefined && this.rootId == itemId) this.setRootItem();
		}
	}

	onSetState(state) {
		if (state.styleNodes != undefined) {
			if (this.defaultNStyle != undefined) this.defaultNStyle.setState(state.styleNodes);
			else this.defaultNStyle = new TreeItemStyle(state.styleNodes,[],this);
		}
		if (state.styleLeafs != undefined) {
			if (this.defaultLStyle != undefined) this.defaultLStyle.setState(state.styleLeafs);
			else this.defaultLStyle = new TreeItemStyle(state.styleLeafs,[],this);
		}
		if (state.lineStyle != undefined) {
			this.lineStyle.color = state.lineStyle.color;
			this.lineStyle.width = state.lineStyle.width;
			
			for (let id in this.listItems){
				let item = this.listItems[id];
				if (item.line != undefined) item.line.update();
			}
		}
		if (state.hoverStyle != undefined) {
			if (this.styleHover != undefined) this.styleHover.setState(state.hoverStyle);
			else this.styleHover = new TreeItemStyle(state.hoverStyle,[],this);
		}
		if (state.selectStyle != undefined) {
			if (this.styleSelect != undefined) this.styleSelect.setState(state.selectStyle);
			else this.styleSelect = new TreeItemStyle(state.selectStyle,[],this);
		}
		if (state.drawLines != undefined) this.setDrawLines(state.drawLines);
		if (state.animate != undefined) this.animationOnOff(state.animate);
		if (state.items != undefined){
			this.setItemsState(state.items);
			this.runAnimation();
		}
		if (state.rootId != undefined){
			this.rootId = state.rootId;
			this.setRootItem();
		}
		// if (state.searchObj != undefined) {
		// 	let searchObj = state.searchObj;
		// 	this.updateTreeBySearchStr(searchObj.filter, searchObj.full, searchObj.register, searchObj.sections);
		// }
		if (this.animationItems.length || this.animationLines.length) this.runAnimation();
		if (state.secret != undefined) this.expandCollepseAllItems(state.secret);
		if (state.needRemove != undefined) {
			let removeIds = state.needRemove;
			while (removeIds.length){
				let id = removeIds.pop();
				let treeItem = this.listItems[id];
				if (treeItem != undefined) treeItem.destroy();
				else console.error("can't destroy", id);
			}
			this.runAnimation();
		}
	}

	setRootItem () {
		if (this.listItems[this.rootId] != undefined){
			this.rootItem = this.listItems[this.rootId];
			this.rootItem.isVisible = true;
			this.htmlElement.appendChild(this.rootItem.view);
		}
	}

	checkChangePos (state) {
		if (state.posX || state.posY || state.width || state.height){
			if (this.rootItem != undefined)
				this.rootItem.hardUpdateIconCenter();
		}
	}
	
	
	checkSelect(event,id) {
		let ID = this.htmlElement.id;

		try {
			if (this.htmlElement.id.indexOf("w") === 0) {
				ID = parseInt(this.htmlElement.id.slice(1));
			}
		} catch(e) {}


		return ID == id ? this.widget : undefined;
	}
	
	mouseDown(x, y, event) {
		const path = event.path || (event.composedPath && event.composedPath());
		if (path == undefined) {console.error("Press path undef");return;}
		let index = 0;
		while (index < path.length && path[index].className != "WidgetTreeItem") ++index;
		
		if (index >= path.length) return;
		
		let id = path[index].id;

		try {
			if (path[index].id.indexOf("w") === 0) {
				id = parseInt(path[index].id.slice(1));
			}
		} catch(e) {}


		let firstPosItemId = id.indexOf('_');
		id = firstPosItemId != -1 ? id.slice(firstPosItemId+1) : id; 
		//ну вот вообще хз
		for (let i=0; i<index; ++i) {
			let name = path[i].classList; 
			if(name == "IconNode") 
				this.widget.callExpand(id,!this.listItems[id].isExpand);
			else if (name == "WidgetLabel") 
				this.widget.setSelected(id);
		}
	}
	
		
	mouseUp(x, y, event) {

		const path = event.path || (event.composedPath && event.composedPath());
		if (path == undefined) return;
		
		let index = 0;
		while (index < path.length && path[index].className != "WidgetTreeItem") ++index;
		
		if (index >= path.length) return;
		
		let id = path[index].id;
		try {
			if (path[index].id.indexOf("w") === 0) {
				id = parseInt(path[index].id.slice(1));
			}
		} catch(e) {}

		//ну вот вообще хз
		for (let i=0; i<index; ++i) 
			if (path[i].classList == "WidgetLabel") this.widget.callMouseUp(event.button,id);
	}
	
	mouseDoubleClick(event) {
		const path = event.path || (event.composedPath && event.composedPath());
		if (path == undefined) return;
		
		let index = 0;
		while (index < path.length && path[index].className != "WidgetTreeItem") ++index;
		
		if (index >= path.length) return;
		
		let id = path[index].id;
		try {
			if (path[index].id.indexOf("w") === 0) {
				id = parseInt(path[index].id.slice(1));
			}
		} catch(e) {}
		
		let kostil = id.indexOf('_');
		id = kostil != -1 ? id.slice(kostil+1) : id;
		//ну вот вообще хз
		for (let i=0; i<index; ++i)
			if (path[i].classList == "WidgetLabel") this.widget.callMouseDouble(event.button,id);
	}
	
	onDrag(dragAndDrop) {
		if(this.hoverId == -1) return false;

		let item = this.listItems[this.hoverId];
		if (item == undefined) return false;
		
		if (item.dragImage != undefined) this.dragImage = item.dragImage;
		return {'itemId' : item.id};
	}
	
	onDrop(event,pos){
		const path = event.path || (event.composedPath && event.composedPath());
		let currentItem = undefined;
		for (let div of path){
			if (div.className == 'WidgetTreeItem'){
				let id = parseInt(div.id.slice(div.id.indexOf('_')+1));
				currentItem = this.listItems[id];
				break;
			}
		}

		if (currentItem == undefined) 
			return {itemId :-1};
		else if (currentItem.id == this.rootId)
			return {itemId :this.rootId};
		
		let parent = currentItem.parentTreeItem;
		if (this.myPos.y == undefined) this.askTreePosition();
		
		let relativePosY = pos.y - this.myPos.y;
		let isBefore = currentItem.centerPosIcon.y > relativePosY;
		let indexChild = parent.children.indexOf(currentItem);
		indexChild = isBefore ? indexChild : ++indexChild;
		let data = {
			itemId : currentItem.id,
			parentId : parent.id,
			indexInsert : indexChild
		}
		return data;
	}
	
	appendChild (child) {
		if (child == undefined) return;

		let ID = child.id;
		try {
			if (child.id.indexOf("w") === 0) {
				ID = parseInt(child.id.slice(1));
			} 
		} catch(e){}

		for (let id in this.listItems){
			let treeItem = this.listItems[id];
			if (treeItem.label == undefined && treeItem.labelId==ID)
				treeItem.setLabel(Rex.widgets[ID]);
		}
	}
	
	changeTypeItem (item, type) {
		if (item == undefined) {console.error("Error item undefined"); return;}
		if (item.getType() == type) return;
		
		if (item.getType() == 'leaf') {
			let tmpState = {};
			
			tmpState['id'] = item.id;
			tmpState['depth'] = item.deep;
			tmpState['labelId'] = item.labelId;
			tmpState['itemHeight'] = item.height;
			tmpState['itemStyle'] = 'default';
			
			let newNode = new TreeNodeHtml(this, tmpState);
			this.listItems[item.id] = newNode;
			
			{//STYLE
				newNode.isVisible = item.isVisible;
				newNode.style.removeItem(newNode);
				newNode.itemStyle = item.itemStyle;
				newNode.isSelected = item.isSelected;
				if (item.style == this.defaultLStyle) 
					newNode.style = this.defaultNStyle;
				else newNode.style = item.style;
				
				item.style.removeItem(item);
				newNode.style.addItem(newNode);
			}
			
			if (item.parentTreeItem != undefined) {
				
				//заменили html чилда
				item.parentTreeItem.areaItems.replaceChild(newNode.view,item.view);
				
				if (this.drawLine) {
					newNode.line = item.line;
					item.line = undefined;
					newNode.line.child = newNode;
				}
				newNode.centerPosIcon = item.centerPosIcon;
				
				//удалили из чилдов 
				//чтоб смог спокойно умереть
				item.label = undefined;
				newNode.parentTreeItem = item.parentTreeItem;
				for (let index in newNode.parentTreeItem.children){
					if (newNode.parentTreeItem.children[index] == item) {
						newNode.parentTreeItem.children[index] = newNode;
						break;
					}
				}
				newNode.updateOffset();
			}
			if (this.rootItem == item){
				this.rootItem = this.listItems[item.id];
				this.htmlElement.replaceChild(this.rootItem.view,item.view);
			}
			
			return newNode;
		}
		else console.error("Error type");
	}
	
	setHoverId (id) {
		if (this.hoverId == id) return;
		
		if (id == -1) {
			let item = this.listItems[this.hoverId];
			if (item != undefined) item.setHovered(false);
		}
		else {
			let item = this.listItems[id];
			if (item != undefined) item.setHovered(true);
		}
		
		this.hoverId = id;
		
		this.widget.callSetHover(id);
	}
	
	askTreePosition () {
		let rect =  this.htmlElement.getBoundingClientRect();
		this.myPos.x = rect.x;
		this.myPos.y = rect.y;
		this.myPos.width = rect.width;
		this.myPos.height = rect.height;
	}

	updatePositionTree () {
		this.askTreePosition();
		//ебаный костыль
		for (let id in this.listItems){
			let item = this.listItems[id];
			if (!item.flagCenterSet && item.label != undefined){
				if (item.hardUpdateIconCenter()) {
					item.flagCenterSet = true;
					if (item.line != undefined) {
						item.line.setPoints();
						item.line.update();
					}
				}
			}
		}
	}
	
	animationOnOff (flag) {
		this.animate = flag;
		if (this.rootItem == undefined) return;
		
		function setAnimation (self,flag){
			if (self == undefined) return;
			if (self.getType() == 'node'){
				for (let index in self.children)
					setAnimation(self.children[index],flag);
			}
		};
		
		setAnimation(this.rootItem,flag);
		
		return;
	
	}
	
	setDrawLines (flag){
		if (this.drawLine == flag) return;
		
		this.drawLine = flag;
		for (let id in this.listItems) {
			let item = this.listItems[id];
			if (item == this.rootItem) continue;
			flag ? item.createLine() : item.destroyLine();
		}
	}
	
	updateTreeBySearchStr (searchFilter, fullCompare, register, sections){
		//if (this.rootItem == undefined) return;
		//
		//searchFilter = register ? searchFilter : searchFilter.toLowerCase();
		//
		//this.rootItem.search(searchFilter,fullCompare, register,sections);
		//this.runAnimation();
	}
	
	runAnimation () {
		if (this.animate) {
			if(this.animationId != 0) {
				window.cancelAnimationFrame(this.animationId);
				this.animationId = 0;
			}
			
			let totalTime = 150;
			let startTime = Date.now();
			
			while(this.animationLines.length) {
				let line = this.animationLines.pop();
				if(line.needUpdatePosLine(totalTime)) {
					if (this.linesAnimate.indexOf(line) == -1) {
						this.linesAnimate.push(line);
						if (line.visible) line.lineHtml.style.display = '';
					}
				}
				else 
					line.lineHtml.style.display = line.visible ? '' : 'none';
			}
			
			while(this.animationItems.length) {
				let node = this.animationItems.pop();
				if(node.animationUpdateHeightItems(totalTime)) {
					if (this.areaAnimates.indexOf(node) == -1) this.areaAnimates.push(node);
					if(node.isExpand && node.areaItems.style.display != '')
						node.areaItems.style.display = '';
				}
				else {
					let s1 = node.areaItems.style.display;
					let s2 = node.isExpand ? '' : 'none';
					if (s1 != s2) node.areaItems.style.display = s2;
				}
			}
			
			totalTime = startTime + totalTime;
			let animate = function(startTime, totalTime, linesAnimate, areaAnimates, curtime) {
				let flagLast = false;
				curtime = Date.now();
				
				if(curtime >= totalTime) {
					curtime = totalTime;
					flagLast = true;
				}
				
				let progressTime = curtime - startTime;
				if(progressTime != 0) {
					if (flagLast){
						while (linesAnimate.length){
							let l = linesAnimate.pop();
							
							l.points.p1.x += progressTime * l.koefX1;
							l.points.p1.y += progressTime * l.koefY1;
							l.points.p2.x += progressTime * l.koefX2;
							l.points.p2.y += progressTime * l.koefY2;
							let points = 'M' + l.points.p1.x + ' ' + l.points.p1.y + ' L' + l.points.p1.x + ' ' + l.points.p2.y + ' L' + l.points.p2.x + ' ' + l.points.p2.y;
							l.lineHtml.setAttribute('d', points);
							l.lineHtml.style.display = l.visible ? '' : 'none';
						}
					
						while (areaAnimates.length){
							let n = areaAnimates.pop();

							n.areaHeight.html += progressTime * n.areaHeight.delta;
							n.areaItems.style.height = n.areaHeight.html + 'px';
							n.areaItems.style.display = n.isExpand ? '' : 'none';
						} 
					} 
					else {
						for(let index in linesAnimate) {
							let l = linesAnimate[index];
							l.points.p1.x += progressTime * l.koefX1;
							l.points.p1.y += progressTime * l.koefY1;
							l.points.p2.x += progressTime * l.koefX2;
							l.points.p2.y += progressTime * l.koefY2;
							
							let points = 'M' + l.points.p1.x + ' ' + l.points.p1.y + ' L' + l.points.p1.x + ' ' + l.points.p2.y + ' L' + l.points.p2.x + ' ' + l.points.p2.y;
							l.lineHtml.setAttribute('d', points);
						}
						
						for(let index in areaAnimates) {
							let n = areaAnimates[index];
							
							n.areaHeight.html += progressTime * n.areaHeight.delta;
							n.areaItems.style.height = n.areaHeight.html + 'px';
						}
					}
				}
				
				if(flagLast) {this.animationId = 0;return;}
				startTime = curtime;
				this.animationId = window.requestAnimationFrame(animate.bind(this, startTime, totalTime, linesAnimate, areaAnimates));
			};
			
			if (this.linesAnimate.length || this.areaAnimates.length)
			this.animationId = window.requestAnimationFrame(animate.bind(this, startTime, totalTime, this.linesAnimate, this.areaAnimates));
		}
		else {
			while(this.animationLines.length) {
				let l = this.animationLines.pop();
				
				if (l.needUpdatePosLine(1)){
					l.points.p1.x += l.koefX1;
					l.points.p1.y += l.koefY1;
					l.points.p2.x += l.koefX2;
					l.points.p2.y += l.koefY2;
					let points = 'M' + l.points.p1.x + ' ' + l.points.p1.y + ' L' + l.points.p1.x + ' ' + l.points.p2.y + ' L' + l.points.p2.x + ' ' + l.points.p2.y;
					l.lineHtml.setAttribute('d', points);
				}
				
				l.lineHtml.style.display = l.visible ? '' : 'none';
			}
			
			while(this.animationItems.length) {
				let node = this.animationItems.pop();
				if(node.animationUpdateHeightItems(1)){
					node.areaHeight.html += node.areaHeight.delta;
					node.areaItems.style.height = node.areaHeight.html + 'px';
					node.areaItems.style.display = node.isExpand ? '' : 'none';
				}
			}
		}
		
	}
	
	addAreaAnimate (area) {
		if (this.animationItems.indexOf(area) == -1)
			this.animationItems.push(area);
	}
	
	addLineAnimate (line) {
		if (this.animationLines.indexOf(line) == -1)
			this.animationLines.push(line);
	}
	
	expandCollepseAllItems (flag) {
		
		function tmpFunc (self,flag){
			if (self == undefined) return;
			
			if (self.getType() == "node"){
				flag ? self.expand() : self.collapse();
				self.htmlTree.runAnimation();
				for (let index = self.children.length-1; index>=0; --index) tmpFunc(self.children[index],flag);
			}
		};
		
		tmpFunc(this.rootItem,flag);
	}
}


class TreeItemHtml {
	constructor() {
		
		this.id = undefined;
		this.type = undefined;
		this.line = undefined;
		this.deep = undefined;
		this.label = undefined;
		this.htmlTree = undefined;
		
		this.height = undefined;
		this.editable = undefined;
		this.dragImage = undefined;
		this.isVisible = undefined;
		this.isSelected = undefined;
		this.isHideSearch = undefined;
		this.parentTreeItem = undefined;
		
		//this.bigVisible = {visible : true, search : true};
		//текущий стиль объекта: select, hover, default, unique
		this.style = undefined;
		this.itemStyle = undefined;
		
		this.labelId = undefined;//для загрузки
		
		//html
		this.view = undefined;
		this.icon = undefined;
		this.htmlElement = undefined;
		
		this.flagCenterSet = false;//костыль пока мы не засетили позицию иконки
		this.centerPosIcon = {x: 0, y: 0};
	}
	
	initTreeItem(treeParent, state, type) {
		
		this.type = type;
		// this.isVisible = true;
		this.isHideSearch = false;
		this.htmlTree = treeParent;
		
		if(state.id != undefined) this.id = state.id;
		if(state.depth != undefined) this.deep = state.depth;
		if(state.visible != undefined) this.isVisible = state.visible;
		if(state.select != undefined) this.isSelected = state.select;
		else this.isSelected = false;
		if(state.itemHeight != undefined) this.height = state.itemHeight; else /*debugger;//*/this.height = 40;
		if(state.labelId != undefined) this.labelId = state.labelId;
		if(state.itemStyle != undefined) {
			let style = state.itemStyle;
			if (style == 'default') {
				if (this.type == 'leaf') this.itemStyle = this.htmlTree.defaultLStyle;
				else this.itemStyle = this.htmlTree.defaultNStyle;
			}
			else this.itemStyle = new TreeItemStyle(style,[],this);
			
			this.style = this.isSelected ? this.htmlTree.styleSelect : this.itemStyle;
			// this.style.addItem(this);
		}
		
		//добавили в главное дерево!
		if(this.htmlTree != undefined && this.id != undefined)
			this.htmlTree.listItems[this.id] = this;
		
		this.view = document.createElement("div");
		this.view.classList.add("WidgetTreeItem");
		this.view.width = "100%";
		this.view.height = this.height + 'px';//"40px";
		
		if(this.id != undefined) this.view.id = this.htmlTree.id+'_'+this.id;
		
		this.icon = document.createElement('div');
		
		if(this.id != undefined) this.icon.id = this.htmlTree.id+'_'+this.id;
		
	}
	
	setState(state) {
		if(state.select != undefined) this.setSelected(state.select);
		if(state.itemStyle != undefined) {
			let s = state.itemStyle;
			let defStyle = this.type == 'leaf' ? this.htmlTree.defaultLStyle : this.htmlTree.defaultNStyle;
			if (s == 'default'){
				if (defStyle != this.style ) {
					delete this.itemStyle;
					this.itemStyle = defStyle;
					if (!this.isSelected) {
						this.style = this.itemStyle;
						this.style.addItem(this);
					}
				}
			}
			else {
				if (defStyle == this.style ) {
					this.itemStyle = new TreeItemStyle(s,[],this);
					if (!this.isSelected){
						this.style.removeItem(this);
						this.style = this.itemStyle;
						this.style.addItem(this);
					} 
				}
				else this.itemStyle.setState(s);
			}
		}
		if(state.itemHeight != undefined) this.changeheight(state.itemHeight);
		if(state.dragImage != undefined) this.dragImage = state.dragImage;
	}
	
	destroy() {
		if(this.parentTreeItem != undefined) {
			//парент всегда нода
			
			//удалили html чилда
			this.parentTreeItem.areaItems.removeChild(this.view);
			
			//удалили линию связи TODO
			this.destroyLine();
			//удалили из чилдов 
			this.parentTreeItem.resizeParentHeight(this,-this.height);
			
			for (let index in this.parentTreeItem.children){
				let item = this.parentTreeItem.children[index];
				if (item == this) {
					this.parentTreeItem.children.splice(index,1);
					break;
				}
			}
			//чтоб смог спокойно умереть
			this.label = undefined;
			
		}
		else this.htmlTree.htmlElement.removeChild(this.view);
		
		if (this.htmlTree.rootItem = this) this.htmlTree.rootItem = undefined;
		
		delete this.htmlTree.listItems[this.id];
	}
	
	createLine () {
		if (this.line != undefined || !this.htmlTree.drawLine || this.parentTreeItem == undefined) return false;
		
		this.line = new TreeLine(this.parentTreeItem, this);
	}
	
	destroyLine () {
		if (this.line == undefined) return;
		
		this.line.destroy();
		delete this.line;
		
		this.line = undefined;
	}
	
	getType() {return this.type;}
	
	setParent(treeItem) {
		if(treeItem == undefined || this.parentTreeItem == treeItem) return;
		if(treeItem.getType() == 'leaf') treeItem = this.htmlTree.changeTypeItem(treeItem, 'node');
		
		this.parentTreeItem = treeItem;
		
		this.isVisible = this.parentTreeItem.isVisible && this.parentTreeItem.isExpand;
		if (this.htmlTree.drawLine) this.createLine();
		
		treeItem.addItem(this);
	}
	
	setLabel(label) {
		if(this.label == undefined) this.label = label;
		
		this.htmlElement.appendChild(label.view.htmlElement);
		label.view.htmlElement.style.minHeight = '';
		label.view.htmlElement.style.maxHeight = '';
		if (!this.hardUpdateIconCenter()) return;
		
		this.flagCenterSet = true;
		//try fix error spaces F5
		//чтобы использовать эту штуку надо сначало, застопить анимацию
		if (this.line != undefined /*&& this.line.checkIconsSet()*/) {
			this.line.setPoints();
			this.line.update();
		}
	}
	
	setVisible (visible) {
		if (this.isVisible == visible) return 0;
		
		this.isVisible = visible;
		
		if (this.line != undefined)  (visible) ? this.expandLine() : this.collapseLine();
	}
	
	onSetVisible (visible) {
		return this.height * (visible ? 1 : -1);
	}
	
	setSelected(isSelect) {
		if(this.isSelected == isSelect) return;
		
		this.isSelected = isSelect;
		
		if (this.isSelected) {
			this.style.removeItem(this);
			
			//this.itemStyle = this.style;
			this.style = this.htmlTree.styleSelect;
			this.style.addItem(this);
		}
		else {
			this.style.removeItem(this);
			this.style = this.itemStyle;
			this.style.addItem(this);
		}
	}
	
	setHovered(isHover){
		if (isHover){
			this.style.removeItem(this);
			//костыль на экспанд
			this.style = this.htmlTree.styleHover;
			this.style.leafIcon = this.itemStyle.leafIcon;
			this.style.nodeExpIcon = this.itemStyle.nodeExpIcon;
			this.style.nodeCollapseIcon = this.itemStyle.nodeCollapseIcon;
			//
			this.style.addItem(this);
		}
		else {
			this.style.removeItem(this);
			this.style = (this.isSelected) ? this.htmlTree.styleSelect : this.itemStyle; 
			this.style.addItem(this);
		}
	}
	
	changeheight (h) {
		let deltaH = h - this.height;
		
		this.height = h;
		if (deltaH == 0) return;
		this.htmlElement.style.height = this.height +'px';
		
		if (this.centerPosIcon.y == 0)  this.hardUpdateIconCenter();
		else this.centerPosIcon.y += deltaH/2;
		
		if (this.line != undefined) this.htmlTree.addLineAnimate(this.line);
		this.onUpdateIconCenter(deltaH,0);
		
		if(this.parentTreeItem != undefined)
			this.parentTreeItem.resizeParentHeight(this, deltaH, true);
	}
	
	updateOffset() {
		if(this.icon == undefined) console.error("iconUndefined");
		
		this.icon.style.marginLeft = 15 * this.deep + 'px';
	}
	
	hardUpdateIconCenter () {
		this.centerPosIcon.x = this.deep * this.htmlTree.padding + 15 + 1;
		// if (isNaN(this.centerPosIcon.x)) debugger;
		
		let h = this.height/2; 
		if (this.parentTreeItem != undefined){
			if (this.parentTreeItem.centerPosIcon.y == 0) 
				if (!this.parentTreeItem.hardUpdateIconCenter()) return false;
			h += this.parentTreeItem.centerPosIcon.y + this.parentTreeItem.height/2;
			for (let index in this.parentTreeItem.children){
				let child = this.parentTreeItem.children[index];
				if (child == undefined) debugger;
				if (child == this) break;
				
				if (child.height == undefined) debugger;
				h += child.height;
				if (child.getType() == 'node') {
					if (child.areaHeight.current == undefined) debugger;
					h += child.areaHeight.current;
				}
			}
		}
		else if (this.deep != 0) return false;
		
		if (isNaN(h)) return false;
 		this.centerPosIcon.y = h; 
		if (this.centerPosIcon.y < 0) debugger;
		return true;
	}
	
	updateIconCenter(deltaH, deltaW) {
		// if (this.id == 3 || this.id == 4) debugger;
		//TODO костыль чтобы точно узнать свои координаты; 
		if(!this.flagCenterSet){
			if (!this.hardUpdateIconCenter()) return;
			
			this.flagCenterSet = true;
			if (this.line != undefined) {
				this.line.setPoints();
				this.line.update();
			}
			
			if(deltaH != 0 || deltaW != 0)
				this.onUpdateIconCenter(deltaH, deltaW);
			return;
		}
		
		if(deltaH == 0 && deltaW == 0) return;
		
		if (isNaN(deltaH) || isNaN(deltaW)) debugger;
		
		this.centerPosIcon.x += deltaW;
		this.centerPosIcon.y += deltaH;
		
		if (this.htmlTree.drawLine) this.htmlTree.addLineAnimate(this.line);
		
		this.onUpdateIconCenter(deltaH, deltaW);
	}
	
	onUpdateIconCenter(deltaH, deltaW) {}
	
	applyStyle () {
		if (this.style == undefined) return;
		if (this.htmlElement != undefined){
			this.changeheight(this.height);
			this.htmlElement.style.color = this.style.textColor;
			this.htmlElement.style.backgroundcolor = this.style.backGrounColor;
			this.htmlElement.style.borderToptStyle = this.style.borderType;
			this.htmlElement.style.borderBottomStyle = this.style.borderType;
			this.htmlElement.style.borderRightStyle = this.style.borderType;
			this.htmlElement.style.borderLeftStyle = this.style.borderType;
			
			this.htmlElement.style.borderTopWidth = this.style.borderSize;
			this.htmlElement.style.borderBottomWidth = this.style.borderSize;
			this.htmlElement.style.borderRightWidth = this.style.borderSize;
			this.htmlElement.style.borderLeftWidth = this.style.borderSize;
			
			this.htmlElement.style.borderTopColor = this.style.borderColor;
			this.htmlElement.style.borderBottomColor = this.style.borderColor;
			this.htmlElement.style.borderRightColor = this.style.borderColor;
			this.htmlElement.style.borderLeftColor = this.style.borderColor;
			
			this.htmlElement.style.borderRadius = this.style.borderRadius;
		}
		if (this.icon != undefined) this.icon.style.color = this.style.iconColor;
		
	}
	
	expandLine() {
		if (!this.htmlTree.drawLine) return;
		let flag = !this.isHideSearch;
		
		if(flag && this.parentTreeItem != undefined) {
			flag = this.parentTreeItem.isExpand;
			this.line.setVisible(flag);
		}
		
		if (flag) for(let index in this.children) this.children[index].expandLine();
	}
	
	collapseLine() {
		if (!this.htmlTree.drawLine )return;
		this.line.setVisible(false);
		for(let index in this.children) this.children[index].collapseLine();
	}
	
	initEvents() {
		this.htmlElement.onmouseover = () => {this.htmlTree.setHoverId(this.id);}
		this.htmlElement.onmouseout = () => {this.htmlTree.setHoverId(-1);}
	}
	
	search (textFilter, fullCompare, register, sections) {
		let containText = false;
		if (this.label != undefined){
			let text = this.label.text;
			text = register ? text : text.toLowerCase();
			
			containText = fullCompare ? text == textFilter : text.indexOf(textFilter) != -1;
		}
		
		let retValue = this.onSearch (textFilter, fullCompare, register, sections);
		
		if (containText) retValue.contain = true;
		retValue.deltaH += this.setVisibleSearch(retValue.contain);
		
		return retValue;
	}
	
	setVisibleSearch (visible) {
		this.isHideSearch = !visible;
		
		this.htmlElement.style.display = visible ? '' : 'none';

		if (this.isVisible != visible) {
			
			this.isVisible = visible;
			
			if(this.line != undefined) this.line.setVisible(visible);
			
			return this.onSetVisible(visible);
		}
		this.onSetVisible(visible);
		return 0;//TODO hz hz 
	}
	
	updatePositionDownLines (child, deltaH) {
		let flagUpdateLine = false;
		//находим всех кто под нами и говорим заапдейтить позицию иконки
		for(let index in this.children) {
			let ourChild = this.children[index];
			
			if(flagUpdateLine) ourChild.updateIconCenter(deltaH, 0);
			if(child == ourChild) flagUpdateLine = true;
		}
	}
	
	onSearch (textFilter, fullCompare, register, leafOnly) {
		return {deltaH : 0, contain : false};
	}
}


class TreeLeafHtml extends  TreeItemHtml {
	constructor(treeHtml, state) {
		super();
		
		this.htmlElement = undefined;
		this.initTreeItem(treeHtml, state);
		
		this.style.addItem(this);
	}
	
	initTreeItem(treeHtml, state) {
		super.initTreeItem(treeHtml, state, 'leaf');
		
		this.htmlElement = document.createElement('div');
		this.htmlElement.classList.add('ContainerLeaf');
		this.htmlElement.style.height = this.height + 'px';
		this.view.appendChild(this.htmlElement);
		
		this.icon.classList.add('IconLeaf');
		// this.icon.innerText = (state.iconText != undefined) ? state.iconText : 'adjust';
		this.htmlElement.appendChild(this.icon);
		this.applyStyle();
		
		this.initEvents();
		
		//если нету парента, то свяжемся через чилдов парента
		if(state.parentId != undefined && state.parentId != -1) {
			let parentId = state.parentId;
			let parentItem = this.htmlTree.listItems[parentId];
			if(parentItem != undefined) {
				this.setParent(parentItem);
				if(this.parentTreeItem == undefined) {
					console.error("ERROR setParent Undefined");
					return;
				}
			}
		}
		
		//если нету еще лейбла то в каждом update будем искать пока не найдем =0
		if(Rex.widgets != undefined)
			if(Rex.widgets[this.labelId] != undefined)
				this.setLabel(Rex.widgets[this.labelId]);
		
		this.updateIconCenter(0,0);
	}
	
	applyStyle () {
		super.applyStyle();
		
		if (this.icon != undefined)
			this.icon.textContent = this.style.leafIcon;
	}
	initEvents() {
		this.htmlElement.onmouseover = () => {this.htmlTree.setHoverId(this.id);}
		this.htmlElement.onmouseout = () => {this.htmlTree.setHoverId(-1);}
	}
	
	setState(state) {
		super.setState(state);
		if (state.iconText != undefined) this.icon.textContent = state.iconText;
	}
}



class TreeLine {
	constructor (parent, child) {
		this.namespaceURL = decodeURIComponent(escape(window.atob("aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc=")));
		
		this.id = child.id;
		
		this.lineSVG = document.createElementNS(this.namespaceURL, "svg");
		this.lineHtml = document.createElementNS(this.namespaceURL, "path");
		
		this.lineSVG.classList.add("LineSVG");
		this.lineSVG.appendChild(this.lineHtml);
		
		this.lineHtml.setAttribute('fill','rgba(0,0,0,0)');

		this.parent = parent;
		this.child = child;
		this.tree = this.parent.htmlTree;
		
		this.width = this.tree.lineStyle.width;
		this.color = this.tree.lineStyle.color;
		
		this.points = {
			p1 : {x : 0, y : 0},
			p2 : {x : 0, y : 0}
		}
		this.visible = child.isVisible;
		
		this.animationId = 0;
		
		this.koefX1 = undefined;
		this.koefY1 = undefined;
		this.koefX2 = undefined;
		this.koefY2 = undefined;
		
		this.tree.htmlElement.appendChild(this.lineSVG);
		
		this.lineHtml.style.display = (child.isVisible) ? '' : 'none';
		if (this.parent && this.child) this.lineSVG.id = this.parent.id + 'to' + this.child.id;
		this.update();
	}
	
	destroy () {
		this.lineSVG.remove();
	}
	
	setColor (colorStr) {
		if (colorStr == this.color) return;
		this.color = colorStr;
		this.update();
	}
	
	setWidth (width) {
		if (width == this.width) return;
		this.width == width;
		this.update();
	}
	
	setVisible (visible) {
		if (this.visible == visible) return;
		this.visible = visible;
		
		this.tree.addLineAnimate(this);
	}
	
	update () {
		if (this.lineHtml.getAttribute('stroke-width') != this.width)
			this.lineHtml.setAttribute('stroke-width',this.width);
		if (this.lineHtml.getAttribute('stroke') != this.color)
			this.lineHtml.setAttribute('stroke',this.color);
	}
	
	setPoints () {
		let ok = true;
		if (!isNaN(this.parent.centerPosIcon.x) && !isNaN(this.parent.centerPosIcon.y)) {
			this.points.p1.x = this.parent.centerPosIcon.x;
			this.points.p1.y = this.parent.centerPosIcon.y;
		}else ok = false;
		
		if (!isNaN(this.child.centerPosIcon.x) && !isNaN(this.child.centerPosIcon.y)) {
			this.points.p2.x = this.child.centerPosIcon.x;
			this.points.p2.y = this.child.centerPosIcon.y;
		}else ok = false;
		
		if (!ok) console.error("Error centerPos");
		
		if (isNaN(this.points.p1.x) || isNaN(this.points.p1.y) ||
			isNaN(this.points.p2.x) || isNaN(this.points.p2.y)){
			console.error("Error Nan");
			return;
		}
		let points = 'M' + this.points.p1.x +' '+this.points.p1.y
			+' L'+ this.points.p1.x +' '+this.points.p2.y
			+' L'+ this.points.p2.x +' '+this.points.p2.y;
		this.lineHtml.setAttribute('d',points);
	}
	
	needUpdatePosLine (totalTime) {
		this.koefX1 = (this.parent.centerPosIcon.x - this.points.p1.x)/totalTime;
		this.koefY1 = (this.parent.centerPosIcon.y - this.points.p1.y)/totalTime;
		this.koefX2 = (this.child.centerPosIcon.x - this.points.p2.x)/totalTime;
		this.koefY2 = (this.child.centerPosIcon.y - this.points.p2.y)/totalTime;
		if (isNaN(this.koefX1) || isNaN(this.koefY1) || isNaN(this.koefX2) || isNaN(this.koefY2)) {console.error("Error Nan"); return false;}
		return (this.koefX1 != 0 || this.koefY1 != 0 || this.koefY1 != 0 || this.koefY2 != 0);
	}
	
	runAnimationLine (p1DeltaX,p1DeltaY,p2DeltaX,p2DeltaY) {
		
		let totalTime = 150;
		let startTime = Date.now();
		
		let koefX1 = p1DeltaX/totalTime;
		let koefY1 = p1DeltaY/totalTime;
		let koefX2 = p2DeltaX/totalTime;
		let koefY2 = p2DeltaY/totalTime;
		
		let lineAnimate = function(startTime, totalTime, koefX1, koefY1, koefX2, koefY2,curtime){
			let flagLast = false;
			curtime = Date.now();
			
			if (curtime >= totalTime) {curtime = totalTime; flagLast = true;}
			
			let progressTime = curtime - startTime;
			if (progressTime != 0) {
				this.points.p1.x += progressTime * koefX1;
				this.points.p1.y += progressTime * koefY1;
				this.points.p2.x += progressTime * koefX2;
				this.points.p2.y += progressTime * koefY2;
				
				let points = 'M' + this.points.p1.x + ' ' + this.points.p1.y + ' L' + this.points.p1.x + ' ' + this.points.p2.y + ' L' + this.points.p2.x + ' ' + this.points.p2.y;
				this.lineHtml.setAttribute('d', points);
			}
			
			if (flagLast) return;
			startTime = curtime;
			this.animationId = window.requestAnimationFrame(lineAnimate.bind(this,startTime, totalTime, koefX1, koefY1, koefX2, koefY2));
		};
		
		totalTime = startTime + totalTime;
		this.animationId = window.requestAnimationFrame(lineAnimate.bind(this,startTime,totalTime,koefX1,koefY1,koefX2,koefY2));
	}
	
	checkIconsSet () {
		if (this.parent == undefined || this.child == undefined) return false;
		return this.parent.flagCenterSet && this.child.flagCenterSet;
	}
}


class TreeNodeHtml extends  TreeItemHtml {
	constructor(treeHtml, state) {
		super();
		
		this.children = undefined;//treeItems
		this.childrenIds = undefined;//temporary array for insert objects
		this.isExpand = undefined;
		this.areaItems = undefined;//html node
		this.areaHeight = undefined;
		this.htmlElement = undefined;//html node
		this.needUpdateHeight = undefined;
		
		this.initTreeItem(treeHtml, state);
		
		this.style.addItem(this);
	}
	
	initTreeItem(treeHtml, state) {
		super.initTreeItem(treeHtml, state, "node");
		
		this.children = [];
		this.isExpand = true;
		this.areaHeight = {
			current: 0,
			delta : 0,
			html : 0,
			search: 0 //вся высота поиска
		};
		this.needUpdateHeight = true;
		
		//создали контейнер для иконки и лейбла
		this.htmlElement = document.createElement("div");
		this.htmlElement.classList.add('ContainerNode');
		this.htmlElement.style.height = this.height + 'px';
		this.view.appendChild(this.htmlElement);
		
		//создали div для чилдов итемов
		this.areaItems = document.createElement("div");
		this.areaItems.classList.add('AreaItems');
		this.view.appendChild(this.areaItems);
		
		//заинитили иконку
		this.icon.classList.add('IconNode');
		// this.icon.style.fontFamily = 'Material Icons';
		this.htmlElement.appendChild(this.icon);
		
		//если нету еще лейбла то в каждом update будем искать пока не найдем =0
		if(Rex.widgets != undefined && Rex.widgets[this.labelId] != undefined)
			this.setLabel(Rex.widgets[this.labelId]);
		
		//развернуто или нет?
		if(state.expanded != undefined) {
			this.isExpand = state.expanded;
			this.icon.innerText = this.isExpand ? this.style.nodeExpIcon : this.style.nodeCollapseIcon;
		}
		else {
			this.isExpand = false;
			this.icon.innerText = this.style.nodeExpIcon;
		}

		if (state.children != undefined) 
			this.childrenIds = state.children;
		else 
			this.childrenIds = [];
		
		//пробуем добавить чилдов вдруг они уже создались
		if(state.children != undefined) 
			for(let id of state.children)
				if(this.htmlTree.listItems[id] != undefined)
					this.addItem(this.htmlTree.listItems[id]);
		
		//если нету парента, то свяжемся через чилдов парента
		if(state.parentId != undefined && state.parentId != -1) {
			let parentId = state.parentId;
			let parentItem = this.htmlTree.listItems[parentId];
			if(parentItem != undefined) this.setParent(parentItem);
		}
		
		this.initEvents();
		this.applyStyle();
		
		this.updateIconCenter(0,0);
	}
	
	applyStyle() {
		super.applyStyle();
		
		if (this.icon != undefined) {
			if(this.isExpand) this.icon.innerText = this.style.nodeExpIcon;
			else this.icon.innerText = this.style.nodeCollapseIcon;
		}
		this.areaItems.style.backgroundcolor = this.style.areaColor;
	}
	
	setState(state) {
		super.setState(state);
		if(state.expanded != undefined) {
			if(this.isExpand != state.expanded)
				this.isExpand ? this.collapse() : this.expand();
		}
		if(state.children != undefined) {
			this.childrenIds = state.children;
	}
	
	}
	destroy () {
		while(this.children.length) {
			// удаляем чилда
			this.children[this.children.length-1].destroy();
			// удаляем id из чилдов
		}
		super.destroy();
	}
	
	onSetVisible (visible) {
		if (visible) {
			this.icon.innerText = this.style.nodeExpIcon;
			this.isExpand = true;
		}
		else this.style.nodeCollapseIcon;
		
		return super.onSetVisible(visible);
	}
	
	addItem(treeItem) {
		if(treeItem == undefined || treeItem.id == undefined) return;
		
		//если у нас есть такой чилд то проверим парента
		if(this.children.indexOf(treeItem) != -1) {
			treeItem.setParent(this);
			return;
		}
		
		{
			let indexOf = this.childrenIds.indexOf(treeItem.id);
			if (indexOf == -1 || indexOf >= this.children.length || this.childrenIds.length == 0) {
		//Добавили в чилды к паренту
		this.children.push(treeItem);
		
		//Добавили в div <htmlView>
		this.areaItems.appendChild(treeItem.view);
			}
			else {
				this.children.splice(indexOf,0,treeItem);
				this.areaItems.insertBefore(treeItem.view,this.children[++indexOf].view);
			}
		}
		if (this.children.length == 1) {
			this.areaHeight.html = 0;
			this.areaItems.style.height = '0px';
		}
		
		//обновили величину смещения
		treeItem.updateOffset();
		treeItem.setParent(this);
		
		// Обновляем суммарную высоту//TODO a надо?
		// let selfToParent = this;

		this.htmlTree.addAreaAnimate(this);
		//Обновляем высоты парентов и перерисовываем все линии снизу
		
		this.resizeParentHeight(treeItem, treeItem.height);
	}
	
	expand() {
		if(this.isExpand) return;
		this.isExpand = true;
		
		//меняем нашу иконку
		this.icon.textContent = this.style.nodeExpIcon;
		
		//если нас скрыли, но пытаются раскрыть со скрипта тупо уходим
		if (this.isHideSearch) return;
		
		//здесь мы точно не скрыты => нам надо получить всюююю высоту наших итемов
		//но часть из них может быть скрыта
		//TODO идти по чилдам и брать высоту?? нахуй тогда поле высота????
		
		let deltaH = 0;
		
		let allExpand = true;
		let self = this.parentTreeItem;
		while (self != undefined) {
			if(!self.isExpand) {
				allExpand = false;
				break;
			}
			self = self.parentTreeItem;
		}
		
		for (let id in this.children){
			let child = this.children[id];
			if (child.isHideSearch) continue;
			
			//раскрыли линии
			if (allExpand) child.setVisible(true);
			
			deltaH += child.height;
			// child.updateIconCenter(deltaH,0);
			if (child.getType() == 'node' && child.isExpand) deltaH += child.areaHeight.current;
		}
		
		if (deltaH != 0) {
			this.areaHeight.current += deltaH;
			this.htmlTree.addAreaAnimate(this);
			
			if(this.parentTreeItem != undefined) this.parentTreeItem.resizeParentHeight(this, deltaH);
		}
	}
	
	collapse() {
		//хотим свернуть item
		//что надо проверить?
		//если все паренты развернуты и видимы, то у всех будем менять высоту на суммарную высоту наших итемов (deltaH)
		//если один из парентов свернут, то нас не видно и наше состояние поменяли через скрипт
		//если развернуты не все, то будем менять у всех развернутых пока не найдем свернутый, чтобы
		//когда мы развернули тот который свернут все было на своих местах
		
		//если нас спрятал поиск, то наша высота должна быть 0, но высота разворота может быть не 0 и нам надо её изменть
		//если он спрятал только часть наших итемов, то от текущей мы должны отнять только их высоту
		if(!this.isExpand /*|| !this.editable*/) return;
		this.isExpand = false;
		
		//меняем нашу иконку
		this.icon.textContent = this.style.nodeCollapseIcon;
		
		let deltaHItemArea = 0;
		let deltaH = this.areaHeight.current;
		this.areaHeight.current = 0;
		
		if (this.isHideSearch) {if (deltaH != 0) console.error("Error deltaH чет сбилось"); /*debugger;*/}
		else {
			//скрываем все линии чилдов
			for(let id in this.children) {
				let child = this.children[id];
				
				//если чилда спрятал поиск
				if(child.isHideSearch) continue;
				
				child.setVisible(false);
				
				// deltaHItemArea = child.centerPosIcon.y - this.centerPosIcon.y;
				// child.updateIconCenter(-deltaHItemArea, 0);
			}
		}
		
		//засетить div'у высоту
		this.htmlTree.addAreaAnimate(this);
		
		//у всех меняем current height и обновляем позиции линий
		if(this.parentTreeItem != undefined && deltaH != 0) 
			this.parentTreeItem.resizeParentHeight(this, -deltaH);
	}
	
	resizeParentHeight(child, deltaH, kostil) {
		//TODO ИЗМЕНИТЬ ПОЗИЦИЮ ЕБАНЫХ ЛИНИЙ
		if (!this.isExpand){
			if (kostil != undefined){
				let flagUpdateLine = false;
				for(let index in this.children) {
					let ourChild = this.children[index];
					
					if(flagUpdateLine) ourChild.updateIconCenter(deltaH, 0);
					if(child == ourChild) flagUpdateLine = true;
				}
			}
				
			// let flagUpdateLine = false;//TODO updatePositionDownLines
			// //находим всех кто под нами и говорим заапдейтить позицию иконки
			// for(let index in this.children) {
			// 	let ourChild = this.children[index];
			//	
			// 	if(flagUpdateLine) ourChild.updateIconCenter(deltaH, 0);
			// 	if(child == ourChild) flagUpdateLine = true;
			// }
			//
			return;
		}
		
		let flagUpdateLine = false;//TODO updatePositionDownLines
		//находим всех кто под нами и говорим заапдейтить позицию иконки
		for(let index in this.children) {
			let ourChild = this.children[index];
			
			if(flagUpdateLine) ourChild.updateIconCenter(deltaH, 0);
			if(child == ourChild) flagUpdateLine = true;
		}
		
		//меняем нашу высоту
		this.areaHeight.current += deltaH;
		this.htmlTree.addAreaAnimate(this);
		
		//если у нас есть парент то говорим ему пересчитать высоту diva и позиции линий
		if(this.parentTreeItem != undefined)
			this.parentTreeItem.resizeParentHeight(this, deltaH,kostil);
	}
	
	onUpdateIconCenter(deltaH, deltaW) {
		for (let index in this.children)
			this.children[index].updateIconCenter(deltaH,deltaW);
	}

	onSearch (textFilter, fullCompare, register, sections) {
		let retValue = {deltaH : 0, contain : false};
		
		//TODO !!!!!!!!!!!!!!!!!!!!!! KOSTIL !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//надо как то узнать у свернутых на сколько смещать ебаную линию
		//а в пизду на производительность все разверну =(
		if (!this.isExpand) this.expand();
		
		for (let index = this.children.length-1; index >= 0; --index){
			let child = this.children[index];
			
			let retChildValue = child.search(textFilter, fullCompare, register, sections);
			retValue.deltaH += retChildValue.deltaH;
			if (retChildValue.contain) retValue.contain = true;

			if (retChildValue.deltaH != 0) this.updatePositionDownLines(child, retChildValue.deltaH);
			// else if (!this.isExpand) {//TODO !!!!!!!!!!!!!!!!!!!!!! KOSTIL !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			// 	let tmpH = child.height;
			// 	if (child.getType() == 'node') tmpH += child.areaHeight.current; 
			// 	this.updatePositionDownLines(child, -tmpH);
			// }
		}
		//меняем нашу высоту
		this.areaHeight.current += retValue.deltaH;
		this.htmlTree.addAreaAnimate(this);
		
		return retValue;
	}
	
	animationUpdateHeightItems (totalTime) {
		this.areaHeight.delta = (this.areaHeight.current-this.areaHeight.html)/totalTime;
		return this.areaHeight.delta != 0;
	}
	
}


class TreeItemStyle {
	constructor (state, items, tree) {
		this._$tree = tree;
		this.items = items;
		
		this._$height = undefined;
		
		this._$textColor = undefined;
		this._$iconColor = undefined;
		this._$areaColor = undefined;
		this._$backGrounColor = undefined;
		
		this._$leafIcon = undefined;
		this._$nodeExpIcon = undefined;
		this._$nodeCollapseIcon = undefined;
		
		this._$editable = undefined;
		this._$draggable = undefined;
		
		this._$dragImage = undefined;
		this._$borderType = undefined;
		this._$borderSize = undefined;
		this._$borderColor = undefined;
		
		this._$borderRadius = undefined;
		
		this.init(state);
	}
	
	addItem (item) {
		if (this.items.indexOf(item) != -1) {
			debugger;
			return ;
		}
		
		this.items.push(item);
		if (item.htmlElement == undefined || item.icon == undefined) return;
		
		if (this.height != undefined) item.changeheight(this.height);
		item.htmlElement.style.color = this.textColor;
		
		if (this.iconColor != undefined)
		item.icon.style.color = this.iconColor;
		
		if (this.backGrounColor != undefined)
		item.htmlElement.style.background = this.backGrounColor;
		
		if (item.getType() == 'leaf') {
			if(this.leafIcon != undefined)
				item.icon.innerText = this.leafIcon;
		}
		else {
			item.areaItems.style.background = this.areaColor;
			if(item.isExpand) {
				if(this.nodeExpIcon != undefined)
					item.icon.innerText = this.nodeExpIcon;
			}
			else {
				if (this.nodeCollapseIcon != undefined)
					item.icon.innerText = this.nodeCollapseIcon;
			}
		}
		
		if (this.borderType != undefined && this.borderSize != undefined && this.borderSize != undefined) {
			item.htmlElement.style.borderTopStyle = this.borderType;
			item.htmlElement.style.borderBottomStyle = this.borderType;
			item.htmlElement.style.borderRightStyle = this.borderType;
			item.htmlElement.style.borderLeftStyle = this.borderType;
			
			
			item.htmlElement.style.borderTopWidth = this.borderSize;
			item.htmlElement.style.borderBottomWidth = this.borderSize;
			item.htmlElement.style.borderRightWidth = this.borderSize;
			item.htmlElement.style.borderLeftWidth = this.borderSize;
			
			item.htmlElement.style.borderTopColor = this.borderColor;
			item.htmlElement.style.borderBottomColor = this.borderColor;
			item.htmlElement.style.borderRightColor = this.borderColor;
			item.htmlElement.style.borderLeftColor = this.borderColor;
			if (this.borderRadius != undefined)
				item.htmlElement.style.borderRadius = this.borderRadius;
		}
	}
	
	removeItem (item) {
		for (let index in this.items) {
			if(this.items[index].id == item.id) {
				this.items.splice(index, 1);
				return true;
			}
		}
		return false;
	}
	
	get height () {return this._$height;}
	set height (h) {
		if (this._$height == h) return;
		
		this._$height = h;
		for (let id in this.items){
			let item = this.items[id];
			item.changeheight(this.height);
		}
	}
	
	get textColor () {return this._$textColor;}
	set textColor (color) {
		if (this._$textColor == color) return;
		
		this._$textColor = color;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined)
				item.htmlElement.style.color = this.textColor;
		}
	}
	get iconColor () {return this._$iconColor;}
	set iconColor (color) {
		if (this._$iconColor == color) return;
		
		this._$iconColor = color;
		for (let id in this.items){
			let item = this.items[id];
			if (item.icon != undefined)
				item.icon.style.color = this.iconColor;
		}
	}
	
	get areaColor () {return this._$areaColor;}
	set areaColor (color) {
		if (this._$areaColor == color) return;
		
		this._$areaColor = color;
		for (let id in this.items){
			let item = this.items[id];
			if (item.getType() == 'leaf') continue;
			if (item.areaItems != undefined)
				item.areaItems.style.backgroundcolor = this.areaColor;
		}
	}
	
	get backGrounColor () {return this._$backGrounColor;}
	set backGrounColor (color) {
		if (this._$backGrounColor == color) return;
		
		this._$backGrounColor = color;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined)
				item.htmlElement.style.background = this.backGrounColor;
		}
	}
	
	get leafIcon () {return this._$leafIcon;}
	set leafIcon (icon) {
		if (this._$leafIcon == icon) return;
		
		this._$leafIcon = icon;
		for (let id in this.items){
			let item = this.items[id];
			if (item.getType() != 'leaf') continue;
			if (item.icon != undefined)
				item.icon.innerText = this.leafIcon;
		}
	}
	
	get nodeExpIcon () {return this._$nodeExpIcon;}
	set nodeExpIcon (icon) {
		if (this._$nodeExpIcon == icon) return;
		
		this._$nodeExpIcon = icon;
		for (let id in this.items){
			let item = this.items[id];
			if (item.getType() == 'leaf') continue;
			 
			if (item.icon != undefined && item.isExpand)
				item.icon.innerText = this.nodeExpIcon;
		}
	}
	
	get nodeCollapseIcon () {return this._$nodeCollapseIcon;}
	set nodeCollapseIcon (icon) {
		if (this._$nodeCollapseIcon == icon) return;
		
		this._$nodeCollapseIcon = icon;
		for (let id in this.items){
			let item = this.items[id];
			if (item.getType() == 'leaf') continue;
			
			if (item.icon != undefined && !item.isExpand)
				item.icon.innerText = this.nodeCollapseIcon;
		}
	}
	
	get borderType () {return this._$borderType;}
	set borderType (type) {
		if (this._$borderType == type) return;
		
		this._$borderType = type;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined) {
				item.htmlElement.style.borderTopStyle = this.borderType;
				item.htmlElement.style.borderBottomStyle = this.borderType;
				item.htmlElement.style.borderRightStyle = this.borderType;
				item.htmlElement.style.borderLeftStyle = this.borderType;
			}
		}
	}
	get borderSize () {return this._$borderSize;}
	set borderSize (size) {
		if (this._$borderSize == size) return;
	
		this._$borderSize = size;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined) {
				item.htmlElement.style.borderTopWidth = this.borderSize;
				item.htmlElement.style.borderBottomWidth = this.borderSize;
				item.htmlElement.style.borderRightWidth = this.borderSize;
				item.htmlElement.style.borderLeftWidth = this.borderSize;
			}
		}
	}
	
	get borderColor () {return this._$borderColor;}
	set borderColor (color) {
		if (this._$borderColor == color) return;
		
		this._$borderColor = color;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined) {
				item.htmlElement.style.borderTopColor = this.borderColor;
				item.htmlElement.style.borderBottomColor = this.borderColor;
				item.htmlElement.style.borderRightColor = this.borderColor;
				item.htmlElement.style.borderLeftColor = this.borderColor;
			}
		}
	}
	
	get borderRadius () {return this._$borderRadius;}
	set borderRadius (radius) {
		if (this._$borderRadius == radius) return;
		
		this._$borderRadius = radius;
		for (let id in this.items){
			let item = this.items[id];
			if (item.htmlElement != undefined)
				item.htmlElement.style.borderRadius = this.borderRadius;
		}
	}
	

	
	init (state) {
		if (state.height != undefined) this.height = state.height;
		
		if (state.textColor != undefined) this.textColor = state.textColor;
		// else this.textColor = 'black';
		if (state.iconColor != undefined) this.iconColor = state.iconColor;
		// else this.iconColor = 'var(--main-color)'
		if (state.areaColor != undefined) this.areaColor = state.areaColor;
		// else this.areaColor = '';
		if (state.backGrounColor != undefined) this.backGrounColor = state.backGrounColor;
		// else this.backGrounColor = 'white';
		
		if (state.textIcon != undefined) this.leafIcon = state.textIcon;
		else this.leafIcon = undefined;
		if (state.textIconExpand != undefined) this.nodeExpIcon = state.textIconExpand;
		else this.nodeExpIcon = undefined;
		if (state.textIconCollapse != undefined) this.nodeCollapseIcon = state.textIconCollapse;
		else this.nodeCollapseIcon = undefined;
		
		if (state.visible != undefined) this.visible = state.visible;
		else this.visible = true;
		if (state.editable != undefined) this.editable = state.editable;
		else this.editable = true;
		if (state.draggable != undefined) this.draggable = state.draggable;
		else this.draggable = true;
		if (state.dragImage != undefined) this.dragImage = state.dragImage;
		else this.dragImage = '';
		
		if (state.borderType != undefined) this.borderType = state.borderType;
		// else this.borderType = 'none';
		if (state.borderSize != undefined) this.borderSize = state.borderSize;
		// else this.borderSize = 0; 
		if (state.borderColor != undefined) this.borderColor = state.borderColor;
		// else this.borderColor = 'var(--main-color)';
		if (state.borderRadius != undefined) this.borderRadius = state.borderRadius;
		// else this.borderRadius = 0;
		
	}
	
	setState (state) {
		if (state.height != undefined) this.height = state.height;
		
		if (state.textColor != undefined) this.textColor = state.textColor;
		if (state.iconColor != undefined) this.iconColor = state.iconColor;
		if (state.areaColor != undefined) this.areaColor = state.areaColor;
		if (state.backGrounColor != undefined) this.backGrounColor = state.backGrounColor;
		
		if (state.textIcon != undefined) this.leafIcon = state.textIcon;
		if (state.textIconExpand != undefined) this.nodeExpIcon = state.textIconExpand;
		if (state.textIconCollapse != undefined) this.nodeCollapseIcon = state.textIconCollapse;
		
		if (state.editable != undefined) this.editable = state.editable;
		if (state.draggable != undefined) this.draggable = state.draggable;
		if (state.dragImage != undefined) this.dragImage = state.dragImage;
		
		if (state.borderType != undefined) this.borderType = state.borderType;
		if (state.borderSize != undefined) this.borderSize = state.borderSize;
		if (state.borderColor != undefined) this.borderColor = state.borderColor;
		if (state.borderRadius != undefined) this.borderRadius = state.borderRadius;
		
	}
}

/**
 * WidgetGantt
 */

var GanttDateFormat = {
	ddmmyyyy	: 0,
	mmddyyyy	: 1,
	yyyymmdd	: 2,
	yyyyddmm	: 3,
	ddmmyy		: 4,
	mmddyy		: 5,
	yymmdd		: 6,
	yyddmm		: 7,
	ddmm		:8
};

var FormatDateProcess = {
	Day		: 0,
	Week	: 1,
	Month	: 2,
	Quarter	: 3,
	Minute	: 4,
	Hour	: 5
};

class GanttTaskHtml extends WidgetViewHtml {
	constructor(widget) {
		super(widget);
		this.iconText = "";
		this.createDomElement("div");
		this.addClassName("WidgetGanttTask");
		this._expandIcon = "keyboard_arrow_down";
		this._noExpandIcon = "keyboard_arrow_right";
		
		this.htmlContainer = document.createElement("div");
		this.htmlContainer.classList.add("GanttTaskContainer");
		this.htmlElement.appendChild(this.htmlContainer);
		
		this.nameTd = document.createElement("td");
		this.htmlIcon = document.createElement("div");
		this.htmlIcon.classList.add("GanttTaskIcon");
		this.nameLabel = document.createElement("div");
		this.nameTd.classList.add("GanttName");
		this.nameTd.appendChild(this.htmlIcon);
		this.nameTd.appendChild(this.nameLabel);
		this.resLabel = document.createElement("td");
		this.resLabel .classList.add("GanttName-p");
		this.durLabel = document.createElement("td");
		this.durLabel .classList.add("GanttName-p");
		this.compLabel = document.createElement("td");
		this.compLabel .classList.add("GanttName-p");
		this.startLabel = document.createElement("td");
		this.startLabel .classList.add("GanttName-p");
		this.endLabel = document.createElement("td");
		this.endLabel .classList.add("GanttName-p");
		this.nameLabel.addEventListener('dblclick', e => {
			this.mouseDoubleClick(e);
		});
		this.nameLabel.addEventListener('mouseenter', e => {
			if(this.htmlElement != e.target && this.nameLabel != e.target) return;
			this.widget.setHovered(true);
		});
		this.nameLabel.addEventListener('mouseleave', e => {
			if(this.htmlElement != e.target && this.nameLabel != e.target) return;
			this.widget.setHovered(false);
		});
		
		this.nameLabel.addEventListener('drop',e => {
			if(this.gantt.dragTask && this.gantt.dragTask.id !== this.id && this.gantt.dragTask.parentId !== this.id) Rex.callRpcMethod('Widgets', this.gantt.id, 'WidgetGantt', 'setParentTask', [this.gantt.dragTask.id , this.id]);
			this.gantt.dragTask = null;
		});
		this.htmlContainer.draggable = true;
		this.htmlContainer.addEventListener('dragstart',e => {
			if(this.gantt) this.gantt.dragTask = this;
		});
		this.htmlContainer.addEventListener('dragend',e => {
			if(this.gantt.dragTask && this.gantt.dragTask.parentId !== -1) Rex.callRpcMethod('Widgets', this.gantt.id, 'WidgetGantt', 'setParentTask', [this.gantt.dragTask.id , -1]);
			this.gantt.dragTask = null;
		});
	}
	
	onDestroy() {
		if((this.widget.parent != null) && (this.widget.parent.children.length == 1)) {
			this.widget.parent.view.htmlElement.classList.remove("Parent");
			this.widget.parent.view.htmlIcon.textContent = this.widget.parent.view.iconText;
		}
	}
	
	setParent(id) {
		let parent = this.widget.gantt.tasks.get(id);
		if(parent == null) this.onInit(this.widget.gantt.view.htmlElement);
		else {
			this.onInit(parent.view.htmlElement);
			parent.view.htmlElement.classList.add("Parent");
			parent.view.htmlElement.classList.remove("NoParent");
			parent.view.htmlIcon.textContent = this.expandIcon;
		}
	}
	
	set expandIcon(value) {
		if(this._expandIcon == value && this.widget.expandIcon == value) return;
		this.widget.expandIcon = value;
		this._expandIcon = value;
	}
	
	get expandIcon() {return this._expandIcon;}
	
	set noExpandIcon(value) {
		if(this._noExpandIcon == value && this.widget.noExpandIcon == value) return;
		this.widget.noExpandIcon = value;
		this._noExpandIcon = value;
	}
	
	get noExpandIcon() {return this._noExpandIcon;}
	
	set parentId(value) {
		if(this.parentId == value) return;
		let parent = this.widget.gantt.tasks.get(value);
		this.widget.parent = parent;
		if(parent == null) this.onInit(this.widget.gantt.view.htmlElement);
		else {
			this.onInit(parent.view.htmlElement);
			parent.view.htmlElement.classList.add("Parent");
			parent.view.htmlElement.classList.remove("NoParent");
		}
		this.widget.parentId = value;
		if(!this.widget.gantt.inited) return;
		this.setParent(value);
	}
	
	get parentId() {return this.widget.parentId;}
	
	set id(value) {
		if(this.widget.id == value && this.htmlElement.id != "undefined") return;
		this.widget.id = value;
		this.htmlElement.id = `${this.gantt.id}_${value}`;
	}
	
	get id() {return this.widget.id;}
	
	set expanded(value) {
		if(this.expanded == value && this.widget.expanded == value) return;
		this.widget.expanded = value;
		if(!this.widget.gantt.inited) return;
		if(value) {
			this.htmlElement.classList.add("Expand");
			this.htmlElement.classList.remove("NoExpand");
			if(this.htmlElement.classList.contains("Parent")) this.htmlIcon.textContent = this.iconText === "" ? this.expandIcon : this.iconText;
		} else {
			this.htmlElement.classList.add("NoExpand");
			this.htmlElement.classList.remove("Expand");
			if(this.htmlElement.classList.contains("Parent")) this.htmlIcon.textContent =this.iconText === "" ?  this.noExpandIcon : this.iconText;
		}
		for(let child of this.children){
			let taskChild = this.gantt.tasks.get(child);
			taskChild.visible = value;
		}
	}
	
	get expanded() {return this.widget.expanded;}
	
	set gantt(_gantt) {
		if(this.gantt == _gantt) return;
		this.widget.gantt = _gantt;
	}
	
	get gantt() {return this.widget.gantt;}
	
	set name(value) {
		if((value == null) || (this.widget.name == value)) return;
		this.widget.name = value;
		this.nameLabel.innerText = value;
		if(value.length > 13){
			this.nameLabel.title = value;
			this.nameLabel.innerText = value.substring(0, 11) + "...";
		}
	}
	
	get name() {return this.widget.name;}
	
	set res(value) {
		if((value == null) || (this.widget.res == value)) return;
		this.widget.res = value;
		this.resLabel.innerText = value;
		if(value.length > 13){
			this.resLabel.title = value;
			this.resLabel.innerText = value.substring(0, 11) + "...";
		}
	}
	
	get res() {return this.widget.res;}
	
	set comp(value) {
		if((value == null) || (this.widget.comp == value)) return;
		this.widget.comp = !value ? 0 : value;
		this.compLabel.innerText = !value ? "0%" : value + '%';
	}
	
	get comp() {return this.widget.comp;}
	
	set start(value) {
		if((value == null) || (this.widget.start == value)) return;
		this.widget.start = this.gantt.parseDateStr(value, this.gantt.dateDisplayFormat);
		if(this.startTime != null){
			let time = this.startTime.split(":");
			if(this.widget.start.getHours() != time[0] || this.widget.start.getMinutes() != time[1]) {
				this.widget.start.setHours(time[0]);
				this.widget.start.setMinutes(time[1]);
			}
		}
		this.startLabel.innerText = this.gantt.view.formatDateStr(this.widget.start, this.gantt.dateDisplayFormat, FormatDateProcess.Day);
	}
	
	get start() {return this.widget.start;}
	
	set startTime(value) {
		if((value == null) || (this.widget.startTime == value)) return;
		this.widget.startTime = value;
		let time = value.split(":");
		this.widget.start.setHours(time[0]);
		this.widget.start.setMinutes(time[1]);
	}
	
	get startTime() {return this.widget.startTime;}
	
	set end(value) {
		if((value == null) || (this.widget.end == value)) return;
		this.widget.end = this.gantt.parseDateStr(value, this.gantt.dateDisplayFormat);
		if(this.endTime != null){
			let time = this.endTime.split(":");
			if(this.widget.end.getHours() != time[0] || this.widget.end.getMinutes() != time[1]) {
				this.widget.end.setHours(time[0]);
				this.widget.end.setMinutes(time[1]);
			}
		}
		this.endLabel.innerText = this.gantt.view.formatDateStr(this.widget.end, this.gantt.dateDisplayFormat, FormatDateProcess.Day);;
	}
	
	get end() {return this.widget.end;}
	
	set endTime(value) {
		if((value == null) || (this.widget.endTime == value)) return;
		this.widget.endTime = value;
		let time = value.split(":");
		this.widget.end.setHours(time[0]);
		this.widget.end.setMinutes(time[1]);
	}
	
	get endTime() {return this.widget.endTime;}
	
	set color(value) {
		if((value == null) || (this.widget.color == value)) return;
		this.widget.color = value;
	}
	
	get color() {return this.widget.color;}
	
	set level(value) {
		if(this.level == value) return;
		this.widget.level = value;
		if(this.nameLabel) this.nameLabel.style.marginLeft = ((2 + this.level) * 10) + "px";
	}
	
	get level() {return this.widget.level;}
	
	set depend(value) {
		if(this.depend == value) return;
		this.widget.depend = value;
	}
	
	get depend() {return this.widget.depend;}
	
	setState(state) {
		if(state.id != null) this.widget.id = state.id;
		if(state.children != null) {
			this.widget.children = state.children;
			this.htmlElement.style.removeProperty("background-color");
			if((this.widget.children.length != 0)) {
				this.htmlElement.classList.add("Parent");
				this.htmlElement.classList.remove("NoParent");
			} else {
				this.htmlElement.classList.add("NoParent");
				this.htmlElement.classList.remove("Parent");
				this.htmlIcon.textContent = this.iconText;
			}
		}
		Rex.copy(this, state);
		if(state.resNames) this.res = state.resNames;
		if(state.iconText != null) {
			this.iconText = state.iconText;
			if(this.htmlElement.classList.contains("Parent") && state.iconText == "") {
				if(this.htmlElement.classList.contains("Expand")) this.htmlIcon.textContent = this.expandIcon;
				else this.htmlIcon.textContent = this.noExpandIcon;
			} else {
				this.htmlIcon.textContent = state.iconText;
			}
		}
		
		if(state.styleName != null) {
			if(this.htmlElement && state.styleName.length > 0) {
				if(this.nameOfStyle.length == 0) this.htmlElement.classList.add(state.styleName);
				else this.htmlElement.classList.remove(this.nameOfStyle);
			}
			this.nameOfStyle = state.styleName;
		}
	}
	
	onInit(node) {
		node.appendChild(this.htmlElement);
		this.htmlContainer.appendChild(this.nameTd);
		
		this.htmlContainer.appendChild(this.resLabel);
		this.htmlContainer.appendChild(this.durLabel);
		this.htmlContainer.appendChild(this.compLabel);
		this.htmlContainer.appendChild(this.startLabel);
		this.htmlContainer.appendChild(this.endLabel);
		if((this.widget.children.length != 0)) {
			this.htmlElement.classList.add("Parent");
			this.htmlElement.classList.remove("NoParent");
			if(this.iconText == "")
				if(this.expanded) this.htmlIcon.textContent = this.expandIcon;
				else this.htmlIcon.textContent = this.noExpandIcon;
			for(let i = 0; i < this.widget.children.length; ++i) {
				if(this.widget.gantt.tasks.get(this.widget.children[i]))
					this.widget.gantt.tasks.get(this.widget.children[i]).view.onInit(this.htmlElement);
			}
			
		} else {
			this.htmlElement.classList.add("NoParent");
			this.htmlElement.classList.remove("Parent");
		}
		
		this.htmlElement.style.visibility = null;
		this.expanded = this.widget.expanded;
	}
	
	checkSelect() {
		let widget = Rex.widgets[this.widgetId];
		let result = undefined;
		if(widget != null) result = widget.view.checkSelect();
		if(result != null) return result;
		return this.hover ? this.widget : undefined;
	}
	
	mouseDown(x, y, e) { Rex.callRpcMethod("Widgets", this.widget.gantt.id, this.widget.gantt.type, "mouseDownTask", [Rex.engine.translateMouseButton(e.which)]); }
	
	mouseUp(x, y, e) { Rex.callRpcMethod("Widgets", this.widget.gantt.id, this.widget.gantt.type, "mouseUpTask", [Rex.engine.translateMouseButton(e.which)]); }
	
	mouseDoubleClick(e) {
		this.widget.setExpanded(!this.widget.expanded);
		Rex.callRpcMethod("Widgets", this.widget.gantt.id, this.widget.gantt.type, "mouseDoubleClickTask", []);
	}
}

class WidgetGanttHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetGantt");
		this.format = this.widget._$vFormat;
		this.countColumns = 0;
		this.vQuarterArr = [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4];
		this.vMonthDaysArr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		this.vMonthArr = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
		try {
			new ResizeObserver(this.drawResize.bind(this)).observe(this.htmlElement);
		} catch(e) {}
		this.createHelper = {
			vMaxDate		: new Date(),	//Максимальная дата среди всех тасков
			vMinDate		: new Date(),	//Минимальная дата среди всех тасков
			vTmpDate		: new Date(),	//Текущая(не сегодняшняя) дата для построения правой таблицы
			vNxtDate		: new Date(),	//Слудующая дата после текущей
			vCurrDate		: new Date(),	//Сегодняшняя дата на стороне пользователя
			vTaskLeft		: 0,	// начадо полосы таска в правой таблицы
			vTaskRight		: 0,	// конец полосы таска в правой таблицы
			vWeekdayColor	: "ffffff",
			vWeekendColor	: "cfcfcf",
			vID				: 0,
			vDateRowStr		: "",//Строка даты для при наведении на полосу таски, которая передается в хинт
			vColWidth		: 0,//Ширина одной колонки в правой таблице
			vColUnit		: 0,//Количество дней в одной колонке в правой таблице
			vChartWidth		: 0,//Ширина всех колонок в правой таблице
			vNumDays		: 0,//Количество дней у таска
			vDayWidth		: 0,//Ширина одного дня
			vFieldHeight	: 20,//Высота строк в таблице
			vHeaderHeight	: 25,
			vNameWidth		: 180,
			vStatusWidth	: 80,//Ширина колонок отображающих информацию о таске
			vLeftWidth		: 300//Ширина левой таблицы
		};
	}
	
	mainTableCreate() {
		// Обработка всех тасков с предустановленной родительской датой и выполнением в %
		this.processRows();
		
		// получить минимальное / максимальное из всех тасков количество дней плюс отступы
		this.createHelper.vMinDate = this.getMinDate(this.format);
		this.createHelper.vMaxDate = this.getMaxDate(this.format);
		
		// Рассчитать переменные ширины диаграммы. vColWidth можно изменить вручную, чтобы изменить ширину каждого столбца
		switch (this.format) {
			case FormatDateProcess.Day: //0
				this.createHelper.vColWidth = 18;
				this.createHelper.vColUnit = 1;
				break;
			case FormatDateProcess.Week: //1
				this.createHelper.vColWidth = 50;
				this.createHelper.vColUnit = 7;
				break;
			case FormatDateProcess.Month: //2
				this.createHelper.vColWidth = 50;
				this.createHelper.vColUnit = 30.5;
				break;
			case FormatDateProcess.Quarter: //3
				this.createHelper.vColWidth = 70;
				this.createHelper.vColUnit = 91.5;
				break;
			case FormatDateProcess.Hour: //5
				this.createHelper.vColWidth = 18;
				this.createHelper.vColUnit = 1;
				break;
			case FormatDateProcess.Minute: //4
				this.createHelper.vColWidth = 18;
				this.createHelper.vColUnit = 1;
				break;
		}
		this.createHelper.vNumDays = (Date.parse(this.createHelper.vMaxDate) - Date.parse(this.createHelper.vMinDate)) / (24 * 60 * 60 * 1000);
		this.countColumns = this.createHelper.vNumDays / this.createHelper.vColUnit;
		this.createHelper.vChartWidth = this.countColumns * this.createHelper.vColWidth + 1;
		this.createHelper.vDayWidth = (this.createHelper.vColWidth / this.createHelper.vColUnit) + (1 / this.createHelper.vColUnit);
		//create main table
		let table = document.createElement("table");
		table.classList.add("WidgetGanttMain-table");
		let tbody = document.createElement("tbody");
		table.appendChild(tbody);
		let tr = document.createElement("tr");
		tbody.appendChild(tr);
		return table;
	}
	
	leftTableCreate() {
		let countShow = 0;
		if (this.showRes) countShow++;
		if (this.showDur) countShow++;
		if (this.showComp) countShow++;
		if (this.showStartDate) countShow++;
		if (this.showEndDate) countShow++;
		this.createHelper.vNameWidth = this.getWidthTaskName();
		this.createHelper.vLeftWidth = 30 + this.createHelper.vNameWidth + this.createHelper.vStatusWidth * countShow;
		let leftTd = document.createElement("td");
		this.setPropertysForElement(leftTd, "GanttLeftTable", {"min-width" : this.createHelper.vLeftWidth + 'px', "max-width" : this.createHelper.vLeftWidth + 'px'});
		
		let div = document.createElement("div");
		div.id = "leftSide";
		this.setPropertysForElement(leftTd, "GanttScroll", {"min-width" : this.createHelper.vLeftWidth + 'px', "max-width" : this.createHelper.vLeftWidth + 'px'});
		leftTd.appendChild(div);
		
		let table = document.createElement("table");
		table.setAttribute("width", "100%");
		table.setAttribute("cellspacing", "0");
		table.setAttribute("cellpadding", "0");
		table.setAttribute("border", "0");
		div.appendChild(table);
		
		let tbody = document.createElement("tbody");
		table.appendChild(tbody);
		tbody.appendChild(this.leftTableCreateVoidTR());
		tbody.appendChild(this.leftTableCreateHeaderTR());
		this.leftTableCreateAllTasksTRs(tbody);
		return leftTd;
	}
	
	leftTableCreateVoidTR() {
		let tr = document.createElement("tr");
		let tdN = document.createElement("td");
		tr.appendChild(tdN);
		tdN.appendChild(document.createElement("nobr"));
		this.setPropertysForElement(tdN, "GanttVoidTdName", {"min-width" : (20 + this.createHelper.vNameWidth) + 'px', "max-width" : (20 + this.createHelper.vNameWidth) + 'px'});
		
		this.buttonSettings = document.createElement("span");
		this.buttonSettings.classList.add("GanttSetting");
		this.buttonSettings.classList.add("MaterialIcon");
		this.buttonSettings.innerText = "settings";
		this.buttonSettings.style.cursor = "pointer";
		tdN.appendChild(this.buttonSettings);
		this.buttonSettings.addEventListener("click", (event) => {
			this.settingsPress();
		});
		
		this.createNewTask = document.createElement("span");
		this.createNewTask.classList.add("GanttSetting");
		this.createNewTask.classList.add("MaterialIcon");
		this.createNewTask.innerText = "note_add";
		this.createNewTask.title = "Create new task";
		this.createNewTask.style.cursor = "pointer";
		tdN.appendChild(this.createNewTask);
		this.createNewTask.addEventListener("click", (event) => {
			Rex.callRpcMethod('Widgets', this.id, this.type, 'createNewTask', []);
		});
		
		if (this.showRes) tr.appendChild(this.makeTD("", "GanttVoidTdShow"));
		if (this.showDur) tr.appendChild(this.makeTD("", "GanttVoidTdShow"));
		if (this.showComp) tr.appendChild(this.makeTD("", "GanttVoidTdShow"));
		if (this.showStartDate) tr.appendChild(this.makeTD("", "GanttVoidTdShow"));
		if (this.showEndDate) tr.appendChild(this.makeTD("", "GanttVoidTdShow"));
		
		return tr;
	}
	
	makeTD(text, className) {
		let td = document.createElement("td");
		td.classList.add(className);
		td.style.setProperty("font-weight", "bold");
		td.textContent = text;
		return td
	}
	
	leftTableCreateHeaderTR() {
		let trHead = document.createElement("tr");
		let td = document.createElement("td");
		td.setAttribute("colspan", "6");
		trHead.appendChild(td);
		let tr = document.createElement("tr");
		td.appendChild(tr);
		tr.classList.add("GanttHeader");
		let tdN = document.createElement("td");
		this.setPropertysForElement(tdN, "GanttName", {"min-width" : (20 + this.createHelper.vNameWidth) + 'px', "max-width" : (20 + this.createHelper.vNameWidth) + 'px'});
		let nobr = document.createElement("nobr");
		this.setPropertysForElement(nobr, "", {"font-size" : "12px", "font-weight" : "bold"});
		nobr.textContent = "   Tasks";
		tdN.appendChild(nobr);
		tr.appendChild(tdN);
		
		if (this.showRes) tr.appendChild(this.makeTD("Resource", "GanttName-p"));
		if (this.showDur) tr.appendChild(this.makeTD("Duration", "GanttName-p"));
		if(this.showComp) tr.appendChild(this.makeTD("% Comp.", "GanttName-p"));
		if (this.showStartDate) tr.appendChild(this.makeTD("Start date", "GanttName-p"));
		if (this.showEndDate) tr.appendChild(this.makeTD("End date", "GanttName-p"));
		return trHead;
	}
	
	leftTableCreateAllTasksTRs(tbody) {
		for(let task of this.tasks.values()) {
			if(task.parentId == -1 && task.parent == null) this.createTrForTask(task, tbody);
		}
	}
	
	createTrForTask(task, tbody){
		let tr = document.createElement("tr");
		tbody.appendChild(tr);
		tr.id = "child_" + task.id;
		tr.addEventListener("mouseenter", (event) => { this.mouseOver(tr, task.id, "left"); });
		tr.addEventListener("mouseleave", (event) => { this.mouseOut(tr, task.id, "left"); });
		
		let td = document.createElement("td");
		td.setAttribute("colspan", "6");
		tr.appendChild(td);
		td.appendChild(task.view.htmlElement);
		task.view.nameTd.style.setProperty("min-width", (20 + this.createHelper.vNameWidth) + 'px');
		task.view.nameTd.style.setProperty("max-width", (20 + this.createHelper.vNameWidth) + 'px');
		if (this.showRes) task.view.resLabel.style.setProperty("display", "block");
		else task.view.resLabel.style.setProperty("display", "none");
		if (this.showDur) {
			task.view.durLabel.style.setProperty("display", "block");
			task.view.durLabel.innerText = task.duration(this.format);
		} else task.view.durLabel.style.setProperty("display", "none");
		if(this.showComp) task.view.compLabel.style.setProperty("display", "block");
		else task.view.compLabel.style.setProperty("display", "none");
		if (this.showStartDate) task.view.startLabel.style.setProperty("display", "block");
		else task.view.startLabel.style.setProperty("display", "none");
		if (this.showEndDate) task.view.endLabel.style.setProperty("display", "block");
		else task.view.endLabel.style.setProperty("display", "none");
		
		for(let i of task.children){
			let child = this.widget.tasks.get(i);
			this.createTrForTask(child, tbody);
		}
	}
	
	rightTableCreate() {
		let rightTd = document.createElement("td");
		this.setPropertysForElement(rightTd, "", {"vertical-align" : "top", "background-color" : "#ffffff"});
		let div = document.createElement("div");
		div.id = "rightSide";
		div.classList.add("GanttScroll2");
		div.style.setProperty("width", `${this.htmlElement.offsetWidth - this.createHelper.vLeftWidth}px`);
		rightTd.appendChild(div);
		let table = document.createElement("table");
		table.style.setProperty("max-width", this.createHelper.vChartWidth + 'px');
		table.setAttribute("cellSpacing", "0");
		table.setAttribute("cellPadding", "0");
		table.setAttribute("border", "0");
		div.appendChild(table);
		let tbody = document.createElement("tbody");
		table.appendChild(tbody);
		tbody.appendChild(this.rightTableCreateHeaderTR());
		tbody.appendChild(this.rightTableCreateFieldsTR("date"));
		this.rightTableCreateAllFieldsTRs(div);
		return rightTd;
	}
	
	rightTableCreateHeaderTR() {
		let tr = document.createElement("tr");
		this.createHelper.vTmpDate.setTime(this.createHelper.vMinDate);
		let countHeader = 0;
		switch(this.format) {
			case (FormatDateProcess.Minute) : {
				countHeader = this.countColumns * 24;
				break;
			}
			case (FormatDateProcess.Day ) : {
				countHeader = this.countColumns / 7;
				break;
			}
			default : {
				countHeader = this.countColumns;
				break;
			}
		}
		for(let i = 0; i < countHeader; i++){
			tr.appendChild(this.makeTdRightTableHeader());
		}
		return tr;
	}
	
	makeTdRightTableHeader() {
		let td = document.createElement("td");
		td.classList.add("GanttDatehead");
		switch(this.format){
			case FormatDateProcess.Minute : {
				if(Date.parse(this.createHelper.vTmpDate.getHours() + 1) >= Date.parse(this.createHelper.vMaxDate)) td.style.setProperty("border-right", "#efefef 1px solid");
				td.setAttribute("colspan", "60");
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat) + ' ' + this.createHelper.vTmpDate.getHours() + ':00 -' + this.createHelper.vTmpDate.getHours() + ':59 ';
				this.createHelper.vTmpDate.setHours(this.createHelper.vTmpDate.getHours() + 1);
				break;
			}
			case FormatDateProcess.Hour : {
				if(Date.parse(this.createHelper.vTmpDate.getDate() + 1) >= Date.parse(this.createHelper.vMaxDate)) td.style.setProperty("border-right", "#efefef 1px solid");
				td.setAttribute("colspan", "24");
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				break;
			}
			case FormatDateProcess.Day : {
				if((this.createHelper.vTmpDate.getMonth() >= this.createHelper.vMaxDate.getMonth()) &&
					(this.createHelper.vTmpDate.getDate() + 7) >= this.createHelper.vMaxDate.getDate()) td.style.setProperty("border-right", "#efefef 1px solid");
				td.setAttribute("colspan", "7");
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, GanttDateFormat.ddmm) + ' - ';
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 6);
				td.textContent += this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				break;
			}
			case FormatDateProcess.Week : {
				if((this.createHelper.vTmpDate.getMonth() >= this.createHelper.vMaxDate.getMonth()) &&
					(this.createHelper.vTmpDate.getDate() + 7) >= this.createHelper.vMaxDate.getDate()) td.style.setProperty("border-right", "#efefef 1px solid");
				td.style.setProperty("width", this.createHelper.vColWidth + 'px');
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 7);
				break;
			}
			case FormatDateProcess.Month : {
				if((this.createHelper.vTmpDate.getMonth() + 1) >= this.createHelper.vMaxDate.getMonth())td.style.setProperty("border-right", "#efefef 1px solid");
				td.style.setProperty("width", this.createHelper.vColWidth + 'px');
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				while(this.createHelper.vTmpDate.getDate() > 1) {
					this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				}
				break;
			}
			case FormatDateProcess.Quarter : {
				if((this.createHelper.vTmpDate.getMonth() + 4) >= this.createHelper.vMaxDate.getMonth()) td.style.setProperty("border-right", "#efefef 1px solid");
				td.style.setProperty("width", this.createHelper.vColWidth + 'px');
				td.textContent = this.formatDateStr(this.createHelper.vTmpDate, this.dateDisplayFormat);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 81);
				while(this.createHelper.vTmpDate.getDate() > 1) {
					this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				}
				break;
			}
		}
		return td;
	}
	
	makeFlagDateMHD(fDate, text, td, div){
		if(fDate){
			td.style.setProperty("border-top", "#efefef 1px solid");
			div.textContent = text;
		} else {
			td.style.setProperty("cursor", "default");
			div.value = "&nbsp;";
		}
	}
	
	makeFlagDateWMQ(fDate, text, td, div){
		if(fDate){
			this.setPropertysForElement(td, "", {"border-top" : "#efefef 1px solid", "background-color" : '#' + this.createHelper.vWeekdayColor});
			div.textContent = text;
		} else {
			div.value = "&nbsp;&nbsp;";
			if (this.createHelper.vCurrDate >= this.createHelper.vTmpDate && this.createHelper.vCurrDate < this.createHelper.vNxtDate){
				td.style.setProperty("background-color", '#' + this.createHelper.vWeekdayColor);
			}
		}
	}
	
	makeTdRightTableFields(fDate){
		let td = document.createElement("td");
		let div = document.createElement("div");
		div.style.setProperty("width", this.createHelper.vColWidth + 'px');
		switch(this.format) {
			case FormatDateProcess.Minute : {
				if (this.createHelper.vTmpDate.getMinutes() === 0) this.setPropertysForElement(td, "GanttHeadwkend", {"background-color" : "ccccff"});
				else this.setPropertysForElement(td, "GanttHead", {"background-color": "ffffff"});
				this.makeFlagDateMHD(fDate, this.createHelper.vTmpDate.getMinutes(), td, div);
				this.createHelper.vTmpDate.setMinutes(this.createHelper.vTmpDate.getMinutes() + 1);
				break;
			}
			case FormatDateProcess.Hour : {
				if (this.createHelper.vTmpDate.getHours() === 0) this.setPropertysForElement(td, "GanttHeadwkend", {"background-color" : "ccccff"});
				else this.setPropertysForElement(td, "GanttHead", {"background-color": "ffffff"});
				this.makeFlagDateMHD(fDate, this.createHelper.vTmpDate.getHours(), td, div);
				this.createHelper.vTmpDate.setHours(this.createHelper.vTmpDate.getHours() + 1);
				break;
			}
			case FormatDateProcess.Day : {
				if (this.formatDateStr(this.createHelper.vCurrDate, GanttDateFormat.mmddyyyy) === this.formatDateStr(this.createHelper.vTmpDate, GanttDateFormat.mmddyyyy)) {
					this.createHelper.vWeekdayColor = "ccccff";
					this.createHelper.vWeekendColor = "9999ff";
				} else {
					this.createHelper.vWeekdayColor = "ffffff";
					this.createHelper.vWeekendColor = "cfcfcf";
				}
				if (this.createHelper.vTmpDate.getDay() % 6 === 0) this.setPropertysForElement(td, "GanttHeadwkend", {"background-color" : '#' + this.createHelper.vWeekendColor});
				else {
					td.classList.add("GanttHead");
					if(fDate){
						td.style.setProperty("background-color", '#' + this.createHelper.vWeekdayColor);
					} else {
						if (this.formatDateStr(this.createHelper.vCurrDate, GanttDateFormat.mmddyyyy) === this.formatDateStr(this.createHelper.vTmpDate, GanttDateFormat.mmddyyyy)){
							td.style.setProperty("background-color", '#' + this.createHelper.vWeekdayColor);
						}
					}
				}
				this.makeFlagDateMHD(fDate, this.createHelper.vTmpDate.getDate(), td, div);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				break;
			}
			case FormatDateProcess.Week : {
				this.createHelper.vNxtDate.setDate(this.createHelper.vNxtDate.getDate() + 7);
				if (this.createHelper.vCurrDate >= this.createHelper.vTmpDate && this.createHelper.vCurrDate < this.createHelper.vNxtDate) this.createHelper.vWeekdayColor = "ccccff";
				else this.createHelper.vWeekdayColor = "ffffff";
				this.setPropertysForElement(td, "GanttHead", {"width": this.createHelper.vColWidth + 'px', "align" : "center"});
				if (this.createHelper.vNxtDate > this.createHelper.vMaxDate) td.style.setProperty("border-right", "#efefef 1px solid");
				this.makeFlagDateWMQ(fDate, this.formatDateStr(this.createHelper.vTmpDate, GanttDateFormat.ddmm), td, div);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 7);
				break;
			}
			case FormatDateProcess.Month : {
				this.createHelper.vNxtDate.setFullYear(this.createHelper.vTmpDate.getFullYear(), this.createHelper.vTmpDate.getMonth(), this.vMonthDaysArr[this.createHelper.vTmpDate.getMonth()]);
				if (this.createHelper.vCurrDate >= this.createHelper.vCurrDate < this.createHelper.vNxtDate) this.createHelper.vWeekdayColor = "ccccff";
				else this.createHelper.vWeekdayColor = "ffffff";
				this.setPropertysForElement(td, "GanttHead", {"width": this.createHelper.vColWidth + 'px', "align" : "center"});
				if (this.createHelper.vNxtDate > this.createHelper.vMaxDate) td.style.setProperty("border-right", "#efefef 1px solid");
				this.makeFlagDateWMQ(fDate, this.vMonthArr[this.createHelper.vTmpDate.getMonth()].substr(0, 3), td, div);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				while (this.createHelper.vTmpDate.getDate() > 1) {
					this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				}
				break;
			}
			case FormatDateProcess.Quarter : {
				this.createHelper.vNxtDate.setDate(this.createHelper.vNxtDate.getDate() + 122);
				if (this.createHelper.vTmpDate.getMonth() < 3) this.createHelper.vNxtDate.setFullYear(this.createHelper.vTmpDate.getFullYear(), 2, 31);
				else if (this.createHelper.vTmpDate.getMonth() < 6) this.createHelper.vNxtDate.setFullYear(this.createHelper.vTmpDate.getFullYear(), 5, 30);
					 else if (this.createHelper.vTmpDate.getMonth() < 9) this.createHelper.vNxtDate.setFullYear(this.createHelper.vTmpDate.getFullYear(), 8, 30);
						 else this.createHelper.vNxtDate.setFullYear(this.createHelper.vTmpDate.getFullYear(), 11, 31);
				if (this.createHelper.vCurrDate >= this.createHelper.vTmpDate && this.createHelper.vCurrDate < this.createHelper.vNxtDate) this.createHelper.vWeekdayColor = "ccccff";
				else this.createHelper.vWeekdayColor = "ffffff";
				this.setPropertysForElement(td, "GanttHead", {"width": this.createHelper.vColWidth + 'px', "align" : "center"});
				if (this.createHelper.vNxtDate.getMonth() >= this.createHelper.vMaxDate.getMonth()) td.style.setProperty("border-right", "#efefef 1px solid");
				this.makeFlagDateWMQ(fDate, 'Qtr. ' + this.vQuarterArr[this.createHelper.vTmpDate.getMonth()], td, div);
				this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 81);
				while (this.createHelper.vTmpDate.getDate() > 1) {
					this.createHelper.vTmpDate.setDate(this.createHelper.vTmpDate.getDate() + 1);
				}
				break;
			}
		}
		td.appendChild(div);
		return td;
	}
	
	rightTableCreateFieldsTR(text) {
		this.createHelper.vTmpDate.setTime(this.createHelper.vMinDate);
		this.createHelper.vNxtDate.setTime(this.createHelper.vMinDate);
		let fDate = text === "date" ? true : false;
		let tr = document.createElement("tr");
		let countFields = 0;
		switch(this.format) {
			case (FormatDateProcess.Minute) : {
				countFields = this.countColumns * 24 * 60;
				break;
			}
			case (FormatDateProcess.Hour ) : {
				countFields = this.countColumns * 24;
				break;
			}
			default : {
				countFields = this.countColumns;
				break;
			}
		}
		for(let i = 0; i <= countFields; i++){
			tr.appendChild(this.makeTdRightTableFields(fDate));
		}
		return tr;
	}
	
	rightTableCreateAllFieldsTRs(tbody) {
		for(let task of this.tasks.values()) {
			if(task.parentId == -1 && task.parent == null) this.createFieldsOnRightTable(task, tbody);
		}
	}
	
	createFieldsOnRightTable(task, tbody){
		if(!task.visible) return;
		this.createHelper.vTmpDate.setTime(this.createHelper.vMinDate);
		this.createHelper.vID = task.id;
		let divChildGrid = document.createElement("div");
		tbody.appendChild(divChildGrid);
		divChildGrid.id = 'childgrid_' + this.createHelper.vID;
		divChildGrid.style.setProperty("position", "relative");
		let div = document.createElement("div");
		divChildGrid.appendChild(div);
		let table = document.createElement("table");
		div.appendChild(table);
		this.setPropertysForElement(table, "", {"position" : "relative", "top" : "0px", "width" : this.createHelper.vChartWidth +'px'});
		let trItem = this.rightTableCreateFieldsTR("item");
		table.appendChild(trItem);
		trItem.id = 'childrow_' + this.createHelper.vID;
		trItem.classList.add("yesdisplay");
		trItem.addEventListener("mouseenter", (event) => { this.mouseOver(trItem, task.id, "right"); });
		trItem.addEventListener("mouseleave", (event) => { this.mouseOut(trItem, task.id, "right"); });
		
		let div1 = document.createElement("div");
		divChildGrid.appendChild(div1);
		div1.id = 'bardiv_' + this.createHelper.vID;
		div1.style.setProperty("position", "absolute");
		let div2 = document.createElement("div");
		div1.appendChild(div2);
		div2.id = 'taskbar_' + this.createHelper.vID;
		// Build date string for Title
		this.createHelper.vDateRowStr = this.formatDateStr(task.start, this.dateDisplayFormat) + ' (' + task.start.getHours() + ':' + task.start.getMinutes()+ ')' + ' - ' + this.formatDateStr(task.end, this.dateDisplayFormat) + ' (' + task.end.getHours() + ':' + task.end.getMinutes()+ ')' ;
		div2.title = task.name + ': ' + task.res + ': ' + this.createHelper.vDateRowStr;
		if (!task.visible) divChildGrid.style.setProperty("display", "none");
		if (this.format === FormatDateProcess.Minute) {
			this.createHelper.vTaskRight = (Date.parse(task.end) - Date.parse(task.start)) / (60 * 1000) + 1 / this.createHelper.vColUnit;
			this.createHelper.vTaskLeft = Math.ceil((Date.parse(task.start) - Date.parse(this.createHelper.vMinDate)) / (60 * 1000));
		} else if (this.format === FormatDateProcess.Hour) {
			this.createHelper.vTaskRight = (Date.parse(task.end) - Date.parse(task.start)) / (60 * 60 * 1000) / this.createHelper.vColUnit;
			this.createHelper.vTaskLeft = (Date.parse(task.start) - Date.parse(this.createHelper.vMinDate)) / (60 * 60 * 1000);
		} else {
			this.createHelper.vTaskRight = (Date.parse(task.end) - Date.parse(task.start)) / (24 * 60 * 60 * 1000) + 1 / this.createHelper.vColUnit;
			this.createHelper.vTaskLeft = (Date.parse(task.start) - Date.parse(this.createHelper.vMinDate)) / (24 * 60 * 60 * 1000);
			if (this.format === FormatDateProcess.Day) this.createHelper.vTaskRight--;
		}
		// Draw Group Bar  which has outer div with inner group div and several small divs to left and right to create angled-end indicators
		table.setAttribute("cellSpacing", "0");
		table.setAttribute("cellPadding", "0");
		table.setAttribute("border", "0");
		this.setPropertysForElement(div1, "", {"margin-left" : Math.ceil(this.createHelper.vTaskLeft * (this.createHelper.vDayWidth) + 1) + 'px',
												"width" :  Math.ceil((this.createHelper.vTaskRight) * (this.createHelper.vDayWidth) - 1) + 'px'});
		this.setPropertysForElement(div2, "GanttTask", {"width" : Math.ceil((this.createHelper.vTaskRight) * (this.createHelper.vDayWidth) - 1) + 'px',
														"cursor" : "pointer", "opacity" : "0.9", "background-color" : task.color});
		let div3 = document.createElement("div");
		div2.appendChild(div3);
		this.setPropertysForElement(div3, "", {"width" : task.compStr, "z-index" : "-4", "float" : "left"});
		if (task.children.length > 0) {
			trItem.style.setProperty("background-color", "#f3f3f3");
			this.setPropertysForElement(div1, "", {"top" : "5px", "height" : "7px"});
			div2.style.setProperty("height", "7px");
			this.setPropertysForElement(div3, "", {"background-color" : "black", "height" : "3px", "margin-top" : "1px", "margin-left" : "1px",
													"margin-right" : "1px", "filter" : "alpha(opacity=60)", "opacity" : "0.6", "cursor" : "pointer"});
			let k = 4;
			let j = 0;
			while(k > 0){
				let divG = document.createElement("div");
				if(j == 0) {
					this.setPropertysForElement(divG, "", {"float" : "left", "height" : k +'px'});
					j++;
				} else {
					if(j == 1) {
						this.setPropertysForElement(divG, "", {"float" : "right", "height" : k +'px'});
						j = 0;
						k--;
					}
				}
				this.setPropertysForElement(divG, "", {"z-index" : "-4", "background-color" : task.color, "overflow" : "hidden", "width" : "1px"});
				div1.appendChild(divG);
			}
		} else {
			trItem.style.setProperty("background-color", "#ffffff");
			this.setPropertysForElement(div1, "", {"top" : "4px", "height" : "18px"});
			div2.style.setProperty("height", "13px");
			this.setPropertysForElement(div3, "GanttComplete", {"background-color" : "black", "height" : "5px", "margin-top" : "4px",
																"filter" : "alpha(opacity=40)", "opacity" : "0.4", "overflow" : "hidden"});
		}
		for(let i of task.children){
			let child = this.widget.tasks.get(i);
			this.createFieldsOnRightTable(child, tbody);
		}
	}
	
	setPropertysForElement(elem, className = "", props) {
		if(className != "") elem.classList.add(className);
		for(let item in props) elem.style.setProperty(item, props[item]);
	}
	
	onInit() {
		this.height = undefined;
		for(let key of this.widget.tasks.keys()) {
			let task = this.widget.tasks.get(key);
			if(task.parentId != -1) continue;
			task.view.onInit(this.htmlElement);
			if(task.children.length != 0) task.view.htmlElement.classList.add("Parent");
		}
		this.draw();
	}
	
	settingsPress() { Rex.callRpcMethod('Widgets', this.id, this.type, 'generateSettings', []); }
	
	 onSetState(state) {
		 Rex.copy(this.widget, state);
		 if(this.tasks == null) this.widget._$vTaskList = new Map();
		 
		 if(state.updates != null) {
			 for(let task of state.updates) {
			 	let updates = new Map();
			 	for(let i = 0; i < state.updates.length; i++){
			 		updates.set(state.updates[i].id, state.updates[i]);
				}
				 if(!this.tasks.has(task.id)) {
					 let sourceTask = null;
					 sourceTask = new GanttTask();
					 this.tasks.set(task.id, sourceTask);
					 sourceTask.view = new GanttTaskHtml(sourceTask);
					 sourceTask.gantt = this.widget;
					 sourceTask.id = task.id;
					 sourceTask.children = task.children;
				 }
			 }
			 for(let task of state.updates){
				 let sourceTask = this.widget.tasks.get(task.id);
				 sourceTask.view.setState(task);
			 }
			 this.checkFormat(this.format);
		 }
		 
		 if(state.format != null) this.checkFormat(state.format);
		 
		 if(state.dateDisplayFormat != null) this.dateDisplayFormat = state.dateDisplayFormat;
		 
		 if(state.selectedTaskId != null) {
			 this.widget.selectTask = this.tasks.get(this.widget.selectedTaskId);
			 if(this.currentSelectedTask != null) this.currentSelectedTask.view.htmlElement.classList.remove("Selected");
			 if(this.widget.selectTask != null) {
				 this.currentSelectedTask = this.widget.selectTask;
				 this.currentSelectedTask.view.htmlElement.classList.add("Selected");
			 }
		 }
		 
		if(state.needRemove != null) {
			for(let taskId of state.needRemove) {
				let task = this.tasks.get(taskId);
			if(task == null) continue;
			task.view.destroy();
			delete this.tasks.get(taskId);
			this.tasks.delete(taskId);
			}
		}
		
		 if(this.widget.inited == true && (state.needRemove != null || state.dateDisplayFormat != null || state.format != null || state.showRes != null || state.updates != null))
			 this.draw();
	 }
	
	 checkFormat(stateFormat){
		switch(stateFormat) {
			case (FormatDateProcess.Minute) : {
				if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < 4)
					this.format = stateFormat;
				else {
					switch(this.createHelper.vColUnit){
						case 0://default value
							if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*3)) this.format = FormatDateProcess.Day;
							else if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
							else this.format = FormatDateProcess.Month;
							break;
						case 1: //0 day
							for(let task of this.tasks.values()){
								if(task.view.durLabel.textContent.split("Ho").length > 1 && Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < 45) this.format = FormatDateProcess.Hour;
								else if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*3)) this.format = FormatDateProcess.Day;
								else if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
								else this.format = FormatDateProcess.Month;
								break;
							}
							break;
						case 7: //1 week
							if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
							else this.format = FormatDateProcess.Month;
							break;
						case 30.5: //2 month
							this.format = FormatDateProcess.Month;
							break;
						case 91.5: //3 quarter
							this.format = FormatDateProcess.Quarter;
							break;
					}
					Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setFormat', [this.format]);
					console.log("Большой период времени, формат \"Минуты\" не преминился.");
				}
				break;
			}
			case (FormatDateProcess.Hour) : {
				if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < 45)
					this.format = stateFormat;
				else {
					switch(this.createHelper.vColUnit){
						case 7: //1 week
							if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
							else this.format = FormatDateProcess.Month;
							break;
						case 30.5: //2 month
							this.format = FormatDateProcess.Month;
							break;
						case 91.5: //3 quarter
							this.format = FormatDateProcess.Quarter;
							break;
						default :
							if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*3)) this.format = FormatDateProcess.Day;
							else if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
							else this.format = FormatDateProcess.Month;
					}
					Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setFormat', [this.format]);
					console.log("Большой период времени, формат \"Часы\" не преминился.");
				}
				break;
			}
			case (FormatDateProcess.Day) : {
				if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*3))
					this.format = stateFormat;
				else {
					switch(this.createHelper.vColUnit){
						case 30.5: //2 month
							this.format = FormatDateProcess.Month;
							break;
						case 91.5: //3 quarter
							this.format = FormatDateProcess.Quarter;
							break;
						default :
							if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20)) this.format = FormatDateProcess.Week;
							else this.format = FormatDateProcess.Month;
							break;
					}
					Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setFormat', [this.format]);
					console.log("Большой период времени, формат \"Дни\" не преминился.");
				}
				break;
			}
			case (FormatDateProcess.Week) : {
				if(Math.ceil((this.getMaxDate() - this.getMinDate()) / (24 * 60 * 60 * 1000) - 1) < (365*20))
					this.format = stateFormat;
				else {
					switch(this.createHelper.vColUnit){
						case 30.5: //2 month
							this.format = FormatDateProcess.Month;
							break;
						case 91.5: //3 quarter
							this.format = FormatDateProcess.Quarter;
							break;
						default :
							this.format = FormatDateProcess.Month;
							break;
					}
					Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setFormat', [this.format]);
					console.log("Большой период времени, формат \"Недели\" не преминился.");
				}
				break;
			}
			default : {
				this.format = stateFormat;
				break;
			}
		}
	}
	 
	appendChild(child) {
		for(let task of this.tasks.values()) {
			let id = child.id.replace("div", "");
			if((task.widgetId == id)) {
				task.view.htmlContainer.appendChild(child);
				child.style.marginLeft = "20px";
				Rex.widgets[task.widgetId].view.width = undefined;
				Rex.widgets[task.widgetId].view.height = undefined;
				child.style.width = null;
				child.style.height = null;
			}
		}
	}
	
	checkSelect() {
		for(let task of this.tasks.values()) {
			if(task.view.checkSelect() != undefined) return task.view.checkSelect();
		}
		return this.hover ? this.widget : undefined;
	}
	
	mouseDown(x, y, event) {
		if(this.widget.hoveredTaskId != -1) this.tasks.get(this.widget.hoveredTaskId).view.mouseDown(x, y, event);
		else  if(this.widget.selectTask != -1) Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "setSelectedTask", [-1]);
	}
	
	mouseUp(x, y, event) { if(this.widget.hoveredTaskId != -1) this.tasks.get(this.widget.hoveredTaskId).view.mouseUp(x, y, event); }
	
	mouseDoubleClick(event) { if(this.widget.hoveredTaskId != -1) this.tasks.get(this.widget.hoveredTaskId).view.mouseDoubleClick(event); }
	
	/**
	 * Draw gantt chart
	 * @method draw
	 */
	draw() {
		
		while(this.htmlElement.childNodes.length) {
			this.htmlElement.childNodes[0].remove();
		}
		let mainTab = this.mainTableCreate();
		let leftTab = this.leftTableCreate();
		let rightTab = this.rightTableCreate();
		mainTab.firstElementChild.firstElementChild.appendChild(leftTab);
		mainTab.firstElementChild.firstElementChild.appendChild(rightTab);
		
		let el = document.createElement("div");
		this.setPropertysForElement(el, "", {"overflow-y" : "auto", "overflow-x": "hidden", "height" : "100%"});
		el.appendChild(mainTab);
		this.htmlElement.appendChild(el);
		this.widget.drawDependencies();
	};
	
	drawResize(){
		let scroll = document.getElementById("rightSide");
		if(scroll == null) return;
		scroll.style.setProperty("width", `${this.htmlElement.offsetWidth - this.createHelper.vLeftWidth}px`);
	}
	
	/**
	 * Mouseover behaviour for gantt row
	 * @method mouseOver
	 * @return {Void}
	 */
	mouseOver(pObj, pID, pPos) {
		let vID = '';
		if (pPos === 'right') vID = this.id + '_' + pID;
		else vID = 'childrow_' + pID;
		pObj.style.setProperty("background-color", "#ffffaa");
		let vRowObj = document.getElementById(vID);
		if (vRowObj) vRowObj.style.setProperty("background-color", "#ffffaa");
	};
	
	/**
	 * Mouseout behaviour for gantt row
	 * @method mouseOut
	 */
	mouseOut(pObj, pID, pPos) {
		let vID ='';
		if (pPos === 'right') vID = this.id + '_' + pID;
		else vID = 'childrow_' + pID;
		let vRowObj = document.getElementById(vID);
		if (vRowObj) {
			if (this.tasks.get(pID).children.length > 0) {
				pObj.style.setProperty("background-color", "#f3f3f3");
				vRowObj.style.setProperty("background-color", "#f3f3f3");
			} else {
				pObj.style.setProperty("background-color", "#ffffff");
				vRowObj.style.setProperty("background-color", "#ffffff");
			}
		}
	};
	
	generateComp(task){
		let vCompSum = 0;
		for(let i = 0; i < task.children.length; i++){
			if(task.children[i] != -1){
				let child = this.tasks.get(task.children[i]);
				if(child.children != null && child.children.length > 0) vCompSum += this.generateComp(child);
				else vCompSum += child.compVal;
			}
		}
		if(task.children.length > 0) vCompSum = Math.ceil(vCompSum / task.children.length);
		else vCompSum = task.compVal;
		task.view.comp = vCompSum;
		return vCompSum;
	}
	
	/**
	 * Recursively process task tree ... set min, max dates of parent tasks and identfy task level.
	 * @method processRows
	 * @return void
	 */
	processRows() {
		for (let task of this.tasks.values()) {
			this.generateComp(task);
			switch (this.dateDisplayFormat) {
				case GanttDateFormat.ddmmyyyy: //0
					task.view.start = task.start.getDate() + '/' + (task.start.getMonth() + 1) + '/' + task.start.getFullYear();
					task.view.end = task.end.getDate() + '/' + (task.end.getMonth() + 1) + '/' + task.end.getFullYear();
					break;
				case GanttDateFormat.mmddyyyy : //1
					task.view.start = (task.start.getMonth() + 1) + '/' + task.start.getDate() + '/' + task.start.getFullYear();
					task.view.end = (task.end.getMonth() + 1) + '/' + task.end.getDate() + '/' + task.end.getFullYear();
					break;
				case GanttDateFormat.yyyymmdd: //2
					task.view.start = task.start.getFullYear() + '/' + (task.start.getMonth() + 1) + '/' + task.start.getDate();
					task.view.end = task.end.getFullYear() + '/' + (task.end.getMonth() + 1) + '/' + task.end.getDate();
					break;
				case GanttDateFormat.yyyyddmm: //3
					task.view.start = task.start.getFullYear()+ '/' + task.start.getDate() + '/' + (task.start.getMonth() + 1);
					task.view.end = task.end.getFullYear() + '/' + task.end.getDate() + '/' + (task.end.getMonth() + 1);
					break;
				case GanttDateFormat.ddmmyy: //4
					task.view.start = task.start.getDate() + '/' + (task.start.getMonth() + 1) + '/' + task.start.getFullYear();
					task.view.end = task.end.getDate() + '/' + (task.end.getMonth() + 1) + '/' + task.end.getFullYear();
					break;
				case GanttDateFormat.mmddyy : //5
					task.view.start = (task.start.getMonth() + 1) + '/' + task.start.getDate() + '/' + task.start.getFullYear();
					task.view.end = (task.end.getMonth() + 1) + '/' + task.end.getDate() + '/' + task.end.getFullYear();
					break;
				case GanttDateFormat.yymmdd: //6
					task.view.start = task.start.getFullYear() + '/' + (task.start.getMonth() + 1) + '/' + task.start.getDate();
					task.view.end = task.end.getFullYear() + '/' + (task.end.getMonth() + 1) + '/' + task.end.getDate();
					break;
				case GanttDateFormat.yyddmm: //3
					task.view.start = task.start.getFullYear() + '/' + task.start.getDate() + '/' + (task.start.getMonth() + 1);
					task.view.end = task.end.getFullYear() + '/' + task.end.getDate() + '/' + (task.end.getMonth() + 1);
					break;
			}
		}
	}
	
	/**
	 * Определяет ширину максимального имени среди всех тасков
	 *
	 * @method getWidthTaskName
	 * @return {WidthTaskName}
	 */
	getWidthTaskName() {
		if(this.tasks.size == 0) return 100;
		let maxWidth = 0;
		if(this.tasks.size){
			for(let task of this.tasks.values()){
				if(maxWidth < (task.name.length + task.level * 5)) maxWidth = (task.name.length + task.level * 5) * 5;
			}
		}
		return maxWidth < 100 ? 100 : maxWidth;
	}
		
		/**
	 * Определяет минимальную дату всех тасков и устанавливает нижнюю границу в зависимости от формата
	 *
	 * @method getMinDate
	 * @param pFormat {String} - current format (minute,hour,day...)
	 * @return {Datetime}
	 */
	getMinDate(pFormat) {
		let vDate = new Date();
		if(this.tasks.size == 0) return vDate;
		vDate.setTime(this.tasks.values().next().value.start);
		// Parse all Task End dates to find min
		for (let task of this.tasks.values()) {
			if (Date.parse(task.start) < Date.parse(vDate)) vDate.setTime(task.start);
		}
		if (pFormat < FormatDateProcess.Minute) {
			vDate.setMinutes(0);
			vDate.setHours(0);
		}
		if (pFormat === FormatDateProcess.Minute) {
			while(vDate.getMinutes() > 0)
				vDate.setMinutes(vDate.getMinutes() - 1);
		} else if (pFormat === FormatDateProcess.Hour) {
			while(vDate.getHours() > 0)
				vDate.setHours(vDate.getHours() - 1);
			vDate.setMinutes(0);
		}
		// Adjust min date to specific format boundaries (first of week or first of month)
		else if (pFormat === FormatDateProcess.Day) {
			// vDate.setDate(vDate.getDate() - 1);
			while (vDate.getDay() % 7 > 0) {
				vDate.setDate(vDate.getDate() - 1);
			}
		} else if (pFormat === FormatDateProcess.Week) {
			while (vDate.getDay() % 7 > 0) {
				vDate.setDate(vDate.getDate() - 1);
			}
		} else if (pFormat === FormatDateProcess.Month) {
			while (vDate.getDate() > 1) {
				vDate.setDate(vDate.getDate() - 1);
			}
		} else if (pFormat === FormatDateProcess.Quarter) {
			if (vDate.getMonth() < 3) vDate.setFullYear(vDate.getFullYear(), 0, 1);
			else if (vDate.getMonth() < 6 ) vDate.setFullYear(vDate.getFullYear(), 3, 1);
				 else if (vDate.getMonth() < 9 ) vDate.setFullYear(vDate.getFullYear(), 6, 1);
					 else vDate.setFullYear(vDate.getFullYear(), 9, 1);
		}
		return (vDate);
	}

	/**
	 * Используется для определения минимальной даты из всех задач и установки нижней границы в зависимости от формата
	 * @method getMaxDate
	 * @param pFormat {String} - current format (minute,hour,day...)
	 * @return {Datetime}
	 */
	getMaxDate(pFormat) {
		let vDate = new Date();
		if(this.tasks.size == 0) return vDate;
		vDate.setTime(this.tasks.values().next().value.end);
		// Parse all Task End dates to find max
		for (let task of this.tasks.values()) {
			if (Date.parse(task.end) > Date.parse(vDate)) vDate.setTime(Date.parse(task.end));
		}
		if (pFormat < FormatDateProcess.Minute) {
			vDate.setMinutes(0);
			vDate.setHours(0);
		}
		if (pFormat === FormatDateProcess.Minute) {
			while(vDate.getMinutes() > 0)
				vDate.setMinutes(vDate.getMinutes() + 1);
			// vDate.setMinutes(vDate.getMinutes() - 1);
		}
		if (pFormat === FormatDateProcess.Hour) {
			while(vDate.getHours() > 0)
				vDate.setHours(vDate.getHours() + 1);
			// vDate.setHours(vDate.getHours() - 1);
		}
		// Adjust max date to specific format boundaries (end of week or end of month)
		if (pFormat === FormatDateProcess.Day) {
			// vDate.setDate(vDate.getDate() + 1);
			while (vDate.getDay() % 6 > 0) {
				vDate.setDate(vDate.getDate() + 1);
			}
			//vDate.setDate(vDate.getDate() + 1);
		}
		if (pFormat === FormatDateProcess.Week) {
			while (vDate.getDay() % 6 > 0) {
				vDate.setDate(vDate.getDate() + 1);
			}
		}
		// Set to last day of current Month
		if (pFormat === FormatDateProcess.Month) {
			while (vDate.getDate() > 1) {
				vDate.setDate(vDate.getDate() + 1);
			}
			vDate.setDate(vDate.getDate() - 1);
		}
		// Set to last day of current Quarter
		if (pFormat === FormatDateProcess.Quarter) {
			if (vDate.getMonth() < 3) vDate.setFullYear(vDate.getFullYear(), 2, 31);
			else if (vDate.getMonth() < 6) vDate.setFullYear(vDate.getFullYear(), 5, 30);
				 else if (vDate.getMonth() < 9) vDate.setFullYear(vDate.getFullYear(), 8, 30);
					 else vDate.setFullYear(vDate.getFullYear(), 11, 31);
		}
		return (vDate);
	}

	/**
	 * Отображение отформатированной даты
	 * @method formatDateStr
	 * @param pDate {Date} - A javascript date object
	 * @param pFormatStr {String} - The date format (mm/dd/yyyy,dd/mm/yyyy,yyyy-mm-dd...)
	 * @return {String}
	 */
	formatDateStr(pDate, pFormatStr = this.dateDisplayFormat, pFormat = this.format) {
		let vYear4Str = pDate.getFullYear() + '';
		let vYear2Str = vYear4Str.substring(2, 4);
		let vMonthStr = (pDate.getMonth() + 1) + '';
		let vDayStr = pDate.getDate() + '';
		switch (pFormatStr) {
			case GanttDateFormat.ddmmyyyy: {//0
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vDayStr + '/' + vMonthStr + '/' + vYear4Str);
					case FormatDateProcess.Week://1
						return (vMonthStr + '/' + vYear4Str);
					case FormatDateProcess.Month://2
						return (vYear4Str);
					case FormatDateProcess.Quarter://3
						return (vYear4Str);
				}
			}
			case GanttDateFormat.mmddyyyy: {//1
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vMonthStr + '/' + vDayStr + '/' + vYear4Str);
					case FormatDateProcess.Week://1
						return (vMonthStr + '/' + vYear4Str);
					case FormatDateProcess.Month://2
						return (vYear4Str);
					case FormatDateProcess.Quarter://3
						return (vYear4Str);
				}
			}
			case GanttDateFormat.yyyymmdd: {//2
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vYear4Str + '/' + vMonthStr + '/' + vDayStr);
					case FormatDateProcess.Week://1
						return (vYear4Str + '/' + vMonthStr);
					case FormatDateProcess.Month://2
						return (vYear4Str);
					case FormatDateProcess.Quarter://3
						return (vYear4Str);
				}
			}
			case GanttDateFormat.yyyyddmm: {//3
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vYear4Str + '/' + vDayStr + '/' + vMonthStr);
					case FormatDateProcess.Week://1
						return (vYear4Str + '/' + vMonthStr);
					case FormatDateProcess.Month://2
						return (vMonthStr);
					case FormatDateProcess.Quarter://3
						return (vYear4Str);
				}
			}
			case GanttDateFormat.ddmmyy: {//4
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vDayStr + '/' + vMonthStr + '/' + vYear2Str);
					case FormatDateProcess.Week://1
						return (vMonthStr + '/' + vYear2Str);
					case FormatDateProcess.Month://2
						return (vYear2Str);
					case FormatDateProcess.Quarter://3
						return (vYear2Str);
				}
			}
			case GanttDateFormat.mmddyy: {//5
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vMonthStr + '/' + vDayStr + '/' + vYear2Str);
					case FormatDateProcess.Week://1
						return (vMonthStr + '/' + vYear2Str);
					case FormatDateProcess.Month://2
						return (vYear2Str);
					case FormatDateProcess.Quarter://3
						return (vYear2Str);
				}
			}
			case GanttDateFormat.yymmdd: {//6
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vYear2Str + '/' + vMonthStr + '/' + vDayStr);
					case FormatDateProcess.Week://1
						return (vYear2Str + '/' + vMonthStr);
					case FormatDateProcess.Month://2
						return (vYear2Str);
					case FormatDateProcess.Quarter://3
						return (vYear2Str);
				}
			}
			case GanttDateFormat.yyddmm: {//7
				switch (pFormat) {
					case FormatDateProcess.Day://0
						return (vYear2Str + '/' + vDayStr + '/' + vMonthStr);
					case FormatDateProcess.Week://1
						return (vYear2Str + '/' + vMonthStr);
					case FormatDateProcess.Month://2
						return (vYear2Str);
					case FormatDateProcess.Quarter://3
						return (vYear2Str);
				}
			}
			case GanttDateFormat.ddmm://8
				if(this.dateDisplayFormat == GanttDateFormat.ddmmyyyy ||
					this.dateDisplayFormat == GanttDateFormat.ddmmyy ||
					this.dateDisplayFormat == GanttDateFormat.yyddmm ||
					this.dateDisplayFormat == GanttDateFormat.yyyyddmm)
						return (vDayStr + '/' + vMonthStr);
				else
					return (vMonthStr + '/' + vDayStr);
		}
	}

	set showDur(v) {
		if(this.widget._$vShowDur === v) return;
		this.widget._$vShowDur = v;
	}

	get showDur() { return this.widget._$vShowDur; }

	set showRes(v) {
		if(this.widget._$vShowRes === v) return;
		this.widget._$vShowRes = v;
	}

	get showRes() { return this.widget._$vShowRes; }

	set showComp(v) {
		if(this.widget._$vShowComp === v) return;
		this.widget._$vShowComp = v;
	};

	get showComp() { return this.widget._$vShowComp; }

	set showStartDate(v) {
		if(this.widget._$vShowStartDate === v) return;
		this.widget._$vShowStartDate = v;
	};

	get showStartDate() { return this.widget._$vShowStartDate }

	set showEndDate(v) {
		if(this.widget._$vShowEndDate === v) return;
		this.widget._$vShowEndDate = v;
	};

	get showEndDate() { return this.widget._$vShowEndDate }

	set dateDisplayFormat(v) {
		if(this.widget._$vDateDisplayFormat === v) return;
		this.widget._$vDateDisplayFormat = v;
	};

	get dateDisplayFormat() { return this.widget._$vDateDisplayFormat; }

	set tasks(tasks){
		if(this.tasks === tasks) return;
		this.widget._$vTaskList = tasks;
	}
	
	get tasks() {
		if(this.widget._$vTaskList) return this.widget._$vTaskList;
		return null;
	}
}

class WidgetScrollHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetScroll");
		this.htmlElement.style.display = "none";
	}
	
	onSetState(state) {
		if(state.scrollType != null) this.widget.scrollType = state.scrollType;
		if(state.arrowsScrollingStep != null) this.widget.arrowsScrollingStep = state.arrowsScrollingStep;
		if(state.mouseScrollingStep != null) this.widget.mouseScrollingStep = state.mouseScrollingStep;
		if(state.arrowsVisible0or1 != null) this.widget.arrowsVisible0or1 = state.arrowsVisible0or1;
	}
	
}

/**
 * WidgetLayout
 */

class WidgetLayoutHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);

		this._scrollPosV = null;
		this._scrollPosH = null;

		this.createDomElement("div");
		this.htmlElement.classList.add("WidgetLayout");
		window.addEventListener("resize", (event) => {
			if(this.widget.parentId != -1) return;
			this.width = window.innerWidth;
			this.height = window.innerHeight;
		});

		try {
			new ResizeObserver(this.observeScrollable.bind(this)).observe(this.htmlElement);
		}
		catch(e) {
		}

		this.htmlElement.children.indexOf = function (child) {
			if (child == null) return -1;
			for (let i = 0; i < this.length; ++i)
				if (child === this[i]) return i;
			return -1;
		};

		this.htmlElement.addEventListener("scroll", function (event) {
			const maxScrollPosV = this.htmlElement.scrollHeight - this.htmlElement.clientHeight;
			if (this.htmlElement.scrollTop !== maxScrollPosV)
				Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPosVertical", [this.htmlElement.scrollTop / maxScrollPosV]);

			const maxScrollPosH = this.htmlElement.scrollWidth - this.htmlElement.clientWidth;
			if (this.htmlElement.scrollLeft !== maxScrollPosH)
				Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPosHorizontal", [this.htmlElement.scrollLeft / maxScrollPosH]);
		}.bind(this));
		
		this.widget._hoveredWidget = null;

		this.offsetData = 
		{
			id : this.id,
			type : this.getLayoutType(),
			children : []
		};
	}

	onSetState(state) {
		if(state.parentId != null) {
			if (state.parentId == -1) {
				this.posX = 0;
		 		this.posY = 0;
		 		this.width = window.innerWidth;
				this.height = window.innerHeight;
			}
		}

		if(state.baseLayoutOrientation != null) this.widget.baseLayoutOrientation = state.baseLayoutOrientation;
		if(state.editMode != null) this.widget.editMode = state.editMode;
		if(state.spacing != null) this.spacing = state.spacing;
		if(state.needControlScroll != null) this.needControlScroll = state.needControlScroll;
		if(state.direction != null) this.widget.direction = state.direction;
		if(state.scrollable != null) this.widget.scrollable = state.scrollable;
		
		if(state.scrollPosV != null) this.scrollPosVertical = state.scrollPosV;
		if(state.scrollPosH != null) this.scrollPosHorizontal = state.scrollPosH;

		if(state.width != null) this.savedW = state.width;
		if(state.height != null) this.savedH = state.height;

		if(state.parentId != null && state.parentId != -1) {
			this.width = this.savedW;
			this.height = this.savedH;
		}

	}

	appendChild(child) {
		if (child == null)
			return;

		if(!this.contains(child)) {
			if (this.widget.direction === 0) {
				this.htmlElement.appendChild(child);
			} else if (this.widget.direction === 1) {
				const firstChild = this.htmlElement.firstChild;
				this.htmlElement.insertBefore(child, firstChild);
			}

			let ID = child.id;
			try {
				if (child.id.indexOf("w") === 0) {
					ID = (child.id.slice(1));
				}
			} catch(e) {}

			if (this.widget.children.indexOf(parseInt(ID)) === -1)
				this.widget.children.push(parseInt(ID));
			
			this.widgetOrder = this.widget.children;
			this.spacing = this.widget._spacing;
			this.scrollPosVertical = this.scrollPosVertical;
			this.scrollPosHorizontal = this.scrollPosHorizontal;
		}
	}

	onInit() {
		for(let childId of this.widget.children) {
			let child = Rex.widgets[childId];
			if(child == null) continue;
			child.view.width = "100%";
			child.view.height = undefined;
		}
	}

	checkSelect(event, parentId) {
		if (this.widget.editMode === true) {
			const path = event.path || (event.composedPath && event.composedPath());
			let widget = Rex.widgets[path[path.length - 1]];
			if (widget == null) return this.hover ? this.widget : null;
			if (widget.parentId === this.widget.id) {
				if (widget.editMode) return widget.view.checkSelect(event, parentId);
				this.widget._hoveredWidget = widget;
				return this.hover ? this.widget : null;
			}
			this.widget._hoveredWidget = null;
			return this.hover ? this.widget : null;
		} else return super.checkSelect(event, parentId);
	}

	// Функция возвращает численное значение типа Layout'а
	// return values
	// 	1 - Vertical || Flex
	// 	2 - Horizontal
	// 	0 - Any other widget
	getLayoutType(widget) {
		if (widget == null)
			widget = this.widget;

		const type = widget.type;

		if (type == "WidgetLayoutVertical" || type == "WidgetLayoutFlex")
			return 1;
		else if (type == "WidgetLayoutHorizontal")
			return 2;

		return 0;
	}

	getScroll() {
		const offset = 
		{
			width : (this.htmlElement.scrollWidth - this.htmlElement.clientWidth),
			height : (this.htmlElement.scrollHeight - this.htmlElement.clientHeight),
		};
		return offset;
	}

	observeScrollable(event) {
		this.setScrollable();
	}

	setScrollable(widgetType = -1, parentId = null) {
		if (Rex.widgets == null)
			return null;

		// get current layout type
		const typeId = this.getLayoutType();
		// it isn't vertical, horizontal or flex layout
		if (typeId === 0)
			return null;

		// keep the type of widget that called the function for the first time
		if (widgetType === -1)
			widgetType = typeId;

		if (this.widget.scrollable === false) {
			// get scroll offset, type and parent id values of current layout
			this.offsetData.offset = this.getScroll();
			this.offsetData.type = typeId;
			this.offsetData.parentId = parentId;

			//check children for scroll offset
			for (let childId of this.widget.children) {
				let widgetChild = Rex.widgets[childId];
				if (!widgetChild)
					return null;

				// if child widget isn't vertical or flex, then push 0 to the children array
				if (this.getLayoutType(widgetChild) === 0) {
					this.offsetData.children.push(0);
					continue;
				}

				widgetChild._scrollable = false;
				// call this method recursively for each child whose type value is not 0
				let data = widgetChild.view.setScrollable(widgetType, this.offsetData.id);
				// push children offset data to the children array
				this.offsetData.children.push(data);
			}

			// update offset values
			this.offsetData.offset = this.getScroll();

			let parentData = null;
			if (Rex.widgets[this.offsetData.parentId] != null) {
				parentData = Rex.widgets[this.offsetData.parentId].view.offsetData;
			} else return null;

			// if vertical or flex
			if (typeId === 1) {
				// add offset height to style height
				if (this.offsetData.offset.height !== 0)
					this.htmlElement.style.minHeight = this.htmlElement.clientHeight + this.offsetData.offset.height + 'px';

				if (parentData != null) {
					if (parentData.type !== typeId && this.offsetData.offset.height !== 0)
						// if layout has offset, that shouldn't have, and has parent offset data
						// set that offset value to the parent
						parentData.offset.height = this.offsetData.offset.height;
				}

				if (this.offsetData.offset.width !== 0) {
					if (parentData != null)
						this.htmlElement.style.minWidth = this.htmlElement.clientWidth + this.offsetData.offset.width + 'px';
				}
			// if horizontal layout
			// the same thing except that the height replaced with a width 
			} else if (typeId === 2) {
				if (this.offsetData.offset.width !== 0)
					this.htmlElement.style.minWidth = this.htmlElement.clientWidth + this.offsetData.offset.width + 'px';

				if (parentData != null) {
					if (parentData.type !== typeId && this.offsetData.offset.width !== 0)
						parentData.offset.width = this.offsetData.offset.width;
				}

				if (this.offsetData.offset.height !== 0) {
					if (parentData != null)
						this.htmlElement.style.minHeight = this.htmlElement.clientHeight + this.offsetData.offset.height + 'px';
				}
			}
		} else {
			// restore old offset values
			for (let childID of this.widget.children) {
				const childWidget = Rex.widgets[childID];
				if (!childWidget)
					continue;

				if (childWidget.type.search("Layout") !== -1 && childWidget.type.search("Grid") === -1) {
					const childHtml = childWidget.view.htmlElement;

					if (typeId === 1)
						childHtml.style.minHeight = childWidget.minHeight + 'px';
					else if (typeId === 2)
						childHtml.style.minWidth = childWidget.minWidth + 'px';
				}
			}
		}

		return this.offsetData;
	}

	set widgetOrder(value) {
		if (value == null) return;
		if (value.length === 0) return;
		this.widget._widgetOrder = value;
		
		if (this.children.length === 0) return;
		if (value.length !== this.children.length) return;
		if (Rex.widgets === undefined) return;
		
		while(this.htmlElement.children.length !== 0)
			this.htmlElement.removeChild(this.htmlElement.children[0]);
		
		for (const id of this.widget._widgetOrder) {
			const child = Rex.widgets[id];
			if (child === undefined) continue;
			this.htmlElement.appendChild(child.view.htmlElement);
		}
	}

	set spacing(value) {}

	set scrollPosVertical(value) {
		if(!this.needControlScroll) return;
		if (value < 0 || value > 1) return;
		this._scrollPosV = value;
		const maxScrollPos = this.htmlElement.scrollHeight - this.htmlElement.clientHeight;
		this.htmlElement.scrollTop = value * maxScrollPos;
	}

	get scrollPosVertical() {
		return this._scrollPosV;
	}

	set scrollPosHorizontal(value) {
		if(!this.needControlScroll) return;
		if (value < 0 || value > 1) return;
		this._scrollPosH = value;
		const maxScrollPos = this.htmlElement.scrollWidth - this.htmlElement.clientWidth;
		this.htmlElement.scrollLeft = value * maxScrollPos;
	}

	get scrollPosHorizontal() {
		return this._scrollPosH;
	}
	
	set needControlScroll(value) {
		if (value == null) return;
		this.widget._needControlScroll = value;
	}
	
	get needControlScroll() {
		return this.widget._needControlScroll;
	}

}


/*
 * Created by Andrey Nikulin on 10.12.2018
 */

class WidgetLayoutFlexHtml extends WidgetLayoutHtml {

	constructor(widget) {
		super(widget);
		this.htmlElement.classList.add("WidgetLayoutFlex");
		this.currentChildren = [];
	}

	onSetState(state) {
		super.onSetState(state);

		if (state.minWidgetHeight != null)	
			this.htmlElement.style.setProperty("--child-min-height", state.minWidgetHeight + "px");
		if (state.maxWidgetHeight != null)
			this.htmlElement.style.setProperty("--child-max-height", state.maxWidgetHeight + "px");
		if (state.minWidgetWidth != null)
			this.htmlElement.style.setProperty("--child-min-width", state.minWidgetWidth + "px");
		if (state.maxWidgetWidth != null)
			this.htmlElement.style.setProperty("--child-max-width", state.maxWidgetWidth + "px");
		if (state.spacing != null)
			this.htmlElement.style.setProperty("--child-spacing", state.spacing + "px");
	}

	appendChild(child) {
		this.htmlElement.appendChild(child);
		this.currentChildren.push(parseInt(child.id));
		this.scrollPosHorizontal = this.scrollPosHorizontal;
		this.scrollPosVertical = this.scrollPosVertical;

		if (!this.widget.scrollable) {
			let delta = Math.abs(this.htmlElement.scrollHeight - this.htmlElement.clientHeight);
			if (delta !== 0)
				this.htmlElement.style.minHeight = this.htmlElement.clientHeight + delta + 'px';
		} else {
			this.htmlElement.style.minHeight = this.widget._oldMinHeightStyleValue;
		}
	}

	set spacing(value) {
		if (value == null) return;
		if (value < 0) return;

		this.widget._spacing = value;
		this.htmlElement.style.setProperty("--child-spacing", value);
	}

}

class WidgetLayoutGridHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.htmlElement.classList.add("WidgetLayoutGrid");

		this.inited = false;

		//Контейнер для виджетов, которые прилетели до инита грида
		this.WIDGETS = [];

		this.widget.scrollGridParamX = false;
		this.widget.scrollGridParamY = false;

		this.gridItems = [];
	}

	onSetState(state) {
		//GRID SIZE
		if(state.countRow != null) {
			if (this.widget.countRow !== state.countRow || this.widget.prevCountRow === undefined)
				this.widget.prevCountRow = this.widget.countRow;
			this.widget.countRow = state.countRow;
		}
		if(state.countCol != null) {
			if (this.widget.countCol !== state.countCol || this.widget.prevCountCol === undefined)
				this.widget.prevCountCol = this.widget.countCol;
			this.widget.countCol = state.countCol;
		}

		//GIRD DATA
		if(state.cells != null) this.widget.cells = state.cells;
		if(state.templateRow) this.widget.templateRows = state.templateRow;
		if(state.templateCol) this.widget.templateColumns = state.templateCol;

		if(state.cellPaddings != null) {
			this.widget.cellPaddings = state.cellPaddings;
			this.widget.expand();
			if (this.inited) this.widget.applyPadding(this.widget.cellPaddings);
		}
		if(state.swapData != null) this.widget.swapCells = state.swapData;

		//GRID OPTIONS
		if(state.editMode != null) this.widget.setEditMode(state.editMode);
		if(state.transparentBorder != null) this.transparentBorder = state.transparentBorder;

		if(state.textAlign != null) this.htmlElement.style.justifyContent = null;

		if(this.WIDGETS.length !== 0) {
			for (let i = 0; i < this.WIDGETS.length; ++i) {
				this.appendChild(this.WIDGETS[i]);
			}
			this.WIDGETS = [];
		}

	}

	appendChild(child) {
		if (!this.contains(child)) {
			if (this.inited === true) {
				let cell = this.widget.getCellByChild(child);
				if (cell == null && !this.WIDGETS.includes(child)) {
					this.WIDGETS.push(child);
					return;
				}
				cell.appendChild(child);
				this.gridItems.push(child);
			} else if (this.inited === false) {
				if (!this.WIDGETS.includes(child))
					this.WIDGETS.push(child);
			}
		}
	}

	generateGridTemplateRows() {
		let grid_template_rows = "";
		let sum = 0;
		for (let i = 0; i < this.widget.countRow; ++i) {
			const val = this.widget._templateRow[i] * 100;
			if (i !== this.widget.countRow - 1)
				grid_template_rows += Math.abs(val) + "%";
			else grid_template_rows += "auto";
			sum += val;
		}
		this.htmlElement.style.gridTemplateRows = grid_template_rows;
	}

	generateGridTemplateColumns() {
		let lessZero = [];
		let grid_template_columns = "";
		let sum = 0;
		for (let i = 0; i < this.widget.countCol; ++i) {
			const val = this.widget._templateCol[i] * 100;
			if (val < 0) lessZero.push(val);
			if (i !== this.widget.countCol - 1)
				grid_template_columns += Math.abs(val) + "%";
			else grid_template_columns += "auto";
			sum += val;
		}
		this.htmlElement.style.gridTemplateColumns = grid_template_columns;
	}

	initGrid(row, col, indexR = 0, indexC = 0) {
		for (let i = indexR; i < row; i++) {
			for (let j = indexC; j < col; j++) {
				let cell = document.createElement("div");
				cell.classList.add("LayoutGridCell");

				cell.parentId = this.widget.id;
				cell.row = i;
				cell.col = j;

				let cellPadding = this.widget.cellPaddings[i][j];

				cell = this.setCellData(cell, cellPadding);

				this.htmlElement.appendChild(cell);
				this.createResizersForCell(row, col, cell);
			}
		}
		this.inited = true;

		//После инита пробегаем по массиву и добавляем виджеты на свои позиции
		if (this.WIDGETS.length !== 0) {
			for (let i = 0; i < this.WIDGETS.length; i++) {
				let child = this.WIDGETS[i];
				this.appendChild(child);
			}
			this.WIDGETS = [];
		}

	}

	createResizersForCell(row, col, cell) {
		//Функция создает "ползунки", за которые можно тянуть, для ячейки
		if (cell.col !== 0) {
			let cellResizerLeft = document.createElement("div");
			cellResizerLeft.classList.add("cell-resizer");
			cellResizerLeft.classList.add("cell-resizer-left");
			cellResizerLeft.parentCell = cell;
			cell.appendChild(cellResizerLeft);
			cell.leftResizer = cellResizerLeft;
			// cellResizerLeft.addEventListener("mousemove", this.resizeL.bind(this.widget));
		}
		if (cell.col !== col - 1) {
			let cellResizerRight = document.createElement("div");
			cellResizerRight.classList.add("cell-resizer");
			cellResizerRight.classList.add("cell-resizer-right");
			cellResizerRight.parentCell = cell;
			cell.appendChild(cellResizerRight);
			cell.rightResizer = cellResizerRight;
		}
		if (cell.row !== 0) {
			let cellResizerTop = document.createElement("div");
			cellResizerTop.classList.add("cell-resizer");
			cellResizerTop.classList.add("cell-resizer-top");
			cellResizerTop.parentCell = cell;
			cell.appendChild(cellResizerTop);
			cell.topResizer = cellResizerTop;
		}
		if (cell.row !== row - 1) {
			let cellResizerBottom = document.createElement("div");
			cellResizerBottom.classList.add("cell-resizer");
			cellResizerBottom.classList.add("cell-resizer-bottom");
			cellResizerBottom.parentCell = cell;
			cell.appendChild(cellResizerBottom);
			cell.bottomResizer = cellResizerBottom;
		}
	}

	addRowToEnd() {
		for (let i = this.widget.prevCountRow; i < this.widget.countRow; ++i) {
			for (let j = 0; j < this.widget.countCol; ++j) {
				let cell = document.createElement("div");
				cell.classList.add("LayoutGridCell");
				if (this.widget.editMode) cell.classList.add("editMode");

				cell.parentId = this.widget.id;
				cell.row = i;
				cell.col = j;

				this.createResizersForCell(i, j, cell);

				const paddingData = this.widget.cellPaddings[i][j];

				this.setCellData(cell, paddingData);
				this.htmlElement.appendChild(cell);

				this.widget.applyPadding();
			}
		}
	}

	removeLastRow() {
		let toRemove = [];

		for (let i = this.widget.countRow; i < this.widget.prevCountRow; ++i) {
			// for (let j = 0; j < this.widget.countCol; ++j) {
			for (let j = 0; j < this.widget.prevCountCol; ++j) {
				const index = i * this.widget.countCol + j;
				const cell = this.htmlElement.children[index];
				toRemove.push(cell);
			}
		}

		for (let i = 0; i < toRemove.length; ++i)
			this.htmlElement.removeChild(toRemove[i]);
	}

	addColToEnd() {
		for (let i = 0; i < this.widget.countRow; ++i) {
			for (let j = this.widget.prevCountCol; j < this.widget.countCol; ++j) {
				const index = i * this.widget.countCol + j;
				let cell = document.createElement("div");
				cell.classList.add("LayoutGridCell");
				if (this.widget.editMode) cell.classList.add("editMode");

				cell.parentId = this.widget.id;
				cell.row = i;
				cell.col = j;

				this.createResizersForCell(i, j, cell);

				const paddingData = this.widget.cellPaddings[i][j];

				this.setCellData(cell, paddingData);
				this.htmlElement.insertBefore(cell, this.htmlElement.children[index]);
			}
		}
	}

	removeLastCol() {
		let toRemove = [];

		for (let i = 0; i < this.widget.countRow; ++i) {
			for (let j = this.widget.countCol; j < this.widget.prevCountCol; ++j) {
				const index = i * this.widget.prevCountCol + j;
				const cell = this.htmlElement.children[index];
				if (!cell) continue;
				toRemove.push(cell);
			}
		}

		for (let cell of toRemove)
			this.htmlElement.removeChild(cell);
	}

	redrawGrid(row, col) {
		if (row == null || col == null) return;
		if (this.htmlElement.children.length === 0) {
			if (!this.inited)
				this.initGrid(row, col);
		} else {
			if (row > this.widget.prevCountRow) {
				this.addRowToEnd();
				this.widget.prevCountRow = row;
			}
			else if (row < this.widget.prevCountRow) {
				this.removeLastRow();
				this.widget.prevCountRow = row;
			}

			if (col > this.widget.prevCountCol) {
				this.addColToEnd();
				this.widget.prevCountCol = col;
			}
			else if (col < this.widget.prevCountCol) {
				this.removeLastCol();
				this.widget.prevCountCol = col;
			}
		}
	}

	checkSelect(event, parentId) {
		const path = event.path || (event.composedPath && event.composedPath());
		if (this.widget.editMode === true) {
			if (this.widget.hovered_widget_cell == null) {
				let widget = Rex.widgets[path[path.length - 1]];
				if (widget == null) return this.hover ? this.widget : null;
				if (widget.parentId === this.widget.id) {
					this.widget.hovered_widget = widget;
					if (widget.editMode) return widget.view.checkSelect(event, parentId);
					return this.hover ? this.widget : null;
				}
				this.widget.hovered_widget = null;
				return this.hover ? this.widget : null;
			}
		} else return super.checkSelect(event, parentId);
	}

	setHover(value) {
		for (let i = 0; i < this.htmlElement.children.length; i++) {
			let child = this.htmlElement.children[i];

			if (value) child.classList.add("editMode");
			else child.classList.remove("editMode");
		}
	}

	setCellData(cell, cellPadding) {
		const width = this.styleWidth;
		const height = this.styleHeight;

		cell.paddingLeftValue = Math.round(width * cellPadding[0]);     // 0 - left
		cell.paddingRightValue = Math.round(width * cellPadding[1]);    // 1 - right
		cell.paddingTopValue = Math.round(height * cellPadding[2]);     // 2 - top
		cell.paddingBottomValue = Math.round(height * cellPadding[3]);  // 3 - bottom

		return cell;
	}

	get styleWidth() {
		return parseInt(this.getStyle(this.htmlElement, "width"));
	}

	get styleHeight() {
		return parseInt(this.getStyle(this.htmlElement, "height"));
	}

	getStyle(node, strCssRule) {
		let oElm = node;
		let strValue = "";
		if (document.defaultView && document.defaultView.getComputedStyle) {
			let v = document.defaultView.getComputedStyle(oElm, "");
			strValue = v[strCssRule];

			if (strValue.length === 0) strValue = node.style[strCssRule];
		}
		else if (oElm.currentStyle) {
			strCssRule = strCssRule.replace(/\-(\w)/g, function (strMatch, p1) {
				return p1.toUpperCase();
			});
			strValue = oElm.currentStyle[strCssRule];
		}
		return strValue;
	}
	
    set transparentBorder(value) {
		if (!this.widget.editMode) return;
		if (value == null) return;
		this.widget._transparentBorder = value;
		this.setHover(!value);
	}
}

/* eslint-disable no-unused-vars */
/* global Widget WidgetLayoutHtml*/


/**
 * Created by prg-37 on 17.09.2017.
 */

class WidgetLayoutVerticalHtml extends WidgetLayoutHtml {

	constructor(widget) {
		super(widget);
		this.addClassName("WidgetLayoutVertical");

		this._childrenAlignType = null;
		this._childrenHorizontalAlignType = 0;
		this._childrenVerticalAlignType = 0;
	}

	onSetState(state) {
		super.onSetState(state);

		if (state.childrenHorizontalAlignType != null)
			this.controlChildrenHorizontalAlignType(state.childrenHorizontalAlignType);
		if (state.childrenVerticalAlignType != null)
			this.controlChildrenVerticalAlignType(state.childrenVerticalAlignType);
	}

	appendChild(child) {
		super.appendChild(child);
	}

	set spacing(value) {
		if (value == null) return;
		if (value < 0) return;

		this.widget._spacing = value;

		for (let i = 0; i < this.htmlElement.children.length - 1; ++i) {
			const child = this.htmlElement.children[i];
			if (child == null) continue;
			child.style.marginBottom = value + "px";
		}

		if (this.htmlElement.children.length > 1) {
			let lastChild = this.htmlElement.children[this.htmlElement.children.length - 1];
			if (lastChild != null)
				lastChild.style.marginBottom = null;
		}
	}
	
	controlChildrenHorizontalAlignType(alignmentType) {			
		if (!alignmentType)
			return;

		if (alignmentType === 0) //none = left
			alignmentType = 1;

		this._childrenHorizontalAlignType = alignmentType;

		if (alignmentType === 1)
			this.htmlElement.style.alignItems = "flex-start";
		else if (alignmentType === 2)
			this.htmlElement.style.alignItems = "center";
		else if (alignmentType === 3)
			this.htmlElement.style.alignItems = "flex-end";
		
	}

	controlChildrenVerticalAlignType(alignmentType) {
		if (!alignmentType)
			return;
			
		this._childrenVerticalAlignType = alignmentType;
			
		if (this.hasScroll()) {
			this.htmlElement.style.justifyContent = "";
			return;
		}

		if (alignmentType === 0)
			this.htmlElement.style.justifyContent = "";
		else if (alignmentType === 1)
			this.htmlElement.style.justifyContent = "flex-start";
		else if (alignmentType === 2)
			this.htmlElement.style.justifyContent = "center";
		else if (alignmentType === 3)
			this.htmlElement.style.justifyContent = "flex-end";
	}

	hasScroll() {
		return Math.abs(this.htmlElement.scrollHeight - this.htmlElement.clientHeight) !== 0;
	}

}


/* eslint-disable no-unused-vars */
/* global Widget WidgetLayoutHtml*/

/**
 * Created by GAA on 11.01.2018.
 */

class WidgetLayoutHorizontalHtml extends WidgetLayoutHtml {

	constructor(widget) {
		super(widget);
		this.htmlElement.classList.add("WidgetLayoutHorizontal");

		this._childrenAlignType = null;
	}

	onSetState(state) {
		super.onSetState(state);

		if (state.childrenHorizontalAlignType != null)
			this.controlChildrenHorizontalAlignType(state.childrenHorizontalAlignType);
		if (state.childrenVerticalAlignType != null)
			this.controlChildrenVerticalAlignType(state.childrenVerticalAlignType);
	}

	appendChild(child) {
		super.appendChild(child);

		this.controlChildrenHorizontalAlignType(this._childrenHorizontalAlignType);
		this.controlChildrenVerticalAlignType(this._childrenVerticalAlignType);
	}

	set spacing(value) {
		if (value == null) return;
		if (value < 0) return;

		this.widget._spacing = value;

		for (let i = 0; i < this.htmlElement.children.length - 1; ++i) {
			const child = this.htmlElement.children[i];
			if (child == null) continue;
			child.style.marginRight = value + "px";
		}

		if (this.htmlElement.children.length > 1) {
			let lastChild = this.htmlElement.children[this.htmlElement.children.length - 1];
			if (lastChild != null)
				lastChild.style.marginRight = null;
		}

	}
	
	controlChildrenHorizontalAlignType(alignmentType) {
		if (!alignmentType)
			return;

		this._childrenHorizontalAlignType = alignmentType;
		
		if (this.hasScroll()) {
			this.htmlElement.style.justifyContent = "";
			return;
		}

		if (alignmentType === 0)
			this.htmlElement.style.justifyContent = "";
		else if (alignmentType === 1)
			this.htmlElement.style.justifyContent = "flex-start";
		else if (alignmentType === 2)
			this.htmlElement.style.justifyContent = "center";
		else if (alignmentType === 3)
			this.htmlElement.style.justifyContent = "flex-end";
	}

	controlChildrenVerticalAlignType(alignmentType) {
		if (!alignmentType)
			return;

		if (alignmentType === 0) //none = top
			alignmentType = 1;

		this._childrenVerticalAlignType = alignmentType;
		
		if (alignmentType === 1)
			this.htmlElement.style.alignItems = "flex-start";
		else if (alignmentType === 2)
			this.htmlElement.style.alignItems = "center";
		else if (alignmentType === 3)
			this.htmlElement.style.alignItems = "flex-end";
	}

	hasScroll() {
		return Math.abs(this.htmlElement.scrollWidth - this.htmlElement.clientWidth) !== 0;
	}
}


/* eslint-disable no-unused-vars */
/* global WidgetViewHtml Rex*/

/**
 * Created by prg-15 on 04.01.2018.
 */
class WidgetScrollAreaHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetScrollArea");

		this.htmlElement.addEventListener("scroll", function (event) {
			const maxScrollPosV = this.htmlElement.scrollHeight - this.htmlElement.clientHeight;
			if (this.htmlElement.scrollTop !== maxScrollPosV)
				Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPosVertical", [this.htmlElement.scrollTop / maxScrollPosV]);

			const maxScrollPosH = this.htmlElement.scrollWidth - this.htmlElement.clientWidth;
			if (this.htmlElement.scrollLeft !== maxScrollPosH)
				Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPosHorizontal", [this.htmlElement.scrollLeft / maxScrollPosH]);
		}.bind(this));
	}

	onSetState(state) {
		if(state.scrollPosV != null) this.scrollPosVertical = state.scrollPosV;
		if(state.scrollPosH != null) this.scrollPosHorizontal = state.scrollPosH;
		if(state.needControlScroll) this.needControlScroll = state.needControlScroll;
	}

	appendChild(child) {
		super.appendChild(child);
		this.scrollPosVertical = this.scrollPosVertical;
		this.scrollPosHorizontal = this.scrollPosHorizontal;
	}

	set scrollPosVertical(value) {
		if(!this.needControlScroll) return;
		if (value < 0 || value > 1) return;
		this._scrollPosV = value;
		const maxScrollPos = this.htmlElement.scrollHeight - this.htmlElement.clientHeight;
		const currentScrollPos = value * maxScrollPos;
		if (this.htmlElement.scrollTop === currentScrollPos) return;
		this.htmlElement.scrollTop = currentScrollPos ;
	}

	get scrollPosVertical() {
		return this._scrollPosV;
	}

	set scrollPosHorizontal(value) {
		if(!this.needControlScroll) return;
		if (value < 0 || value > 1) return;
		this._scrollPosH = value;
		const maxScrollPos = this.htmlElement.scrollWidth - this.htmlElement.clientWidth;
		const currentScrollPos = value * maxScrollPos;
		if (this.htmlElement.scrollLeft === currentScrollPos) return;
		this.htmlElement.scrollLeft = currentScrollPos ;
	}

	get scrollPosHorizontal() {
		return this._scrollPosH;
	}

	set needControlScroll(value) {
		if (value == null) return;
		this.widget._needControlScroll = value;
	}

	get needControlScroll() {
		return this.widget._needControlScroll;
	}

}


/**
 * Created by prg-30 on 10.06.2017.
 */

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex*/

class WidgetInputHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);

		this.m_text = "";

		this.createDomElement("div");
		this.addClassName("WidgetInput");

		this.inputElement = document.createElement("input");
		this.inputElement.type = "text";
		this.inputElement.required = true;
		this.headerElement = document.createElement("label");
		this.spanElement = document.createElement("span");

		this.htmlElement.appendChild(this.headerElement);
		this.htmlElement.appendChild(this.inputElement);
		this.htmlElement.appendChild(this.spanElement);

		try {
			new ResizeObserver(this.controlFontSize.bind(this)).observe(this.htmlElement);
		} catch (e) {
		}


		// this.attributeStyle = ["min", "max", "value", "type", "pattern", "step", "checked", "disable", "list", "maxlength", "placeholder", "required"];
	}

	onSetState(state) {
		if (typeof state.regularExp !== "undefined") {
			try {
				this.widget.regularExp = decodeURIComponent(escape(window.atob(state.regularExp)));
			} catch (e) {
				console.error(this.widget.type, "setState->", "regularExp DecodeError!")
			}
		}
		if (state.flagUpdate != null) this.widget.flagUpdate = state.flagUpdate;
		if (state.valid != null) this.controlValid(state.valid);
		if (state.typeValidate != null) this.widget.typeValidate = state.typeValidate;
		if (state.autoFontSize != null) this.autoFontSize = state.autoFontSize;

		if (state.textColor != null) this.controlTextColor();
		if (state.fontBold != null || state.fontItalic != null) this.controlFontStyle();
		if (state.fontSize != null) this.controlFontSize();
		if (state.typeInput != null) this.controlTypeInput();

		if (state.text != null) {
			// if (this.text == this.inputElement.value) return;
			// if (this.text == this.sendData) return;
			this.controlInputFormat();
		}
	}

	onInit() {
		this.inputElement.id = `${"input_" + this.widget.id}`;
		this.inputElement.classList.add("WidgetInputText");
		this.headerElement.classList.add("WidgetInputHeader");
		this.spanElement.classList.add("WidgetInputBar");

		this.inputElement.oninput = () => {
			if (this.inputElement.value != this.sendData) {
				this.controlInputFormat();
			}
		};
	}

	set text(value) {
		// let old = this.widget.text;
		// let nText = "";
		// try {nText = decodeURIComponent(escape(window.atob(value)));}
		// catch(e) { console.error(this.widget.type, "setState->", "Text DecodeError!")}
		// if(old != nText) {
		// 	this.widget.text = nText;
		// 	this.widget.str = this.widget.text;
		// 	if(this.sendData == nText) return;
		// 	this.inputElement.value = nText;
		// 	this.controlInputFormat();
		// }

		let nText = "";
		try {
			nText = decodeURIComponent(escape(window.atob(value)));
		} catch (e) {
			console.error(this.widget.type, "setState->", "Text DecodeError!")
		}

		this.widget.text = nText;
		if (this.sendData == nText) return;
		this.inputElement.value = nText;
		this.sendData = nText;
		this.controlInputFormat(false);
		
	}

	get text() {
		return this.widget.text;
	}

	set header(value) {
		let oldh = this.widget.header;
		let nHeader = "";
		try {
			nHeader = decodeURIComponent(escape(window.atob(value)));
		} catch (e) {
			console.error(this.widget.type, "setState->", "Header DecodeError!")
		}
		if (oldh != nHeader) {
			this.widget.header = nHeader;
			this.headerElement.innerText = nHeader;
		}
	}

	get header() {
		return this.widget.header;
	}

	set customStyle(value) {
		this.widget.customStyle = value;
		for (let name in value) {
			let v = value[name];
			if (this.attributeStyle.indexOf(name) != -1) {
				if (document.body.style[name] !== undefined || (name.substr(0, 2) === "--")) {
					this.inputElement.style.setProperty(name, v);
					continue;
				}
				this.inputElement.setAttribute(name, v);
			} else {
				if (document.body.style[name] !== undefined || (name.substr(0, 2) === "--")) {
					this.htmlElement.style.setProperty(name, v);
					continue;
				}
				this.htmlElement.setAttribute(name, v);
			}
		}
	}

	set autoFontSize(value) {
		if (value == null) return;
		this.widget._autoFontSize = value;
		this.controlFontSize();
		if (!value) {
			let t = "px";
			let font_size = parseInt(this.widget.fontSize);

			if (this.widget.fontSize.indexOf("px") != -1) t = "px";
			else if (this.widget.fontSize.indexOf("%") != -1) t = "%";

			this.inputElement.style.fontSize = font_size + t;
		}
	}

	get autoFontSize() {
		return this.widget._autoFontSize;
	}

	//рут: я не просто так это гавно скопипиздил, где-то может ебануть
	//саня: но блядь, тут же одна и та же херня, и все три работают одновременно.
	//рут: бля, я предупредил
	//саня: похуй.
	//саня: ...
	//саня: но пожалуй оставлю все же комментарий.
	//keyDown(event) {
	//	console.log('preeesssss',event);
	//	if(event.key == "Enter") this.widget.pressEnter(true);
	//	this.widget.str = this.inputElement.value;
	//	this.widget._text = this.widget.str;
	//	Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setText', [this.widget.text]);
	//}
	//
	//UPD саня: ну бомбануло конечно. странно, что это вообще работало...
	// саня: я тут подправил чутка - хотя бы сделал методы разными. до следущего бабаха
	//
	//
	//upd2 саня: бля снова бомбануло. немного причесал, но и это не идеально.
	// саня: зато убрал костыль сверху. до следущего бабаха

	keyUp(event) {
		//this.widget.str = this.inputElement.value;
		//this.widget._text = this.widget.str;
		//Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setText', [this.widget.text]);
	}

	keyPress(event) {
		if (event.key == "Enter") {
			this.controlInputFormat();
			this.widget.pressEnter(true);
		}
	}

	sendText(v) {
		let data = this.inputElement.value;
		if (null != v)
			data = v;

		if(this.sendData == data) return;
		this.sendData = data;
		Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "setTextJS", [data]);
	}

	controlTextColor() {
		this.inputElement.style.color = this.textColor;
		this.headerElement.style.color = this.textColor;
		this.headerElement.style.filter = "brightness(50%)";

		this.spanElement.style.setProperty("--main-color", this.textColor);
	}

	controlFontStyle() {
		let italic = "";
		if (this.fontItalic) italic = "italic";
		this.inputElement.style.fontStyle = italic;
		this.headerElement.style.fontStyle = italic;

		let bold = "";
		if (this.fontBold) bold = "bold";
		this.inputElement.style.fontWeight = bold;
		this.headerElement.style.fontWeight = bold;
	}

	controlFontSize() {
		let t = "px";
		let font_size = parseInt(this.widget.fontSize);

		if (this.widget.fontSize.indexOf("px") != -1) t = "px";
		else if (this.widget.fontSize.indexOf("%") != -1) t = "%";

		if (!this.autoFontSize)
			this.headerElement.style.fontSize = (font_size * 0.8) + t;
		else {
			let html = this.headerElement;
			const ratio = html.clientWidth < html.clientHeight ? html.clientWidth / html.clientHeight :
				html.clientHeight / html.clientWidth;
			const side = Math.max(html.clientWidth, html.clientHeight);
			const fontSize = side * ratio * 4.5;
			html.style.fontSize = fontSize + "%";
			this.inputElement.style.fontSize = (fontSize + 40) + "%";
		}

	}

	controlValid(stateValid) {
		this.widget.valid = stateValid;
		if (stateValid) this.inputElement.classList.remove("Invalid");
		else this.inputElement.classList.add("Invalid");
	}

	controlTypeInput() {
		if (this.typeInput == 1) this.inputElement.type = "password";
		else this.inputElement.type = "";
		this.controlInputFormat(false);
	}

	controlInputFormat(send) {
		if (this.typeInput == 0 || this.typeInput == 1) {
			if(send == null) this.sendText();
			return;
		}

		if (this.typeInput == 2) { // Numeric
			// 1000000.545455 => 1 000 000.545455

			let sendData = this.inputElement.value;

			let index1 = sendData.indexOf(".");
			let index2 = sendData.indexOf(",");
			if(index1 != -1) {
				// find .
				let intPart = sendData.substring(0, index1);
				let doublePart = sendData.substring(index1);

				let intStr = intPart.replace(/[^.\d]+/g, "");
				let doubleStr = doublePart.replace(/[^.\d]+/g, "");
				sendData = intStr + doubleStr;

				let viewData = "";
				intStr = intStr.split("").reverse().join("");
				for(let i = 0; i < intStr.length; i++) {
					
					viewData += intStr[i];
					if ((i + 1) % 3 == 0 && (i != intStr.length - 1) && (i != 0)) {
						viewData += " ";
					}
				}
				viewData = viewData.split("").reverse().join("") + doubleStr;

				this.inputElement.value = viewData;
				if(send == null) this.sendText(sendData);
				return;

			} else if(index2 != -1) {
				// find .
				let intPart = sendData.substring(0, index2);
				let doublePart = sendData.substring(index2);

				let intStr = intPart.replace(/[^.\d]+/g, "");
				let doubleStr = doublePart.replace(/[^.\d]+/g, "");
				sendData = intStr + doubleStr;

				let viewData = "";
				intStr = intStr.split("").reverse().join("");
				for(let i = 0; i < intStr.length; i++) {
					
					viewData += intStr[i];
					if ((i + 1) % 3 == 0 && (i != intStr.length - 1) && (i != 0)) {
						viewData += " ";
					}
				}
				viewData = viewData.split("").reverse().join("") + doubleStr;

				this.inputElement.value = viewData;
				if(send == null) this.sendText(sendData);
				return;

			} else {
				// not found double - only digits
				sendData = sendData.replace(/[^.\d]+/g, "");
				sendData = sendData.split("").reverse().join(""); //Reverse

				let viewData = "";
				for(let i = 0; i < sendData.length; i++) {
					
					viewData += sendData[i];
					if ((i + 1) % 3 == 0 && (i != sendData.length - 1) && (i != 0)) {
						viewData += " ";
					}
				}
				sendData = sendData.split("").reverse().join("");
				viewData = viewData.split("").reverse().join("");

				this.inputElement.value = viewData;
				if(send == null) this.sendText(sendData);
				return;
			}

		} else if (this.typeInput == 3) { // PhoneNumber
			// 89135777887 => 8 (913) 577 - 7887


			// Only digits
			let sendData = this.inputElement.value;
			sendData = sendData.replace(/[^.\d]+/g, "");

			// Length <= 16
			if (sendData.length > 11) sendData = sendData.substring(0, 11);

			let viewData = ""; 
			
			if(sendData.length > 0) viewData += sendData.substring(0, 1);
			if(sendData.length > 1) viewData += " (" + sendData.substring(1, 4);
			if(sendData.length > 4) viewData += ") " + sendData.substring(4, 7);
			if(sendData.length > 7) viewData += " - " + sendData.substring(7, 11);

			this.inputElement.value = viewData;
			if(send == null) this.sendText(sendData);
			return;
			
		} else if (this.typeInput == 4) { // CreditCard
			//7899566445613451 => 7899 5664 4561 3451

			// Only digits
			let sendData = this.inputElement.value;
			sendData = sendData.replace(/[^.\d]+/g, "");

			// Length <= 16
			if (sendData.length > 16) sendData = sendData.substring(0, 16);

			let viewData = "";
			for (let i = 0; i < sendData.length; i++) {
				viewData += sendData[i];
				if ((i + 1) % 4 == 0 && (i != sendData.length - 1))
					viewData += " ";
			}

			this.inputElement.value = viewData;
			if(send == null) this.sendText(sendData);
			return;
		}
	}

}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Scene Widget WidgetViewHtml Rex*/

/**
 * Created by prg-15 on 05.01.2018.
 */
class WidgetTabHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetTab");
		
		this.headerElement = document.createElement("div");
		this.headerElement.classList.add("WidgetTabHeader");
		this.htmlElement.appendChild(this.headerElement);
		
		this.containerElement = document.createElement("div");
		this.containerElement.classList.add("WidgetTabContainer");
		this.htmlElement.appendChild(this.containerElement);
		
		this.items = [];
		
		this._tabPosition = null;
		this._tabHeaderWidth = null;
		this._tabHeaderHeight = null;

		this._tabNeedCloseButton = null;

		this._currentLayout = null;
	}
	
	onSetState(state) {
		if(state.currentTabId != null) this.widget.currentTabId = state.currentTabId;
		if(state.tabPosition != null) this.tabPosition = state.tabPosition;
		if(state.tabHeaderWidth != null) this.tabHeaderWidth = state.tabHeaderWidth;
		if(state.tabHeaderHeight != null) this.tabHeaderHeight = state.tabHeaderHeight;
		if(state.tabHeaderAutoSize != null) this.tabHeaderAutoSize = state.tabHeaderAutoSize;
		if(state.items != null) this.updateItems();
		
	}
	
	appendChild(child) {
		//тут так и должно быть пусто. это перегруженый метод, и надо что бы он оставался таким.
		//appendChild происходит в set currentTabId()
		this.updateItems();
	}
	
	set currentTab(value) {
		if(value == -1 && this._currentTab == -1) return;
		
		if(value == -1 && this._currentTab != -1) {
			this.hideItem(this.items[this._currentTab]);
		} else if(this._currentTab == -1) {
			this.showItem(this.items[value]);
		} else {
			this.hideItem(this.items[this._currentTab]);
			this.showItem(this.items[value]);
		}
		
		this._currentTab = value
	}
	
	get currentTab() {
		return this._currentTab;
	}
	
	
	set tabPosition(value) {
		if(this.headerElement != null && this.containerElement != null) {
			this.htmlElement.classList.remove(this.posToStr(this._tabPosition));
			this.headerElement.classList.remove(this.posToStr(this._tabPosition));
			
			this.htmlElement.classList.add(this.posToStr(value));
			this.headerElement.classList.add(this.posToStr(value));
		}
		
		this.tabHeaderHeight = this.tabHeaderHeight;
		this.tabHeaderWidth = this.tabHeaderWidth;
		
		this._tabPosition = value;
	}
	
	get tabPosition() {
		return this._tabPosition;
	}
	
	set tabHeaderWidth(value) {
		if(value <= 0) return;
		this._tabHeaderWidth = value;
		if(this.containerElement == null) return;
		if(this._tabPosition == 1) {
			this.headerElement.style.width = this._tabHeaderWidth + "px";
			this.headerElement.style.minWidth = this._tabHeaderWidth + "px";
			this.containerElement.style.height = "100%";
		} else if(this._tabPosition == 3) {
			this.headerElement.style.width = this._tabHeaderWidth + "px";
			this.headerElement.style.minWidth = this._tabHeaderWidth + "px";
			this.containerElement.style.height = "100%";
		}
	}
	
	get tabHeaderWidth() {
		return this._tabHeaderWidth;
	}
	
	set tabHeaderHeight(value) {
		if(value <= 0) return;
		this._tabHeaderHeight = value;
		if(this.containerElement == null) return;
		if(this._tabPosition == 0) { // TOP
			this.containerElement.style.height = "calc(100% - " + this._tabHeaderHeight + "px)";
			this.headerElement.style.width = "100%";
			this.headerElement.style.minHeight = this._tabHeaderHeight + "px";
		} else if(this._tabPosition == 2) { // BOTTOM
			this.containerElement.style.height = "calc(100% - " + this._tabHeaderHeight + "px)";
			this.headerElement.style.width = "100%";
			this.headerElement.style.minHeight = this._tabHeaderHeight + "px";
		}
	}
	
	get tabHeaderHeight() {
		return this._tabHeaderHeight;
	}
	
	set tabHeaderAutoSize(value) {
		this._tabHeaderAutoSize = value;
		if(this.headerElement != null) {
			if(value) this.headerElement.classList.add("TabAutoSize");
			else this.headerElement.classList.remove("TabAutoSize");
		}
	}
	
	get tabHeaderAutoSize() {
		return this._tabHeaderAutoSize;
	}

	set tabNeedCloseButton(value) {

		this._tabNeedCloseButton = value;

		this.updateItems();
	}

	get tabNeedCloseButton() {

		return this._tabNeedCloseButton;
	}
	
	posToStr(v) {
		switch(v) {
			case 0 : {
				return "Top"
			}
			case 1 : {
				return "Right"
			}
			case 2 : {
				return "Bottom"
			}
			case 3 : {
				return "Left"
			}
		}
		return "Top";
	}
	
	updateItems() {
		if(Rex.widgets == null) return;
		// CLEAR
		for(let i = 0; i < this.headerElement.childNodes.length; ++i) {
			let btn = this.headerElement.childNodes[i];
			if(btn == null) continue;
			btn.remove();
			i--;
		}
		
		for(let i = 0; i < this.containerElement.childNodes.length; ++i) {
			let w = this.containerElement.childNodes[i];
			if(w == null) continue;
			w.remove();
			i--;
		}
		
		// ADD
		for(let i = 0; i < this.items.length; ++i) {
			let item = this.items[i];
			let bID = item.buttonID;
			let wID = item.widgetID;
			
			let b = Rex.widgets[bID];
			let w = Rex.widgets[wID];
			if(b == null || w == null) continue;
			if(this.children.indexOf(bID) == -1 || this.children.indexOf(wID) == -1) continue;
			
			item.index = i;
			item.button = b;
			item.widget = w;
			b.title = i;

			let pageHeader = document.createElement('div');

			pageHeader.classList.add("WidgetTabPageHeader");

			if(this.tabNeedCloseButton) {

				let closeButton = document.createElement('div');

				closeButton.classList.add("MaterialIcon");
				closeButton.classList.add("TabPageCloseButton");
				closeButton.textContent = "close";
				closeButton.onclick = (event) => Rex.callRpcMethod('Widgets', this.id, this.type, 'removeTab', [i]);

				pageHeader.appendChild(closeButton);
			}

			pageHeader.appendChild(b.view.htmlElement);

			this.headerElement.appendChild(pageHeader);

			this.containerElement.appendChild(w.view.htmlElement);

			item.widget.view.htmlElement.classList.add("TabContentHidden");
			item.button.view.htmlElement.classList.add("TabButton");
			
		}
		
		this.currentTab = this.currentTab;
	}
	
	hideItem(item) {
		if(item == null) return;
		if(item.button == null || item.widget == null) return;
		item.button.view.htmlElement.classList.remove("TabButtonSelected");
		item.widget.view.htmlElement.classList.add("TabContentHidden");
	}
	
	showItem(item) {
		if(item == null) return;
		if(item.button == null || item.widget == null) return;
		item.button.view.htmlElement.classList.add("TabButtonSelected");
		item.widget.view.htmlElement.classList.remove("TabContentHidden");
	}
	
	
	
}



/**
 * Created by semyon on 07.01.2018.
 */
class WidgetComboBoxHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetComboBox");

		this.currentIndex = -1;
		this._$itemsArea = new ComboBoxArea(this);
		this._$govno = -1;

		this.lastPosY = this.posY;//костыль на изменение позиции y

		this.lineElement = document.createElement("div");
		this.lineElement.classList.add("LineContainer");
		this.htmlElement.appendChild(this.lineElement);

		this.headInputElement = document.createElement("div");
		this.headInputElement.classList.add("InputWithHeader");
		this.lineElement.appendChild(this.headInputElement);

		this.headerElement = document.createElement("div");
		this.headerElement.innerText = "header";
		this.headerElement.classList.add("InputHeader");
		this.headInputElement.appendChild(this.headerElement);

		this.autoSize = true;
		this.displayElement = document.createElement("div");
		// this.displayElement.style.textOverflow = 'ellipsis';
		// this.displayElement.style.height = '70%';
		// this.displayElement.style.justifyContent = 'center';
		// this.displayElement.style.overflow = 'hidden';
		this.headInputElement.appendChild(this.displayElement);
		this.displayElement.classList.add("DisplayLabel");

		this.inputSearch = document.createElement("input");
		this.inputSearch.classList.add("InputSearch");

		this.inputSearch.value = 'search text';
		this.inputSearch.style.display = 'none';
		this.headInputElement.appendChild(this.inputSearch);

		this.buttonExpand = document.createElement("div");
		this.buttonExpand.classList.add("ButtonCombobox");
		this.buttonExpand.innerText = "expand_more";
		this.lineElement.appendChild(this.buttonExpand);

		this.inputSearch.oninput = ()=> {
			if (this._$itemsArea == undefined) return;
			let findstr = this.inputSearch.value.toLowerCase();
			this._$itemsArea.findContainStr(findstr);
		}
	}

	onDestroy () {
		this._$itemsArea.destroy();
		delete this._$itemsArea;
	}

	getArea () {return this._$itemsArea;}
	onSetState(state) {

		//TODO: костыль на высоту
		// if (this.itemsArea.style.width != this.htmlElement.offsetWidth+ 'px') this.itemsArea.style.width = this.htmlElement.offsetWidth+ 'px';
		//TODO: еще костыль (базовый не вызывает removeChild)
		if (state.children != undefined && state.children.length < this.getArea().getSizeItems()) this.updateChildByRemove(state.children);
		//TODO: костыль на изменение позиции
		if (state.posY != undefined && this.posY != this.lastPosY) {this.getArea().updateGeometry();}

		if (state.header != undefined) this.setHeader(state.header);
		// if (state.headerVisible != undefined) 
		// 	this.headerElement.style.visibility = (state.headerVisible == 'true') ? 'visible' : 'hidden';
		if (state.currentIndex != undefined /*&& state.currentIndex != this.currentIndex*/) this.setCurrentItem(state.currentIndex);
		if (state.expanded != undefined) (state.expanded) ? this.getArea().expand() : this.getArea().collapse();
		if (state.expandedHeight != undefined){
			this.getArea().setAutoHeight(state.expandedAuto);
			this.getArea().setUserHeight(state.expandedHeight);
		}
		if (state.buttonColor != undefined) this.buttonExpand.style.backgroundColor = state.buttonColor;
		if (state.visible != undefined) {
			if (!state.visible) this.htmlElement.style.display = 'none';
			else this.htmlElement.style.display = '';
		}
		if (state.buttonSize != undefined) {
			this.headInputElement.style.width = 100-state.buttonSize+'%';
			this.buttonExpand.style.width = state.buttonSize+'%';
		} 
	}

	updateChildByRemove (listIds) {
		for (let i=0; i<this.getArea().getSizeItems(); ++i){
			let w = this.getArea().getItem(i);
			if (w == undefined || w.children.length == 0 || w.children[0] == undefined) {
				console.log("Error");
				// if (this.currentIndex == i) this.widget.setCurrentItemIndex(-1);
				this.removeChild(w);
				continue;
			}
			let index = listIds.indexOf(parseInt(w.children[0].id));
			if (index == -1){
				// if (this.currentIndex == i) this.widget.setCurrentItemIndex(-1);
				this.removeChild(w.children[0]);--i;
			}
		}
		this.setCurrentItem(this.currentIndex) //currentIndex)
	}
	onInit() {
		// this.widget.width = "100%";
		(this.widget.expanded) ? this.getArea().expand() : this.getArea().collapse();
		this.setCurrentItem(this.widget.currentItem);
	}
	setHeader (text) {
		
		let newText = text;
		try { newText = decodeURIComponent(escape(window.atob(text)));
		} catch(e) { console.log(this.widget.type, " -> setState-> \"header\" DecodeError!"); return;}
		
		if(this.widget.header === newText) return;
		this.widget.header = newText;
		
		this.headerElement.innerText = newText;
		this.headerElement.innerHTML = newText;
	}
	
	onMouseDown(x, y, event) {
		const path = event.path || (event.composedPath && event.composedPath());
		if (event == undefined || path == undefined) {console.log("combobox click undef"); return;}

		if (path.includes(this.buttonExpand)){
			if (this.getArea().getSizeItems() == 0) return;
			this.widget.setExpand(!this.getArea().isExpand());
			return;
		}
		// let index = path.indexOf(this.getArea().htmlElement);
		// if (index >= 1){
		// 	let w = path[sindex-1];
		// 	for (index=0; index<this.getArea().getSizeItems(); ++index)
		// 		if (this.getArea().getItem(index) == w) break;
		// 	if (index == this.getArea().getSizeItems()) {console.error("can't find widget ",w);return;}
		// 	if (!this.widget.setCurrentItemIndex(index)) this.getArea().collapse();
		// }
	}
	setCurrentItem (index) {

		for (let index=0; index<this.getArea().getSizeItems(); ++index) {
			let w = this.getArea().getItem(index);

			if (w == undefined || w.classList == undefined) continue;

			if (w.classList.contains('hidden')) w.classList.remove('hidden');
			if (w.classList.contains('select')) w.classList.remove('select');
		}

		if (index == -1) {
			this.displayElement.innerHTML = '';
			this.inputSearch.value = this.displayElement.innerHTML;
			this.currentIndex = index;
			this.getArea().collapse();
		}
		// if (this.currentIndex != -1)

    	let w = this.getArea().getItem(index);
		if (w == undefined) {
			if (index != undefined && index != -1) this._$govno = index;
			this.getArea().collapse(); return;
		}

		w.classList.add('select');

		this.displayElement.textContent = w.children[0].textContent;
		this.inputSearch.value = this.displayElement.textContent;
		this.currentIndex = index;
		this.getArea().collapse();
	}
	checkSelect(event) {
		if (this.getArea().checkSelectArea(event.x, event.y)) return this.widget;
		return this.hover ? this.widget : undefined;
	}
    appendChild(widget) {this.getArea().appendChild(widget);}
	removeChild(widget){this.getArea().removeChild(widget);}

	controlFontSize(e) {
		if(!this.autoSize) {
			this.displayElement.style.fontSize = this.fontSize + 'px';
			return;
		}
		let html = this.displayElement;
		const ratio = html.clientWidth < html.clientHeight ? html.clientWidth / html.clientHeight : html.clientHeight / html.clientWidth; 
		const side = Math.max(html.clientWidth, html.clientHeight);
		const fontSize = side * ratio * 2;
		if (fontSize < 100) html.style.fontSize = "100%";
		else html.style.fontSize = (fontSize) + '%';
	}
	
}

class ComboBoxArea {
	constructor (combobox) {

		this._$parent = combobox;
		this._$show = false;
		this._$up = false;
		this._$defaultItemHeight = 35;
		this._$heightItem = this._$defaultItemHeight;

		//параметры предка
		let rect = this._$parent.htmlElement.getBoundingClientRect();//левый верхний угол
		this._$x = rect.x;
		this._$y = rect.y;
		this._$heightParent = 0;

		//наша высота
		this._$expandHeight = 0;
		this._$userHeight = 300;
		this._$autoHeight = false;

		let scene = document.getElementById(this._$parent.container);
		if (scene == undefined) console.error("Combobox->constructor : бля сцена труп");
		this.htmlElement = document.createElement("div");

		this.htmlElement.classList.add("ComboBoxArea");
		this.htmlElement.classList.add("Down");
		this.htmlElement.id = "w" + combobox.id;
		scene.appendChild(this.htmlElement);

		this._$items = this.htmlElement.children;
	}

	destroy () {
		let scene = document.getElementById(this._$parent.container);
		if (scene == undefined) console.error("Combobox->destructor : бля сцена труп");
		else scene.removeChild(this.htmlElement);
		// document.removeChild(this.htmlElement);
	}

	checkSelectArea(x,y) {
		if (this._$show){
			//наверх
			if (this._$up && x >= this._$x && x <= this._$x + this.htmlElement.offsetWidth && y <= this._$y && y >= this._$y - this.htmlElement.offsetHeight) return true;
			//вниз
			else if (!this._$up && x >= this._$x && x <= this._$x + this.htmlElement.offsetWidth && y >= this._$y && y <= this._$y + this.htmlElement.offsetHeight) return true;
		}
		return false;
	}
	setAutoHeight (boolflag) {
		this._$autoHeight = boolflag;
		this.updateHeigth();
	}
	setUserHeight (height) {
		this._$userHeight = height;
		if (!this._$autoHeight) this.updateHeigth();
	}

	updateHeigth (sizeItems) {
		if (this._$autoHeight) {
			if (sizeItems != undefined) {
				if (sizeItems > 5) {
					this._$expandHeight = 5 * this._$heightItem;
					this.htmlElement.style.overflowY = 'scroll';
				}
				else {
					this._$expandHeight = sizeItems * this._$heightItem;
					this.htmlElement.style.overflowY = 'hidden';
				}
			}
		}
		else {
			if (sizeItems == undefined) {
				sizeItems = 0;
				for (let index=0; index<this._$items.length; ++index) {
					let w = this.htmlElement.children[index];
					if (!w.classList.contains('hidden')) ++sizeItems;
				}
			}

			let prevHeight = sizeItems*this._$heightItem;
			//если высота пользователя меньше высоты числа итемов сетим его высоту и скролл
			if (prevHeight > this._$userHeight) {
				this._$expandHeight = this._$userHeight;
				this.htmlElement.style.overflowY = 'scroll';
			}
			//иначе оставляем свое
			else {
				this._$expandHeight = prevHeight;
				this.htmlElement.style.overflowY = 'hidden';
			}
		}

		//высота окна - высота то верхней точки - высота виджета
		let sizeToDown = window.innerHeight - this._$y - this._$heightParent;//posY
		let sizeToTop = this._$y;


		//всегда хотим сначала разворачивать вниз
		//если не влазиет в низ
		if (this._$expandHeight > sizeToDown) {
			//проверяем не влезет ли наверх
			if (this._$expandHeight < sizeToTop) {
				this._$up = true;
				this.htmlElement.style.overflowY = (this._$expandHeight  < this._$items.length * this._$heightItem) ? 'scroll' : 'hidden';
			}
			//если не влезло смотрим где больше места
			else {
				this.htmlElement.style.overflowY = 'scroll';
				this._$up = sizeToTop > sizeToDown;
				this._$expandHeight = (this._$up) ? sizeToTop : sizeToDown;
			}
		}
		else this._$up = false;

		//изменение позиции по X
		if (this.htmlElement.style.left != this._$x)this.htmlElement.style.left = this._$x + 'px';
		//куда и как раскрывать
		if (this._$up){
			if(this.htmlElement.classList.contains('Down')) {
				this.htmlElement.classList.remove('Down');
				this.htmlElement.classList.add('Up');
			}
			this.htmlElement.style.top = null;
			this.htmlElement.style.bottom = window.innerHeight - this._$y + 'px';
		}
		else {
			if (this.htmlElement.classList.contains('Up')) {
				this.htmlElement.classList.remove('Up');
				this.htmlElement.classList.add('Down');
			}
			this.htmlElement.style.bottom = null;
			this.htmlElement.style.top = this._$y + this._$heightParent+'px';
		}
		//сеттим высоту
		if (this._$show) this.htmlElement.style.height = this._$expandHeight + 'px';
	}
	updateGeometry () {
		let flag = false;
		let rect = this._$parent.htmlElement.getBoundingClientRect();//левый верхний угол
		if (this._$x != rect.x) {
			this._$x = rect.x;
			flag = true;
		}
		if (this._$y != rect.y) {
			this._$y = rect.y;
			flag = true;
		}
		if (this._$heightParent != rect.height) {
			this._$heightParent = rect.height;
			flag = true;
		}
		if (this.htmlElement.style.width != rect.width) {
			this.htmlElement.style.width = rect.width + 'px';
		}
		if (flag) this.updateHeigth();
	}
	updateItemHeight (height) {
		if (height == undefined){
			this._$heightItem = this._$defaultItemHeight;
			for (let i=0; i<this._$items.length; ++i){
				let w = this._$items[i];
				if (w != undefined && w.style.offsetHeight != undefined && this._$heightItem < w.style.offsetHeight)
					this._$heightItem = w.style.offsetHeight;
			}
		}
		else {
			let h = this._$defaultItemHeight;
			try {h = parseInt(height);}catch(e){}

			if (this._$heightItem < h+2) this._$heightItem = h+2;//2 - по пикселю на бордер
		}
	}

	collapse () {
		if (!this._$show) return;
		this._$show = false;
		this.htmlElement.style.height = '0px';
		this._$parent.inputSearch.style.display = 'none';
		this._$parent.displayElement.style.display = '';
		this._$parent.inputSearch.value = this._$parent.displayElement.innerText;
		this._$parent.inputSearch.value = this._$parent.displayElement.innerHTML;
		for (let i=0; i<this._$items.length; ++i){
			let ch = this._$items[i];
			if (ch.classList.contains('hidden')) ch.classList.remove('hidden');
		}
	}
	expand () {
		this.updateGeometry();//когда-нибудь этот метод будет вызываться осмысленно на изменение позиции!!!
		this.updateHeigth(this.getSizeItems());
		this._$show = true;
		this.htmlElement.style.height = this._$expandHeight + 'px';
		this._$parent.inputSearch.style.display = '';
		this._$parent.displayElement.style.display = 'none';
	}

	findContainStr (findstr){
		let itemsSize = 0;
		for (let i=0; i<this._$items.length; ++i){
			let ch = this._$items[i];
			let str = ch.innerText.toLowerCase();
			if (str.indexOf(findstr) != -1) {
				if (ch.classList.contains('hidden')) ch.classList.remove('hidden');
				++itemsSize;
			}
			else if (!ch.classList.contains('hidden')) ch.classList.add('hidden');
		}
		this.updateHeigth(itemsSize);
	}

	appendChild(widget) {
        if (widget == undefined) debugger;
        let item = document.createElement("div");
        item.classList.add("ItemArea");
        item.appendChild(widget);
        item.id = widget.id;

        this.htmlElement.appendChild(item);
        item.onmouseover = () => {
            for (let index=0; index<this._$items.length; ++index)
                if (this._$items[index] == item)
                    this._$parent.widget.sendHoverIndex(index);
        }
        item.onmousedown = () => {
            for (let index=0; index<this._$items.length; ++index)
                if (this._$items[index] == item)
                    if (!this._$parent.widget.setCurrentItemIndex(index))
                        this.collapse();
        }

        // widget.innerText = widget.innerHTML;//это просто костль для верхней строчки О_О которая в wiscontainere перетирает текст
        this.updateItemHeight(widget.style.height);
        this.updateHeigth(this._$items.length);

        if (this._$parent._$govno != -1 && this._$parent._$govno <= this._$items.length-1) this._$parent.setCurrentItem(this._$parent._$govno);
    }
    removeChild(widget){
        for (let index = 0; index<this._$items.length; ++index){
            let w = this._$items[index];
            if (w.id == widget.id){
                this.htmlElement.removeChild(this._$items[index]);
                this.updateItemHeight();
                this.updateHeigth(this._$items.length);//vot hz?
                break;
            }
        }
    }

	getSizeItems () {return this._$items.length;}
	getItem (index) {return this._$items[index];}
	isExpand () {return this._$show;}
}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global WidgetViewHtml Rex*/

/**
 * WidgetImage
 */

class WidgetWindowHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.isIncrease = false;
		this.isProjection = false;
		this.widthProjection = -1;
		this.maxSize = false;
		this.errorAttach = 25;
		// this.customButtons = {};
		this.active = false;

		this.createDomElement("div");
		this.addClassName("WidgetWindow");

		this.contentElement = document.createElement("div");
		this.contentElement.classList.add("WindowContent");
		this.htmlElement.appendChild(this.contentElement);

		this.contetnContainerElement = document.createElement("div");
		this.contetnContainerElement.id = "wcc_" + this.id;
		this.contetnContainerElement.classList.add("WidgetWindowContainer");
		this.contentElement.appendChild(this.contetnContainerElement);

		this.headerElement = undefined;
		this.headerTextElement = undefined;

		this.minElement = undefined;
		this.maxElement = undefined;
		this.closeElement = undefined;

		window.addEventListener("resize", (event) => {
			if (this.verticalSizePolicy == 2) this.height = window.innerHeight;
			if (this.horizontalSizePolicy == 2) this.width = window.innerWidth;
			if (this.horizontalAlignType == 1) this.posX = 0;
			if (this.horizontalAlignType == 3) this.posX = window.innerWidth - this.width;
			if (this.verticalAlignType == 1) this.posY = 0;
			if (this.verticalAlignType == 3) this.posY = window.innerHeight - this.height;
		});
		this.createHeader();

		this.outerShielding = null;
		this.innerShielding = null;

	}

	onInit() {
		this.htmlElement.style.padding = null;

		this.controlHeaderColor(this.backgroundHeader);
		this.controlContainerColor();
		this.controlBColor();
		this.updateCustomButtons();
		this.controlIconName();
	}

	onSetState(state) {
		if (state.needAttach != null) this.widget.needAttach = state.needAttach;
		if (state.needUnAttach != null) this.widget.needUnAttach = state.needUnAttach;
		if (state.header != null) this.controlHeader(state.header);

		if (state.textAlign != null) this.controlAlign();
		if (state.fontSize != null) this.controlFontSize();
		if (state.textColor != null) this.controlTextColor();
		if (state.fontBold != null || state.fontItalic != null || state.textDecoration != null) this.controlFontStyle();
		if (state.backgroundHeader != null) this.controlHeaderColor(state.backgroundHeader);
		if (state.backgroundContainer != null) this.controlContainerColor();
		if (state.backgroundColor != null) this.controlBColor();
		if (state.customButtons) this.updateCustomButtons();

		if (state.iconName != null) this.controlIconName();


		if (null != state.enableMimimaze) {
			if (this.minElement != null) {
				if(state.enableMimimaze)
					this.minElement.style.display = "";
				else 
					this.minElement.style.display = "none";
			}
		}

		if (null != state.enableMaximaze) {
			if (this.maxElement != null) {
				if (state.enableMaximaze)
					this.maxElement.style.display = "";
				else
					this.maxElement.style.display = "none";
			}
		}

		if (null != state.enableClose) {
			if (this.closeElement != null) {
				if (state.enableClose)
					this.closeElement.style.display = "";
				else
					this.closeElement.style.display = "none";
			}
		}

		if(state.indents != null) {
			this.htmlElement.style.setProperty("--border-window", state.indents + "px");
		}

	}

	controlBColor() {
		this.contentElement.style.background = this.widget._backgroundColor;
	}

	appendChild(node) {
		if (node == null) return;
		node.style.position = "";

		let childId = node.id;
		let findIndex = this.children.indexOf(parseInt(childId));
		if (findIndex != -1 && findIndex < this.children.length - 1) {
			let nextChildId = this.children[findIndex + 1];
			let nextChild = Rex.widgets[nextChildId];
			if (nextChild != null && nextChild.view.htmlElement != null && this.contetnContainerElement == nextChild.view.htmlElement.parentNode) {
				this.contetnContainerElement.insertBefore(node, nextChild.view.htmlElement);
				return;
			}
		}

		this.contetnContainerElement.appendChild(node);
	}

	contains(node) {
		return this.contetnContainerElement.contains(node);
	}

	removeChild(node) {
		return this.contetnContainerElement.removeChild(node);
	}

	setHorizontalAlignType(value) {
		if (this.horizontalAlignType == value) return;
		this.horizontalAlignType = value;
		if (value) Rex.callRpcMethod("Widgets", this.id, this.type, "setPosX", [this.posX]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setHorizontalAlignType", [value]);
	}

	setVerticalAlignType(value) {
		if (this.verticalAlignType == value) return;
		this.verticalAlignType = value;
		if (value) Rex.callRpcMethod("Widgets", this.id, this.type, "setPosY", [this.posY]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setVerticalAlignType", [value]);
	}

	setWidgetAlign(horizontal, vertical) {
		if (this.horizontalAlignType == horizontal && this.verticalAlignType == vertical) return;
		this.horizontalAlignType = horizontal;
		this.verticalAlignType = vertical;
		if (horizontal) Rex.callRpcMethod("Widgets", this.id, this.type, "setPosX", [this.posX]);
		if (vertical) Rex.callRpcMethod("Widgets", this.id, this.type, "setPosY", [this.posY]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setWidgetAlign", [horizontal, vertical]);
	}

	setHorizontalSizePolicy(value) {
		if (this.horizontalSizePolicy == value) return;
		this.horizontalSizePolicy = value;
		if (value) Rex.callRpcMethod("Widgets", this.id, this.type, "setWidth", [this.width]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setHorizontalSizePolicy", [value]);
	}

	setVerticalSizePolicy(value) {
		if (this.verticalSizePolicy == value) return;
		this.verticalSizePolicy = value;
		if (value) Rex.callRpcMethod("Widgets", this.id, this.type, "setHeight", [this.height]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setVerticalSizePolicy", [value]);
	}

	setSizePolicy(horizontal, vertical) {
		if (this.horizontalSizePolicy == horizontal && this.verticalSizePolicy == vertical) return;
		this.horizontalSizePolicy = horizontal;
		this.verticalSizePolicy = vertical;
		if (horizontal) Rex.callRpcMethod("Widgets", this.id, this.type, "setWidth", [this.width]);
		if (vertical) Rex.callRpcMethod("Widgets", this.id, this.type, "setHeight", [this.height]);
		Rex.callRpcMethod("Widgets", this.id, this.type, "setSizePolicy", [horizontal, vertical]);
	}

	set enableHeader(value) {
		if (this.widget.enableHeader == value) return;
		this.widget.enableHeader = value;
		if (value) {
			this.contentElement.classList.remove("withoutHeader");
			this.contentElement.classList.add("WithHeader");
			if (this.headerElement == undefined)
				this.createHeader();
		} else {
			this.contentElement.classList.add("withoutHeader");
			this.contentElement.classList.remove("WithHeader");
			if (this.headerElement != undefined) {
				this.contentElement.removeChild(this.headerElement);
				this.headerElement = undefined;
			}
		}
		if(this.contetnContainerElement != null) {
			let H = 0;
			if(this.headerElement != null)
				H = parseInt(this.headerElement.offsetHeight);
			
			this.contetnContainerElement.style.height = "calc(100% - " + (H) + "px)";
		}
	}

	get enableHeader() {
		return this.widget.enableHeader;
	}

	controlHeader(stateHeader) {
		let newText = "";
		try {
			newText = decodeURIComponent(escape(window.atob(stateHeader)));
		} catch (e) {
			console.log(this.widget.type, " -> setState-> \"header\" DecodeError!");
			return;
		}

		if (this.widget.header === newText) return;
		this.widget.header = newText;
		if (this.headerTextElement) this.headerTextElement.innerText = newText;
	}


	controlAlign() {

		if (!this.widget.enableHeader) return;
		if (this.textAlign == 0) this.headerTextElement.innerText = "";
		else this.headerTextElement.innerText = this.widget.header;
		switch (this.textAlign) { //justify-content: center;
			case 0: // TEXT NONE
				this.headerIconElement.style.width = "100%";
				if (this.textContainer.contains(this.headerTextElement)) this.textContainer.removeChild(this.headerTextElement);
				if (!this.textContainer.contains(this.headerIconElement)) this.textContainer.appendChild(this.headerIconElement);
				break;
			case 1: // TEXT LEFT
				this.headerIconElement.style.width = "30%";
				this.headerTextElement.style.width = "70%";
				if (this.textContainer.contains(this.headerTextElement)) this.textContainer.removeChild(this.headerTextElement);
				if (this.textContainer.contains(this.headerIconElement)) this.textContainer.removeChild(this.headerIconElement);
				this.textContainer.appendChild(this.headerTextElement);
				this.textContainer.appendChild(this.headerIconElement);
				break;
			case 2: // TEXT CENTER
				this.headerTextElement.style.width = "100%";
				if (this.textContainer.contains(this.headerIconElement)) this.textContainer.removeChild(this.headerIconElement);
				if (!this.textContainer.contains(this.headerTextElement)) this.textContainer.appendChild(this.headerTextElement);
				break;
			case 3: // TEXT RIGHT
				this.headerIconElement.style.width = "30%";
				this.headerTextElement.style.width = "70%";
				if (this.textContainer.contains(this.headerTextElement)) this.textContainer.removeChild(this.headerTextElement);
				if (this.textContainer.contains(this.headerIconElement)) this.textContainer.removeChild(this.headerIconElement);
				this.textContainer.appendChild(this.headerIconElement);
				this.textContainer.appendChild(this.headerTextElement);
				break;
		}
	}

	controlFontSize() {
		this.htmlElement.style.fontSize = null;
		if (this.headerTextElement != null) this.headerTextElement.style.fontSize = this.fontSize + "px";
		if (this.headerElement != null) {
			this.headerElement.style.fontSize = this.fontSize + "px";
			// t
			let H = parseInt(this.headerElement.innerHeight);
			this.contetnContainerElement.style.height = "calc(100% - " + (H) + "px)";

			let size = H / 1.8;

			for (let i = 0; i < this.leftButtonsContainer.childNodes.length; ++i) {
				let e = this.leftButtonsContainer.childNodes[i];
				if (e == null) continue;
				e.style.height = size + "px";
				e.style.width = size + "px";
				e.style.borderRadius = size / 2 + "px";
				e.style.lineHeight = size + "px";
				e.style.fontSize = size + "px";
			}

			for (let i = 0; i < this.rightButtonsContainer.childNodes.length; ++i) {
				let e = this.rightButtonsContainer.childNodes[i];
				if (e == null) continue;
				e.style.height = size + "px";
				e.style.width = size + "px";
				e.style.borderRadius = size / 2 + "px";
				e.style.lineHeight = size + "px";
				e.style.fontSize = size + "px";
			}

		} else {
			this.contetnContainerElement.style.height = "100%";
		}

	}

	controlTextColor() {
		if (this.headerElement == null) return;
		this.headerTextElement.style.color = this.textColor;
		this.headerIconElement.style.color = this.textColor;
		this.htmlElement.style.color = null;

		this.headerElement.style.color = this.textColor;
	}

	controlIconName() {
		if (this.headerElement == null) return;
		this.headerIconElement.textContent = this.iconName;
	}

	controlFontStyle() {
		let italic = "";
		if (this.fontItalic) italic = "italic";
		if (this.headerTextElement != null) this.headerTextElement.style.fontStyle = italic;
		// this.headerElement.style.fontStyle = italic;

		let bold = "";
		if (this.fontBold) bold = "bold";
		if (this.headerTextElement != null) this.headerTextElement.style.fontWeight = bold;
		// this.headerElement.style.fontWeight = bold;

		let decoration = this.widget.textDecorationType;
		if (this.headerTextElement != null) this.headerTextElement.style.textDecoration = decoration;

		this.htmlElement.style.fontWeight = null;
		this.htmlElement.style.fontStyle = null;
		this.htmlElement.style.textDecoration = null;

	}

	controlHeaderColor(stateValue) {
		if (this.headerElement == null) return;
		for (let i = 0; i < this.leftButtonsContainer.childNodes.length; ++i) {
			let e = this.leftButtonsContainer.childNodes[i];
			if (e == null) continue;
			e.style.background = stateValue;
			e.style.filter = "brightness(110%)";
		}

		for (let i = 0; i < this.rightButtonsContainer.childNodes.length; ++i) {
			let e = this.rightButtonsContainer.childNodes[i];
			if (e == null) continue;
			e.style.background = stateValue;
			e.style.filter = "brightness(110%)";
		}
		this.headerElement.style.background = stateValue;
	}

	controlContainerColor() {
		if (this.contetnContainerElement != null) this.contetnContainerElement.style.background = this.backgroundContainer;
	}

	updateCustomButtons() {
		if (this.headerElement == null) return;

		this.controlHeaderColor(this.backgroundHeader);

		for (let i = 0; i < this.leftButtonsContainer.childNodes.length; ++i) {
			let btn = this.leftButtonsContainer.childNodes[i];
			if (btn == null) continue;
			btn.remove();
			i--;
		}

		if (null == this.customButtons)
			return;

		for (let key of Object.keys(this.customButtons)) {
			// for (let btn of this.customButtons) {
			let btn = this.customButtons[key];
			if (null == btn)
				continue;

			let elem = document.createElement("span");
			elem.className = "WidgetWindowLeftButton";
			elem.title = btn.buttonName;
			elem.style.background = btn.buttonColor;
			elem.innerText = btn.iconName;
			elem.style.color = btn.iconColor;
			this.leftButtonsContainer.appendChild(elem);
		}

		this.controlFontSize();

	}

	set elevation(value) {
		if ((value == null) || (this.widget.elevation == value)) return;
		this.widget.elevation = value;
		this.contentElement.style.boxShadow = `var(--elevation-${value})`;
	}

	createHeader() {
		if (!this.widget.enableHeader)
			return;

		this.headerElement = document.createElement("div");
		this.contentElement.insertBefore(this.headerElement, this.contetnContainerElement);
		this.headerElement.className = "TopBar";

		// LEFT BUTTONS
		this.leftButtonsContainer = document.createElement("div");
		this.leftButtonsContainer.classList.add("WidgetWindowLeftButtonsContainer");
		this.headerElement.appendChild(this.leftButtonsContainer);

		// TEXT
		this.textContainer = document.createElement("div");
		this.textContainer.className = "WidgetWindowHeaderTextContainer";
		this.headerElement.appendChild(this.textContainer);

		this.headerTextElement = document.createElement("div");
		this.headerTextElement.className = "HeaderTextWindow";
		this.headerTextElement.innerText = this.widget.header;
		this.textContainer.appendChild(this.headerTextElement);

		this.headerIconElement = document.createElement("div");
		this.headerIconElement.className = "IconTextWindow";
		this.headerIconElement.innerText = this.iconName;
		this.textContainer.appendChild(this.headerIconElement);

		// RIGHT BUTTONS
		this.rightButtonsContainer = document.createElement("div");
		this.rightButtonsContainer.classList.add("WidgetWindowRightButtonsContainer");
		this.headerElement.appendChild(this.rightButtonsContainer);

		this.minElement = document.createElement("span");
		this.minElement.className = "MinBtn";
		this.minElement.innerText = "remove";
		this.minElement.title = "Minimize Window";

		this.maxElement = document.createElement("span");
		this.maxElement.className = "MaxBtn";
		this.maxElement.title = "Maximize Window";
		this.maxElement.innerText = "web_asset";

		this.closeElement = document.createElement("span");
		this.closeElement.className = "XBtn";
		this.closeElement.innerText = "close";
		this.closeElement.title = "Close Window";

		this.rightButtonsContainer.appendChild(this.minElement);
		this.rightButtonsContainer.appendChild(this.maxElement);
		this.rightButtonsContainer.appendChild(this.closeElement);

		this.controlAlign();
		this.controlTextColor();
		this.updateCustomButtons();

		this.headerElement.style.background = this.backgroundHeader;
		this.contetnContainerElement.style.background = this.backgroundContainer;
	}

	// Область возможного заполнения
	createProjectionWindow(x, y, w, h) {
		let container = document.getElementById("container1");
		if (container == null) return;
		let projection = document.getElementById("ProjectionWindow" + (this.widget.id));
		if (projection == undefined) {
			projection = document.createElement("div");
			projection.className = "ProjectionWindow";
			projection.id = "ProjectionWindow" + (this.widget.id);
			container.appendChild(projection);
		}
		projection.style.top = y + "px";
		projection.style.left = x + "px";
		projection.style.width = w + "px";
		projection.style.height = h + "px";
		this.isProjection = true;
		this.widthProjection = w;
	}

	deleteProjectionWindow() {
		let container = document.getElementById("container1");
		if (container == null) return;
		let projection = document.getElementById("ProjectionWindow" + (this.widget.id));
		if (projection != undefined) {
			container.removeChild(projection);
			this.isProjection = false;
			this.widthProjection = -1;
		}
	}

	maximize_v1(func = "maximize", animation = true) {
		if (animation) this.htmlElement.style.transition = ".5s";
		if ((this.maxSize && func == "maximize") || (this.isIncrease && func == "increase")) {
			this.setSizePolicy(this.normalsize.horizontalSizePolicy, this.normalsize.verticalSizePolicy);
			this.setWidgetAlign(this.normalsize.horizontalAlign, this.normalsize.verticalAlign);
			this.widget.setGeometry(this.normalsize.posX, this.normalsize.posY, this.normalsize.width, this.normalsize.height);
			this.posX = this.normalsize.posX;
			this.posY = this.normalsize.posY;
			this.width = this.normalsize.width;
			this.height = this.normalsize.height;
			this.isIncrease = false;
			this.maxSize = false;
			this.maxElement.innerText = "web_asset";
			this.maxElement.title = "Maximize Window";
		} else {
			if (!this.isIncrease)
				this.normalsize = {
					posX: this.widget.posX,
					posY: this.widget.posY,
					width: this.widget.width,
					height: this.widget.height,
					verticalAlign: this.widget.verticalAlignType,
					horizontalAlign: this.widget.horizontalAlignType,
					horizontalSizePolicy: this.widget.horizontalSizePolicy,
					verticalSizePolicy: this.widget.verticalSizePolicy
				};
			if (func == "maximize") {
				this.setSizePolicy(2, 2); //FullScreen;
				this.setHorizontalAlignType(1);
				this.setVerticalAlignType(1);
				this.isIncrease = false;
				this.maxSize = true;
				this.maxElement.innerText = "filter_none";
				this.maxElement.title = "Reduce Window";
			} else if (func == "increase") {
				this.htmlElement.style.width = window.innerWidth / 2;
				this.width = window.innerWidth / 2;
				this.htmlElement.style.left = "calc(100% - " + (this.width) + "px)";
				Rex.callRpcMethod("Widgets", this.id, this.type, "setWidth", [this.width]);
				this.setVerticalSizePolicy(2); //FullScreen;
				this.setVerticalAlignType(1);

				// if(this.horizontalAlignType == 3) {
				// 	this.posX = window.innerWidth / 2;
				// 	Rex.callRpcMethod('Widgets', this.id, this.type, 'setPosX', [this.posX]);
				// }
				this.maxSize = false;
				this.isIncrease = true;
			}
		}
		if (animation) setTimeout(() => {
			this.htmlElement.style.transition = null;
		}, 500);
	}

	onNeedAttach(x, y) {
		
		let borderX = 0;
		let borderY = 0;
		let borderW = window.innerWidth;
		let borderH = window.innerHeight;

		if(this.parentId != -1) {
			let parentWidget = Rex.widgets[this.parentId];
			if(parentWidget != null) {
				let rect = parentWidget.view.htmlElement.getBoundingClientRect();

				borderX = rect.left;
				borderY = rect.top;
				borderW = rect.left + rect.width;
				borderH = rect.top + rect.height;
			}
		}

		let pT = this.paddingTop;
		let pB = this.paddingBottom;
		let pL = this.paddingLeft;
		let pR = this.paddingRight;

		if (y < (this.errorAttach + borderY)) {	// --- TOP ---

			if (this.verticalAlignType != 1)
				this.setVerticalAlignType(1);

			if (!this.maxSize && (!this.isProjection || (borderW - pL - pR) > this.widthProjection)) //create Top projection even if exist Left or Right projection
				this.createProjectionWindow(borderX + pL, 
					borderY + pT, 
					borderW - pL - pR, 
					borderH - pT - pB);
			return;
		} else if (borderH - this.errorAttach < y) {	// --- BOTTON ---
			if (this.verticalAlignType != 3)
				this.setVerticalAlignType(3);

			if (!this.maxSize && (!this.isProjection || (borderW - pL - pR) > this.widthProjection)) //create Top projection even if exist Left or Right projection
				this.createProjectionWindow(borderX + pL, 
					borderY + pT, 
					borderW - pL - pR, 
					borderH - pT - pB);
			return;
		} else if (x < (this.errorAttach + borderX)) {	// --- LEFT ---
			if (this.horizontalAlignType != 1)
				this.setHorizontalAlignType(1);

			if (!this.isProjection && !this.isIncrease)
				this.createProjectionWindow(borderX + pL, borderY + pT, (borderW / 2 - pL - pR), (borderH - pT - pB));
				
			return;
		} else if (borderW - this.errorAttach < x) {	// --- RIGHT ---

			if (this.horizontalAlignType != 3)
				this.setHorizontalAlignType(3);
			
			if (!this.isProjection && !this.isIncrease) 
				this.createProjectionWindow(borderW / 2 + pL, borderY + pT, borderW / 2 - pL - pR, borderH - pT - pB); // height
			
			return;
		}
		
		// delete Top projection
		if (this.isProjection && y >= pT) 
			this.deleteProjectionWindow(); 

		if (this.isProjection && (this.widthProjection < borderW - pL - pR) &&
			x >= pL && x <= borderW - pR) // delete !Top projection
			this.deleteProjectionWindow();
		
		if ((x > 2 * this.errorAttach) && (borderW - 2 * this.errorAttach > x)) {
			if (this.isIncrease && !(this.widget.startMousePos.x == x && this.widget.startMousePos.y == y)) {
				this.normalsize.posX = x - this.normalsize.width / 2;
				this.normalsize.posY = 0;
				if (this.normalsize.horizontalAlign != 0) this.normalsize.horizontalAlign = 0;
				if (this.normalsize.verticalAlign != 0) this.normalsize.verticalAlign = 0;
				this.widget.startMove.x = this.normalsize.posX;
				this.widget.startMove.y = this.normalsize.posY;
				this.maximize_v1("increase", false);
			}
			if (this.horizontalAlignType != 0) {
				if (this.widget.needUnAttach) this.setHorizontalAlignType(0);
			}
		}

		if ((this.widget.startMousePos.x != x || this.widget.startMousePos.y != y) && y > this.errorAttach) {

			if (this.maxSize) {
				this.normalsize.posX = x - this.normalsize.width / 2;
				this.normalsize.posY = 0;
				if (this.normalsize.horizontalAlign != 0) this.normalsize.horizontalAlign = 0;
				if (this.normalsize.verticalAlign != 0) this.normalsize.verticalAlign = 0;
				this.widget.startMove.x = this.normalsize.posX;
				this.widget.startMove.y = this.normalsize.posY;
				this.maximize_v1("maximize", false);
			}
			if ((y > 2 * this.errorAttach) && (borderH - 2 * this.errorAttach > y)) {
				if (this.verticalAlignType != 0)
					if (this.widget.needUnAttach) this.setVerticalAlignType(0);
			}
		}

	}

	onFocused(f) {
		this.active = f;
		if (f) {
			this.htmlElement.style.zIndex = null;
			this.htmlElement.classList.add("WidgetWindowActive");
		} else {
			this.htmlElement.style.zIndex = this.widget.order;
			this.htmlElement.classList.remove("WidgetWindowActive");
		}
	}

	onMouseDoubleClick(event) {
		if (event.target.className == "MaxBtn" || event.target.className == "XBtn" || event.target.className == "MinBtn" || event.target.className == "WidgetWindowLeftButton") return;

		// if(event.x == this.widget.startMousePos.x && event.y == this.widget.startMousePos.y)
		// if((event.x > this.posX + 10) && (event.x < this.posX + this.width - 10) //check is header, 10 it's padding
		// 	&& (event.y > this.posY + 10)) {
		const path = event.path || (event.composedPath && event.composedPath());
		if (path.indexOf(this.headerElement) != -1) { //проверить на хидере ли курсор
			if (this.isIncrease) {
				this.maximize_v1("increase");
			} else this.maximize_v1();
		}
	}

	onMouseUp(x, y, event) {
		if (event.target.className == "MaxBtn" || event.target.className == "MaxBtnSpan") {
			this.maximize_v1();
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "maximizeWindow", []);
			return;
		}
		if (event.target.className == "XBtn" || event.target.className == "XBtnSpan") {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "closeWindow", []);
			return;
		}
		if (event.target.className == "MinBtn" || event.target.className == "MinBtnSpan") {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "minimizeWindow", []);
			return;
		}

		if (event.target.className == "WidgetWindowLeftButton") {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "pressCustomButton", [event.target.title]);
			return;
		}

		if (this.isProjection) {
			this.deleteProjectionWindow();

			if ((x < this.paddingLeft) || (x > this.htmlElement.parentElement.offsetWidth - this.paddingRight)) {
				if (this.horizontalAlignType % 2 == 1 && this.widget.needAttach && !this.maxSize && !this.isIncrease) {
					this.maximize_v1("increase");
				}
			} else {
				if (this.widget.needAttach && !this.maxSize) {
					this.maximize_v1();
				}
			}

		} else {
			if ((this.maxSize || this.isIncrease))
				if (this.width != this.widget.startWidth || this.height != this.widget.startHeight) { // окно поменяло размер
					console.log("mouseUp");
					if (this.height != this.widget.startHeight) this.setVerticalSizePolicy(0); //fixed
					if (this.width != this.widget.startWidth) this.setHorizontalSizePolicy(0);
					if (this.widget.needAttach) {
						// this.setVerticalAlignType(0); //none
						// this.setHorizontalAlignType(0);
						this.setWidgetAlign(0, 0); //none
					} else {
						if (this.height != this.widget.startHeight && this.posY != 0) this.setVerticalAlignType(0); //none
						if (this.width != this.widget.startWidth) {
							if (this.horizontalAlignType == 1 && this.posX != 0) this.setHorizontalAlignType(0); //none
							if (this.horizontalAlignType == 3 && this.posX == window.innerWidth / 2) this.setHorizontalAlignType(0);
						}
					}
					this.normalsize = {
						posX: this.widget.posX,
						posY: this.widget.posY,
						width: this.widget.width,
						height: this.widget.height,
						verticalAlign: this.widget.verticalAlignType,
						horizontalAlign: this.widget.horizontalAlignType,
						horizontalSizePolicy: this.widget.horizontalSizePolicy,
						verticalSizePolicy: this.widget.verticalSizePolicy
					};
					this.isIncrease = false;
					this.maxSize = false;
				}
		}
	}

	destroy() {
		if (this.htmlElement == null) return;
		let parent = this.htmlElement.parentElement;
		if (parent == null) return;
		this.htmlElement.style.opacity = 0;
		setTimeout(() => {
			parent.removeChild(this.htmlElement);
			this.onDestroy();
		}, 250);

		this.updateFocus();
	}

	startMoving() {
		if (this.htmlElement == null) return;
		
		// IN
		if (this.innerShielding == null) {
			this.innerShielding = document.createElement("div");
			this.innerShielding.classList.add("WindowMovingShielding");
			this.innerShielding.addEventListener("mouseup", this.stopMoving.bind(this), false);
			this.htmlElement.appendChild(this.innerShielding);
		}
		// OUT
		if (this.outerShielding == null) {
			this.outerShielding = document.createElement("div");
			this.outerShielding.classList.add("WindowMovingShielding");
			this.outerShielding.style.height = window.innerHeight + "px";
			this.outerShielding.style.zIndex = 199;
			this.outerShielding.addEventListener("mouseup", this.stopMoving.bind(this), false);
			let containerElement = document.getElementById(this.container);
			if (containerElement) containerElement.appendChild(this.outerShielding);
		}

	}

	stopMoving() {
		if (this.innerShielding != null) this.innerShielding.removeEventListener("mouseup", this.stopMoving.bind(this), false);
		if (this.outerShielding != null) this.outerShielding.removeEventListener("mouseup", this.stopMoving.bind(this), false);

		let elements = document.getElementsByClassName("WindowMovingShielding");
		for (let i = 0; i < elements.length; ++i) {
			let e = elements[i];
			if (e == null) continue;
			e.remove();
			i--;
		}
		if (this.innerShielding != null) this.innerShielding.remove();
		if (this.outerShielding != null) this.outerShielding.remove();

		this.innerShielding = null;
		this.outerShielding = null;
	}

}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Scene Widget WidgetViewHtml Rex*/

/**
 * WidgetSlider
 */

class WidgetSliderHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);

		// Отступы по бокам
		this.paddings = 5;

		this.pressedSlider = false;

		this.holdPrimary = true;

		this.createDomElement("div");
		this.addClassName("WidgetSlider");

		// Header Container
		this.headerContainer = document.createElement("div");
		this.headerContainer.classList.add("SliderHeader");
		this.htmlElement.appendChild(this.headerContainer);

		// Inputs Container
		this.sliderInputsContainer = document.createElement("div");
		this.sliderInputsContainer.classList.add("SliderInputContainer");
		this.sliderInputsContainer.style.display = "none";
		this.htmlElement.appendChild(this.sliderInputsContainer);
		
		this.sliderInputValue = document.createElement("input");
		this.sliderInputValue.classList.add("WidgetSliderInput1");
		this.sliderInputValue.type = "number";
		this.sliderInputValue.required = true;
		this.sliderInputValue.addEventListener("input", function(e) {
			this.setValue(e.srcElement.value, true);
		}.bind(this));
		this.sliderInputsContainer.appendChild(this.sliderInputValue);

		this.sdiff = document.createElement("div");
		this.sdiff.style.width = "100%";
		this.sdiff.style.maxWidth = "50%";
		this.sliderInputsContainer.appendChild(this.sdiff);

		this.sliderInputSValue = document.createElement("input");
		this.sliderInputSValue.classList.add("WidgetSliderInput2");
		this.sliderInputSValue.type = "number";
		this.sliderInputSValue.required = true;
		this.sliderInputSValue.addEventListener("input", function(e) {
			this.setValue(e.srcElement.value, false);
		}.bind(this));
		this.sliderInputsContainer.appendChild(this.sliderInputSValue);

		// Slider Container
		this.sliderContainer = document.createElement("div");
		this.sliderContainer.classList.add("SliderContainer");
		// this.sliderContainer.style.height = "70%";
		this.htmlElement.appendChild(this.sliderContainer);

		// Slider Line
		this.sliderLine = document.createElement("div");
		this.sliderLine.classList.add("SliderLine");
		this.sliderLine.style.width = "calc(100% - " + (this.paddings * 2) + "px)";
		this.sliderLine.style.transform = "translate(" + this.paddings + "px)";
		this.sliderContainer.appendChild(this.sliderLine);

		// Slider RangeLine
		this.sliderRangeLine = document.createElement("div");
		this.sliderRangeLine.classList.add("SliderLine");
		this.sliderRangeLine.style.transform = "translate(" + this.paddings + "px)";
		this.sliderRangeLine.style.display = "none";
		this.sliderRangeLine.style.filter = "brightness(0.8)";
		this.sliderRangeLine.style.background = "rgb(38, 166, 154)";
		this.sliderContainer.appendChild(this.sliderRangeLine);

		// Slider LimitLine
		this.sliderLimitLine = document.createElement("div");
		this.sliderLimitLine.classList.add("SliderLimitLine");
		this.sliderLimitLine.style.display = "none";
		this.sliderLine.appendChild(this.sliderLimitLine);

		// Slider Slide
		this.sliderSlide = document.createElement("div");
		this.sliderSlide.classList.add("SliderSlide");
		this.sliderContainer.appendChild(this.sliderSlide);

		//Slider SlideTooltip
		this.sliderTooltip = document.createElement("div");
		this.sliderTooltip.classList.add("SliderTooltip");
		this.sliderTooltip.style.display = "none";
		this.sliderTooltip.style.visibility = "hidden";
		this.sliderContainer.appendChild(this.sliderTooltip);

		// Slider Second Slide
		this.sliderSecondSlide = document.createElement("div");
		this.sliderSecondSlide.classList.add("SliderSlide");
		this.sliderSecondSlide.style.display = "none";
		this.sliderContainer.appendChild(this.sliderSecondSlide);

		//Slider Second SlideTooltip
		this.sliderSecondTooltip = document.createElement("div");
		this.sliderSecondTooltip.classList.add("SliderTooltip");
		this.sliderSecondTooltip.style.display = "none";
		this.sliderSecondTooltip.style.visibility = "hidden";
		this.sliderContainer.appendChild(this.sliderSecondTooltip);

		// SliderValueLeft
		this.sliderValueLeft = document.createElement("div");
		this.sliderValueLeft.classList.add("SliderBoundaries");
		this.sliderValueLeft.style.textAlign = "left";
		this.sliderContainer.appendChild(this.sliderValueLeft);

		// SliderValueRight
		this.sliderValueRight = document.createElement("div");
		this.sliderValueRight.classList.add("SliderBoundaries");
		this.sliderValueRight.style.textAlign = "right";
		this.sliderContainer.appendChild(this.sliderValueRight);

		// Slider Shield
		this.sliderShield = document.createElement("div");
		this.sliderShield.classList.add("SliderShield");
		this.sliderContainer.appendChild(this.sliderShield);
		
	}

	onSetState(state) {
		if (null == state) return;
		var d;
		let q;
		
		if (null != state.header) {
			let header = decodeURIComponent(escape(window.atob(state.header)));
			this.headerContainer.textContent = header;
		}

		if (null != state.min) {
			// if (this.limitMin < state.min) this.limitMin = state.min;
			this.min = state.min;
			this.sliderValueLeft.textContent = this.min;
		}

		if (null != state.max) {
			// if (this.limitMax > state.max) this.limitMax = state.max;
			this.max = state.max;
			this.sliderValueRight.textContent = this.max;
		}

		if (null != state.limitMin) {
			// if (this.limitMin < this.min) this.min = this.limitMin;
			this.limitMin = state.limitMin;
		}

		if (null != state.limitMax) {
			// if (this.limitMax > this.max) this.max = this.limitMax;
			this.limitMax = state.limitMax;
		}

		if (state.enableRange != null) {
			if (state.enableRange == true) {
				this.sliderSecondSlide.style.display = "";
				this.sliderSecondTooltip.style.display = "";
				this.sliderRangeLine.style.display = "";

				if (true == this.enableInputs) {
					this.sliderInputsContainer.style.display = "";
					this.sliderContainer.style.height = "calc(70% - 20px)";
				}

			} else {
				this.sliderSecondSlide.style.display = "none";
				this.sliderSecondTooltip.style.display = "none";
				this.sliderRangeLine.style.display = "none";

				this.sliderInputsContainer.style.display = "none";
				this.sliderContainer.style.height = "70%";
			}
		}

		if (state.enableLimits != null) {
			if (state.enableLimits == true) {
				this.sliderLimitLine.style.display = "";
			} else {
				this.sliderLimitLine.style.display = "none";
			}
		}

		if (state.enableTooltip != null) {
			if (state.enableTooltip == true) {
				this.sliderTooltip.style.display = "";
				if (this.enableRange) this.sliderSecondTooltip.style.display = "";
			} else {
				this.sliderTooltip.style.display = "none";
				this.sliderSecondTooltip.style.display = "none";
			}
		}

		if (state.enableInputs != null) {
			if (this.enableRange == true && state.enableInputs == true) {
				this.sliderInputsContainer.style.display = "";
				this.sliderContainer.style.height = "calc(70% - 20px)";
			} else {
				this.sliderInputsContainer.style.display = "none";
				this.sliderContainer.style.height = "70%";
			}
		}

		if (state.colorLine != null) {
			this.sliderLine.style.background = state.colorLine;
		}
		if (state.colorSlide != null && state.colorSlide != "") {
			this.sliderSlide.style.background = state.colorSlide;
			this.sliderSecondSlide.style.background = state.colorSlide;
			this.sliderRangeLine.style.background = state.colorSlide;
		}
		if (state.colorTooltip != null) {
			this.sliderTooltip.style.background = state.colorTooltip;
			this.sliderSecondTooltip.style.background = state.colorTooltip;
		}
		if (state.colorLimitLine != null) {
			this.sliderLimitLine.style.borderColor = state.colorLimitLine;
		}

		if(state.step != null) {
			this.sliderInputValue.step = this.step;
			this.sliderInputSValue.step = this.step;
		}

		if(state.min != null || state.limitMin != null) {
			this.sliderInputValue.min = Math.max(this.min, this.limitMin);
		}

		if(state.min != null || state.limitMin != null) {
			this.sliderInputSValue.max = Math.min(this.max, this.limitMax);
		}

		this.updateDraw();

	}

	onInit() {
		this.updateDraw();
	}

	updateDraw() {

		// Сокрытие отображения значения, если оно вне видимого диапазона
		if (this.value < this.min || this.value > this.max)
			this.sliderSlide.style.display = "none";
		else
			this.sliderSlide.style.display = "";

		// Сокрытие отображения второго значения, если оно вне видимого диапазона
		if (this.secondValue < this.min || this.secondValue > this.max)
			this.sliderSecondSlide.style.display = "none";
		else if (this.enableRange)
			this.sliderSecondSlide.style.display = "";

		// Расчет координат
		let workedWidth = this.sliderLine.clientWidth;
		let pixelVal = ((this.max - this.min) / workedWidth);

		// Primary
		let pointValue = (this.value - this.min) / pixelVal;
		this.sliderSlide.style.left = pointValue + "px";

		this.sliderTooltip.style.left = pointValue + "px";
		this.sliderTooltip.textContent = this.value;

		// Secondary
		let pointSecondValue = (this.secondValue - this.min) / pixelVal;
		this.sliderSecondSlide.style.left = pointSecondValue + "px";

		this.sliderSecondTooltip.style.left = pointSecondValue + "px";
		this.sliderSecondTooltip.textContent = this.secondValue;

		// Range line
		this.sliderRangeLine.style.left = Math.min(pointValue, pointSecondValue) + "px";
		this.sliderRangeLine.style.width = Math.abs(pointValue - pointSecondValue) + "px";

		// LIMITS
		let limitMinPos = (this.limitMin - this.min) / pixelVal;
		let limitMaxPos = (this.limitMax - this.min) / pixelVal;

		this.sliderLimitLine.style.left = limitMinPos + "px";
		this.sliderLimitLine.style.width = (limitMaxPos - limitMinPos) + "px";

		this.sliderInputValue.value = this.value;
		this.sliderInputSValue.value = this.secondValue;
		
		this.sliderInputValue.max = this.secondValue;
		this.sliderInputSValue.min = this.value;

	}

	mouseDown(x, y, e) {
		
		// if(this.enableRange && this.enableInputs && e.path != null && e.path.indexOf(this.sliderInputValue) != -1) {
		// 	this.sliderInputValue.focus;
		// 	return;
		// }

		// if(this.enableRange && this.enableInputs && e.path != null && e.path.indexOf(this.sliderSInputValue) != -1) {
		// 	this.sliderSInputValue.focus;
		// 	return;
		// }

		if (e.target != this.sliderShield && e.target != this.htmlElement)
			return;

		this.pressedSlider = true;

		let pressPosX = e.offsetX - this.paddings;

		let workedWidth = this.sliderLine.clientWidth;
		let diffVal = ((this.max - this.min) / workedWidth); // 1px - value;

		let value = pressPosX * diffVal + this.min;
		let primary = Math.abs(this.value - value) < Math.abs(this.secondValue - value);
		if(this.value == this.secondValue) {
			if(value < this.value) primary = true;
			else primary = false
		}

		if((true == primary) || (false == this.enableRange)) this.holdPrimary = true;
		else this.holdPrimary = false;

		this.controlMouse(e);
	}

	mouseMove(x, y, e) {
		if (false == this.pressedSlider)
			return;

		this.controlMouse(e);
	}

	mouseUp() {
		this.pressedSlider = false;
		this.sliderTooltip.style.visibility = "hidden";
		this.sliderSecondTooltip.style.visibility = "hidden";
	}

	mouseWheel(d, e) {

		if (false == this.hover)
			return;

		if (e.target != this.sliderShield && e.target != this.htmlElement)
			return;

		let pressPosX = e.offsetX - this.paddings;

		let workedWidth = this.sliderLine.clientWidth;
		let diffVal = ((this.max - this.min) / workedWidth); // 1px - value;

		let value = pressPosX * diffVal + this.min;
		let primary = Math.abs(this.value - value) < Math.abs(this.secondValue - value);
		if(this.value == this.secondValue) {
			if(value < this.value) primary = true;
			else primary = false
		}
		
		if ((true == primary) || (false == this.enableRange))
			this.setValue(this.value - this.step * d, true);
		else
			this.setValue(this.secondValue - this.step * d, false);
		
	}

	controlMouse(e) {
		if (e.target != this.sliderShield && e.target != this.htmlElement)
			return;

		let pressPosX = e.offsetX - this.paddings;

		let workedWidth = this.sliderLine.clientWidth;
		let diffVal = ((this.max - this.min) / workedWidth); // 1px - value;

		let value = pressPosX * diffVal + this.min;

		if (this.holdPrimary) {
			this.setValue(value, true);
			this.sliderTooltip.style.visibility = "";
		} else {
			this.setValue(value, false);
			this.sliderSecondTooltip.style.visibility = "";
		}
	}

	setValue(v, primary) {

		let l = v % this.step;
		if (0 != v) {
			if ((this.step / 2) > l)
				v -= l;
			else
				v += (this.step - l);
		}

		let size = 0;
		let strV = this.step.toString();
		let index1 = strV.indexOf(".");
		if ((index1 != -1)) {
			size = strV.split(".")[1].length;
		}
		let index2 = strV.indexOf(",");
		if ((index1 != -1)) {
			size = strV.split(".")[1].length;
		}

		if (v < this.min) v = this.min;
		if (v > this.max) v = this.max;

		if (true == this.enableLimits) {
			if (v < this.limitMin) v = this.limitMin;
			if (v > this.limitMax) v = this.limitMax;
		}

		v = parseFloat(v.toFixed(size));

		if (true == primary) {
			if(true == this.enableRange && v > this.secondValue) return;
			this.value = v;
			Rex.callRpcMethod("Widgets", this.id, this.type, "setValue", [this.value]);
		} else {
			if(true == this.enableRange && v < this.value) return;
			this.secondValue = v;
			Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondValue", [this.secondValue]);
		}

		this.updateDraw();
	}

}


/**
 * Created by prg-15 on 05.01.2018.
 */
class WidgetTextAreaHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		
		this._scrollPos = null;
		
		this.createDomElement("div");
		this.htmlElement.classList.add("WidgetTextArea");

		this.headerElement = document.createElement("div");
		this.headerElement.classList.add("WidgetTextAreaHeader");
		this.htmlElement.appendChild(this.headerElement);
		
		this.textAreaElement = document.createElement("textarea");
		this.textAreaElement.classList.add("WidgetTextAreaContent");
		this.htmlElement.appendChild(this.textAreaElement);

		this.textAreaElement.addEventListener("scroll", function (event) {
			const maxScrollPos = this.textAreaElement.scrollHeight - this.textAreaElement.clientHeight;
			const currentPos = this.textAreaElement.scrollTop;
			if (maxScrollPos !== currentPos)
				Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
		}.bind(this));
		
		
		this.textAreaElement.oninput = () => {
			if (this.widget.text == event.target.value) return;
			this.widget.text = event.target.value;
			Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setParameters', [this.widget.text, this.widget.cursorPosition, this.widget.selectPosition, this.widget.globalSelectPosition, this.widget.cursorLine, this.widget.selectLine]);
		};
		
	}
	
	onInit() {
		this.scrollPos = this.scrollPos;
	}
	
	onSetState(state) {
		if(state.cursorPosition != null) this.widget.cursorPosition = state.cursorPosition;
		if(state.selectPosition != null) this.widget.selectPosition = state.selectPosition;
		if(state.globalSelectPosition != null) this.widget.globalSelectPosition = state.globalSelectPosition;
		if(state.cursorLine != null) this.widget.cursorLine = state.cursorLine;
		if(state.selectLine != null) this.widget.selectLine = state.selectLine;
		if(state.lineHeight != null) this.widget.lineHeight = state.lineHeight;
		if(state.scrollPos != null) this.scrollPos = state.scrollPos;
		
		if(state.header != null) this.controlHeader(state.header);
		if(state.text != null) this.controlText(state.text);
		if(state.horizontalTextAlign != null) this.controlAlign();
		if(state.fontSize != null) this.controlFontSize();
		if(state.textColor != null) this.controlTextColor();
		if(state.fontBold != null || state.fontItalic != null) this.controlFontStyle();
		
		if(state.activated != null) {
			this.htmlElement.classList.remove("Disabled");
			if (!state.activated)
				this.textAreaElement.setAttribute("readonly", "true");
			else
				this.textAreaElement.removeAttribute("readonly");
		}
		
	}
	
	controlText(stateText) {
		let newText = "";
		try { newText = decodeURIComponent(escape(window.atob(stateText)));
		} catch(e) { console.log(this.widget.type, " -> setState-> \"text\" DecodeError!"); return;}
		
		this.textAreaElement.value = newText;
		this.widget.text = newText;
	}
	
	controlHeader(stateHeader) {
		let newText = "";
		try { newText = decodeURIComponent(escape(window.atob(stateHeader)));
		} catch(e) { console.log(this.widget.type, " -> setState-> \"header\" DecodeError!"); return;}
		
		if(this.widget.header === newText) return;
		this.headerElement.textContent = newText;
	}
	
	controlAlign() {
		switch(this.horizontalTextAlign) { //justify-content: center;
			case 1:
				this.headerElement.style.justifyContent = "flex-start";
				this.textAreaElement.style.textAlign = "left";
				break;
			case 2:
				this.headerElement.style.justifyContent = "center";
				this.textAreaElement.style.textAlign = "center";
				break;
			case 3:
				this.headerElement.style.justifyContent = "flex-end";
				this.textAreaElement.style.textAlign = "right";
				break;
			default:
				this.textAreaElement.style.textAlign = "";
				break;
		}
		
	}
	
	controlFontSize() {
		this.textAreaElement.style.fontSize = this.fontSize + "px";
		this.headerElement.style.fontSize = "calc(" + this.fontSize + "px * 1.2)";
	}
	
	controlTextColor() {
		this.textAreaElement.style.color = this.textColor; 
		this.headerElement.style.color = this.textColor;
		this.headerElement.style.filter = "brightness(50%)";
	}
	
	controlFontStyle() {
		let italic = "";
		if(this.fontItalic) italic = "italic";
		this.textAreaElement.style.fontStyle = italic;
		this.headerElement.style.fontStyle = italic;
		
		let bold = "";
		if(this.fontBold) bold = "bold";
		this.textAreaElement.style.fontWeight = bold;
		this.headerElement.style.fontWeight = bold;
	}
	
	keyUp(event) {
		// if (this.widget.text == event.target.value) return;
		// this.widget.text =  event.target.value;
		// Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'setParameters', [this.widget.text, this.widget.cursorPosition, this.widget.selectPosition, this.widget.globalSelectPosition, this.widget.cursorLine, this.widget.selectLine]);
	}

	set scrollPos(value) {
		if (value < 0 || value > 1) return;
		this._scrollPos = value;
		
		const maxScrollPos = this.textAreaElement.scrollHeight - this.textAreaElement.clientHeight;
		const currentScrollPos = value * maxScrollPos;
		if (this.textAreaElement.scrollTop == currentScrollPos) return;
		this.textAreaElement.scrollTop = currentScrollPos ;
	}

	get scrollPos() {
		return this._scrollPos;
	}


}

/**
 * WidgetLabel
 */

class WidgetLabelHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetLabel");

		this.htmlText = document.createElement("div");
		this.htmlText.classList.add("WidgetLabelText");

		try {
			new ResizeObserver(this.controlFontSize.bind(this)).observe(this.htmlElement);
		} catch (e) {
		}
	}
	
	onSetState(state) {
		if(state.pressed != null) this.widget.pressed = state.pressed;
		if(state.raisedElevation != null) this.widget.raisedElevation = state.raisedElevation;
		if(state.defaultElevation != null) this.widget.defaultElevation = state.defaultElevation;
		if(state.autoSize != null) this.autoSize = state.autoSize;
		if(state.lessHundred != null) this._lessHundred = state.lessHundred;
		if(state.lineHeight != null) this.widget.lineHeight = state.lineHeight;
		
		if(state.text != null) this.controlText(state.text);
		if(state.iconName != null) this.controlIconName(state.iconName);
		if(state.verticalTextAlign != null) this.controlVerticalTextAlign(state.verticalTextAlign);
		if(state.horizontalTextAlign != null) this.controlHorizontalTextAlign(state.horizontalTextAlign);
		if(state.fontSize != null) this.controlFontSize();
		if(state.controlWidgetSizeFlag != null) this.ctrlWidgetSize(state.controlWidgetSizeFlag);
		if(state.controlFontSizeState != null) this.ctrlFontSize();
		if(state.breakWordType != null) this.controlBreakWord(state.breakWordType);
	}
	
	controlText(stateText) {
		let text = "";
		try { 
			text = decodeURIComponent(escape(window.atob(stateText)));
		} catch(e) {
			console.log(this.widget.type, "setState->", "Text DecodeError!", e, stateText);
			return;
		}
		
		this.widget.text = text;
		if (!this.htmlElement.contains(this.htmlText)) {
			this.htmlElement.appendChild(this.htmlText);
		}

		if(this.widget.iconName == "") 
			this.htmlText.textContent = text;
	}
	
	controlIconName(stateIconName) {
		if(this.widget.iconName == stateIconName) {
			return;
		}

		this.widget.iconName = stateIconName;
		
		if(this.widget.iconName == "") {
			this.htmlText.textContent = this.widget.text;
			this.htmlText.classList.remove("MaterialIcon");
		} else {
			this.htmlText.textContent = stateIconName;
			this.htmlText.classList.add("MaterialIcon");
		}
	}
	
	controlVerticalTextAlign(stateTextAlign) {
		if(this.widget.verticalTextAlign == stateTextAlign) return;
		this.widget.verticalTextAlign = stateTextAlign;
		switch (stateTextAlign) {
			case 1: // TEXT TOP
				this.htmlText.style.alignItems = "flex-start";
				break;
			case 2: // TEXT CENTER
				this.htmlText.style.alignItems = "center";
				break;
			case 3: // TEXT BOTTOM
				this.htmlText.style.alignItems = "flex-end";
				break;
		}
	}
	
	controlHorizontalTextAlign(stateTextAlign) {
		if(this.widget.horizontalTextAlign == stateTextAlign) return;

		switch(stateTextAlign) { //justify-content: center;
			case 1: // TEXT LEFT
				this.htmlText.style.justifyContent = "flex-start";
				this.htmlText.style.textAlign = "left";
				break;
			case 2: // TEXT CENTER
				this.htmlText.style.justifyContent = "center";
				this.htmlText.style.textAlign = "center";
				break;
			case 3: // TEXT RIGHT
				this.htmlText.style.justifyContent = "flex-end";
				this.htmlText.style.textAlign = "right";
				break;
		}
	}

	controlFontSize(e) {
		if(!this.autoSize) {
			this.htmlElement.style.fontSize = this.fontSize + 'px';
			return;
		}

		let html = this.htmlElement;
		const ratio = html.clientWidth < html.clientHeight ?
			html.clientWidth / html.clientHeight : html.clientHeight / html.clientWidth;

		const side = Math.max(html.clientWidth, html.clientHeight);
		if (side === 0) {
			return;
		}

		let fontSize = side * ratio;
		if (ratio < 0.5) {
			fontSize *= 2;
		}

		if (fontSize < 100 && !this._lessHundred) {
			this.htmlText.style.fontSize = "100%";
		} else {
			this.htmlText.style.fontSize = (fontSize) + '%';
		}
	}

	controlBreakWord(type) {
		if (type === 0) {
			this.htmlText.style.wordBreak = "normal";
		} else if (type == 1) {
			this.htmlText.style.wordBreak = "break-all";
		} else if (type == 2) {
			this.htmlText.style.wordBreak = "keep-all";
		} else if (type == 3) {
			this.htmlText.style.wordBreak = "break-word";
		}
	}
	
	set autoSize (value) {
		this._autoSize = value;
		if (!this.autoSize)
			this.htmlElement.style.fontSize = this.fontSize + "px";
		else this.controlFontSize();
	}
	
	get autoSize () {
		return this._autoSize;
	}
	
	//This method can be invoked from C++ or neurone only
	ctrlWidgetSize (value) {
		if (value == null) return;
		if (value === 0) return;
		
		let html = this.htmlElement;
		if (value === 1 || value === 3) {
			while (html.scrollWidth > html.clientWidth) {
				if (html.style.minWidth === html.scrollWidth + "px")
					break;
				html.style.minWidth = html.scrollWidth + "px";
				html.style.maxWidth = html.scrollWidth + "px";
			}
		} 
		if (value === 2 || value === 3) {
			while (html.scrollHeight > html.clientHeight) {
				if (html.style.minHeight === html.scrollHeight + "px")
					break;
				html.style.minHeight = html.scrollHeight + "px";
				html.style.maxHeight = html.scrollHeight + "px";
			}
		}
	}

	//This method can be invoked from C++ or neurone only
	ctrlFontSize() {
		let html = this.htmlText;
		while (html.scrollWidth > html.clientWidth || html.scrollHeight > html.clientHeight) {
			html.style.fontSize = (parseInt(html.style.fontSize) - 1) + "px";
		}
	}
	
}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetButtonHtml*/

/**
 * Created by semyon on 05.01.2018.
 */
class WidgetLoaderHtml extends WidgetButtonHtml {
	
	constructor(widget) {
		super(widget);
		this.addClassName("WidgetLoader");

		this.htmlElement.style.overflow = "hidden";

		this.input = document.createElement("input");
		this.input.setAttribute("type", "file");
		this.input.multiple = true;
		this.input.style.display = "none";
		this.input.addEventListener("change", (event) => {
			this.pressLoadFiles(event);
		});

		// BLOCK OPEN FILE IN BROWSER
		["dragenter", "dragover", "dragleave", "drop"].forEach(eventName => {
			this.input.addEventListener(eventName, this.preventDefaults.bind(this), false)   
			document.body.addEventListener(eventName, this.preventDefaults.bind(this), false)
		});

		//over
		["dragenter", "dragover"].forEach(eventName => {
			this.htmlElement.addEventListener(eventName, this.dropOver.bind(this), false)
		});
		
		["dragleave"].forEach(eventName => {
			this.htmlElement.addEventListener(eventName, this.dropUnOver.bind(this), false)
		});

	}

	onMouseDown() {
		if (this.widget.loaderMode == 0) {
			this.input.value = "";
			this.input.click();
		} else {
			this.widget.downloadFile();
		}
	}

	onDrop(event) {

		if(this.dropable == false) {
			return;
		}

		if(this.droppableEvement == null) {
			return;
		}

		this.preventDefaults(event);

		var dt = event.dataTransfer
		var files = dt.files;
		this.widget.loadFiles(files);
		this.dropUnOver();

	}

	preventDefaults (e) {
		e.preventDefault()
		e.stopPropagation()
	}

	pressLoadFiles(event) {
		let files = event.target.files;
		this.widget.loadFiles(files);
	}

	dropOver(e) {


		if(this.dropable == false) {
			return;
		}

		if(this.droppableEvement != null) 
			return
		
		this.droppableEvement = document.createElement("div");
		this.droppableEvement.textContent = "arrow_forward";
		this.droppableEvement.classList.add("DroppableView");
		let res1 = this.htmlElement.appendChild(this.droppableEvement);
		
		this.htmlElement.classList.add("DroppableFile");
		
		try {
			this.htmlElement.removeChild(this.htmlIcon);
			this.hiNeed = true;
		} catch(e) {
			this.hiNeed = false;
		}
		
		try {
			this.htmlElement.removeChild(this.htmlText);
			this.htNeed = true;
		} catch(e) {
			this.htNeed = false;
		}
		
	}

	dropUnOver(e) {

		this.htmlElement.classList.remove("DroppableFile");
		
		if(this.droppableEvement != null) {
			this.droppableEvement.remove();
			this.droppableEvement = null;
		}

		if(this.hiNeed)
			this.htmlElement.appendChild(this.htmlIcon);
		
		if(this.htNeed)
			this.htmlElement.appendChild(this.htmlText);

	}
	
}


class WidgetLoadingHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.htmlElement = document.createElement("div");
		this.addClassName("WidgetLoading");

		this.show = false;
		this.needProgressBar = false;
		this.loadingDataSize = 0;
		this.dataSize = 100;
		this.progressBarType = 0;
		this._loadTime = 10;
		this.loadingTime = 0;
		this.flag = true;
		this.colorProgressBar = "";
		this.colorDots = "";

		this.parentWidget = null;
		this.parentWidgetHtml = null;
		this._$loaderHtmlElement = null;
		this._$loaderInner = null;
		this._$ppcSpan = null;
		this._$ppcProgressFill = null;
		this._$progressPieChart = null;
		this.containerElement = document.getElementById("container1");
	}

	onInit() {
		this.htmlElement.style.display = "none";
	}

	onDestroy() {
		if (this._$loaderInner != undefined) this._$loaderInner.remove();
	}

	onSetState(state) {
		if (state.backgroundColor != null && state.backgroundColor !== "" && this._$loaderHtmlElement != null) {
			this._$loaderHtmlElement.style.setProperty("--wl-background-color-main", this.backgroundColor);
			this._$loaderHtmlElement.style.setProperty("--wl-background-color-main-non-opacity", this.getColorWithoutTransparency(this.backgroundColor));
		}

		if (state.colorProgressBar != null && state.colorProgressBar !== "" && this._$loaderHtmlElement != null) {
			this._$loaderHtmlElement.style.setProperty("--wl-progress-color", this.colorProgressBar);
		}

		if (state.colorDots != null && state.colorDots !== "" && this._$loaderHtmlElement != null) {
			this._$loaderHtmlElement.style.setProperty("--wl-color-dots", this.colorDots);
		}

		if (state.needProgressBar != null) {
			this.needProgressBar = state.needProgressBar;
		}

		if (state.show != null) {
			this.show = state.show;
			if (this.show) {
				this.loadingTime = 0;
				this.startLoader();
			} else {
				this.loadingTime = this.loadTime;
				this.stopLoader();
			}
		}

		if (state.progressBarType != null) {
			this.progressBarType = state.progressBarType;
		}

		if (state.loadTime != null) {
			this._loadTime = state.loadTime;
			if (this.show && this.progressBarType === 1) {
				this.flag = false;
			}
		}

		if (state.dataSize != null) this.dataSize = state.dataSize;

		if (state.loadingDataSize != null) {
			this.loadingDataSize = state.loadingDataSize;
			if (this.show && this.progressBarType === 0)
				this._$changePercent(this._$convertLoadingDataSizeToPercent());
		}
	}

	startLoader() {
		if (this._$loaderHtmlElement != null) return;
		if (this.widget.parentId == -1) {
			this.parentWidgetHtml = this.containerElement;
		} else {
			if (Rex.widgets == null) return;
			this.parentWidget = Rex.widgets[this.widget.parentId];
			if (this.parentWidget == null) return;
			this.parentWidgetHtml = this.parentWidget.view.htmlElement;
			if (this.parentWidgetHtml == null) return;
		}

		this._$loaderHtmlElement = document.createElement("div");
		if (this.needProgressBar)
			this._$loaderHtmlElement.classList.add("cs-loader-with-progress");
		else this._$loaderHtmlElement.classList.add("cs-loader");
		this._$loaderHtmlElement.id = "loader-" + this.id;
		this.containerElement.appendChild(this._$loaderHtmlElement);

		if (this.backgroundColor != null && this.backgroundColor !== "") {
			this._$loaderHtmlElement.style.setProperty("--wl-background-color-main", this.backgroundColor);
			this._$loaderHtmlElement.style.setProperty("--wl-background-color-main-non-opacity", this.getColorWithoutTransparency(this.backgroundColor));
		}

		if (this.colorProgressBar != null && this.colorProgressBar !== "") {
			this._$loaderHtmlElement.style.setProperty("--wl-progress-color", this.colorProgressBar);
		}

		if (this.colorDots != null && this.colorDots !== "") {
			this._$loaderHtmlElement.style.setProperty("--wl-color-dots", this.colorDots);
		}

		this._$loaderInner = document.createElement("div");
		if (this.needProgressBar)
			this._$loaderInner.classList.add("cs-loader-inner-with-progress");
		else this._$loaderInner.classList.add("cs-loader-inner");
		this._$loaderHtmlElement.appendChild(this._$loaderInner);

		let label1 = document.createElement("label");
		label1.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label1);

		let label2 = document.createElement("label");
		label2.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label2);

		let label3 = document.createElement("label");
		label3.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label3);

		let label4 = document.createElement("label");
		label4.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label4);

		let label5 = document.createElement("label");
		label5.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label5);

		let label6 = document.createElement("label");
		label6.innerText = "\tfiber_manual_record";
		this._$loaderInner.appendChild(label6);

		if (this.needProgressBar) {
			this._$progressPieChart = document.createElement("div");
			this._$progressPieChart.classList.add("progress-pie-chart");
			this._$progressPieChart.id = "progress-pie-chart-" + this.id;
			this._$progressPieChart.setAttribute("data-percent", "0");
			this._$loaderHtmlElement.appendChild(this._$progressPieChart);

			this._$ppcProgress = document.createElement("div");
			this._$ppcProgress.classList.add("ppc-progress");
			this._$progressPieChart.appendChild(this._$ppcProgress);

			this._$ppcProgressFill = document.createElement("div");
			this._$ppcProgressFill.classList.add("ppc-progress-fill");
			this._$ppcProgressFill.id = "ppc-progress-fill-" + this.id;
			this._$ppcProgress.appendChild(this._$ppcProgressFill);

			this._$ppPercent = document.createElement("div");
			this._$ppPercent.classList.add("ppc-percents");
			this._$progressPieChart.appendChild(this._$ppPercent);

			let ppPercentWrapper = document.createElement("div");
			ppPercentWrapper.classList.add("pcc-percents-wrapper");
			this._$ppPercent.appendChild(ppPercentWrapper);

			this._$ppcSpan = document.createElement("span");
			this._$ppcSpan.id = "ppc-span-" + this.id;
			if (this.progressBarType === 0)
				this._$ppcSpan.innerText = "0%";
			if (this.progressBarType === 0)
				this._$ppcSpan.innerText = "0\nsec.";
			ppPercentWrapper.appendChild(this._$ppcSpan);
		}

		this._$updateLoaderPos();

		// создаем экземпляр наблюдателя за контейнером, чтобы узнать, когда там происходят изменения.
		try {
			this._$observer = new MutationObserver((mutations) => {
				mutations.forEach((mutation) => {
					//если его нет - досвидания.
					if (this.parentWidgetHtml == null) return;
					//пытаемся достать сам лоадер
					this._$updateLoaderPos();
				});
			});
		} catch (e) {
			console.error("Error MutationObserver RexWidgetLoadingHtml", e);
		}

		// настраиваем наблюдатель. следит за чилдами и свойствами.
		let config = {
			childList: true,
			subtree: true,
			characterData: true,
			attributes: true,
			attributeFilter: ["style"]
		};
		// передаем элемент и настройки в наблюдатель
		let target = undefined;
		if (this.widget.parentId == -1)
			target = this.parentWidgetHtml;
		else {
			target = this._$getRootParent(this.widget);
			if (target == null || target.view == null || target.view.htmlElement == null) {
				console.error("Can't find root element!");
				return;
			}
			target = target.view.htmlElement;
		}
		this._$observer.observe(target, config);
		if (this.needProgressBar) {
			if (this.progressBarType === 0)
				this._$changePercent(this._$convertLoadingDataSizeToPercent());
			else if (this.progressBarType === 1) {
				this.loadingTime = 0;
				this._$setTimeout();
			}
		}
	}

	_$convertLoadingDataSizeToPercent() {
		let percent = this.loadingDataSize * 100 / this.dataSize;
		percent = Math.round(percent);
		return percent;
	}

	_$changePercent(value) {
		if (value > 100 || !this.needProgressBar || !this.show || this.progressBarType !== 0) return;
		let percent = value;
		let deg = 360 * percent / 100;
		if (this._$progressPieChart != null) this._$progressPieChart.classList.remove("gt-50");
		if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.clip = null;
		if (this._$ppcProgress != null) this._$ppcProgress.style.clip = null;
		if (percent > 50) {
			if (this._$progressPieChart != null) this._$progressPieChart.classList.add("gt-50");
			if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.clip = `rect(0, ${this._$progressPieChart.offsetWidth}px, ${this._$progressPieChart.offsetWidth}px, ${this._$progressPieChart.offsetWidth / 2}px)`;
			if (this._$ppcProgress != null) this._$ppcProgress.style.clip = `rect(0, ${this._$progressPieChart.offsetWidth / 2}px, ${this._$progressPieChart.offsetWidth}px, 0)`;
		}
		if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.transform = `rotate(${deg}deg)`;
		if (this._$ppcSpan != null) this._$ppcSpan.innerText = percent + "%";
	}

	_$setTimeout() {
		if (this.loadingTime > this._loadTime || !this.needProgressBar || !this.show || this.progressBarType !== 1) {
			this.loadingTime = 0;
			return;
		}
		if (!this.flag) {
			this.flag = true;
			this._$setTimeout();
			return;
		}
		let percent = Math.round(this.loadingTime * 100 / this._loadTime);
		let deg = 360 * percent / 100;
		if (this._$progressPieChart != null) this._$progressPieChart.classList.remove("gt-50");
		if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.clip = null;
		if (this._$ppcProgress != null) this._$ppcProgress.style.clip = null;
		if (percent > 50) {
			if (this._$progressPieChart != null) this._$progressPieChart.classList.add("gt-50");
			if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.clip = `rect(0, ${this._$progressPieChart.offsetWidth}px, ${this._$progressPieChart.offsetWidth}px, ${this._$progressPieChart.offsetWidth / 2}px)`;
			if (this._$ppcProgress != null) this._$ppcProgress.style.clip = `rect(0, ${this._$progressPieChart.offsetWidth / 2}px, ${this._$progressPieChart.offsetWidth}px, 0)`;
		}
		if (this._$ppcProgressFill != null) this._$ppcProgressFill.style.transform = `rotate(${deg}deg)`;
		if (this._$ppcSpan != null) this._$ppcSpan.innerText = (this._loadTime - this.loadingTime) + "\nsec.";
		this.loadingTime++;
		setTimeout(() => {
			if (!this.show) {
				this.loadingTime = 0;
				return;
			}
			this._$setTimeout();
		}, 1000);
	}

	_$updateLoaderPos() {
		if (this.parentWidgetHtml == null) return;
		if (this._$loaderHtmlElement == null) return;
		//если он уже есть - копируем в лоадер все настройки парента.
		this._$loaderHtmlElement.style.width = this.parentWidgetHtml.offsetWidth + "px";
		this._$loaderHtmlElement.style.height = this.parentWidgetHtml.offsetHeight + "px";
		let pos = this._$getOffsetPos(this.parentWidgetHtml);
		this._$loaderHtmlElement.style.top = pos.top + "px";
		this._$loaderHtmlElement.style.left = pos.left + "px";
		this._$loaderHtmlElement.style.visibility = this.parentWidgetHtml.style.visibility;
		this._$loaderHtmlElement.style.display = this.parentWidgetHtml.style.display;

		let width = this._$loaderHtmlElement.offsetWidth;
		let height = this._$loaderHtmlElement.offsetHeight - 100;

		if ((width < 210 || height < 210) && (width > 65 && height > 65)) {
			if (width < height) {
				this.setGeometryHtml(this._$progressPieChart, width - 20 + "px", width - 20 + "px", width - 20 + "px", width - 20 + "px");

				if (this._$progressPieChart.classList.contains("gt-50"))
					this.setPositionHtml(this._$ppcProgress, `calc(50% - ${(width - 20) / 2}px)`, `calc(50% - ${(width - 20) / 2}px)`, true, `rect(0, ${(width - 20) / 2}px, ${width - 20}px, 0)`);
				else this.setPositionHtml(this._$ppcProgress, `calc(50% - ${(width - 20) / 2}px)`, `calc(50% - ${(width - 20) / 2}px)`, true, `rect(0, ${width - 20}px, ${width - 20}px, ${(width - 20) / 2}px)`);

				this.setGeometryHtml(this._$ppcProgressFill, width - 20 + "px", width - 20 + "px", width - 20 + "px", width - 20 + "px");
				if (this._$progressPieChart.classList.contains("gt-50"))
					this.setPositionHtml(this._$ppcProgressFill, `calc(50% - ${(width - 20) / 2}px)`, `calc(50% - ${(width - 20) / 2}px)`, true, `rect(0, ${width - 20}px, ${width - 20}px, ${(width - 20) / 2}px)`);
				else this.setPositionHtml(this._$ppcProgressFill, `calc(50% - ${(width - 20) / 2}px)`, `calc(50% - ${(width - 20) / 2}px)`, true, `rect(0, ${(width - 20) / 2}px, ${width - 20}px, 0)`);

				this.setGeometryHtml(this._$ppPercent, width - 20 - 16 + "px", width - 20 - 16 + "px", width - 20 - 16 + "px", width - 20 - 16 + "px");
				this.setPositionHtml(this._$ppPercent, `calc(50% - ${(width - 20 - 16) / 2}px)`, `calc(50% - ${(width - 20 - 16) / 2}px)`, false);
				this._$ppcSpan.style.fontSize = ((width - 20 - 16) / 3.5) + "px";
			} else {
				this.setGeometryHtml(this._$progressPieChart, height - 20 + "px", height - 20 + "px", height - 20 + "px", height - 20 + "px");
				if (this._$progressPieChart.classList.contains("gt-50"))
					this.setPositionHtml(this._$ppcProgress, `calc(50% - ${(height - 20) / 2}px)`, `calc(50% - ${(height - 20) / 2}px)`, true, `rect(0, ${(height - 20) / 2}px, ${height - 20}px, 0)`);
				else this.setPositionHtml(this._$ppcProgress, `calc(50% - ${(height - 20) / 2}px)`, `calc(50% - ${(height - 20) / 2}px)`, true, `rect(0, ${height - 20}px, ${height - 20}px, ${(height - 20) / 2}px)`);

				this.setGeometryHtml(this._$ppcProgressFill, height - 20 + "px", height - 20 + "px", height - 20 + "px", height - 20 + "px");
				if (this._$progressPieChart.classList.contains("gt-50"))
					this.setPositionHtml(this._$ppcProgressFill, `calc(50% - ${(height - 20) / 2}px)`, `calc(50% - ${(height - 20) / 2}px)`, true, `rect(0, ${height - 20}px, ${height - 20}px, ${(height - 20) / 2}px)`);
				else tthis.setPositionHtml(this._$ppcProgressFill, `calc(50% - ${(height - 20) / 2}px)`, `calc(50% - ${(height - 20) / 2}px)`, true, `rect(0, ${(height - 20) / 2}px, ${height - 20}px, 0)`);

				this.setGeometryHtml(this._$ppPercent, height - 20 - 16 + "px", height - 20 - 16 + "px", height - 20 - 16 + "px", height - 20 - 16 + "px");
				this.setPositionHtml(this._$ppPercent, `calc(50% - ${(height - 20 - 16) / 2}px)`, `calc(50% - ${(height - 20 - 16) / 2}px)`, false);
				this._$ppcSpan.style.fontSize = ((height - 20 - 16) / 3.5) + "px";
			}
		}
	}

	setGeometryHtml(element, width, height, minWidth, minHeight) {
		if (!element) {
			return;
		}
		element.style.width = width;
		element.style.height = height;
		element.style.minWidth = minWidth;
		element.style.minHeight = minHeight;
	}

	setPositionHtml(element, top, left, flag, clip) {
		element.style.top = top;
		element.style.left = left;
		if (flag)
			element.style.clip = clip;
	}

	stopLoader() {
		//отключаем наблюдателя
		if (this._$observer != null) {
			this._$observer.disconnect();
		}
		//выкидываем лоадер
		if (this._$loaderHtmlElement != null) {
			this.containerElement.removeChild(this._$loaderHtmlElement);
		}
		this.parentWidget = null;
		this.parentWidgetHtml = null;
		this._$loaderHtmlElement = null;
		this._$loaderInner = null;
		this._$ppcSpan = null;
		this._$ppcProgressFill = null;
		this._$progressPieChart = null;
		delete this._$observer;
	}

	_$getOffsetPos(el) {
		let _x = 0;
		let _y = 0;
		while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
			_x += el.offsetLeft - el.scrollLeft;
			_y += el.offsetTop - el.scrollTop;
			el = el.offsetParent;
		}
		return {
			top: _y,
			left: _x
		};
	}

	_$getRootParent(element) {
		if (element.parentId == -1) return element;
		let parentWidget = Rex.widgets[element.parentId];
		if (parentWidget == null) return element;
		return this._$getRootParent(parentWidget);
	}

	getColorWithoutTransparency(color) {
		let result = "";
		if (color.indexOf("rgb(") !== -1) {
			return color;
		} else if (color.indexOf("rgba(") !== -1) {
			result = "rgb(";
			let tstr = color.replace("rgba(", "");
			tstr = tstr.replace(")", "");
			let arr = tstr.split(",", 4);
			if (arr.length == 4) {
				result += Math.round(arr[0]);
				result += ",";
				result += Math.round(arr[1]);
				result += ",";
				result += Math.round(arr[2]);
				result += ")";
				return result;
			} else {
				console.error("error parse rgba : ", color);
				return "";
			}
		} else if (color.indexOf("#") !== -1) {
			if (color.length === 4 || color.length === 7) return color;
			if (color.length === 9) {
				for (let i = 0; i < 7; ++i) {
					result += color[i];
				}
				return result;
			}
		}

		return color;
	}
}


/**
 * WidgetSwitch
 */

class WidgetSwitchHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetSwitch");

		this.label = document.createElement("label");
		this.htmlElement.appendChild(this.label);
		this.label.classList.add("switch");
		
		this.span = document.createElement("span");
		this.label.appendChild(this.span);
		this.span.classList.add("WidgetSwitch-label");
		
		
	}
	
	onSetState(state) {
		if(state.pressed != null) this.widget.pressed = state.pressed;
	}
	
	onInit() {
		this.enable = this.widget.enable;
	}
	
	set enable(value) {
		this.widget.enable = value;
		if(value) {
			this.span.classList.add("TurnOn");
			this.textOn = this.widget.textOn;
		} else {
			this.span.classList.remove("TurnOn");
			this.textOff = this.widget.textOff;
		}
	}
	
	get enable() {return this.widget.enable;}
	
	set textOn(value) {
		this.widget.textOn = value;
		this.span.innerText = value;
	}
	
	get textOn() {return this.widget.textOn;}
	
	set textOff(value) {
		this.widget.textOff = value;
		this.span.innerText = value;
	}
	
	get textOff() {return this.widget.textOff;}
	
}

/**
 * WidgetSwitch
 */

class WidgetStickHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetStick");
		
		this.containerHtml = document.createElement("div");
		this.containerHtml.classList.add("WidgetStickContainer");
		this.htmlElement.appendChild(this.containerHtml);
		
		this.stickButttons = document.createElement("div");
		this.containerHtml.appendChild(this.stickButttons);
		this.stickButttons.classList.add("stick-buttons");
		
		this.stickTop = document.createElement("div");
		this.stickButttons.appendChild(this.stickTop);
		this.stickTop.classList.add("stick-top");
		
		this.upElement = document.createElement("div");
		this.stickTop.appendChild(this.upElement);
		this.upElement.classList.add("stick-top-left");
		//this.upElement.innerText = "&#9700";
		
		this.rightElement = document.createElement("div");
		this.stickTop.appendChild(this.rightElement);
		this.rightElement.classList.add("stick-top-right");
		//this.rightElement.innerText = "&#9701";
		
		this.stickBottom = document.createElement("div");
		this.stickButttons.appendChild(this.stickBottom);
		this.stickBottom.classList.add("stick-bottom");
		
		this.leftElement = document.createElement("div");
		this.stickBottom.appendChild(this.leftElement);
		this.leftElement.classList.add("stick-bottom-left");
		//this.leftElement.innerText = "&#9699";
		
		this.downElement = document.createElement("div");
		this.stickBottom.appendChild(this.downElement);
		this.downElement.classList.add("stick-bottom-right");
		//this.downElement.innerText = "&#9698";
		
		this.stickEnter = document.createElement("div");
		this.containerHtml.appendChild(this.stickEnter);
		this.stickEnter.classList.add("stick-switch");
		
		this.labelElement = document.createElement("label");
		this.stickEnter.appendChild(this.labelElement);
		this.labelElement.classList.add("stick-label");
		this.labelElement.innerText = "OK";
		try {
			new ResizeObserver(this.setSizes).observe(this.htmlElement);
		} catch (e) {
		}
		
	}
	
	setSizes(e) {
		if(!e) return;
		if(!e[0]) return;
		if(!e[0].target) return;
		if(!e[0].target.lastChild) return;
		let realW = e[0].contentRect.width;
		let realH = e[0].contentRect.height;
		let value = Math.min(realH, realW);
		e[0].target.lastChild.style.width = value + "px";
		e[0].target.lastChild.style.height = value + "px";
	}
	
	onSetState(state) {
		if(state.currentButton != null) this.widget.currentButton = state.currentButton;
		
	}
	
	onInit() {
		this.upElement.id = `${this.widget.id}Up`;
		this.rightElement.id = `${this.widget.id}Right`;
		this.leftElement.id = `${this.widget.id}Left`;
		this.downElement.id = `${this.widget.id}Down`;
		this.stickEnter.id = `${this.widget.id}Enter`;
		let diameter = Math.min(this.widget.width, this.widget.height);
		// this.width = diameter;
		// this.height = diameter;
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-debugger */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex*/

/**
 * WidgetImage
 */

class WidgetImageHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.imageData = "";
		this.createDomElement("div");
		this.addClassName("WidgetImage");
		
		this.htmlImage = document.createElement("div");
		this.htmlImage.classList.add("WidgetImageImg");
		this.htmlImage.classList.add("MaterialIcon");
		this.htmlElement.appendChild(this.htmlImage);
	}
	
	onSetState(state) {

		if(state.iconName != null) this.controlIconName(state.iconName);
	}
	
	set position(value){
		// Stretch 	= 0, // растянуть
		// Centered = 1, // по центру
		// Filling 	= 2, // заполнение
		// ToSize 	= 3, // по размеру
		// Repeat 	= 4  // замостить
		this.widget.position = value;
		if(value == 0 ) this.htmlImage.style.backgroundSize = "100% 100%";
		if(value == 1 ) {this.htmlImage.style.backgroundSize = "";  this.htmlImage.style.backgroundRepeat = "no-repeat";}
		if(value == 2 ) this.htmlImage.style.backgroundSize = "cover";
		if(value == 3 ) this.htmlImage.style.backgroundSize = "contain";
		if(value == 4 ) {this.htmlImage.style.backgroundSize = ""; this.htmlImage.style.backgroundRepeat = "repeat"}
	}
	get position(){ return this.widget.position; }
	
	set imageId(value) {
		this.widget.imageId = value;
		if(value != -1) this.checkLoad();
	}

	checkLoad() {
		let im = Rex.images[this.widget.imageId];
		if(im == null) {requestAnimationFrame(this.checkLoad.bind(this)); return;}
		if(im.image == null) {requestAnimationFrame(this.checkLoad.bind(this)); return;}
		this.htmlImage.style.backgroundImage = `url(${im.data})`;
		if(this.htmlImage.style.backgroundImage == null) {requestAnimationFrame(this.checkLoad.bind(this)); return;}
	}
	
	get imageId() { return this.widget.imageId; }
	
	controlIconName(stateIconName) {
		if(this.widget.iconName == stateIconName) return;
		this.widget.iconName = stateIconName;
		this.htmlImage.textContent = stateIconName;
	}

	set textAlign(value) {
		if(this.widget.textAlign == value) return;
		this.widget.textAlign = value;
		switch(value) { //justify-content: center;
			case 1:
				this.htmlImage.style.justifyContent = "flex-start";
				break;
			case 2:
				this.htmlImage.style.justifyContent = "center";
				break;
			case 3:
				this.htmlImage.style.justifyContent = "flex-end";
				break;
		}
	}
	
}


/**
 * WidgetList
 */

class WidgetListHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetList");
		
		this.containerElement = document.createElement("div");
		this.containerElement.classList.add("WidgetListContainer");
		this.htmlElement.appendChild(this.containerElement);
		
		this._currentItem = -1;
		this._selection = [];
		this.items = [];

		this._itemColor = null;
		this._selectedItemColor = null;
	}
	
	onSetState(state) {
		if(state.heightItem != null) this.updateHeightItems();
		if(state.children != null) this.updateChildren();
	}
	
	onMouseDown(x, y, e) {
		let childs = this.widget.children;
		for(let i = 0; i < childs.length; i++) {
			let child = Rex.widgets[childs[i]];
			if(!child) continue;
			if(child.view.hover) {
				this.widget.setCurrentItem(i);
				break;
			}
		}
		// if(e.which == 3) Rex.gui.popMenu(Rex.widgets[this.widget.layout.children[this.currentItem]].id, x, y);
	}
	
	checkSelect(event, parentId) {
		if(!this.selected) return super.checkSelect(event, parentId);
		return this.hover ? this.widget : undefined;
	}
	
	appendChild(htmlElement) {
		let item = document.createElement("div");
		item.classList.add("WidgetListItem");
		item.style.height = this.heightItem + "px";
		item.style.minHeight = this.heightItem + "px";
		if(this.items.length == this._currentItem)
			item.classList.add("WidgetListCurrentItem");
		item.appendChild(htmlElement);
		this.containerElement.appendChild(item);
		this.items.push(item);
	}
	
	set selection(value) {
		for(let index of this._selection) {
			let item = this.items[index];
			if(item == null) continue;
			item.classList.remove("WidgetListSelectedItem");
			item.style.backgroundColor = this._itemColor;
		}
		
		for(let index of value) {
			let item = this.items[index];
			if(item == null) continue;
			item.classList.add("WidgetListSelectedItem");
			item.style.backgroundColor = this._selectedItemColor;
		}
		
		this._selection = value;
	}
	
	set currentItem(value) {
		let oldItem = this.items[this._currentItem];
		if(oldItem != null) oldItem.classList.remove("WidgetListCurrentItem");
		
		let newItem = this.items[value];
		if(newItem != null) newItem.classList.add("WidgetListCurrentItem");
		
		this._currentItem = value;
	}
	
	get currentItem() {
		return this._currentItem;
	}

	set selectedItemColor(value) {

		if(this._selectedItemColor == value)
			return;

		let selection = this._selection;

		let items = this.items;

		for(let index of selection) {

			let item = items[index];

			if(item == null)
				continue;

			item.style.backgroundColor = value;
		}

		this._selectedItemColor = value;
	}

	get selectedItemColor() {
		return this._selectedItemColor;
	}

	set multiSelect(value) {

		if(this.widget.multiSelect == value)
			return;

		this.widget.multiSelect = value;
	}

	get multiSelect() {

		return this.widget.multiSelect;
	}
	
	updateHeightItems() {
		for(let item of this.items) {
			if(item == null) continue;
			item.style.height = this.heightItem + "px";
			item.style.minHeight = this.heightItem + "px";
		}
	}
	
	updateChildren() {
		for(let i = 0; i < this.items.length; ++i) {
			let item = this.items[i];
			if (item == null) continue;
			
			if(item.children.length > 0) {

				let ID = item.childNodes[0].id;
				try {
					if (ID.indexOf("w") === 0) {
						ID = ID.slice(1);
					}
				}catch(e) {}

				let findInt = (this.widget.children.indexOf(parseInt(ID)) == -1);
				let findString = (this.widget.children.indexOf(ID) == -1);
				if(findInt && findString) item.remove();
				else continue;
			} else item.remove();
		
			this.items.splice(i,1);
			--i;
		}
	}	
}

/**
 * Created by prg-15 on 05.01.2018.
 */
class WidgetPopUpMenuHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetPopUpMenu");
	}
	
	onSetState(state) {
		this.htmlElement.style.minWidth = "max-content";
		if(state.parentMenuId != null) this.widget.parentMenuId = state.parentMenuId;
		if(state.itemWidth != null) this.widget.itemWidth = state.itemWidth;
		if(state.itemHeight != null) this.widget.itemHeight = state.itemHeight;
		if(state.children !== undefined) {
			if(this.htmlElement.style.transform !== "translate(-100%,-100%)") {
				let w = false, h = false;
				let height = this.widget.children.length  * this.widget.itemHeight;
				if(height + this.widget.posY > window.innerHeight) h = true;
				if(this.widget.posX + this.htmlElement.offsetWidth > window.innerWidth) w = true;
				if(w && h) {
					this.htmlElement.style.transform = "translate(-100%,-100%)";
				} else {
					if(h) this.htmlElement.style.transform = "translateY(-100%)";
					if(w) this.htmlElement.style.transform = "translateX(-100%)";
				}
			}
		}
	}
	
	onInit() {
		this.width = undefined;
		this.height = undefined;
		this.order = 666;
	}
	
	pop(x, y) {
		this.widget.setPos(x, y);
		this.widget.setVisible(true);
	}
	
}

class WidgetMenuItemHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.addClassName("WidgetMenuItem");
		this.createDomElement("div");
	}
	
	set iconAlign (value){
		this.widget.iconAlign = value;
		if (this.widget.inited) {
			if (this.widget.iconAlign == 0) this.widget.icon.view.htmlElement.style.display = "none";
			if (this.widget.iconAlign == 3) this.widget.icon.view.htmlElement.style.order = 1;
			if (this.widget.iconAlign == 1 || this.widget.iconAlign == 3) {
				this.widget.icon.view.width = "22px";
				this.widget.icon.view.height = "100%";
				this.widget.icon.view.htmlElement.style.display = "block";
			}
			if(this.widget.iconAlign == 1) this.widget.icon.view.htmlElement.style.marginLeft = "-23px";
			
			if (this.widget.iconAlign == 2) {
				this.widget.label.view.htmlElement.style.display = "none";
				this.widget.icon.view.width = "100%";
				this.widget.icon.view.height = "100%";
			}
		}
	}
	
	onInit() {
		this.width = undefined;
		this.height = undefined;
		
		this.widget.icon.view.height = undefined;
		this.widget.icon.view.width = undefined;
		this.widget.label.view.width = undefined;
		this.widget.label.view.height = undefined;
		
		this.iconAlign = this.widget.iconAlign;
	}
	
	checkSelect() {
		return this.hover ? this.widget : undefined;
	}
	
}

class WidgetInvestmentMenuItemHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.addClassName("WidgetInvestmentMenuItem");
		this.createDomElement("div");
	}
	
	onSetState(state) {
		if(state.menuId != null) this.widget.menuId = state.menuId;
	}
	
	set iconAlign (value){
		this.widget.iconAlign = value;
		if (this.widget.inited) {
			if (this.widget.iconAlign == 0) this.widget.icon.view.htmlElement.style.display = "none";
			if (this.widget.iconAlign == 3) this.widget.icon.view.htmlElement.style.order = 1;
			if (this.widget.iconAlign == 1 || this.widget.iconAlign == 3) {
				this.widget.icon.view.width = "22px";
				this.widget.icon.view.height = "100%";
				this.widget.icon.view.htmlElement.style.display = "block";
			}
			if(this.widget.iconAlign == 1) this.widget.icon.view.htmlElement.style.marginLeft = "-23px";

			if (this.widget.iconAlign == 2) {
				this.widget.label.view.htmlElement.style.display = "none";
				this.widget.icon.view.width = "100%";
				this.widget.icon.view.height = "100%";
			}
		}
	}
	
	onInit() {
		this.width = undefined;
		this.height = undefined;
		
		this.widget.icon.view.height = undefined;
		this.widget.icon.view.width = undefined;
		this.widget.label.view.width = undefined;
		this.widget.label.view.height = undefined;
		
		this.iconAlign = this.widget.iconAlign;
		
		this.arrowElement = document.createElement("div");
		this.htmlElement.appendChild(this.arrowElement);
		this.arrowElement.className = "PopUpArrow";
		this.arrowElement.innerText = "keyboard_arrow_right";
		this.arrowElement.style.order = 9999;
		this.arrowElement.style.fontFamily = "Material Icons";
		this.arrowElement.style.position = "relative";
		this.arrowElement.style.right = "-22px";
		
	}
	
	checkSelect() {
		return this.hover ? this.widget : undefined;
	}
	
	setVisibleChild() {
		let parent = Rex.widgets[this.widget.parentId];
		if(parent === undefined) return;
		for(let i = 0; i < parent.children.length; ++i) {
			let child = Rex.widgets[parent.children[i]];
			if(child === undefined) continue;
			if(child.type == "WidgetInvestmentMenuItem") {
				let menu = Rex.widgets[child.menuId];
				if(menu !== undefined){
					menu.setVisible(false);
				}
			}
		}
	}
	
	onMouseUp(x, y, event) {
		if(this.widget.isHovered() && this.widget.menuId != -1) {
			this.widget.press = false;
			let menu = Rex.widgets[this.widget.menuId];
			if(menu === undefined) return;
			let parentMenu = Rex.widgets[this.widget.parentId];
			if(menu.visible === true) {
				menu.setVisible(false);
				return;
			}
			this.setVisibleChild();
			let h = menu.children.length * menu.itemHeight;
			let x = this.widget.aPosX + this.htmlElement.offsetWidth - 20;
			let y = this.widget.aPosY;
			if(this.widget.aPosX + this.htmlElement.offsetWidth + menu.view.htmlElement.offsetWidth > window.innerWidth)
				x = this.widget.aPosX - menu.view.htmlElement.offsetWidth;
			if(h + this.widget.aPosY > window.innerHeight)
				y = this.widget.aPosY - h + menu.itemHeight;
			menu.view.htmlElement.style.transform = "";
			menu.view.pop(x, y);
		}
	}
	
}

/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex*/

/**
 * WidgetSpinBox
 */

class WidgetSpinBoxHtml extends WidgetViewHtml {
	
	constructor(state) {
		super(state);
		this.createDomElement("div");
		this.addClassName("WidgetInput");
		
		this.headerElement = document.createElement("label");
		this.headerElement.classList.add("WidgetInputHeader");
		
		this.inputElement = document.createElement("input");
		this.inputElement.id = `${"input_" + this.widget.id}`;
		this.inputElement.type = "number";
		this.inputElement.required = true;
		this.inputElement.classList.add("WidgetInputText");
		
		this.spanElement = document.createElement("span");
		this.spanElement.classList.add("WidgetInputBar");
		
		this.htmlElement.appendChild(this.headerElement);
		this.htmlElement.appendChild(this.inputElement);
		this.htmlElement.appendChild(this.spanElement);
		
		this.inputElement.oninput = function (e) {
			
			if (isNaN(this.widget.value) && e.data === "-") {
				return;
			}

			if (e.data)
				this.checkSpinBoxValue(e.srcElement.value, false);
			else
				this.checkSpinBoxValue(e.srcElement.value, true);

		}.bind(this);
		
		this.timer;             //timer identifier
		this.timerTime = 1000;  //time in ms, 5 second for example

	}
	
	onSetState(state) {

		if(state.pressEnter != null)
			this.widget.pressEnter = state.pressEnter;
		
		if(state.textColor != null)
			this.controlTextColor();
		
		if(state.fontBold != null || state.fontItalic != null)
			this.controlFontStyle();

		if(state.minValue != null) 
			this.inputElement.min = this.minValue;
		
		if(state.maxValue != null) 
			this.inputElement.max = this.maxValue;
		
	}
	
	onInit() {
		this.step = this.widget.step;
		this.value = this.widget.value;
	}
	
	set step(value) {
		if(this.widget.step == value) return;
		this.widget.step = value;
		if(value == -1) delete this.inputElement.step;
		else this.inputElement.step = value;
	}
	
	get step() {return this.widget.step;}
	
	set value(val) {
		if(this.widget.value == val) return;
		this.widget.value = val;
		this.inputElement.value = this.widget.value;
	}
	
	set header(value) {
		let oldh = this.widget.header;
		let nHeader = "";
		try {nHeader = decodeURIComponent(escape(window.atob(value)));}
		catch(e) {console.error(this.widget.type, "setState->", "Header DecodeError!")}
		if(oldh != nHeader) {
			this.widget.header = nHeader;
			this.headerElement.innerText = nHeader;
		}
	}
	
	get header() {
		return this.widget.header;
	}
	
	controlTextColor() {
		this.inputElement.style.color = this.textColor;
		this.headerElement.style.color = this.textColor;
		this.headerElement.style.filter = "brightness(50%)";
		
		this.spanElement.style.setProperty("--main-color", this.textColor);
	}
	
	controlFontStyle() {
		let italic = "";
		if(this.fontItalic) italic = "italic";
		this.inputElement.style.fontStyle = italic;
		this.headerElement.style.fontStyle = italic;
		
		let bold = "";
		if(this.fontBold) bold = "bold";
		this.inputElement.style.fontWeight = bold;
		this.headerElement.style.fontWeight = bold;
	}
	
	checkSpinBoxValue(val, send) {
		
		let value =  this.widget.value;		// Старое значение
		let source = "" + val;	// Новое значение
		
		// Не число
		if(isNaN(source)) {
			this.htmlElement.value = value;
			return;
		}
		
		// Не валидная запятая
		if(source.indexOf(",") != -1) source.replace(",",".");
		
		// Валидный дабл
		source = parseFloat(source);
		
		// Нет чисел после запятой
		if(this.nodp == 0) {
			value = parseInt(source);
		} else {
			if(this.nodp != -1) value = source.toFixed(this.nodp);
			else value = source;
		}
		
		// MIN MAX
		if(value > this.maxValue) return;
		else if(value < this.minValue) return;
		
		clearTimeout(this.timer);
		this.widget.str = value;
		this.widget._text = value;
		this.inputElement.value = value;
		this.widget.value = value;

		if (send)
			this.sendValue();
		else
			this.timer = setTimeout(this.sendValue.bind(this), this.timerTime);

	}
	
	sendValue() {
		this.timer = -1;
		Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "setValueJS", [parseFloat(this.widget._text)]);
	}

	onDestroy() {
		if(this.timer !== -1)
			this.sendValue();
	}

	
}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global Widget WidgetViewHtml Rex*/

/**
 * Created by on 09.01.2018.
 */
class WidgetDialogHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetDialog");
		
		this.dialogContent = document.createElement("div");
		this.dialogContent.classList.add("WidgetDialogContent");
		this.htmlElement.appendChild(this.dialogContent);
		
		this.headerElement = document.createElement("div");
		this.headerElement.classList.add("WidgetDialogHeader");
		this.dialogContent.appendChild(this.headerElement);
		
		this.dialogContentContainer = document.createElement("div");
		this.dialogContentContainer.classList.add("WidgetDialogContentContainer");
		this.dialogContent.appendChild(this.dialogContentContainer);
		
		this.buttonsContainer = document.createElement("div");
		this.buttonsContainer.classList.add("WidgetDialogButtonsContainer");
		this.dialogContent.appendChild(this.buttonsContainer);

		Rex.gui.hoveredWidget = undefined;
	}
	
	onSetState(state) {
		if(state.width != null) this.dialogContent.style.width = state.width + "px";
		if(state.height != null) this.dialogContent.style.height = this.updateHeight();
		// if(state.minWidth != null) this.dialogContent.style.minWidth = state.minWidth + "px";
		// if(state.minHeight != null) this.dialogContent.style.minHeight = state.minHeight + "px";
		// if(state.maxWidth != null) this.dialogContent.style.maxWidth = state.maxWidth + "px";
		// if(state.maxHeight != null) this.dialogContent.style.maxHeight = state.maxHeight + "px";
		
		if(state.header != null) this.controlHeader(state.header);
		
		if(state.buttonNames != null) this.updateButtons();
		
	}
	
	appendChild(child) {
		if(!this.contains(child)) {
			this.dialogContentContainer.appendChild(child);
		}
	}
	
	controlHeader(stateHeader) {
		let newText = "";
		try { newText = decodeURIComponent(escape(window.atob(stateHeader)));
		} catch(e) { console.log(this.widget.type, " -> setState-> \"header\" DecodeError!"); return;}
		
		if(this.widget.header === newText) return;
		this.widget.header = newText;
		this.headerElement.innerText = newText;
		
		this.updateHeight();
	}
	
	updateButtons() {
		for(let i = 0; i < this.buttonsContainer.childNodes.length; ++i) {
			let btn = this.buttonsContainer.childNodes[i];
			if(btn == null) continue;
			btn.remove();
			i--;
		}
		
		for(let k of this.buttonNames) {
			let btnText = k;
			try {
				btnText = decodeURIComponent(escape(window.atob(k)));
			} catch(e) {
				console.error("Fail decode DialogBtnName ->", e);
			}
			
			let elem = document.createElement("div");
			elem.className = "WidgetDialogButton";
			elem.title = btnText;
			elem.innerText = btnText;
			this.buttonsContainer.appendChild(elem);
		}
		
		this.updateHeight();
		
	}
	
	
	onMouseUp(x, y, event) {
		if(event.target.className == "WidgetDialogButton") {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "onPressButton", [event.target.title]);
		}
	}
	
	
	updateHeight() {
		this.dialogContent.style.height = this.widget.height + "px";
		let h1 = this.headerElement.offsetHeight;
		let h2 = this.buttonsContainer.offsetHeight;
		this.dialogContentContainer.style.height = "calc(100% - " + (h1+h2) + "px)"
		
	}
}


class WidgetHelperHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetHelper");

		this.buttons = [];

		this.helperContent = document.createElement("div");
		this.helperContent.classList.add("WidgetHelperContent");
		this.htmlElement.appendChild(this.helperContent);

		this.widgetHelperTextAndBtnContainer = null;
		this.textDiv = null;
		this.svg = null;
		this.targetWidgetHtml = null;
		this.padding = 5;
		
		this.resW = null;
		this.resH = null;
	}

	addElement(type, className, parentElement) {
		let element = document.createElement(type);
		element.classList.add(className);
		parentElement.appendChild(element);
		return element;
	}

	decodeText(text) {
		let decodeText = "";
		try {
			decodeText = decodeURIComponent(escape(window.atob(text)));
		}
		catch (e) {
			console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
			decodeText = "Error";
		}
		return decodeText;
	}

	onSetState(state) {
		if (state.text != null) this.controlText(state.text);
		if (state.widgetId != null) {
			this.widget.widgetId = state.widgetId;
			this.createView();
		}
		if (state.buttons != null) {
			this.updateButtons();
			this.createArrowSvg();
		}
		if (state.posX != null) {
			this.posXH = state.posX;
		}
		if (state.posY != null) {
			this.posYH = state.posY;
		}
		if (state.width != null) {
			this.widthH = state.width;
		}
		if (state.height != null) {
			this.heightH = state.height;
		}
		if (state.minWidth != null) {
			this.minWidthH = state.minWidth;
		}
		if (state.minHeight != null) {
			this.minHeightH = state.minHeight;
		}
		if (state.maxWidth != null) {
			this.maxWidthH = state.maxWidth;
		}
		if (state.maxHeight != null) {
			this.maxHeightH = state.maxHeight;
		}
		if (state.blockPress != null) {
			this.widget.blockPress = state.blockPress;

			let targetDiv = document.getElementById(`${this.id}_targetDiv`);
			if (this.widget.blockPress) {
				if (targetDiv == null && this.targetWidgetHtml != null) {
					targetDiv = this.addElement("div", "WidgetHelperTargetDisableEvents", this.helperContent);
					targetDiv.id = `${this.id}_targetDiv`;
					let rect = this.targetWidgetHtml.getBoundingClientRect();
					targetDiv.style.width = rect.width + "px";
					targetDiv.style.height = rect.height + "px";
					targetDiv.style.top = rect.y + "px";
					targetDiv.style.left = rect.x + "px";
				}
			}
			else {
				if (targetDiv != null) {
					targetDiv.remove();
				}
			}
		}
		if (state.alignButton != null) {
			this.widget.alignButton = state.alignButton;
			this.updateButtons();
		}
	}

	controlText(stateHeader) {
		let newText = "";
		try {
			newText = decodeURIComponent(escape(window.atob(stateHeader)));
		} catch (e) { console.log(this.widget.type, " -> setState-> \"header\" DecodeError!"); return; }

		if (this.widget.text === newText) return;
		this.widget.text = newText;
		if (this.textDiv != null) this.textDiv.innerText = newText;
	}

	updateButtons() {
		if (this.buttonsContainer == null) return;
		for (let i = 0; i < this.buttonsContainer.childNodes.length; ++i) {
			let btn = this.buttonsContainer.childNodes[i];
			if (btn == null) continue;
			btn.remove();
			i--;
		}

		switch (this.widget.alignButton) {
			case 1:
				this.buttonsContainer.style.justifyContent = "flex-start";
				break;
			case 2:
				this.buttonsContainer.style.justifyContent = "center";
				break;
			case 3:
				this.buttonsContainer.style.justifyContent = "flex-end";
				break;
			default:
				this.buttonsContainer.style.justifyContent = "flex-end";
				break;
		}

		for (const btn of this.buttons) {
			let btnText = btn.name;
			try {
				btnText = decodeURIComponent(escape(window.atob(btn.name)));
			} catch (e) {
				console.error("Fail decode HelperBtnName ->", e);
			}

			const elem = document.createElement("div");
			elem.className = "WidgetHelperButton";
			elem.title = btnText;
			elem.innerText = btnText;
			if(!btn.show) 
				elem.style.display = "none";
			this.buttonsContainer.appendChild(elem);
		}

	}

	createView() {
		
		if (this.helperContent != null) {
			while (this.helperContent.childNodes.length)
				this.helperContent.removeChild(this.helperContent.firstChild);
			this.widgetHelperTextAndBtnContainer = null;
			this.textDiv = null;
			this.svg = null;
		}
		if (this.widget.widgetId == -1 || Rex.widgets == null) {
			this.widget.targetWidget = null;
			return;
		}
		if (this.widget.targetWidget == null || this.widget.targetWidget.id != this.widget.widgetId) {
			this.widget.targetWidget = Rex.widgets[this.widget.widgetId];
		}
		if (this.widget.targetWidget == null || this.widget.targetWidget.view == null || this.widget.targetWidget.view.htmlElement == null) return;
		this.targetWidgetHtml = this.widget.targetWidget.view.htmlElement;

		if (this.resizeEls !== this.targetWidgetHtml) {
			if (this.resizeObs) delete this.resizeObs;
			this.resizeObs = new ResizeObserver(this.createView.bind(this)).observe(this.htmlElement);
			this.resizeEls = this.targetWidgetHtml;
		}
		
		let rect = this.targetWidgetHtml.getBoundingClientRect();
		
		const rx = Math.round(rect.x);
		const ry = Math.round(rect.y);
		const rw = Math.round(rect.width);
		const rh = Math.round(rect.height);
		
		if (this.resW !== rw || this.resH !== rh) {
			setTimeout(this.createView.bind(this), 500);
		} 
		
		this.resW = rw;
		this.resH = rh;
		
		let topDiv = this.addElement("div", "WidgetHelperDisableEvents", this.helperContent);
		topDiv.style.height = ry + "px";

		let bottomDiv = this.addElement("div", "WidgetHelperDisableEvents", this.helperContent);
		bottomDiv.style.top = ry + rh + "px";

		let leftDiv = this.addElement("div", "WidgetHelperDisableEvents", this.helperContent);
		leftDiv.style.width = rx + "px";
		leftDiv.style.height = rh + "px";
		leftDiv.style.top = ry + "px";

		let rightDiv = this.addElement("div", "WidgetHelperDisableEvents", this.helperContent);
		
		const rdH = rh;
		const rdW = window.innerWidth - (rx + rw);
		rightDiv.style.width = rdW + "px";
		rightDiv.style.height = rh + "px";
		rightDiv.style.top = ry + "px";
		rightDiv.style.left = rx + rw + "px";

		if (this.widget.blockPress) {
			let targetDiv = this.addElement("div", "WidgetHelperTargetDisableEvents", this.helperContent);
			targetDiv.id = `${this.id}_targetDiv`;
			targetDiv.style.width = rw + "px";
			targetDiv.style.height = rdH + "px";
			targetDiv.style.top = ry + "px";
			targetDiv.style.left = rx + "px";
		}
		
		this.widgetHelperTextAndBtnContainer = this.addElement("div", "WidgetHelperTextAndBtnContainer", this.helperContent);
		this.posXH = this.posX;
		this.posYH = this.posY;
		this.widthH = this.width;
		this.heightH = this.height;
		this.minWidthH = this.minWidth;
		this.minHeightH = this.minHeight;
		this.maxHeightH = this.maxHeight;
		this.maxWidthH = this.maxWidth;

		this.textDiv = this.addElement("div", "WidgetHelperLabel", this.widgetHelperTextAndBtnContainer);
		this.textDiv.innerText = this.widget.text;

		this.buttonsContainer = this.addElement("div", "WidgetHelperButtonsContainer", this.widgetHelperTextAndBtnContainer);

		this.updateButtons();

		this.createArrowSvg();

	}

	createArrowSvg() {
		if (this.widgetHelperTextAndBtnContainer == null) return;
		if (this.svg != null)
			this.svg.remove();
		this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		this.svg.classList.add("WidgetHelperArrowSvg");
		this.helperContent.appendChild(this.svg);

		let svgNS = this.svg.namespaceURI;

		let arrowDefs = document.createElementNS(svgNS, "defs");
		this.svg.appendChild(arrowDefs);

		let mask1 = document.createElementNS(svgNS, "mask");
		mask1.id = "mask1";
		mask1.setAttribute("maskUnits", "userSpaceOnUse");
		arrowDefs.appendChild(mask1);

		let pathMask1 = document.createElementNS(svgNS, "path");
		pathMask1.setAttribute("fill", "none");
		pathMask1.setAttribute("stroke", "white");
		pathMask1.setAttribute("stroke-width", "4");
		pathMask1.setAttribute("stroke-dasharray", "200%");
		pathMask1.setAttribute("stroke-dashoffset", "200%");
		pathMask1.setAttribute("marker-end", "url(#arrowMarker)");
		mask1.appendChild(pathMask1);

		let animate = document.createElementNS(svgNS, "animate");
		animate.id = "animationLine";
		animate.setAttribute("attributeName", "stroke-dashoffset");
		animate.setAttribute("dur", "2s");
		animate.setAttribute("values", "200%;0");
		animate.setAttribute("begin", "0s");
		animate.setAttribute("fill", "freeze");
		pathMask1.appendChild(animate);

		let mask2 = document.createElementNS(svgNS, "mask");
		mask2.id = "mask2";
		mask2.setAttribute("maskUnits", "userSpaceOnUse");
		arrowDefs.appendChild(mask2);

		let pathMask2 = document.createElementNS(svgNS, "path");
		pathMask2.setAttribute("fill", "none");
		pathMask2.setAttribute("stroke", "white");
		pathMask2.setAttribute("stroke-width", "4");
		pathMask2.setAttribute("stroke-dasharray", "25");
		pathMask2.setAttribute("stroke-dashoffset", "25");
		mask2.appendChild(pathMask2);

		let animate2 = document.createElementNS(svgNS, "animate");
		animate2.id = "animationArrow";
		animate2.setAttribute("attributeName", "stroke-dashoffset");
		animate2.setAttribute("dur", "0.5s");
		animate2.setAttribute("values", "25;0");
		animate2.setAttribute("begin", "animationLine.end - 1s");
		animate2.setAttribute("fill", "freeze");
		pathMask2.appendChild(animate2);

		let arrowMarker = document.createElementNS(svgNS, "marker");
		arrowMarker.id = "arrowMarker";
		arrowMarker.setAttribute("viewbox", "0 0 15 15");
		arrowMarker.setAttribute("refX", "8");
		arrowMarker.setAttribute("refY", "7");
		arrowMarker.setAttribute("markerUnits", "strokeWidth");
		arrowMarker.setAttribute("orient", "auto");
		arrowMarker.setAttribute("markerWidth", "16");
		arrowMarker.setAttribute("markerHeight", "15");
		arrowMarker.setAttribute("stroke-dashoffset", "100%");
		arrowDefs.appendChild(arrowMarker);

		let pathArrow = document.createElementNS(svgNS, "path");
		pathArrow.classList.add("HelperArrowMarkerPath");
		let dArrow = "M0,0 c12,7 12,5 0,15";
		pathArrow.setAttribute("d", dArrow);
		pathArrow.setAttribute("mask", "url(#mask2)");
		pathMask2.setAttribute("d", dArrow);
		arrowMarker.appendChild(pathArrow);

		let pathLine = document.createElementNS(svgNS, "path");
		pathLine.classList.add("HelperArrowLine");
		pathLine.setAttribute("marker-end", "url(#arrowMarker)");
		pathLine.setAttribute("mask", "url(#mask1)");
		this.svg.appendChild(pathLine);

		let rectH = this.widgetHelperTextAndBtnContainer.getBoundingClientRect();

		let posHelper = {
			xStart: this.widget.posX,
			yStart: this.widget.posY,
			xCenter: rectH.x + (rectH.width / 2),
			yCenter: rectH.y + (rectH.height / 2),
			xEnd: this.widget.posX + rectH.width,
			yEnd: this.widget.posY + rectH.height
		};

		let rectTW = this.targetWidgetHtml.getBoundingClientRect();

		let posTargetWidget = {
			xStart: rectTW.x,
			yStart: rectTW.y,
			xCenter: rectTW.x + (rectTW.width / 2),
			yCenter: rectTW.y + (rectTW.height / 2),
			xEnd: rectTW.x + rectTW.width,
			yEnd: rectTW.y + rectTW.height
		};

		let dLine = "";

		//center
		if (posHelper.xCenter >= posTargetWidget.xStart && posHelper.xCenter <= posTargetWidget.xEnd) {
			//down
			if (posHelper.yCenter > posTargetWidget.yEnd) {
				dLine = this.drawArrowDownCenter(dLine, posHelper, posTargetWidget);
			}
			//center
			else if (posHelper.yCenter <= posTargetWidget.yEnd && posHelper.yCenter >= posTargetWidget.yStart) {
				dLine = this.drawArrowCenterCenter(dLine, posHelper, posTargetWidget);
			}
			//up
			else if (posHelper.yCenter < posTargetWidget.yStart) {
				dLine = this.drawArrowUpCenter(dLine, posHelper, posTargetWidget);
			}
		}
		//right
		else if (posHelper.xCenter > posTargetWidget.xEnd) {
			//down
			if (posHelper.yCenter > posTargetWidget.yEnd) {
				dLine = this.drawArrowDownRight(dLine, posHelper, posTargetWidget);
			}
			//center
			else if (posHelper.yCenter <= posTargetWidget.yEnd && posHelper.yCenter >= posTargetWidget.yStart) {
				dLine = this.drawArrowCenterRight(dLine, posHelper, posTargetWidget, arrowMarker);
			}
			//up
			else if (posHelper.yCenter < posTargetWidget.yStart) {
				dLine = this.drawArrowUpRight(dLine, posHelper, posTargetWidget);
			}
		}
		//left
		else if (posHelper.xCenter < posTargetWidget.xStart) {
			//down
			if (posHelper.yCenter > posTargetWidget.yEnd) {
				dLine = this.drawArrowDownLeft(dLine, posHelper, posTargetWidget);
			}
			//center
			else if (posHelper.yCenter <= posTargetWidget.yEnd && posHelper.yCenter >= posTargetWidget.yStart) {
				dLine = this.drawArrowCenterLeft(dLine, posHelper, posTargetWidget, arrowMarker);
			}
			//up
			else if (posHelper.yCenter < posTargetWidget.yStart) {
				dLine = this.drawArrowUpLeft(dLine, posHelper, posTargetWidget);
			}
		}

		pathMask1.setAttribute("d", dLine);
		pathLine.setAttribute("d", dLine);
	}

	drawArrowUpRight(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xStart - this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;
		dLine += " ";
		dLine += posHelper.xStart - 2 * this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;
		dLine += " Q";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posHelper.yCenter;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yStart - this.padding;
		return dLine;
	}

	drawArrowCenterRight(dLine, posHelper, posTargetWidget, arrowMarker) {
		dLine = "M";
		if (Math.abs(posHelper.yCenter - posTargetWidget.yCenter) < 70) {
			dLine += posHelper.xStart - this.padding;
			dLine += ",";
			dLine += posHelper.yCenter;

			dLine += " ";
			dLine += posHelper.xStart - 2 * this.padding;
			dLine += ",";
			dLine += posHelper.yCenter;

			dLine += " Q";
			dLine += posHelper.xStart - this.padding;
			dLine += ",";
		}
		else {
			dLine += posHelper.xCenter;
			dLine += ",";
			dLine += posHelper.yCenter < posTargetWidget.yCenter ? posHelper.yEnd + this.padding : posHelper.yStart - this.padding;

			dLine += " ";
			dLine += posHelper.xCenter;
			dLine += ",";
			dLine += posHelper.yCenter < posTargetWidget.yCenter ? posHelper.yEnd + 2 * this.padding : posHelper.yStart - 2 * this.padding;


			dLine += " Q";
			dLine += posHelper.xCenter;
			dLine += ",";
		}
		
		dLine += posTargetWidget.yCenter;
		dLine += " ";
		dLine += posTargetWidget.xEnd + this.padding;
		dLine += ",";
		dLine += posTargetWidget.yCenter;

		if (posHelper.yStart > posTargetWidget.yStart && posHelper.yEnd < posTargetWidget.yEnd)
			arrowMarker.setAttribute("orient", "auto");
		else arrowMarker.setAttribute("orient", "180");
		return dLine;
	}

	drawArrowDownRight(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xStart - this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;

		dLine += " ";
		dLine += posHelper.xStart - 2 * this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;

		dLine += " Q";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posHelper.yCenter;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yEnd + this.padding;
		return dLine;
	}

	drawArrowCenterLeft(dLine, posHelper, posTargetWidget, arrowMarker) {
		dLine = "M";
		if (Math.abs(posHelper.yCenter - posTargetWidget.yCenter) < 70) {
			dLine += posHelper.xEnd + this.padding;
			dLine += ",";
			dLine += posHelper.yCenter;

			dLine += " ";
			dLine += posHelper.xEnd + 2 * this.padding;
			dLine += ",";
			dLine += posHelper.yCenter;

			dLine += " Q";
			dLine += posHelper.xEnd + this.padding;
			dLine += ",";
		}
		else {
			dLine += posHelper.xCenter;
			dLine += ",";
			dLine += posHelper.yCenter < posTargetWidget.yCenter ? posHelper.yEnd + this.padding : posHelper.yStart - this.padding;

			dLine += " ";
			dLine += posHelper.xCenter;
			dLine += ",";
			dLine += posHelper.yCenter < posTargetWidget.yCenter ? posHelper.yEnd + 2 * this.padding : posHelper.yStart -  2 * this.padding;

			dLine += " Q";
			dLine += posHelper.xCenter;
			dLine += ",";
		}

		dLine += posTargetWidget.yCenter;
		dLine += " ";
		dLine += posTargetWidget.xStart - this.padding;
		dLine += ",";
		dLine += posTargetWidget.yCenter;

		if (posHelper.yStart > posTargetWidget.yStart && posHelper.yEnd < posTargetWidget.yEnd)
			arrowMarker.setAttribute("orient", "auto");
		else arrowMarker.setAttribute("orient", "0");
		return dLine;
	}

	drawArrowDownLeft(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xEnd + this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;

		dLine += " ";
		dLine += posHelper.xEnd + 2 * this.padding;
		dLine += ",";
		dLine += posHelper.yCenter;

		dLine += " Q";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posHelper.yCenter;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yEnd + this.padding;
		return dLine;
	}

	drawArrowUpLeft(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yEnd + this.padding;

		dLine += " ";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yEnd + 2 * this.padding;

		dLine += " Q";
		dLine += posTargetWidget.xStart - this.padding;
		dLine += ",";
		dLine += posHelper.yEnd + 2 * this.padding;
		dLine += " ";
		dLine += posTargetWidget.xStart - this.padding;
		dLine += ",";
		dLine += posTargetWidget.yCenter;
		return dLine;
	}

	drawArrowDownCenter(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yStart - this.padding;

		dLine += " ";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yStart - 2 * this.padding;

		dLine += " Q";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posHelper.yStart - this.padding;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yEnd + this.padding;
		return dLine;
	}

	drawArrowUpCenter(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yEnd + this.padding;

		dLine += " ";
		dLine += posHelper.xCenter;
		dLine += ",";
		dLine += posHelper.yEnd + 2 * this.padding;

		dLine += " Q";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posHelper.yEnd + this.padding;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yStart - this.padding;
		return dLine;
	}

	drawArrowCenterCenter(dLine, posHelper, posTargetWidget) {
		dLine = "M";
		dLine += posHelper.xEnd + this.padding;
		dLine += ",";
		dLine += posHelper.yEnd + this.padding;

		dLine += " ";
		dLine += posHelper.xEnd + 2 * this.padding;
		dLine += ",";
		dLine += posHelper.yEnd + 2 * this.padding;

		dLine += " Q";
		dLine += posHelper.xEnd + 25;
		dLine += ",";
		dLine += posHelper.yEnd + 25;
		dLine += " ";
		dLine += posTargetWidget.xCenter;
		dLine += ",";
		dLine += posTargetWidget.yEnd + this.padding;
		return dLine;
	}

	onMouseUp(x, y, event) {
		if (event.target.className == "WidgetHelperButton") {
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "onPressButton", [event.target.title]);
		}
	}

	changePosition() {
		if (this.widgetHelperTextAndBtnContainer == null) return;
		this.widgetHelperTextAndBtnContainer.style.top = this.widget.posY + "px";
		this.widgetHelperTextAndBtnContainer.style.left = this.widget.posX + "px";
		this.createArrowSvg();
	}

	set posXH(value) {
		this.widget.posX = value;
		this.changePosition();
	}

	set posYH(value) {
		this.widget.posY = value;
		this.changePosition();
	}

	set widthH(value) {
		if (this.widget.width == value) return;
		if (!isNaN(value)) {
			this.widget.width = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.width = value + "px";
		}
		else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.width = value;
		}
		this.createArrowSvg();
	}

	set heightH(value) {
		if (this.widget.height == value) return;
		if (!isNaN(value)) {
			this.widget.height = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.height = value + "px";
		} else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.height = value;
		}
		this.createArrowSvg();
	}

	set minWidthH(value) {
		if (!isNaN(value)) {
			this.widget.minWidth = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.minWidth = value + "px";
		} else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.minWidth = value;
		}
		this.createArrowSvg();
	}

	set minHeightH(value) {
		if (!isNaN(value)) {
			this.widget.minHeight = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.minHeight = value + "px";
		} else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.minHeight = value;
		}
		this.createArrowSvg();
	}

	set maxWidthH(value) {
		if (!isNaN(value)) {
			this.widget.maxWidth = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.maxWidth = value + "px";
		} else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.maxWidth = value;
		}
		this.createArrowSvg();
	}

	set maxHeightH(value) {
		if (!isNaN(value)) {
			this.widget.maxHeight = value;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.maxHeight = value + "px";
		} else {
			if (value === undefined) value = null;
			if (this.widgetHelperTextAndBtnContainer != null) this.widgetHelperTextAndBtnContainer.style.maxHeight = value;
		}
		this.createArrowSvg();
	}
}


/**
 * WidgetSpacer
 */
	
class WidgetSpacerHtml extends WidgetViewHtml {
	
	constructor(state) {
		super(state);
		this.createDomElement("div");
	}
	
	onSetState(state) {
		if(state.depress != null) this.widget.depress = state.depress;
		if(state.orientation != null) this.widget.orientation = state.orientation;
	}
	
}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global WidgetViewHtml Rex*/

/**
 * Created by ALLekSSSanDR on 09.01.2018.
 */

/**
 * WidgetConstructor
 */

class WidgetConstructorHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetConstructor");
		
		this.canvas = null;
		this.cloneElement = null;
		
		this.alignWidgets = true;
		this.errorWidgetsAlign = 10;
		this.backgroundColor = "rgb(250, 250, 250)";
		this.borderColor = "rgb(50, 50, 50)";
		this.gridAlign = true;
		this.gridSize = 10;
		this.gridStyle = 1;
		
		this.autoScroll = true;
		
		this.tempChilds = [];
		
		this.timer;
		this.timerInterval = 500;
		
	}
	
	onSetState(state) {
		if(state === undefined) return;
		
		// FOCUSED
		if(Rex.widgets != null) {
			if(state.focused != null) {
				if(!this.widget.isEditable()) return;
				this.widget.focusedWidget = (state.focused != -1) ? Rex.widgets[state.focused] : undefined;
				if(this.widget.focusedWidget != null) {
					this.widget.focusedWidgets = [];
					this.widget.focusedWidgets.push(this.widget.focusedWidget);
				} else {
					// Clear Focused Borders
					this.clearFocusHtml();
				}
				this.updateFocusedWidgets();
			}
		}
		
		// BACKGROUND
		if(state.backgroundColor != null) {
			this.htmlElement.style.backgroundColor = state.backgroundColor;
			if(state.backgroundColor != "") {
				let value = state.backgroundColor
				try{
					value = decodeURIComponent(escape(window.atob(value)));
				}catch(e) {
					// error
				}
				this.htmlElement.style.setProperty("--bgcolor", value);
			}
				
		}
		
		// BORDER
		if(state.borderColor != null) this.htmlElement.style.border = "1px solid " + state.borderColor;
		
		// EDITABLE
		if(state.editable != null) {
			if(!state.editable) {
				this.clearFocusHtml();
				this.clearHoveredHTML();
				clearTimeout(this.timer);
				if(this.htmlElement != null) this.htmlElement.classList.remove("Editable");
			} else {
				if(this.htmlElement != null) this.htmlElement.classList.add("Editable");
				this.timer = setTimeout(this.onUpdateFocused.bind(this), this.timerTime);
			}
		}
		
		// GRID SIZE
		if(state.gridSize != null) {
			this.htmlElement.style.setProperty("--grid-size",state.gridSize + "px");
		}
		
		// GRID STYLE
		if(state.gridStyle != null) {
			if((state.gridStyle == 0 || state.gridStyle == 1) && (this.widget.mouse != null && this.widget.mouse.leftButtonPressed == false))  this.removeGrid();
			else this.makeGrid();
		}
		
		// AUTO SCROLL
		if(state.autoScroll != null) {
			if(this.htmlElement != null) {
				if(state.autoScroll) this.htmlElement.style.overflow = "auto";
				else this.htmlElement.style.overflow = "hidden";
			}
		}
		
		// NEED SAVE SCREENSHOT
		if(state.screenShotRequest != null) {
			if(state.screenShotRequest) this.generateScreenShot();
		}
		
		// HOVERED WIDGET
		if(Rex.widgets != null) {
			if(state.hovered != null) {
				if(!this.widget.isEditable()) {
					this.clearFocusHtml();
					return;
				}
				this.widget.hoveredWidget = (state.hovered != -1) ? Rex.widgets[state.hovered] : undefined;
				if(this.widget.focusedWidgets == null) return;
				this.hoverHtml(state.hovered);
				if(this.widget.focusedWidgets.indexOf(this.widget.hoveredWidget) != -1) this.clearHoveredHTML();
			}
		}

		// CHILDRENS
		if(state.children != null && Rex.widgets != null) {

			let need = false;
			if(state.children.length == this.tempChilds.length) {
				for(let i = 0; i < state.children.length; ++i) {
					if(state.children[i] == this.tempChilds[i])
						continue;
					need = true;
					break;
				}
			} else {
				need = true;
			}

			if(need) {
				// remove
				for(let id of this.children) {
					let child = Rex.widgets[id];
					if(null == child) continue;
					this.htmlElement.removeChild(child.view.htmlElement);
				}

				// append
				for(let id of this.children) {
					let child = Rex.widgets[id];
					if(null == child) continue;
					this.htmlElement.appendChild(child.view.htmlElement);
				}
				this.tempChilds = state.children;
			}
		}
		
		this.widget.needUpdate = true;
	}
	
	checkSelect(event, parentId) {
		if(this.hover) {
			if(!this.widget.isEditable()) return super.checkSelect(event, parentId);
			return this.widget;
		}
		return undefined;
	}
	
	onInit() {
		
		if(this.gridStyle == 0 || this.gridStyle == 1) this.removeGrid();
		else this.makeGrid();
		
		this.htmlElement.style.backgroundColor = this.backgroundColor;
		this.htmlElement.style.border = "1px solid " + this.borderColor;
		
		if(this.editable)this.htmlElement.classList.add("Editable");
		
		this.htmlElement.style.setProperty("--grid-size", this.gridSize + "px");
		
		this.updateFocusedWidgets();
	}
	
	// Обновление графической составляющей HTML
	updateFocusedWidgets() {
		if(!this.widget.isEditable()) return;
		
		// Очистка рамок при началае обновления
		let borders = document.getElementsByClassName("ConstructorFocusWidget");
		if(borders != undefined) {
			for(let key of borders) {
				if(key == undefined) continue;
				if(key.id.indexOf("Border" + (this.widget.id)) != -1) {
					// this.htmlElement.removeChild(key);
					key.remove();
				}
			}
		}
		
		if(this.widget.focusedWidgets)
			for(let i = 0; i < this.widget.focusedWidgets.length; ++i) {
				if(this.widget.focusedWidgets !== undefined && this.widget.focusedWidgets.length > 0) {
					let flag = false;
					if(this.widget.children.indexOf(this.widget.focusedWidgets[i].id) != -1) flag = true;
					let widget = Rex.widgets[this.widget.focusedWidgets[i].id];
				
					if(widget === undefined) continue;
					if(flag) {
					//Рамочка выделения виджета
						let pw = 8;
						let hpw = pw * 0.5;
						let t = 0;//widget.posY;
						let l = 0;//widget.posX;
						let w = widget.view.htmlElement.offsetWidth;
						let h = widget.view.htmlElement.offsetHeight;
						let pts = [
							// {TOP LEFT}
							[t - (pw/2), 			l - (pw/2), 			"XY"],	// LEFT TOP
							[t - (pw/2), 			l + (w * 0.5) - hpw, 	"T"],	// TOP
							[t - (pw/2), 			l + w - pw + (pw/2), 	"WY"],	// TOP RIGHT
							[t + (h * 0.5) - hpw, 	l - (pw/2), 			"L"],	// LEFT MIDDLE
							[t + (h * 0.5) - hpw, 	l + w - pw + (pw/2), 	"R"],	// RIGHT MIDDLE
							[t + h - pw + (pw/2), 	l - (pw/2), 			"XH"],	// LEFT
							[t + h - pw + (pw/2), 	l + (w * 0.5) - hpw, 	"B"],	// BOTTOM
							[t + h - pw + (pw/2), 	l + w - pw + (pw/2), 	"WH"]	// RIGHT
						];
						let borderChild = document.getElementById("Border" + (this.widget.id) + "For" + (widget.id));
						if(borderChild == undefined) {
							borderChild = document.createElement("div");
							borderChild.className = "ConstructorFocusWidget";
							borderChild.id = "Border" + (this.widget.id) + "For" + (widget.id);
							this.htmlElement.appendChild(borderChild);
							for(let i1 = 0; i1 < pts.length; ++i1) {
								let borderPoints = document.createElement("div");
								borderPoints.className = "BorderPoints";
								borderChild.appendChild(borderPoints);
							}
						}
						// borderChild.style.top = (widget.posY - 1) + "px";
						// borderChild.style.left = (widget.posX - 1) + "px";
						// borderChild.style.height = (widget.height) + "px";
						// borderChild.style.width = (widget.width) + "px";

						let node = widget.view.htmlElement;

						borderChild.style.top = (node.offsetTop - 1) + "px";
						borderChild.style.left = (node.offsetLeft - 1) + "px";
						borderChild.style.height = (node.offsetHeight + 3) + "px";
						borderChild.style.width = (node.offsetWidth + 3) + "px";
						this.focusedHtml = borderChild;

						for(let i1 = 0; i1 < borderChild.children.length; ++i1) {
							let point = borderChild.children[i1];
							point.style.top = (pts[i1][0]) + "px";
							point.style.left = (pts[i1][1]) + "px";
							point.classList.add(pts[i1][2]);
							point.style.width = (pw) + "px";
							point.style.height = (pw) + "px";
							point.style.cursor = "";
						}
					}
					else {
					
						let borders = document.getElementsByClassName("ConstructorFocusWidget");
						if(borders != undefined) {
							for(let key of borders) {
								if(key == undefined) continue;
								if(key.id.indexOf("Border" + (this.widget.id)) != -1) {
								// this.htmlElement.removeChild(key);
									key.remove();
								}
							}
						}
					
						// ФОКУСНЫЙ ВИДЖЕТ - не ГЛАВНЫЙ ЧИЛД (возможно чилд чилда)
						if(widget != null && widget.view != null) {
							//Рамочка выделения виджета
							let pw = 8;
							let hpw = pw * 0.5;

							let ClientRect = widget.view.htmlElement.getBoundingClientRect();
							let t = ClientRect.top - this.getAPosY();
							let l = ClientRect.left  - this.getAPosX();
							let w = widget.view.htmlElement.offsetWidth;
							let h = widget.view.htmlElement.offsetHeight;

							let borderChild = document.getElementById("Border" + (this.widget.id) + "For" + (widget.id));
							if(borderChild == undefined) {
								borderChild = document.createElement("div");
								borderChild.className = "ConstructorFocusWidget";
								borderChild.classList.add("NoChild");
								borderChild.id = "Border" + (this.widget.id) + "For" + (widget.id);
								this.focusedHtml = borderChild;
								this.htmlElement.appendChild(borderChild);
							}
							borderChild.style.top = (t - 1) + "px";
							borderChild.style.left = (l - 1) + "px";
							borderChild.style.height = (h) + "px";
							borderChild.style.width = (w) + "px";
						}
					}
				}
				else {
					let borders = document.getElementsByClassName("ConstructorFocusWidget");
					if(borders != undefined) {
						for(let key of borders) {
							if(key == undefined) continue;
							if(key.id.indexOf("Border" + (this.widget.id)) != -1) {
								// this.htmlElement.removeChild(key);
								key.remove();
							}
						}
					}
				}
			}
		
		// Область выделения
		if(this.widget.selectionArea != undefined) {
			if (this.widget.selectionArea.selectedArea != -1) {
				let st = Math.min(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2) - this.widget.aPosY;
				let sl = Math.min(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2) - this.widget.aPosX;
				let sw = Math.max(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2) - Math.min(this.widget.selectionArea.selectAreaX1, this.widget.selectionArea.selectAreaX2);
				let sh = Math.max(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2) - Math.min(this.widget.selectionArea.selectAreaY1, this.widget.selectionArea.selectAreaY2);
				let selection = document.getElementById("ConstructorSelection" + (this.widget.id));
				if(selection == undefined) {
					selection = document.createElement("div");
					selection.id = "ConstructorSelection" + (this.widget.id);
					selection.classList.add("ConstructorSelection");
					this.htmlElement.appendChild(selection);
				}
				selection.style.top = (st) + "px";
				selection.style.left = (sl) + "px";
				selection.style.width = (sw) + "px";
				selection.style.height = (sh) + "px";
			}
			else {
				let select = document.getElementById("ConstructorSelection" + (this.widget.id));
				if(select != undefined) {
					// this.htmlElement.removeChild(select);
					select.remove();
				}
			}
		}
	}
	
	clearFocusHtml() {
		let focused = document.getElementsByClassName("ConstructorFocusWidget");
		if(focused != undefined) {
			for(let i = 0; i < focused.length; ++i) {
				let node = focused[i];
				if(node == undefined) continue;
				// this.htmlElement.removeChild(node);
				node.remove();
				--i;
			}
		}
		this.focusedHtml = null;
	}	
	
	hoverHtml(id) {
		// DELETE HOVER
		this.clearHoveredHTML();
		if(!this.widget.isEditable() || (this.widget.mouse == null || this.widget.mouse.leftButtonPressed)) return;
		
		// NEW HOVER
		let w = Rex.widgets[id];
		if(w != null && this.hoverHtmlElement == null) {
			this.hoverHtmlElement = document.createElement("div");
			this.hoverHtmlElement.classList.add("ConstructorHoveredWidget");
			this.hoverHtmlElement.id = "ConstructorHoveredWidget_" + w.id;
			// this.hoverHtmlElement.style.top = "" + w.posY + "px";
			// this.hoverHtmlElement.style.left = "" + w.posX + "px";
			// this.hoverHtmlElement.style.width = "" + w.width + "px";
			// this.hoverHtmlElement.style.height = "" + w.height + "px";
			
			this.hoverHtmlElement.style.top = "" + w.view.htmlElement.offsetTop + "px";
			this.hoverHtmlElement.style.left = "" + w.view.htmlElement.offsetLeft + "px";
			this.hoverHtmlElement.style.width = "" + w.view.htmlElement.offsetWidth + "px";
			this.hoverHtmlElement.style.height = "" + w.view.htmlElement.offsetHeight + "px";

			this.hoverHtmlElement.title = w.type + " : " + w.name;
			this.htmlElement.appendChild(this.hoverHtmlElement);
		}
	}
	
	clearHoveredHTML() {
		let hovered = document.getElementsByClassName("ConstructorHoveredWidget");
		if(hovered != undefined) {
			for(let i = 0; i < hovered.length; ++i) {
				let node = hovered[i];
				if(node == undefined) continue;
				// this.htmlElement.removeChild(node);
				node.remove();
				--i;
			}
		}
		this.hoverHtmlElement = null;
	}
	
	makeGrid() {
		this.htmlElement.classList.add("ConstructorGrid");
	}
	
	removeGrid() {
		this.htmlElement.classList.remove("ConstructorGrid");
	}
	
	// **********************************ALIGNMENT**********************************
	makeVerticalAlignment(align) {
		if(!this.widget.isEditable() || this.widget.mouse.rightButtonPressed) return;
		if(this.alignV != null) this.removeVerticalAlignment();
		let vertical = document.getElementById("ConstructorAlignmentV" + (this.widget.id));
		if(vertical == undefined) {
			vertical = document.createElement("div");
			vertical.id = "ConstructorAlignmentV" + (this.widget.id);
			vertical.classList.add("ConstructorAlignmentV");
			this.htmlElement.appendChild(vertical);
		}
		vertical.style.top = (Math.min(align.w2.posY, align.w1.posY)) + "px";
		vertical.style.left = (align.alignmentPos)  + "px";
		vertical.style.height = (Math.max(align.w2.posY + align.w2.height, align.w1.posY + align.w1.height) - Math.min(align.w2.posY, align.w1.posY)) + "px";
		
		this.alignV = vertical;
	}
	
	removeVerticalAlignment() {
		if(this.alignV == null) return;
		// this.htmlElement.removeChild(this.alignV);
		this.alignV.remove();
		this.alignV = null;
	}
	
	makeHorizontalAlignment(align) {
		if(!this.widget.isEditable() || this.widget.mouse.rightButtonPressed) return;
		if(this.alignH != null) this.removeHorizontalAlignment();
		let horizontal = document.getElementById("ConstructorAlignmentH" + (this.widget.id));
		if(horizontal == undefined) {
			horizontal = document.createElement("div");
			horizontal.id = "ConstructorAlignmentH" + (this.widget.id);
			horizontal.classList.add("ConstructorAlignmentH");
			this.htmlElement.appendChild(horizontal);
		}
		horizontal.style.top = (align.alignmentPos) + "px";
		horizontal.style.left = (Math.min(align.w2.posX, align.w1.posX)) + "px";
		horizontal.style.width = (Math.max(align.w2.posX + align.w2.width, align.w1.posX + align.w1.width) - Math.min(align.w2.posX, align.w1.posX)) + "px";
		
		this.alignH = horizontal;
	}
	
	removeHorizontalAlignment() {
		if(this.alignH == null) return;
		// this.htmlElement.removeChild(this.alignH);
		this.alignH.remove();
		this.alignH = null;
	}
	
	clearAlignment() {
		this.removeVerticalAlignment();
		this.removeHorizontalAlignment();
	}
	
	generateScreenShot() {
		// this.t = performance.now();
		
		// WidgetWindow
		let e = null;
		try {
			e = this.htmlElement.parentElement.parentElement.parentElement;
			(e == null) ? this.cloneElement = this.htmlElement.cloneNode(true) : this.cloneElement = e.cloneNode(true);
		} catch(e) { return; }
		
		this.cloneElement.style.top = window.outerHeight + 1000 + "px";
		this.cloneElement.style.left = window.outerWidth + 1000 + "px";
		this.cloneElement.style.zIndex = -1;
		this.htmlElement.appendChild(this.cloneElement);
		let w = parseInt(this.cloneElement.clientWidth);
		let h = parseInt(this.cloneElement.clientHeight);
		
		// CREATE CANVAS
		this.canvas = document.createElement("canvas");
		this.canvas.width = w;
		this.canvas.height = h;
		this.canvas.style.top = window.hei + "px";
		this.canvas.style.left = window.outerHeight + 1000 + "px";
		this.canvas.style.zIndex = "-1";
		this.htmlElement.appendChild(this.canvas);
		
		// CALCULATED CLONED CSS STYLES
		this.completedStyles(this.cloneElement);
		
		// GENERATE XML
		let htmlXml = this.generateXml(this.cloneElement.innerHTML);
		let data = "data:image/svg+xml;charset=utf-8,"+"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\""+ w +"px\" height=\""+ h +"px\"><foreignObject width=\""+ w +"px\" height=\""+ h +"px\">" + htmlXml + "</foreignObject></svg>";
		
		this.send = false;
		this.img = new Image();
		this.img.onload = this.onLoadImageSrc.bind(this);
		this.img.src = data;
		
		setTimeout(this.onLoadImageSrc.bind(this), 3000);
	}
	
	onLoadImageSrc() {
		if(this.send) return;
		
		let img = this.img;
		let w = img.width;
		let h = img.height;
		
		//let ctx = this.canvas.getContext('2d');
		//ctx.drawImage(img, 0, 0, w, h, 0, 0, w, h);
		let ctx = this.canvas.getContext("2d");
		try {
			ctx.drawImage(img, 0, 0, w, h, 0, 0, w, h);
			
		} catch (e) {
			console.error("Fail Generate ScreenShot!");
		}
		Rex.callRpcMethod("Widgets", this.id, this.type, "onLoadScreenShot", [this.canvas.toDataURL()]);
		
		// CLEAR DATA
		this.htmlElement.removeChild(this.canvas);
		this.htmlElement.removeChild(this.cloneElement);
		this.img = null;
		this.canvas = null;
		this.cloneElement = null;
		delete this.canvas;
		delete this.cloneElement;
		
		this.send = true;
		
		// console.log("Generate Screen Shot: " + (performance.now() - this.t1) + " milliseconds.");
	}
	
	generateXml(htmlText) {
		let doc = document.implementation.createHTMLDocument("");
		doc.write(htmlText);
		doc.documentElement.setAttribute("xmlns", doc.documentElement.namespaceURI);
		htmlText = (new XMLSerializer).serializeToString(doc.body);
		return htmlText;
	}
	
	getStyle(node, strCssRule){
		let oElm = node;
		let strValue = "";
		if(document.defaultView && document.defaultView.getComputedStyle){
			let v = document.defaultView.getComputedStyle(oElm, "");
			strValue = v[strCssRule];
			
			if(strValue == undefined) strValue = node.style[strCssRule];
		}
		else if(oElm.currentStyle){
			strCssRule = strCssRule.replace(/\-(\w)/g, function (strMatch, p1){ return p1.toUpperCase();});
			strValue = oElm.currentStyle[strCssRule];
		}
		return strValue;
	}
	
	completedStyles(node) {
		
		// 11319 msec.
		//if(window.getComputedStyle) cssMass = window.getComputedStyle(node);
		let cssStylesArray = ["position", "left", "top", "width", "height", "overflow", "-webkit-user-select", "-moz-user-select", "user-select", "-webkit-user-drag", "image-rendering", "-webkit-transform-origin", "display", "max-width", "-ms-touch-action", "touch-action", "filter", "visibility", "-moz-box-sizing", "box-sizing", "z-index", "behavior", "pointer-events", "right", "bottom", "float", "clear", "margin-top", "margin-bottom", "margin-left", "margin-right", "will-change", "opacity", "-webkit-transition", "-moz-transition", "-o-transition", "transition", "-ms-transform-origin", "transform-origin", "cursor", "background", "outline", "color", "border", "font", "box-shadow", "border-radius", "background-color", "border-bottom", "line-height", "text-align", "text-decoration", "background-position", "background-repeat", "border-top-left-radius", "border-top-right-radius", "border-bottom-left-radius", "border-bottom-right-radius", "text-indent", "font-size", "background-image", "background-size", "padding", "overflow-y", "padding-right", "border-top", "margin", "white-space", "background-clip", "-webkit-transform", "-moz-transform", "-ms-transform", "-o-transform", "transform", "font-weight", "zoom", "-ms-filter", "-ms-user-select", "content", "border-top-color", "border-bottom-color", "border-left-color", "border-right-color", "border-width", "justify-content", "align-items", "text-overflow", "padding-top", "padding-left", "flex-direction", "font-family", "font-style", "letter-spacing", "text-transform", "word-wrap", "direction", "padding-bottom", "min-width", "--combobox-height-items", "flex-grow", "--base-selected-color", "--baseA-selected-color", "--grid-color", "--grid-size", "animation", "border-left", "border-right", "fill", "--input-space", "flex", "--popup-item-height", "order", "-webkit-appearance", "appearance", "vertical-align", "--tab-height", "--tab-count-tabs", "--tab-current-tab", "--var-transform-left", "min-height", "-khtml-user-select", "-khtml-user-drag", "border-bottom-width", "border-bottom-style", "border-right-width", "border-right-style", "resize", "border-top-style", "border-top-width", "--border-window"];
		
		let style = "";
		for(let cssName of cssStylesArray) {
			
			// if(!isNaN(cssName)) continue;
			// if(cssName == "cssText") continue;
			// if(cssName == "length") continue;
			// if(cssName == "parentRule") continue;
			// if(cssName == "cssFloat") continue;
			// if(cssName == "item") continue;
			// if(cssName == "getPropertyValue") continue;
			// if(cssName == "getPropertyPriority") continue;
			// if(cssName == "setProperty") continue;
			// if(cssName == "removeProperty") continue;
			
			// let pre = node.style.cssName;
			let ggg = this.getStyle(node, cssName);
			
			if(ggg == null || ggg == "0px" || ggg == "auto" || ggg == "") continue;
			node.style.cssName = ggg;
			style += cssName + ":" + ggg + "; ";
			
			// let post = node.style.cssName;
			// console.log("NAME:", cssName, "PRE:", pre, "G:", ggg, "POST:",  post);
		}
		
		try {node.setAttribute("style", style);}catch(e){/**/}
		
		for(let childNode of node.childNodes) {
			if(childNode instanceof HTMLElement)
				this.completedStyles(childNode);
		}
		
	}
	
	onUpdateFocused() {
		if (!this.widget.isEditable()) 
			return;

		if (!this.focusedHtml) {
			this.timer = setTimeout(this.onUpdateFocused.bind(this), this.timerTime);
			return;
		}
		if (!this.widget.focusedWidget) {
			this.timer = setTimeout(this.onUpdateFocused.bind(this), this.timerTime);
			return;
		}
		
		const fch = this.widget.focusedWidget.view.htmlElement;
		if (this.focusedHtml.offsetHeight - 3 !== fch.offsetHeight || this.focusedHtml.offsetWidth - 3 !== fch.offsetWidth || 
			this.focusedHtml.offsetTop + 1 !== fch.offsetTop || this.focusedHtml.offsetLeft + 1 !== fch.offsetLeft) {
			this.updateFocusedWidgets();
		}

		this.timer = setTimeout(this.onUpdateFocused.bind(this), this.timerTime);

	}

}


/* eslint-disable no-unused-vars */
/* global WidgetViewHtml Rex*/

/**
 * Created by prg-15 on 10.01.2018.
 */
class WidgetCalendarHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("Calendar");
		
		this.calendarType = 1;	// Тип предназначения календаря (просто смотреть/ выбор даты / выбор периода / выбор недели)
		
		this.day = new Date().getDate();		// Установленный день
		this.month = new Date().getMonth() + 1;	// Установленный месяц
		this.year = new Date().getFullYear();	// Установленный год
		
		this.secondaryDay = this.day;		// Второй Установленный для диапазона день 
		this.secondaryMonth = this.month;	// Второй Установленный для диапазона месяц 
		this.secondaryYear = this.year;		// Второй Установленный для диапазона год
		
		this.todayDay = new Date().getDate();			// Текущий день на стороне клиента
		this.todayMonth = new Date().getMonth() + 1;	// Текущий месяц на стороне клиента
		this.todayYear = new Date().getFullYear();		// Текущий год на стороне клиента

		// Rex.callRpcMethod("Widgets", this.id, this.type, "setClientTime", [parseInt(this.todayDay), parseInt(this.todayMonth), parseInt(this.todayYear)]);
		//рпс не срабатывает потому что, в этот момент scene = undefined, пока унес в onInit
		
		this.viewMonth = this.month;	// Отображаемый месяц 
		this.viewYear = this.year;		// Отображаемый год 
		
		this.holidays = []; // Праздники
		this.events = [];	// Пользовательские события
		
		this.chooseYear = false;
	}
	
	onSetState(state) {
		if(state === undefined) return;
		
		if(state.holidays != null) {
			this.widget.holidays = state.holidays;
			this.updateCalendarGrid();
		}
		
		if(state.events != null) {
			this.widget.events = state.events;
			this.updateCalendarGrid();
		}
		
		if(state.calendarType != null) {
			this.updateCalendarGrid();
			this.updateCurrentDate();
		}
		
		if(state.events != null) {
			for(let i = 0; i < this.events.length; ++i) {
				let e = this.events[i];
				try {e.title = decodeURIComponent(escape(window.atob(e.title)));}
				catch(e) {}
			}
			this.widget.events = this.events;
		}
		
		
		if(state.holidays != null || state.events != null) this.updateCalendarGrid();
		
		if(state.day != null) {
			this.day = state.day;
			this.updateCurrentDate();
			this.updateCalendarGrid();
		}
		
		if(state.month != null) {
			this.month = state.month;
			this.viewMonth = state.month;
			this.updateCurrentDate();
			this.updateCurrentMoth();
			this.updateCalendarGrid();
		}
		
		if(state.year != null) {
			this.year = state.year;
			this.viewYear = state.year;
			this.updateCurrentYear();
			this.updateCurrentMoth();
			this.updateCurrentDate();
			this.updateCalendarGrid();
		}
		
		if(state.secondaryDay != null || state.secondaryMonth != null || state.secondaryYear != null) {
			this.updateCurrentDate();
			this.updateCalendarGrid();
			this.updateCurrentYear();
		}
	}
	
	
	onInit() {
		// HEADER
		this.htmlHeader = document.createElement("div");
		this.htmlHeader.className = "CalendarHeader";
		
		this.htmlCurrentYear = document.createElement("div");
		this.htmlCurrentYear.className = "CurrentYear";
		this.htmlCurrentYear.textContent = this.year;
		
		this.htmlCurrentDate = document.createElement("div");
		this.htmlCurrentDate.className = "CurrentDate";
		this.htmlCurrentDate.style.color = "#fff";
		this.updateCurrentDate();
		
		this.htmlHeader.appendChild(this.htmlCurrentYear);
		this.htmlHeader.appendChild(this.htmlCurrentDate);
		
		// DATA CONTENT
		this.htmlDateContent = document.createElement("div");
		this.htmlDateContent.className = "CalendarDateContent";
		
		// navigation month
		this.htmlMonthNavigator = document.createElement("div");
		this.htmlMonthNavigator.className = "MonthNavigator";
		
		this.htmlLeftNav = document.createElement("div");
		this.htmlLeftNav.className = "LeftNav";
		this.htmlLeftNav.textContent = "keyboard_arrow_left";
		
		this.htmlCurrentMonth = document.createElement("div");
		this.htmlCurrentMonth.className = "CurrentMonth";
		this.updateCurrentMoth();
		
		this.htmlRightNav = document.createElement("div");
		this.htmlRightNav.className = ("RightNav");
		this.htmlRightNav.textContent = "keyboard_arrow_right";
		
		// week
		this.htmlWeek = document.createElement("div");
		this.htmlWeek.className = "Week";
		
		for(let dayCode of this.widget.dayCode) {
			let d = document.createElement("div");
			d.textContent = dayCode;
			d.className = "WeekDay";
			this.htmlWeek.appendChild(d);
			
		}
		
		// calendar grid
		this.htmlCalendarGrid = document.createElement("div");
		this.htmlCalendarGrid.className = "CalendarGrid";
		this.updateCalendarGrid();
		
		this.htmlMonthNavigator.appendChild(this.htmlLeftNav);
		this.htmlMonthNavigator.appendChild(this.htmlCurrentMonth);
		this.htmlMonthNavigator.appendChild(this.htmlRightNav);
		this.htmlDateContent.appendChild(this.htmlMonthNavigator);
		this.htmlDateContent.appendChild(this.htmlWeek);
		this.htmlDateContent.appendChild(this.htmlCalendarGrid);
		
		// YEAR CONTENT
		this.htmlYearContent = document.createElement("div");
		this.htmlYearContent.className = "CalendarYearContent";
		
		this.htmlElement.appendChild(this.htmlHeader);
		this.htmlElement.appendChild(this.htmlDateContent);
		this.htmlElement.appendChild(this.htmlYearContent);
		
		Rex.callRpcMethod("Widgets", this.id, this.type, "setClientTime", [parseInt(this.todayDay), parseInt(this.todayMonth), parseInt(this.todayYear)]);
		
	}
	
	onMouseDown(event) {
		let pressElement = event.target;
		if(pressElement == null) return;
		
		if(pressElement.classList.contains("LeftNav")) {
			this.prevMonth();
			this.updateCurrentMoth();
			this.updateCalendarGrid();
		} else if(pressElement.classList.contains("RightNav")) {
			this.nextMonth();
			this.updateCurrentMoth();
			this.updateCalendarGrid();
		} else if(pressElement.classList.contains("CurrentYear")) {
			this.changeYear();
		} else if(pressElement.classList.contains("CurrentDate")) {
			this.changeDate();
		} else if(pressElement.classList.contains("Year")) {
			let y = pressElement.dataset.year;
			this.viewYear = parseInt(y);
			this.changeDate();
		}
		
		if(this.calendarType == 0) return;
		
		//Выбор числа
		if(this.calendarType == 1) {
			// Нажатие на день
			if(pressElement.classList.contains("Day")) {
				let d = pressElement.dataset.day;
				let m = pressElement.dataset.month;
				let y = pressElement.dataset.year;
				this.setDay(parseInt(d));
				this.setMonth(parseInt(m));
				this.setYear(parseInt(y));
			} else 
				return;
		}
		
		//Выбор второго значения для диапазона
		if(this.calendarType == 2) {
			if(pressElement.classList.contains("Day")) {
				let d = parseInt(pressElement.dataset.day);
				let m = parseInt(pressElement.dataset.month);
				let y = parseInt(pressElement.dataset.year);
				
				let date = new Date(y, m, d);
				let date1 = new Date(this.year, this.month, this.day);
				let date2 = new Date(this.secondaryYear, this.secondaryMonth, this.secondaryDay);
				
				if(event.button == 0) {
					if(date > date2) {
						this.setSecondaryDay((d));
						this.setSecondaryMonth((m));
						this.setSecondaryYear((y));
					} else {
						this.setDay((d));
						this.setMonth((m));
						this.setYear((y));
					}
				}
				
				if(event.button == 2) {
					if(date < date1) {
						this.setDay((d));
						this.setMonth((m));
						this.setYear((y));
					} else {
						this.setSecondaryDay((d));
						this.setSecondaryMonth((m));
						this.setSecondaryYear((y));
					}
				}
				
			}
		}
		
		// Выбор недели
		if(this.calendarType == 3) {
			if(pressElement.classList.contains("Day")) {
				let d = parseInt(pressElement.dataset.day);
				let m = parseInt(pressElement.dataset.month);
				let y = parseInt(pressElement.dataset.year);
				
				let date = new Date(y,m - 1,d);
				let date1 = new Date(date - (this.widget.getDayOfTheWeek(d, m, y) * 86400000));
				let date2 = new Date(date1 - 1 + (6 * 86400000) + 1);
				
				this.setDay(date1.getDate());
				this.setMonth(date1.getMonth() + 1);
				this.setYear(date1.getFullYear());
				
				this.setSecondaryDay(date2.getDate());
				this.setSecondaryMonth(date2.getMonth() + 1);
				this.setSecondaryYear(date2.getFullYear());
			}
		}
	}
	
	onMouseWheel(value) {
		//if(this.chooseYear) return;
		//if(value == 1) this.nextMonth();
		//else this.prevMonth();
		//this.updateCurrentMoth();
		//this.updateCalendarGrid();
	}
	
	setDay(value) {
		if(this.day == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setDay", [value]);
	}
	
	setMonth(value) {
		if(this.month == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setMonth", [value]);
	}
	
	setYear(value) {
		if(this.year == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setYear", [value]);
	}
	
	setSecondaryDay(value) {
		if(this.secondaryDay == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryDay", [value]);
	}
	setSecondaryMonth(value) {
		if(this.secondaryMonth == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryMonth", [value]);
	}
	setSecondaryYear(value) {
		if(this.secondaryYear == value) return;
		Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryYear", [value]);
	}
	
	updateCurrentDate() {
		if(this.htmlCurrentDate == null) return;
		
		// VIEW or SELECTION
		if(this.calendarType == 0 || this.calendarType == 1)
			this.htmlCurrentDate.textContent = this.widget.dayCode[this.widget.getDayOfTheWeek(this.day, this.month, this.year)] + ", " + this.widget.monthCode[this.month - 1] + " " + this.day;
		
		// RANGE
		if(this.calendarType == 2) {
			let t = this.day + "." + this.month + "." + this.year % 1000 + " - " + this.secondaryDay + "." + this.secondaryMonth + "." + this.secondaryYear % 1000;
			this.htmlCurrentDate.textContent = t;
		}
		
		// WEEK
		if(this.calendarType == 3) {
			let w = this.widget.getNumberWeek(this.day, this.month, this.year);
			let text = this.day + "." + this.month + "." + this.year % 1000 + " - " + this.secondaryDay + "." + this.secondaryMonth + "." + this.secondaryYear % 1000;
			this.htmlCurrentDate.textContent = text;
		}
		
	}
	
	updateCurrentYear() {
		if(this.htmlCurrentYear == null) return;
		if(this.calendarType == 3) {
			this.htmlCurrentYear.textContent = "НЕДЕЛЯ " + this.widget.getNumberWeek(this.day, this.month, this.year);
			return;
		}
		this.htmlCurrentYear.textContent = this.viewYear;
	}
	
	updateCurrentMoth() {
		if(this.htmlDateContent == null) return;
		this.htmlCurrentMonth.textContent = this.widget.monthCode[this.viewMonth - 1] + " " + this.viewYear;
	}
	
	updateCalendarGrid() {
		if(this.htmlCalendarGrid == null) return;
		
		// Clear old data
		for(let i = 0; i < this.htmlCalendarGrid.childNodes.length; ++i){
			let nodeChild = this.htmlCalendarGrid.childNodes[i];
			this.htmlCalendarGrid.removeChild(nodeChild);
			--i;
		}
		
		let date = new Date(this.viewYear, this.viewMonth - 1, 1);
		
		let weekDay = this.widget.getDayOfTheWeek(1, this.viewMonth, this.viewYear);
		if(weekDay == 0) date = new Date(date - (7 * 86400000));
		else date = new Date(date - (weekDay * 86400000));
		
		for(let i = 0; i < 6; ++i) {
			
			let w = document.createElement("div");
			this.htmlCalendarGrid.appendChild(w);
			w.className = "Week";
			
			for(let j = 0; j < 7; ++j) {
				// ++indexDay;
				
				let d = document.createElement("div");
				w.appendChild(d);
				d.className = "Day";
				
				this.checkDayEvent(d, date.getDate(), date.getMonth() + 1, date.getFullYear());
				date = new Date((date - 1) + 86400001);
			}
		}
	}
	
	checkDayEvent(node, d, m, y) {
		if(node == null || d == null || m == null || y == null) return;
		node.textContent = d;
		node.dataset.day = d;
		node.dataset.month = m;
		node.dataset.year = y;
		
		let date = new Date(y, m - 1, d);
		let date1 = new Date(this.year, this.month - 1, this.day);
		let date2 = new Date(this.secondaryYear, this.secondaryMonth - 1, this.secondaryDay);
		
		let personEvent = this.widget.getPersonEvent(d, m, y);
		
		// ВОСКРЕСЕНЬЕ
		if(date.getDay() == 0) {
			node.style.color = "red";
		} 
		
		// СЕГОДНЯШНИЙ ДЕНЬ
		if((this.todayDay == d) && (this.todayMonth == m) && (this.todayYear == y)) {
			node.style.color = "#2bbbad";
		}
		
		// Выбранный день
		if((this.day == d) && (this.month == m) && (this.year == y)) {
			node.style.background = "#009688";
			node.style.color = "white";
		}
		
		// Выбранный период
		if(this.calendarType == 2 || this.calendarType == 3) {
			if(date1 <= date && date <= date2) {
				node.style.background = "#009688";
				node.style.color = "white";
			}
		}
		
		if(m != this.viewMonth) {
			node.style.color = "#a09595";
			if(date.getDay() == 0) node.style.color = "#f5a5a5";
		}
		
		// ПОЛЬЗОВАТЕЛЬСКИЙ ПРАЗДНИК
		if(this.widget.isHolidays(d, m, y)) {
			node.style.color = "red";
		}
		
		// ПОЛЬЗОВАТЕЛЬСКОЕ СОБЫТИЕ
		if(personEvent != null) {
			node.style.color = personEvent.color;
			node.title = personEvent.title;
		}
		
	}
	
	nextMonth() {
		++this.viewMonth;
		if(this.viewMonth > 12) {
			this.viewMonth = 1;
			++this.viewYear;
			if(this.htmlCurrentYear != null) this.htmlCurrentYear.textContent = this.viewYear;
			
		}
	}
	
	prevMonth() {
		--this.viewMonth;
		if(this.viewMonth < 1) {
			this.viewMonth = 12;
			--this.viewYear;
			if(this.htmlCurrentYear != null) this.htmlCurrentYear.textContent = this.viewYear;
		}
	}
	
	changeYear() {
		this.chooseYear = true;
		this.htmlYearContent.style.visibility = "visible";
		this.htmlYearContent.style.height = "";
		this.htmlCurrentYear.style.color = "#fff";
		
		this.htmlDateContent.style.visibility = "hidden";
		this.htmlDateContent.style.height = "0px";
		this.htmlCurrentDate.style.color = "";
		
		this.updateYears();
	}
	
	changeDate() {
		this.chooseYear = false;
		this.htmlYearContent.style.visibility = "hidden";
		this.htmlYearContent.style.height = "0px";
		this.htmlCurrentYear.style.color = "";
		
		this.htmlDateContent.style.visibility = "visible";
		this.htmlDateContent.style.height = "";
		this.htmlCurrentDate.style.color = "#fff";
		
		if(this.htmlCurrentYear != null) this.htmlCurrentYear.textContent = this.viewYear;
		this.updateCurrentMoth();
		this.updateCalendarGrid();
	}
	
	
	updateYears() {
		// Clear old data
		for(let i = 0; i < this.htmlYearContent.childNodes.length; ++i){
			let nodeChild = this.htmlYearContent.childNodes[i];
			this.htmlYearContent.removeChild(nodeChild);
			--i;
		}
		
		for(let i = this.year - 100; i < this.year + 100; ++i) {
			let year = document.createElement("div");
			this.htmlYearContent.appendChild(year);
			year.className = "Year";
			year.textContent = i;
			year.dataset.year = i;
			if(i == this.year) {
				year.style.color = "#009688";
				year.style.fontSize = "25px";
			}
			
		}
		
		this.htmlYearContent.scrollTop = this.htmlYearContent.scrollHeight / 2 - 120;
	}
}


/* eslint-disable no-unused-vars */
/* global WidgetViewHtml Rex*/

/**
 * Created by prg-15 on 11.02.2018.
 */
class WidgetTimeHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetTime");
		
		this.selectedType = 0;
		
		this.hours = new Date().getHours();				// Часы
		this.minutes = new Date().getMinutes();			// Минуты
		this.seconds = new Date().getSeconds();			// Секунды
		
		this.secondHours = new Date().getHours();		// 2 Часы
		this.secondMinutes = new Date().getMinutes();	// 2 Минуты
		this.secondSeconds = new Date().getSeconds();	// 2 Секунды
		
		this.chooseH = true;
		this.pm = false;
		
		this.hoursPositions = [];
		this.minutesPositions = [];
		this.htmlDigits = [];
		
		this.pressed = false;
		
		this.namespaceURL = decodeURIComponent(escape(window.atob("aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc=")));

		this.headerHeight = this.height / 4;
		this.dialDiameter = Math.min(this.width, this.height) * 0.75;
		
		// HEADER
		this.htmlHeader = document.createElement("div");
		this.htmlHeader.className = "TimeHeader";
		this.htmlHeader.style.height = (this.height / 4) + "px";
		this.htmlElement.appendChild(this.htmlHeader);
		
		// COUNT
		
		this.htmlCounter = document.createElement("div");
		this.htmlCounter.className = "TimeCounter";
		this.htmlHeader.appendChild(this.htmlCounter);
		
		// time
		this.htmlCurrentTime = document.createElement("div");
		this.htmlCurrentTime.className = "CurrentTime";
		
		this.htmlCurrentHours = document.createElement("div");
		this.htmlCurrentHours.className = "CurrentHours";
		this.htmlCurrentHours.classList.add("H");
		
		this.htmlCurrentPoint = document.createElement("div");
		this.htmlCurrentPoint.className = "TimePoints";
		this.htmlCurrentPoint.textContent = ":";
		
		this.htmlCurrentMinutes = document.createElement("div");
		this.htmlCurrentMinutes.className = "CurrentMinutes";
		this.htmlCurrentMinutes.classList.add("M");
		
		this.htmlCurrentTime.appendChild(this.htmlCurrentHours);
		this.htmlCurrentTime.appendChild(this.htmlCurrentPoint);
		this.htmlCurrentTime.appendChild(this.htmlCurrentMinutes);
		this.htmlHeader.appendChild(this.htmlCurrentTime);
		
		//format
		this.htmlCurrentFormat = document.createElement("div");
		this.htmlCurrentFormat.className = "CurrentFormat";
		
		this.htmlFormatAM = document.createElement("div");
		this.htmlFormatAM.className = "FormatAM";
		this.htmlFormatAM.textContent = "AM";
		
		this.htmlFormatPM = document.createElement("div");
		this.htmlFormatPM.className = "FormatPM";
		this.htmlFormatPM.textContent = "PM";
		
		this.htmlHeader.appendChild(this.htmlCurrentFormat);
		this.htmlCurrentFormat.appendChild(this.htmlFormatAM);
		this.htmlCurrentFormat.appendChild(this.htmlFormatPM);
		
		// CONTENT
		this.htmlTimeContent = document.createElement("div");
		this.htmlTimeContent.className = "TimeContent";
		this.htmlElement.appendChild(this.htmlTimeContent);

		this.chooseHours(this.chooseH);
		this.updateFormat(this.pm);

	}
	
	onSetState(state) {
		
		if(state.selectedType != null) {
			this.makeDial();
			this.updateTime();
		}
		
		if(state.hours != null) {
			this.widget.hours = state.hours;
			if(state.hours > 12) this.updateFormat(true);
			else this.updateFormat(false);
			
			this.updateTime();
			this.updateDial();
		}
		
		if(state.minutes != null) {
			this.widget.minutes = state.minutes;
			this.updateTime();
			this.updateDial();
		} 
				
		if(state.secondaryHours != null) {
			this.secondHours = state.secondaryHours;
			if(state.secondaryHours > 12) this.updateFormat(true);
			else this.updateFormat(false);
			this.updateTime();
			this.updateDial();
		}
		
		if(state.secondaryMinutes != null) {
			this.secondMinutes = state.secondaryMinutes;
			this.updateTime();
			this.updateDial();
		} 
		
		if(state.height != null || state.width != null) {
			this.htmlHeader.style.height = (this.height / 4) + "px";
			this.makeDial();
		}
	}
	
	onInit() {
		
		this.chooseHours(this.chooseH);
		this.updateFormat(this.pm);
		
		this.updateTime();
	}
	
	onMouseMove(event) {
		
	}
	
	onMouseUp(event) {
		this.pressed = false;
	}
	
	onMouseDown(event) {
		this.pressed = true;
		
		let pressElement = event.target;
		if(pressElement == null) return;
		
		this.updateDial();
		
		if(pressElement.classList.contains("CurrentHours")) {
			// Выбор часов
			this.chooseHours(true);
		} else if(pressElement.classList.contains("CurrentMinutes")) {
			// Выбор минут
			this.chooseHours(false)
		} else if(pressElement.classList.contains("FormatAM")) {
			// Выбор минут
			if(this.chooseH) this.updateFormat(false);
		} else if(pressElement.classList.contains("FormatPM")) {
			// Выбор минут
			if(this.chooseH) this.updateFormat(true);
		} else {
			
			if(event.button == 0) {
				if(pressElement.classList.contains("Digit")) {
					let value = parseInt(pressElement.dataset.value);
					if(this.chooseH) Rex.callRpcMethod("Widgets", this.id, this.type, "setHours", [value]);
					else Rex.callRpcMethod("Widgets", this.id, this.type, "setMinutes", [value]);
				}
			} else {
				if(pressElement.classList.contains("Digit")) {
					let value = parseInt(pressElement.dataset.value);
					if(this.chooseH) Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryHours", [value]); 
					else Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryMinutes", [value]);
					
				}
			}
				
			//	
			//	
			//
			// let x0 = this.getAPosX() + this.width / 2;
			// let y0 = this.getAPosY() + this.height * 0.25 + (this.height * 0.75 / 2) ;
			//
			// let x1 = 0;
			// let y1 = 1;
			//
			// let x2 = (event.x - x0);
			// let y2 = -(event.y - y0);
			//
			// console.log(x0,y0 ,x2,y2);
			//
			// let cosAB = (x1*x2 + y1*y2) / (Math.sqrt(x1*x1 + y1*y1) * Math.sqrt(x2*x2 + y2*y2));
			//
			//
			//
			// let index;
			//
			// console.log("angls",this.angels);
			// console.log("cosAB",cosAB);
			// console.log("arcos", cosAB * 180 / Math.PI);
			
		}
	}
	
	onMouseWheel(value) {
		if(value == 1) {
			this.addVal();
		} else {
			this.remVal();
		}
	}
	
	addVal() {
		if(this.chooseH) {
			if(this.pressed) {
				let v = this.secondHours + 1;
				if(v > 23) v = 0;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryHours", [v]);
			} else {
				let v = this.hours + 1;
				if(v > 23) v = 0;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setHours", [v]);
			}
		} else {
			if(this.pressed) {
				let v = this.secondMinutes + 1;
				if(v > 59) v = 0;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryMinutes", [v]);
			} else {
				let v = this.minutes + 1;
				if(v > 59) v = 0;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setMinutes", [v]);
			}
		}
	}
	
	remVal() {
		if(this.chooseH) {
			if(this.pressed) {
				let v = this.secondHours - 1;
				if(v < 0) v = 23;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryHours", [v]);
			} else {
				let v = this.hours - 1;
				if(v < 0) v = 23;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setHours", [v]);
			}
		} else {
			if(this.pressed) {
				let v = this.secondMinutes - 1;
				if(v < 0) v = 59;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setSecondaryMinutes", [v]);
			} else {
				let v = this.minutes - 1;
				if(v < 0) v = 59;
				Rex.callRpcMethod("Widgets", this.id, this.type, "setMinutes", [v]);
			}
		}
	}
	
	chooseHours(value) {
		this.chooseH = value;
		
		if(value) {
			this.htmlCurrentHours.style.color = "#fff";
			if(!this.selectedType == 1) this.htmlCurrentHours.style.textDecoration = "underline";
			this.htmlCurrentMinutes.style.color = "";
			this.htmlCurrentMinutes.style.textDecoration = "";
		} else {
			this.htmlCurrentHours.style.color = "";
			this.htmlCurrentHours.style.textDecoration = "";
			this.htmlCurrentMinutes.style.color = "#fff";
			if(!this.selectedType == 1) this.htmlCurrentMinutes.style.textDecoration = "underline";
		}
		this.makeDial();
	}

	updateFormat(value) {
		this.pm = value;
		
		if(this.htmlFormatAM == null) return;
		if(value) {
			this.htmlFormatAM.style.color = "";
			this.htmlFormatAM.style.textDecoration = "";
			this.htmlFormatPM.style.color = "#fff";
			if(!this.selectedType == 1) this.htmlFormatPM.style.textDecoration = "underline";
		} else {
			this.htmlFormatAM.style.color = "#fff";
			if(!this.selectedType == 1) this.htmlFormatAM.style.textDecoration = "underline";
			this.htmlFormatPM.style.color = "";
			this.htmlFormatPM.style.textDecoration = "";
		}
		this.updateDial();
	}
	
	
	updateTime() {
		if(this.htmlCurrentMinutes == null) return;
		if(this.selectedType == 0) {
			if(this.hours > 9) this.htmlCurrentHours.textContent = this.hours; else this.htmlCurrentHours.textContent = "0" + this.hours;
			if(this.minutes > 9) this.htmlCurrentMinutes.textContent = this.minutes; else this.htmlCurrentMinutes.textContent = "0" + this.minutes;
			this.htmlCurrentHours.style.width 	= "";
			this.htmlCurrentMinutes.style.width = "";
			this.htmlCurrentPoint.style.width 	= "";
			
			this.htmlCurrentHours.style.fontSize 	="";
			this.htmlCurrentMinutes.style.fontSize 	="";
			this.htmlCurrentPoint.style.fontSize 	="";
			
			this.htmlCurrentHours.style.lineHeight 		= "";
			this.htmlCurrentMinutes.style.lineHeight 	= "";
			this.htmlCurrentPoint.style.lineHeight 		= "";
			
			this.htmlCurrentPoint.textContent = ":";
			this.htmlCounter.style.visibility = "hidden";
			
			
		} else if(this.selectedType == 1) {
			
			let h = (this.hours > 9) ? this.hours : "0" + this.hours;
			let m = (this.minutes > 9) ? this.minutes : "0" + this.minutes;
			
			let h2 = (this.secondHours > 9) ? this.secondHours : "0" + this.secondHours;
			let m2 = (this.secondMinutes > 9) ? this.secondMinutes : "0" + this.secondMinutes;
			
			this.htmlCurrentHours.textContent = h + " " + h2;
			this.htmlCurrentMinutes.textContent = m + " " + m2;
			this.htmlCurrentHours.style.width 	= 50 + "px";
			this.htmlCurrentMinutes.style.width = 50 + "px";
			this.htmlCurrentPoint.style.width = 10 + "px";
			
			this.htmlCurrentHours.style.fontSize 	= 40 + "px";
			this.htmlCurrentMinutes.style.fontSize 	= 40 + "px";
			this.htmlCurrentPoint.style.fontSize 	= 30 + "px";
				
			this.htmlCurrentHours.style.lineHeight 		= 40 + "px";
			this.htmlCurrentMinutes.style.lineHeight 	= 40 + "px";
			this.htmlCurrentPoint.style.lineHeight 	= 40 + "px";
			
			this.htmlCurrentHours.style.textDecoration 		= "";
			this.htmlCurrentMinutes.style.textDecoration 	= "";
			
			this.htmlCurrentPoint.textContent = ": :";
			
			
			let getDate = (h, m) => new Date(0, 0,0, h, m);
			let different = (getDate(this.secondHours , this.secondMinutes) - getDate(this.hours , this.minutes));
			let differentRes, hours, minuts;
			if(different > 0) {
				differentRes = different;
				hours = Math.floor((differentRes % 86400000) / 3600000);
				minuts = Math.round(((differentRes % 86400000) % 3600000) / 60000);
			} else {
				differentRes = Math.abs((getDate(this.hours, this.minutes) - getDate(this.secondHours,this.secondMinutes)));
				hours = Math.floor(24 - (differentRes % 86400000) / 3600000);
				minuts = Math.round(60 - ((differentRes % 86400000) % 3600000) / 60000);
			}
			if(minuts == 60) minuts = "00";
			let result = hours + ":" + minuts;
			
			this.htmlCounter.textContent = result;
			this.htmlCounter.style.visibility = "visible";
		}
	}
	
	makeDial() {
		if(this.htmlTimeContent == null) return;
		
		// Clear old data
		this.htmlDigits = [];
		for(let i = 0; i < this.htmlTimeContent.childNodes.length; ++i){
			let nodeChild = this.htmlTimeContent.childNodes[i];
			this.htmlTimeContent.removeChild(nodeChild);
			--i;
		}
		
		let headerHeight = this.height / 4;
		let dialDiameter = Math.min(this.width, this.height) * 0.75;
		
		let dialCenterX = this.width / 2;
		let dialCenterY = (this.height * 0.75) / 2;
		
		let radiusDigit = dialDiameter / 10;
		
		this.hoursPositions = [];
		this.minutesPositions = [];
		
		// Координаты отрисовки часов
		for(let i = 0; i < 12; ++i) {
			this.hoursPositions.push([this.width / 2 +  (Math.cos((i * 30 - 60) * (Math.PI / 180))  *  ((dialDiameter / 2) * 0.8)),
				((this.height * 0.75) / 2) +  (Math.sin((i * 30 - 60) * (Math.PI / 180)) * ((dialDiameter / 2) * 0.8))]);
		}
		
		// Координаты отрисовки минут
		for(let i = 0; i < 60; ++i) {
			this.minutesPositions.push([(this.width / 2)  + (Math.cos((i * 6 - 84) * (Math.PI / 180)) * ((dialDiameter / 2) * 0.8)),
				((this.height * 0.75) / 2) + (Math.sin((i * 6 - 84) * (Math.PI / 180)) *((dialDiameter / 2) * 0.8))]);
		}
		
		this.htmlSVG = document.createElementNS(this.namespaceURL, "svg");
		this.htmlSVG.classList.add("TimeSVG");
		this.htmlSVG.style.height = this.height * 0.75;
		this.htmlTimeContent.appendChild(this.htmlSVG);
		
		//<!--DIAL-->
		this.htmlDial = document.createElementNS(this.namespaceURL, "circle");
		this.htmlDial.setAttribute("class", "Dial");
		this.htmlDial.setAttribute("cx", dialCenterX);
		this.htmlDial.setAttribute("cy", dialCenterY);
		this.htmlDial.setAttribute("r", dialDiameter / 2);
		this.htmlDial.setAttribute("stroke", "transparent");
		this.htmlDial.setAttribute("fill", "rgba(0, 0, 0, 0.07)");
		this.htmlDial.setAttribute("stroke-width", 2);
		this.htmlSVG.appendChild(this.htmlDial);
		
		this.htmlDialCenter = document.createElementNS(this.namespaceURL, "circle");
		this.htmlDialCenter.setAttribute("class", "DialCenter");
		this.htmlDialCenter.setAttribute("cx", dialCenterX);
		this.htmlDialCenter.setAttribute("cy", dialCenterY);
		this.htmlDialCenter.setAttribute("r", radiusDigit / 4);
		this.htmlDialCenter.setAttribute("stroke", "transparent");
		this.htmlDialCenter.setAttribute("fill", "#009688");
		this.htmlDialCenter.setAttribute("stroke-width", 2);
		this.htmlSVG.appendChild(this.htmlDialCenter);
		
		// SECONDARY TIME
		if(this.selectedType == 1) {
			this.htmlLine2 = document.createElementNS(this.namespaceURL, "path");
			this.htmlLine2.setAttribute("class", "DialLine");
			this.htmlLine2.setAttribute("fill", "transparent");
			this.htmlLine2.setAttribute("stroke-width", 3);
			this.htmlSVG.appendChild(this.htmlLine2);
			
			this.htmlDialValue2 = document.createElementNS(this.namespaceURL, "circle");
			this.htmlDialValue2.setAttribute("class", "DialCenter");
			this.htmlDialValue2.setAttribute("r", radiusDigit);
			this.htmlDialValue2.setAttribute("stroke", "transparent");
			this.htmlDialValue2.setAttribute("stroke-width", 2);
			this.htmlSVG.appendChild(this.htmlDialValue2);
		}
		
		this.htmlLine = document.createElementNS(this.namespaceURL, "path");
		this.htmlLine.setAttribute("class", "DialLine");
		this.htmlLine.setAttribute("fill", "transparent");
		this.htmlLine.setAttribute("stroke-width", 3);
		this.htmlSVG.appendChild(this.htmlLine);
		
		this.htmlDialValue = document.createElementNS(this.namespaceURL, "circle");
		this.htmlDialValue.setAttribute("class", "DialCenter");
		this.htmlDialValue.setAttribute("r", radiusDigit);
		this.htmlDialValue.setAttribute("stroke", "transparent");
		this.htmlDialValue.setAttribute("stroke-width", 2);
		this.htmlSVG.appendChild(this.htmlDialValue);
		
		if(this.chooseH) {
			for(let i = 0; i < 12; ++i) {
				let posx = this.hoursPositions[i][0] - radiusDigit ;
				let posy = this.hoursPositions[i][1] - radiusDigit  + headerHeight;
				
				let digit = document.createElement("div");
				this.htmlTimeContent.appendChild(digit);
				digit.className = "Digit";
				
				this.htmlDigits.push(digit);
				
				digit.style.left = posx + "px";
				digit.style.top =  posy + "px";
				digit.style.height = (radiusDigit * 2) + "px";
				digit.style.width =  (radiusDigit * 2) + "px";
				digit.style.lineHeight =  (radiusDigit * 2) + "px";
				
			}
		} else {
			for(let i = 0; i < 60; i+=5) {
				let posx = this.minutesPositions[59 - i][0] - radiusDigit / 2;
				let posy = this.minutesPositions[59 - i][1] - radiusDigit / 2 + headerHeight;
				
				let digit = document.createElement("div");
				this.htmlTimeContent.appendChild(digit);
				digit.className = "Digit";
				
				this.htmlDigits.push(digit);
				
				digit.style.left = posx + "px";
				digit.style.top =  posy + "px";
				digit.style.height = (radiusDigit ) + "px";
				digit.style.width =  (radiusDigit ) + "px";
				digit.style.lineHeight =  (radiusDigit) + "px";
			}
		}
		
		this.updateDial();
	}
	
	setDialStyle(node, value, hours) {
		
		node.style.backgroundColor = "transparent";
		
		if(hours) {
			if(value == this.hours || (value == this.secondHours && this.selectedType == 1)) {
				node.style.color = "#fff";
			} else {
				node.style.color = "";
			}
			
			if(this.selectedType == 1) {
				if(this.hours < this.secondHours && value > this.hours && value < this.secondHours) node.style.backgroundColor = "#65c7be";
				else if(this.hours > this.secondHours && (value > this.hours || value < this.secondHours)) node.style.backgroundColor = "#65c7be";
				
			} else {
				node.style.backgroundColor = "transparent";
			}
		} else {
			if(value == this.minutes || (value == this.secondMinutes && this.selectedType == 1)) {
				node.style.color = "#fff";
			} else {
				node.style.color = "";
			}
			
			
			if(this.selectedType == 1) {
				if(this.minutes < this.secondMinutes && value > this.minutes && value < this.secondMinutes) node.style.backgroundColor = "#65c7be";
				else if(this.minutes > this.secondMinutes && (value > this.minutes || value < this.secondMinutes)) node.style.backgroundColor = "#65c7be";
			} else {
				node.style.backgroundColor = "transparent";
			}
		}
		
		node.dataset.value = value;
		node.textContent = value;
	}
	
	
	updateDial() {
		if(this.htmlSVG == null) return;
		
		let dialCenterX = this.width / 2;
		let dialCenterY = (this.height * 0.75) / 2;
		
		// Отрисовка чисел
		if(this.chooseH) {
			for(let i = 0; i < 12; ++i) {
				let digit = this.htmlDigits[i];
				
				if(!this.pm) {
					this.setDialStyle(digit, (i+1), true);
				} else {
					let value = i + 13;
					value = (value != 24) ? value : "00";
					this.setDialStyle(digit, value, true);
					
				}
			}
		} else {
			for(let i = 11; i >= 0; --i) {
				let digit = this.htmlDigits[i];
				
				let value = (12 - i) * 5;
				value = (value != 60) ? value : 0;
				this.setDialStyle(digit, value, false);
				
			}
		}
		
		let index = 0;
		let index2 = 0;
		
		let x1 = 0;
		let y1 = 0;
		
		let x2 = 0;
		let y2 = 0;
		
		if(this.chooseH) {
			index = (this.hours - 1);
			if(index > 11) index -= 12;
			if(index < 0) index = 11;
			x1 = this.hoursPositions[index][0];
			y1 = this.hoursPositions[index][1];
			
			index2 = (this.secondHours - 1);
			if(index2 > 11) index2 -= 12;
			if(index2 < 0) index2 = 11;
			x2 = this.hoursPositions[index2][0];
			y2 = this.hoursPositions[index2][1];

		} else {
			index = (this.minutes);
			if(index - 1 < 0) index = 60;
			x1 = this.minutesPositions[index - 1][0];
			y1 = this.minutesPositions[index - 1][1];
			
			index2 = (this.secondMinutes);
			if(index2 - 1 < 0) index2 = 60;
			x2 = this.minutesPositions[index2 - 1][0];
			y2 = this.minutesPositions[index2 - 1][1];
		}
		
		let flag = true;
		let flag2 = true;
		if(this.chooseH) {
			if(this.pm && this.hours < 12) flag = false;
			if(!this.pm && this.hours > 12) flag = false;
			if(this.pm && this.secondHours < 12) flag2 = false;
			if(!this.pm && this.secondHours > 12) flag2 = false;
		}
		
		if(flag) {
			let d = ("M " + dialCenterX + " " +  dialCenterY + " " + x1 + " " + y1);
			this.htmlLine.setAttribute("d", d);
			
			this.htmlDialValue.setAttribute("cx", x1);
			this.htmlDialValue.setAttribute("cy", y1);
			
			let r =  Math.min(this.width, this.height) * 0.75 / 12;
			if(!this.chooseH) {
				if((this.minutes % 5) == 0) this.htmlDialValue.setAttribute("r",  r);
				else this.htmlDialValue.setAttribute("r",  r / 3);
			} else {
				this.htmlDialValue.setAttribute("r",  r);
			}
			this.htmlDialValue.setAttribute("fill", "#009688");
			this.htmlLine.setAttribute("stroke", "#009688");
		} else {
			this.htmlDialValue.setAttribute("fill", "transparent");
			this.htmlLine.setAttribute("stroke", "transparent");
		}
		
		
		if(this.selectedType == 1 && flag2 && this.htmlLine2 != null) {
			let d = ("M " + dialCenterX + " " + dialCenterY + " " + x2 + " " + y2);
			this.htmlLine2.setAttribute("d", d);
			this.htmlDialValue2.setAttribute("cx", x2);
			this.htmlDialValue2.setAttribute("cy", y2);
			
			let r = Math.min(this.width, this.height) * 0.75 / 14;
			if(!this.chooseH) {
				if((this.secondMinutes % 5) == 0) this.htmlDialValue2.setAttribute("r", r);
				else this.htmlDialValue2.setAttribute("r", r / 4);
			} else {
				this.htmlDialValue2.setAttribute("r", r);
			}
			this.htmlDialValue2.setAttribute("fill", "#eaa1a1");
			this.htmlLine2.setAttribute("stroke", "#eaa1a1");
			
			if(this.chooseH) {
				if(this.hours == this.secondHours) this.htmlDialValue.setAttribute("stroke", "#eaa1a1"); 
				else this.htmlDialValue.setAttribute("stroke", "transparent");
			}else {
				if(this.minutes == this.secondMinutes) this.htmlDialValue.setAttribute("stroke", "#eaa1a1"); 
				else this.htmlDialValue.setAttribute("stroke", "transparent");
			}
			
		} else if(this.htmlLine2 != null) {
			this.htmlDialValue2.setAttribute("fill", "transparent");
			this.htmlLine2.setAttribute("stroke", "transparent");
		}
	}
	
}



class WidgetToolBoxHtml extends WidgetViewHtml {
	
	constructor(widget) {

		super(widget);

		this.hoveredPage = null;

		this.createDomElement("div");
		this.addClassName("WidgetToolBox");
		
		try {
			new ResizeObserver(this.onResize.bind(this)).observe(this.htmlElement);
		} catch (e) {
		}
	}

	appendChild(child) {

		if(Rex.undef(child, "child")) return;

		this.widget.appendChild(Rex.widgets[child.id]);
	}

	addPage(page) {

		if(Rex.undef(page, "page")) return;

		let pageHtmlElement = page.getHtmlElement();

		let widget = this.widget;

		let htmlElement = this.htmlElement;

		if(pageHtmlElement.parentNode == htmlElement) {

			console.error("Page %o already exists in toolBox html view %o", page, this)

			return;
		}

		let widgetPages = this.widget.pages;

		let index;

		for(index = 0; index < widgetPages.length; ++index) {

			let p = widgetPages[index].pageHtml;

			if(p == page)
				break;
		}

		if(index == widgetPages.length)
			return;

		let prevPageHtml = null;

		for(--index; index >= 0; --index) {

			prevPageHtml = widgetPages[index].pageHtml.getHtmlElement();

			if(prevPageHtml.parentNode == htmlElement)
				break;
		}

		if(index >= 0)
			prevPageHtml.insertAdjacentElement('afterEnd', pageHtmlElement);
		else
			htmlElement.insertAdjacentElement('afterBegin', pageHtmlElement);
	}

	removePage(page) {

		if(Rex.undef(page, "page")) return;

		let pageHtmlElement = page.getHtmlElement();

		let htmlElemenet = this.htmlElement;

		if(htmlElemenet.contains(pageHtmlElement))
			htmlElemenet.removeChild(pageHtmlElement);
	}

	checkSelect(event, parentId) {
		if(!this.hover)
			return undefined;

		let widgetPages = this.widget.pages;

		for(let widgetPage of widgetPages) {

			let page = widgetPage.pageHtml;
			
			const path = event.path || (event.composedPath && event.composedPath());
			if (page.iconHovered ||
				path[path.length - 1] == page.headerLabel.id ||
				path[path.length - 1] == page.headerImage.id) {
				page.headerHovered = true;
				this.hoveredPage = page;
				return this.widget;
			}else {
				page.headerHovered = false;
			}
			
		}

		// let ret = page.checkSelect(event, parentId);
		// if(ret != undefined) {
		// 	if(ret == page) {
		// 		this.hoveredPage = page;
		// 		return this.widget;
		// 	}
		// 	// if(ret.view != page.headerLabel) {
		// 	// 	event.path.push(ret.id);
		// 	// 	continue;
		// 	// }
		// 	return ret;
		// }
		
		this.hoveredPage = null;
		const path = event.path || (event.composedPath && event.composedPath());
		if (path.length == 1) 
			return Rex.widgets[path[0]];
		else if (path.length == 2)
			return super.checkSelect(event, path.pop());

		return this.widget;
	}

	onMouseDown(x, y, event) {
		if(this.hoveredPage != null)
			this.hoveredPage.onMouseDown(x, y, event);
	}

	onResize() {
		this.widget.onResize();
	}

}

WidgetToolBoxHtml.Page = class {

	constructor(toolbox) {

		if(Rex.undef(toolbox, "toolbox")) return;

		this.toolbox = toolbox;

		this.inited = false;

		this.showed = false;

		this.headerLabel = null;
		this.headerImage = null;

		this.contentWidget = null;

		this.headerHeight = null;
		this.contentHeight = null;

		this.labelWidth = null;
		this.imageWidth = null;

		this.needIcon = null;
		this.showedIcon = null;
		this.hiddenIcon = null;

		this.html = {
			page : null,
			header : {
				header : null,
				icon : null,
				body : {
					body : null,
					label : null,
					image : null
				}
			},
			content : null
		}

		this.iconHovered = false;
		this.headerHovered = false;

		this.onClickHandler = null;

		this.createHtml();
	}

	updateIconContent() {

		let icon = this.html.header.icon;

		if(icon == null)
			return;

		if(this.showed) {

			if(this.showedIcon == null)
				return;

			icon.innerText = this.showedIcon;

		} else {

			if(this.hiddenIcon == null)
				return;

			icon.innerText = this.hiddenIcon;
		}
	}

	showContent() {

		if(this.contentWidget == null)
			return;

		let page = this.html.page;
		let content = this.html.content;

		this.updateIconContent();

		if (!page.contains(content)) {
			content.style.height = "0px";
			page.appendChild(content);
			setTimeout(function () {
				this.html.content.style.height = this.contentHeight + "px";
			}.bind(this), 100);
		}
	}

	hideContent() {

		if(this.contentWidget == null)
			return;

		let page = this.html.page;
		let content = this.html.content;

		this.updateIconContent();

		if (page.contains(content)) {
			this.html.content.style.height = 0 + "px";
			setTimeout(function () {
				this.html.page.removeChild(this.html.content);
			}.bind(this), 700);
		}
	}

	setShowing(showed) {

		if(showed == undefined)
			return;

		if(this.showed == showed)
			return

		this.showed = showed;

		if(showed)
			this.showContent();
		else
			this.hideContent();
	}

	setNeedIcon(value) {

		if(this.needIcon == value)
			return;

		if(value == undefined)
			return;

		this.needIcon = value;

		this.redrawHeader();
	}

	setShowedIcon(icon) {

		if(this.showedIcon == icon)
			return;

		if(icon == undefined)
			return;

		this.showedIcon = icon;

		this.updateIconContent();
	}

	setHiddenIcon(icon) {

		if(this.hiddenIcon == icon)
			return;

		if(icon == undefined)
			return;

		this.hiddenIcon = icon;

		this.updateIconContent();
	}

	createHeaderIconHtml() {

		let icon = document.createElement('div');

		icon.classList.add('WidgetToolBoxPageHeaderIcon');

		icon.classList.add('MaterialIcon');

		icon.onmouseover = () => this.iconHovered = true;
		icon.onmouseout = () => this.iconHovered = false;

		return icon;
	}

	createHeaderLabelHtml() {

		let label = document.createElement('div');

		label.classList.add('WidgetToolBoxPageHeaderLabel');

		this.updateLabelWidth();

		return label;
	}

	createHeaderImageHtml() {

		let image = document.createElement('div');

		image.classList.add('WidgetToolBoxPageHeaderImage');

		this.updateImageWidth();

		return image;
	}

	createHeaderHtml() {

		let header = document.createElement('div');
		let body = document.createElement('div');

		header.classList.add('WidgetToolBoxPageHeader');
		body.classList.add('WidgetToolBoxPageHeaderBody');

		if(this.headerHeight != null)
			header.style.height = this.headerHeight + "px";

		let icon = this.createHeaderIconHtml();
		let label = this.createHeaderLabelHtml();
		let image = this.createHeaderImageHtml();

		body.appendChild(image);
		body.appendChild(label);

		header.appendChild(icon);
		header.appendChild(body);
		
		return {
				header : header,
				icon : icon,
				body : {
					body : body,
					label : label,
					image : image
				}
			};
	}

	createContentHtml() {

		let content = document.createElement('div');

		content.classList.add('WidgetToolBoxPageContent');

		if(this.contentHeight != null)
			content.style.height = this.contentHeight + "px";

		return content;
	}

	createHtml() {

		let page = document.createElement('div');

		page.classList.add('WidgetToolBoxPage');

		let header = this.createHeaderHtml();
		let content = this.createContentHtml();

		page.appendChild(header.header);

		this.html = {
			page : page,
			header : header,
			content : content
		}

		if(this.showed)
			this.showContent();
	}

	getHtmlElement() {

		return this.html.page;
	}

	init() {

		let headerLabel = this.headerLabel;
		let headerImage = this.headerImage;
		let contentWidget = this.contentWidget;

		if(headerLabel == null) return;
		if(headerImage == null) return;
		if(contentWidget == null) return;

		let html = this.html;

		let header = html.header;

		let imageHtml = headerImage.htmlElement;
		let labelHtml = headerLabel.htmlElement;

		labelHtml.style.width = "100%";
		labelHtml.style.height = "100%";

		imageHtml.style.width = "100%";
		imageHtml.style.height = "100%";

		header.body.label.appendChild(labelHtml);
		header.body.image.appendChild(imageHtml);

		let contentWidgetHtml = contentWidget.htmlElement;

		contentWidgetHtml.style.width = "100%";
		
		html.content.appendChild(contentWidget.htmlElement);

		if(this.showed)
			this.showContent();

		this.toolbox.addPage(this);

		this.inited = true;
	}

	updateLabelWidth() {

		let label = this.html.header.body.label;

		let width = this.labelWidth;

		if(label != null && width != null)
			label.style.width = width + "%";
	}

	updateImageWidth() {

		let image = this.html.header.body.image;

		let width = this.imageWidth;

		if(image != null && width != null)
			image.style.width = width + "%";
	}

	updateIconWidth() {

		let icon = this.html.header.icon;

		let iconWidth = this.headerHeight;
		let toolboxWidth = this.toolbox.htmlElement.clientWidth;

		if(icon == null || iconWidth == null)
			return;

		if(this.needIcon)


		if(iconWidth > toolboxWidth)
			iconWidth = toolboxWidth;

		let iconWidthStr = iconWidth + "px";

		icon.style.width = iconWidthStr;
		icon.style.fontSize = iconWidthStr;

		let headerBody = this.html.header.body.body;

		if(headerBody == null)
			return;

		let headerBodyWidth = toolboxWidth - iconWidth;

		let scroll = 0;
		if (this.toolbox.htmlElement.scrollHeight - this.toolbox.htmlElement.clientWidth !== 0)
			scroll = -15;
		headerBody.style.width = headerBodyWidth + scroll + "px";
	}

	redrawHeader() {

		let header = this.html.header.header;
		let icon = this.html.header.icon;
		let headerBody = this.html.header.body.body;

		if(header == null || icon == null)
			return;

		if(this.needIcon) {

			if(!header.contains(icon)) {

				header.insertBefore(icon, header.firstChild)
			}

			this.updateIconWidth();

		} else {

			if(header.contains(icon)) {

				header.removeChild(icon);

				if(headerBody != null)
					headerBody.style.width = "100%";
			}
		}
	}

	setHeaderLabel(headerLabel) {

		if(Rex.undef(headerLabel, "headerLabel")) return;

		if(this.headerLabel != null) {

			console.error("headerLabel already exists");

			return;
		}

		this.headerLabel = headerLabel;

		this.init();
	}

	setHeaderImage(headerImage) {

		if(Rex.undef(headerImage, "headerImage")) return;

		if(this.headerImage != null) {

			console.error("headerImage already exists");

			return;
		}

		this.headerImage = headerImage;

		this.init();
	}

	setContentWidget(contentWidget) {

		if(Rex.undef(contentWidget, "contentWidget")) return;

		if(this.contentWidget != null) {

			console.error("contentWidget already exists");

			return;
		}

		this.contentWidget = contentWidget;

		this.init();
	}

	setHeaderHeight(headerHeight) {

		if(Rex.undef(headerHeight, "headerHeight")) return;

		if(this.headerHeight == headerHeight)
			return;

		this.headerHeight = headerHeight;

		let headerHtml = this.html.header.header;

		if(headerHtml)
			headerHtml.style.height = headerHeight + "px";

		if(this.needIcon)
			this.updateIconWidth();
	}

	setContentHeight(contentHeight) {

		if(Rex.undef(contentHeight, "contentHeight")) return;

		if(this.contentHeight == contentHeight)
			return;

		this.contentHeight = contentHeight;

		let contentHtml = this.html.content;

		if(contentHtml)
			contentHtml.style.height = contentHeight + "px";
	}

	setLabelWidth(labelWidth) {

		if(Rex.undef(labelWidth, "labelWidth")) return;

		if(this.labelWidth == labelWidth)
			return;

		this.labelWidth = labelWidth;

		this.imageWidth = 100 - labelWidth;

		this.updateLabelWidth();
		this.updateImageWidth();
	}

	setImageWidth(imageWidth) {

		if(Rex.undef(imageWidth, "imageWidth")) return;

		if(this.imageWidth == imageWidth)
			return;

		this.imageWidth = imageWidth;

		this.labelWidth = 100 - imageWidth;

		this.updateLabelWidth();
		this.updateImageWidth();
	}

	setOnMouseDownHandler(handler) {

		if(Rex.undef(handler, "handler")) return;

		this.onClickHandler = handler;
	}

	checkSelect(event, parentId) {

		if(!this.inited)
			return;
		
		const path = event.path || (event.composedPath && event.composedPath());
		
		if(this.iconHovered ||
			path[path.length - 1] == this.headerLabel.id ||
			path[path.length - 1] == this.headerImage.id) {
			
			let ret = this.headerLabel.checkSelect(event, parentId) || this.headerImage.checkSelect(event, parentId);

			if(ret != undefined) {

				this.headerHovered = true;

				return this;
			}
		}

		this.headerHovered = false;

		if(this.showed && this.contentWidget != null)
			return this.contentWidget.checkSelect(event, parentId);
	}

	onMouseDown(x, y, event) {

		if(this.onClickHandler != null)
			this.onClickHandler();
	}

	onToolboxResize() {

		this.redrawHeader();
	}

}

class WidgetToolBoxPageHtml extends WidgetViewHtml {

	constructor(widget) {

		super(widget);

		this.createDomElement("div");
	}

}

/**
 * WidgetFrame
 */

class WidgetFrameHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetFrame");
		
		this.referenceBlock = document.createElement("iframe");
		this.referenceBlock.classList.add("frameWidgetFrame");
		this.referenceBlock.style.display = "none";
		this.referenceBlock.addEventListener("onload",this.onLoad.bind(this));
		this.htmlElement.appendChild(this.referenceBlock);
		
		window.addEventListener("message", this.onCrossFrameMessage.bind(this));

		this.sourseBlock = document.createElement("div");
		this.sourseBlock.classList.add("frameWidgetFrame");
		this.sourseBlock.style.display = "none";
		this.sourseBlock.addEventListener("onload",this.onLoad.bind(this));
		this.htmlElement.appendChild(this.sourseBlock);
		
	}

	getLocation (href) {
    var l = document.createElement("a");
    l.href = href;
    return l;
	};

	onCrossFrameMessage(event)
	{

		//console.log("EPPA", event.data, this.src, this.getLocation(this.src).search);

		if(!(event.data.messageInfo.search === this.getLocation(this.src).search)) return;
		Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 
				'onCrossFrameMessage', [JSON.stringify(event.data)]);
	}
	
	onSetState(state){
		if(state.srcEncode != null) {
			
			try {this.src = decodeURIComponent(escape(window.atob(state.srcEncode)));
			} catch (e) { console.error(this.type, " -> setState-> ", state._srcEncode, " DecodeError!");}
			this.widget.src = this.src;
			
			if(this.external) {
				this.referenceBlock.setAttribute("src", this.src);
				this.referenceBlock.style.display = "";
				this.sourseBlock.style.display = "none";
			} else {
				this.sourseBlock.innerHTML = this.src;
				this.sourseBlock.style.display = "";
				this.referenceBlock.style.display = "none";
			}
			
		}
		
	}
	
	onLoad(){
		Rex.callRpcMethod('Widgets', this.widget.id, this.widget.type, 'onload', []);
	}
	
}

/**
 * WidgetTableHtml
 */

class WidgetTableHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.addClassName("WidgetTable");
		this.createDomElement("div");
	}

	appendChild(child) {
		let content = document.getElementById("t-" + child.id);
		if(!content) content = document.getElementById("t-" + child.id.replace("div", ""));
		if(content)
			content.appendChild(child);
	}

	set meta(value) {
		this.widget.meta = value;
		if(!this.widget.inited) return;
		this.remake();
	}
	
	get meta() {return this.widget.meta;}

	set data(value) {
		this.widget.data = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get data() {return this.widget.data;}

	set fixHeadRow(value) {
		this.widget.fixHeadRow = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get fixHeadRow() {return this.widget.fixHeadRow;}

	set needBorder(value) {
		this.widget.needBorder = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get needBorder() {return this.widget.needBorder;}

	set needHeadRow(value) {
		this.widget.needHeadRow = value;
		if(!this.widget.inited) return;
		this.remake();
	}
	
	get needHeadRow() {return this.widget.needHeadRow;}
	
	set needRowsNumber(value) {
		this.widget.needRowsNumber = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get needRowsNumber() {return this.widget.needRowsNumber;}

	set needResize(value) {
		this.widget.needResize = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get needResize() {return this.widget.needResize;}

	set canEditable(value) {
		this.widget.canEditable = value;
		if(!this.widget.inited) return;
		this.remake();
	}

	get canEditable() {return this.widget.canEditable;}

	onSetState(state) {
		if(state.needHeadRow != null) this.widget.needHeadRow = state.needHeadRow;
		if(state.isNumberSort != null) this.widget.isNumberSort = state.isNumberSort;
	}

	onInit() {
		for(let i = 0; i < this.widget.children.length; ++i) {
			Rex.widgets[this.widget.children[i]].view.height = undefined;
			Rex.widgets[this.widget.children[i]].view.width = undefined;
		}
		this.remake();
	}

	remake() {
		this.htmlElement.style.backgroundImage="";
		this.resortByOrder();
		this.widget.needHeadRow ? this.widget.scrollTop = (document.querySelector('.content-container') ? document.querySelector('.content-container').scrollTop : 0) : this.widget.scrollTop = this.htmlElement.scrollTop;
		while (this.htmlElement.firstChild) {
			this.htmlElement.removeChild(this.htmlElement.firstChild);
		}
		if(this.widget.data != null && this.widget.data.length) {
			this.htmlElement.setAttribute("contenteditable", "false");
			if(this.widget.fixHeadRow && this.widget.needHeadRow) {
				this.makeFixHeadTable();
			} else {
				this.htmlElement.style.display = 'block';
				if(this.widget.needHeadRow) {
					this.makeHeadTable();
				} else
					this.makeTable();
			}
		} else
			{
				this.htmlElement.style.backgroundImage="url(https://cdn2.iconfinder.com/data/icons/large-svg-icons/512/datasheet_database_data_sheet-512.png)";
			}
	}

	makeFixHeadTable() {
		let headerContainer = document.createElement("div");
		headerContainer.classList.add("header-container");
		let headTableContainer = document.createElement("table");
		headTableContainer.classList.add("table-container", "fix-head");
		headerContainer.appendChild(headTableContainer);
		let head = document.createElement("thead");
		this.makeHead(head);
		headTableContainer.appendChild(head);
		this.htmlElement.appendChild(headerContainer);
		let contentContainer = this.makeContentContainer();
		this.htmlElement.appendChild(contentContainer);
		contentContainer.scrollTop = this.widget.scrollTop;
	}

	makeContentContainer() {
		let contentContainer = document.createElement("div");
		contentContainer.classList.add("content-container");
		let tableContainer = document.createElement("table");
		tableContainer.classList.add("table-container");
		contentContainer.appendChild(tableContainer);
		let tableHead = document.createElement("thead");
		this.makeHead(tableHead, true);
		tableContainer.appendChild(tableHead);
		let tableBody = document.createElement("tbody");
		this.makeBody(tableBody);
		tableContainer.appendChild(tableBody);
		return contentContainer;
	}

	makeHead(parent, fake = false) {
		let row = document.createElement("tr");
		row.classList.add("header-row");
		this.makeHeadCols(row, fake);
		parent.appendChild(row);
		this.appendRowAttribute(0, row);
		this.appendContentRowAttribute(0, row);
	}

	makeHeadCols(parent, fake) {
		let head = this.widget.data[0];
		if(this.widget.needRowsNumber) {
			let colHead = document.createElement("th");
			colHead.classList.add('numbers');
			colHead.classList.add('first');
			colHead.textContent = '#';
			parent.appendChild(colHead);
		}
		for(let i = 0; i < head.length; ++i) {
			let colHead = document.createElement("th");
			if(this.widget.needBorder && i !== (head.length - 1)) colHead.classList.add('border-need');
			if(i === 0) {
				this.makeColsParams(colHead, head, i, fake, "table-resizer-right");
			} else if(i === head.length - 1) {
				this.makeColsParams(colHead, head, i, fake, "table-resizer-left");
			} else {
				this.makeColsParams(colHead, head, i, fake, "");
			}
			parent.appendChild(colHead);
		}
	}

	makeColsParams(colHead, head, index, fake, resizerClass) {
		if(resizerClass === "table-resizer-left") colHead.classList.add("last-col");
		if(resizerClass === "table-resizer-right") colHead.classList.add("first-col");
		if(!this.widget.needResize) colHead.classList.add("resize-off");
		let resizer = document.createElement("div");
		resizerClass !== "" ? resizer.classList.add("table-resizer", resizerClass) : resizer.classList.add("table-resizer", "table-resizer-left");
		colHead.appendChild(resizer);
		let content = document.createElement("div");
		content.classList.add("table-content");
		this.appendAllAttribute(colHead);
		this.appendContentAllAttribute(content);
		this.appendCellAttribute(0, index, colHead);
		if(head[index].length) {
			if(!head[index].indexOf("WidgetInTableId:")) {
				let id = Number.parseInt(head[index].substring("WidgetInTableId:".length));
				if(!isNaN(id)) {
					this.appendContentCellAttribute(id, content);
					content.id = "t-" + id;
					if(Rex.widgets[id]) {
						Rex.widgets[id].view.htmlElement.style.flex = 1;
						content.appendChild(fake ? Rex.widgets[id].view.htmlElement.cloneNode(true) : Rex.widgets[id].view.htmlElement);
					}
				}
			} else {
				content.textContent = head[index];
			}
		}
		if(resizerClass === "") {
			let rightResizer = document.createElement("div");
			rightResizer.classList.add("table-resizer", "table-resizer-right");
			colHead.appendChild(rightResizer);
		}
		this.createSortBaton(0, index, content);
		colHead.appendChild(content);
	}

	createSortBaton(rowIndex, colIndex, parent) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, "sort"));
		if(attributes) {
		let sortBaton = document.createElement("div");
			sortBaton.classList.add("sort-baton");
			sortBaton.classList.add("default");
			let stem = document.createElement("div");
			stem.classList.add("stem");
			let indicator = document.createElement("div");
			indicator.classList.add("indicator");
			indicator.classList.add("indicator-up");
			let pointerLeft = document.createElement("div");
			pointerLeft.classList.add("pointer-left");
			let pointerRight = document.createElement("div");
			pointerRight.classList.add("pointer-right");
			let pointerMiddle = document.createElement("div");
			pointerMiddle.classList.add("pointer-middle");
			indicator.appendChild(pointerLeft);
			indicator.appendChild(pointerRight);
			indicator.appendChild(pointerMiddle);
			sortBaton.appendChild(indicator);
			sortBaton.appendChild(stem);
			parent.appendChild(sortBaton);
			for(attribute in attributes) {
				if(attribute === "default") {
					if(attributes[attribute] === "none") {
						sortBaton.classList.toggle("default");
					}
				} else if(attribute === "indicator") {
					if(attributes[attribute] === "indicator-down") {
						indicator.classList.toggle("indicator-up");
						indicator.classList.toggle("indicator-down");
					}
				}
			}
		}
	}

	makeBody(parent) {
		for(let i = this.widget.needHeadRow ? 1 : 0; i < this.widget.data.length; ++i) {
			let row = document.createElement('tr');
			this.makeCols(i, row);
			parent.appendChild(row);
			this.appendRowAttribute(i, row);
			this.appendContentRowAttribute(i, row);
		}
	}
	
	resortByOrder() {
		if(this.widget.data != null && this.widget.data.length &&!this.widget.haveColRowSpan("You can't make order merged cells")) {
			let arrOrderRow = [];
			let first;
			for(let i = 0; i < this.data.length; ++i) {
				let order = decomposeObj(this.meta, joinTextToCompose("rows", i, "order"));
				arrOrderRow[i] = order ? order : 0;
			}
			if(this.widget.needHeadRow) {
				arrOrderRow[0] = -100000;
			}
			let flag = this.letsSort(arrOrderRow, false);
			let arrOrderCol = [];
			for(let i = 0; i < this.data[0].length; ++i) {
				let order = decomposeObj(this.meta, joinTextToCompose("rows", 0, "cols", i, "order"));
				arrOrderCol[i] = order ? order : 0;
			}
			if(this.letsSort(arrOrderCol, true) || flag) {
				Rex.callRpcMethod('Widgets', this.id, this.type, 'setDataJson', [JSON.stringify(this.data)]);
				Rex.callRpcMethod('Widgets', this.id, this.type, 'setMetaJson', [JSON.stringify(this.meta)]);
			}
		}
	}
	
	letsSort(a, cols) { //Сортировка подсчётом (обратная)
		let n = a.length, count = [], b = [];
		for(let i = 0; i < n; i++) count[i] = 0;
		for(let i = n - 1; i > 0; i--) {
			for(let j = i - 1; j > -1; j--) {
				if(a[i] < a[j]) count[j]++;
				else count[i]++;
			}
		}
		let retData = [];
		let retMeta = {};
		if(decomposeObj(this.meta, "all"))
			composeObj(retMeta, "all", decomposeObj(this.meta, "all"));
		if(cols) {
			for(let i = 0; i < n; i++) {
				b[count[i]] = a[i];
				for(let j = 0; j < this.data.length; ++j) {
					if(!retData[j]) retData[j] = [];
					retData[j][count[i]] = this.data[j][count[i]];
					if(decomposeObj(this.meta, joinTextToCompose("rows", j, "cols", i)))
						composeObj(retMeta,joinTextToCompose("rows", j, "cols", count[i]),decomposeObj(this.meta, joinTextToCompose("rows", j, "cols", i)));
					if(i === 0) {
						if(decomposeObj(this.meta, joinTextToCompose("rows", j, "content")))
							composeObj(retMeta,joinTextToCompose("rows", j, "content"),decomposeObj(this.meta, joinTextToCompose("rows", j, "content")));
						if(decomposeObj(this.meta, joinTextToCompose("rows", j, "order")))
							composeObj(retMeta,joinTextToCompose("rows", j, "order"),decomposeObj(this.meta, joinTextToCompose("rows", j, "order")));
						if(decomposeObj(this.meta, joinTextToCompose("rows", j, "styles")))
							composeObj(retMeta,joinTextToCompose("rows", j, "styles"),decomposeObj(this.meta, joinTextToCompose("rows", j, "styles")));
						if(decomposeObj(this.meta, joinTextToCompose("rows", j, "attribures")))
							composeObj(retMeta,joinTextToCompose("rows", j, "attribures"),decomposeObj(this.meta, joinTextToCompose("rows", j, "attribure")));
					}
				}
			}
			
		} else {
			for(let i = 0; i < n; i++) {
				b[count[i]] = a[i];
				retData[count[i]] = this.data[i];
				if(decomposeObj(this.meta, joinTextToCompose("rows", i)))
					composeObj(retMeta, joinTextToCompose("rows", count[i]),decomposeObj(this.meta, joinTextToCompose("rows", i)));
			}
		}
		this.widget.meta = retMeta;
		if (this.widget.data.join(',') === retData.join(',')) {
			this.widget.data = retData;
			return false;
		}
		this.widget.data = retData;
		return true;
	}

	makeCols(rowIndex, parent) {
		if(this.widget.needRowsNumber) {
			let colHead = document.createElement("td");
			colHead.textContent = rowIndex;
			colHead.classList.add('numbers');
			parent.appendChild(colHead);
		}
		for(let i = 0; i < this.widget.data[rowIndex].length; ++i) {
			let cell = document.createElement('td');
			let content = document.createElement("div");
			content.classList.add("table-content");
			cell.appendChild(content);
			if(this.widget.needBorder && i !== (this.widget.data[rowIndex].length - 1)) cell.classList.add('border-need');
			this.appendAllAttribute(cell);
			this.appendContentAllAttribute(content);
			this.appendCellAttribute(rowIndex, i, cell);
			if(this.widget.data[rowIndex][i].length) {
				if(!this.widget.data[rowIndex][i].indexOf("WidgetInTableId:")) {
					let id = Number.parseInt(this.widget.data[rowIndex][i].substring("WidgetInTableId:".length));
					if(!isNaN(id)) {
						this.appendContentCellAttribute(id, content);
						content.id = "t-" + id;
						if(Rex.widgets[id])
							content.appendChild(Rex.widgets[id].view.htmlElement);
					}
				} else {
					content.textContent = this.widget.data[rowIndex][i];
				}
			}
			parent.appendChild(cell);
		}
	}

	appendCellAttribute(rowIndex, colIndex, cell) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, "attributes"));
		for(attribute in attributes) {
			cell.setAttribute(attribute, attributes[attribute]);
		}
		let style;
		let styles = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, "styles"));
		for(style in styles) {
			cell.style[style] = styles[style];
		}
	}

	appendAllAttribute(cell) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose("all", "attributes"));
		for(attribute in attributes) {
			cell.setAttribute(attribute, attributes[attribute]);
		}
		let style;
		let styles = decomposeObj(this.meta, joinTextToCompose("all", "styles"));
		for(style in styles) {
			cell.style[style] = styles[style];
		}
	}

	appendRowAttribute(rowIndex, row) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "attributes"));
		for(attribute in attributes) {
			row.setAttribute(attribute, attributes[attribute]);
		}
		let style;
		let styles = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "styles"));
		for(style in styles) {
			row.style[style] = styles[style];
		}
	}

	appendContentCellAttribute(widgetId, content) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose(widgetId, "attributes"));
		for(attribute in attributes) {
			content.setAttribute(attribute, attributes[attribute]);
		}
		let style;
		let styles = decomposeObj(this.meta, joinTextToCompose(widgetId, "styles"));
		for(style in styles) {
			content.style[style] = styles[style];
		}
	}

	appendContentAllAttribute(content) {
		let attribute;
		let attributes = decomposeObj(this.meta, joinTextToCompose("all", "content", "attributes"));
		for(attribute in attributes) {
			content.setAttribute(attribute, attributes[attribute]);
		}
		let style;
		let styles = decomposeObj(this.meta, joinTextToCompose("all","content", "styles"));
		for(style in styles) {
			content.style[style] = styles[style];
		}
	}

	appendContentRowAttribute(rowIndex, row) {
		for(let i = 0; i < row.childNodes.length; ++i) {
			let attribute;
			let attributes = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "content","attributes"));
			for(attribute in attributes) {
				row.childNodes[i].querySelector('.table-content').setAttribute(attribute, this.widget.meta.rows[rowIndex].attributes[attribute]);
			}
			let style;
			let styles = decomposeObj(this.meta, joinTextToCompose("rows", rowIndex, "content", "styles"));
			for(style in styles) {
				row.childNodes[i].querySelector('.table-content').style[style] = styles[style];
			}
		}
	}

	 makeHeadTable() {
		let table = document.createElement('table');
		table.classList.add("table-container");
		let head = document.createElement('thead');
		this.makeHead(head);
		table.appendChild(head);
		let body = document.createElement('tbody');
		this.makeBody(body);
		table.appendChild(body);
		this.htmlElement.appendChild(table);
	}

	makeTable() {
		let table = document.createElement('table');
		table.classList.add("table-container");
		let body = this.makeTbody();
		table.appendChild(body);
		this.htmlElement.scrollTop = this.widget.scrollTop;
		this.htmlElement.appendChild(table);
	}

	makeTbody() {
		let body = document.createElement('tbody');
		this.makeBody(body);
		return body;
	}
	
	removeChild(node) {
		let content = document.getElementById("t-" + node.id);
		if(!content) content = document.getElementById("t-" + node.id.replace("div", ""));
		if(content)
			content.removeChild(node);
	}
	
	checkSelect(event, parentId) {
		for(let _widgetID of this.widget.children) {
			let ret = Rex.widgets[_widgetID] ? Rex.widgets[_widgetID].view.checkSelect(event, parentId) : undefined;
			if(ret) return ret;
		}
		return this.hover ? this.widget : undefined;
	}
}



/**
 * Created by ALLekSSSanDR on 25.10.2018.
 */
	
class WidgetGroupBoxHtml extends WidgetViewHtml {
	
	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetGroupBox");
		
		this.htmlContainer = document.createElement("div");
		this.htmlContainer.classList.add("WidgetGroupBoxContainer");
		
		this.htmlContainer.style.borderWidth = this.borderSize + "px";
		this.htmlContainer.style.borderStyle = "solid";
		this.htmlContainer.style.borderColor = "black";
		
		this.htmlText = document.createElement("div");
		this.htmlText.classList.add("WidgetGroupBoxText");
		this.htmlText.textContent = this.headerText;
		
		 this.onSetState(widget);
	}
	
	onSetState(state) {
		if(state === undefined) return;
		
		// Header
		if(state.headerText != null) {
			try { this.headerText = decodeURIComponent(escape(window.atob(this.headerText)));}
			catch(e) { console.error(this.widget.type, "setState->", "headerText DecodeError!")}
			this.htmlText.textContent = this.headerText;
		}
		
		// BORDER COLOR
		if(state.borderColor != null) this.htmlContainer.style.borderColor = this.borderColor;
		
		// BORDER SIZE
		if(state.borderSize != null) {
			this.htmlContainer.style.borderWidth = this.borderSize + "px";
			this.htmlContainer.style.width = "calc(100% - " + (10 + this.borderSize * 2) + "px)";
			this.htmlContainer.style.height = "calc(100% - " + (this.fontSize + this.borderSize * 2) + "px)";
			this.htmlContainer.style.marginTop = this.fontSize / 2 + "px";
			this.htmlText.style.height = Math.max(this.borderSize, this.fontSize) * 1.5 + "px";
			this.htmlText.style.left = 20 + this.borderSize + "px";
		}
		
		//FONT SIZE
		if(state.fontSize != null) {
			this.htmlContainer.style.marginTop = this.fontSize / 2 + "px";
			this.htmlText.style.fontSize = this.fontSize + "px";
			this.htmlText.style.height = Math.max(this.borderSize, this.fontSize) * 1.5 + "px";
			this.htmlContainer.style.height = "calc(100% - " + (10 + this.fontSize - this.fontSize / 2  + this.borderSize * 2) + "px)";
		}
		
	}
	
	onInit() {
		this.htmlElement.appendChild(this.htmlContainer);
		this.htmlElement.appendChild(this.htmlText);
	}
	
	onMouseMove(x, y, event) {
		if(!this.editMode && !this.editable) return;
		if(this.focusChild == null) this.hoverChild = this.checkChild(event);
		else {
			this.focusChild.setPos(x - this.widget.aPosX - this.dx, y - this.widget.aPosY - this.dy);
			this.focusChild.view.htmlElement.style.top = y - this.widget.aPosY - this.dy + "px";
			this.focusChild.view.htmlElement.style.left = x - this.widget.aPosX  - this.dx + "px";
		}
	}
	
	onMouseDown(x, y, event) {
		if(!this.editMode && !this.editable) return;
		this.focusChild = this.hoverChild;
		if(this.focusChild == null) return;
		this.dx = x - this.focusChild.aPosX;
		this.dy = y - this.focusChild.aPosY;
	}
	
	onMouseUp(x, y, event) {
		if(!this.editMode && !this.editable) return;
		this.focusChild = null;
	}
	
	appendChild(child) {
		if(!this.contains(child)) {
			this.htmlContainer.appendChild(child);
			
			let id = child.id;
			if(isNaN(parseInt(id))) {
				id = id.replace("div", "");
			}
			let w = Rex.widgets[parseInt(id)];
			
			if(w != null) {
				child.style.top = w.posY + "px";
				child.style.left = w.posX + "px";
			}
		}
	}
	
	checkSelect(event, parentId) {
		if(this.hover) {
			if(!this.widget.isEditable() && !this.editMode) return super.checkSelect(event, parentId);
			return this.widget;
		}
		return undefined;
	}
	
	checkChild(event) {
		const path = event.path || (event.composedPath && event.composedPath());
		for(let key = this.children.length - 1; key > -1; --key) {
			let w = Rex.widgets[this.children[key]];
			if(w == null) continue;
			for(let e of path) {
				if(e == null) continue;
				if(e.id == null) continue;
				if(e.id == w.id) return w;
			}
		}
		return null;
	}
}


/**
 * Created by ALLekSSSanDR on 09.11.2018.
 */
	
class WidgetColorPickerHtml extends WidgetViewHtml {
	
	constructor(state) {
		super(state);
		this.createDomElement("div");
		this.addClassName("WidgetColorPicker");
		this.pickViewC = this.makeElement(this.htmlElement, "div", "WidgetColorPickerViewC");
		this.pickView = this.makeElement(this.pickViewC, "div", "WidgetColorPickerView", null, "click", this.eventView.bind(this));
		
		///
		/// MODAL
		///
		
		this.pickColorModalContainer = document.createElement("div");
		this.pickColorModalContainer.classList.add("WidgetColorPickerModal");
		document.getElementById(this.container).appendChild(this.pickColorModalContainer);
		
		this.pickColorContainer = document.createElement("div");
		this.pickColorContainer.classList.add("WidgetColorPickerChooserView");
		this.pickColorModalContainer.appendChild(this.pickColorContainer);
		
		// КОНТЕЙНЕР ДЛЯ CANVAS ЕЛЕМЕНТОВ
		this.pickColorCanvasContent = document.createElement("div");
		this.pickColorCanvasContent.classList.add("WidgetColorPickerCC");
		this.pickColorContainer.appendChild(this.pickColorCanvasContent);
		
		// CANVAS  <<< HUE >>>
		this.pickCanvasHC = document.createElement("div");
		this.pickCanvasHC.classList.add("WidgetColorPickerHC");
		this.pickColorCanvasContent.appendChild(this.pickCanvasHC);
		
		this.labelH = this.makeElement(this.pickCanvasHC, "div", "WidgetColorPickerLabel", "H");
		this.canvasHButton = this.makeElement(this.pickCanvasHC, "button", "WidgetColorPickerHButton", null, "button", null);
		this.canvasHCanvas = this.makeElement(this.pickCanvasHC, "canvas", "WidgetColorPickerHCanvas", null, "canvas", null);
		this.inputH = this.makeElement(this.pickCanvasHC, "input", "WidgetColorPickerInput", null, "input", this.eventInputHSLA);
		
		// CANVAS  <<< Saturation >>>
		this.pickCanvasSC = document.createElement("div");
		this.pickCanvasSC.classList.add("WidgetColorPickerSC");
		this.pickColorCanvasContent.appendChild(this.pickCanvasSC);
		this.labelS = 		 this.makeElement(this.pickCanvasSC, "div", "WidgetColorPickerLabel", "S");
		this.canvasSButton = this.makeElement(this.pickCanvasSC, "button", "WidgetColorPickerSButton", null, "button", null);
		this.canvasSCanvas = this.makeElement(this.pickCanvasSC, "canvas", "WidgetColorPickerSCanvas", null, "canvas", null);
		this.inputS = 		 this.makeElement(this.pickCanvasSC, "input", "WidgetColorPickerInput", null, "input", this.eventInputHSLA);
		
		// CANVAS  <<< Lightness >>>
		this.pickCanvasLC = document.createElement("div");
		this.pickCanvasLC.classList.add("WidgetColorPickerLC");
		this.pickColorCanvasContent.appendChild(this.pickCanvasLC);
		this.labelL = this.makeElement(this.pickCanvasLC, "div", "WidgetColorPickerLabel", "L");
		this.canvasLButton = this.makeElement(this.pickCanvasLC, "button", "WidgetColorPickerLButton", null, "button", null);
		this.canvasLCanvas = this.makeElement(this.pickCanvasLC, "canvas", "WidgetColorPickerLCanvas", null, "canvas", null);
		this.inputL = 		 this.makeElement(this.pickCanvasLC, "input", "WidgetColorPickerInput", null, "input", this.eventInputHSLA);
		
		// CANVAS  <<< ALPHA >>>
		this.pickCanvasAC = document.createElement("div");
		this.pickCanvasAC.classList.add("WidgetColorPickerAC");
		this.pickColorCanvasContent.appendChild(this.pickCanvasAC);
		this.labelA = this.makeElement(this.pickCanvasAC, "div", "WidgetColorPickerLabel", "A");
		this.canvasAButton = this.makeElement(this.pickCanvasAC, "button", "WidgetColorPickerAButton", null, "button", null);
		this.canvasACanvas = this.makeElement(this.pickCanvasAC, "canvas", "WidgetColorPickerACanvas", null, "canvas", null);
		this.inputA = 		 this.makeElement(this.pickCanvasAC, "input", "WidgetColorPickerInput", null, "input", this.eventInputHSLA);
		this.inputA.setAttribute("step", 0.1);
		
		// КОНТЕЙНЕР ДЛЯ ВЫВОДА ИНФОРМАЦИИ
		this.pickColorInfoContent = document.createElement("div");
		this.pickColorInfoContent.classList.add("WidgetColorPickerIC");
		this.pickColorContainer.appendChild(this.pickColorInfoContent);
		
		this.convertContainer = this.makeElement(this.pickColorInfoContent, "div", "WidgetColorPickerICC");
		
		// RGBA
		this.RGBAContainer = this.makeElement(this.convertContainer, "div", "WidgetColorPickerRGBA");
		this.l_R = this.makeElement(this.RGBAContainer, "div", "WidgetColorPickerLabel", "R:");
		this.i_R = this.makeElement(this.RGBAContainer, "input", "WidgetColorPickerInput", null, "input", this.eventInputRGBA);
		this.l_G = this.makeElement(this.RGBAContainer, "div", "WidgetColorPickerLabel", "G:");
		this.i_G = this.makeElement(this.RGBAContainer, "input", "WidgetColorPickerInput", null, "input", this.eventInputRGBA);
		this.l_B = this.makeElement(this.RGBAContainer, "div", "WidgetColorPickerLabel", "B:");
		this.i_B = this.makeElement(this.RGBAContainer, "input", "WidgetColorPickerInput", null, "input", this.eventInputRGBA);
		this.l_A = this.makeElement(this.RGBAContainer, "div", "WidgetColorPickerLabel", "A:");
		this.i_A = this.makeElement(this.RGBAContainer, "input", "WidgetColorPickerInput", null, "input", this.eventInputRGBA);
		this.i_A.setAttribute("step", 0.1);
		
		// CMYK
		this.CMYKContainer = this.makeElement(this.convertContainer, "div", "WidgetColorPickerCMYK");
		this.l_C = this.makeElement(this.CMYKContainer, "div", 		"WidgetColorPickerLabel", "C:");
		this.i_C = this.makeElement(this.CMYKContainer, "input", 	"WidgetColorPickerInput", null, "input", this.eventInputCMYK);
		this.l_M = this.makeElement(this.CMYKContainer, "div", 		"WidgetColorPickerLabel", "M:");
		this.i_M = this.makeElement(this.CMYKContainer, "input", 	"WidgetColorPickerInput", null, "input", this.eventInputCMYK);
		this.l_Y = this.makeElement(this.CMYKContainer, "div", 		"WidgetColorPickerLabel", "Y:");
		this.i_Y = this.makeElement(this.CMYKContainer, "input", 	"WidgetColorPickerInput", null, "input", this.eventInputCMYK);
		this.l_K = this.makeElement(this.CMYKContainer, "div", 		"WidgetColorPickerLabel", "K:");
		this.i_K = this.makeElement(this.CMYKContainer, "input", 	"WidgetColorPickerInput", null, "input", this.eventInputCMYK);
		
		// HEX
		this.HEXContainer = this.makeElement(this.convertContainer, "div", "WidgetColorPickerHEX");
		this.l_HEX = this.makeElement(this.HEXContainer, "div", "WidgetColorPickerLabelHEX", "HEX:");
		this.i_HEX = this.makeElement(this.HEXContainer, "input", "WidgetColorPickerInputHEX", null, "input", this.eventInputHEX);
		this.i_HEX.type = "";
		
		// RAL CLASSIC
		this.RALContainer = this.makeElement(this.convertContainer, "div", "WidgetColorPickerHEX");
		this.l_RAL = this.makeElement(this.RALContainer, "div", 	"WidgetColorPickerLabelRAL", "RAL:");
		this.i_RAL = this.makeElement(this.RALContainer, "select", "WidgetColorPickerInputRAL", null, "change", this.eventInputRAL);
		let i_none = document.createElement("option");
		i_none.textContent = "none";
		this.i_RAL.appendChild(i_none);
		for(let k in COLOR_PICKER_RAL_CLASSIC_MAP) {
			let item = document.createElement("option");
			item.textContent = k;
			this.i_RAL.appendChild(item);
		}
		
		this.viewColorContainerMain = this.makeElement(this.pickColorInfoContent, "div", "WidgetColorPickerViewerContainerMain");
		this.viewColorContainer = this.makeElement(this.viewColorContainerMain, "div", "WidgetColorPickerViewerContainer");
		this.viewColor = this.makeElement(this.viewColorContainer, "div", "WidgetColorPickerViewer");
		
		this.okElement = this.makeElement(this.pickColorContainer, "div", "WidgetColorPickerAccept", "Ok", "click", this.eventOk);
		this.closeElement = this.makeElement(this.pickColorContainer, "div", "WidgetColorPickerClose", "Cancel", "click", this.eventHide);
		
		this._pickedColor = "#00000000";
		
		this.H = 150;	// Hue - оттенок 0°- 360° 
		this.S = 0;		// Saturation - насыщенность  0 - 255 // 0..100%
		this.L = 50;	// Lightness  - светлота от -100 - 100 // 0..100%
		this.A = 0.5;
		
		// 0..255
		this.RGBA_R = 127;
		this.RGBA_G = 127;
		this.RGBA_B = 127;
		this.RGBA_A = 0.5;
		
		// 0..100%
		this.CMYK_C = 0;
		this.CMYK_M = 0;
		this.CMYK_Y = 0;
		this.CMYK_K = 50;
		
		this.HEX = "#7f7f7f7f";
		this.RAL = "none";
		
	}
	
	onSetState(state) {
		if(state.pickedColor != null && state.pickedColor !== "") {
			this._pickedColor = state.pickedColor;
			this.setHEX(state.pickedColor);
			
			this.hexToRgb();
			this.rgbToHsl();
			this.rgbToCmyk();
			this.checkRAL();
			
			this.updateData();
		}
	}
	
	changeColor(event) {
		Rex.callRpcMethod('Widgets', this.id, this.type, 'changeColor', [event.target.value]);
	}
	
	
	makeElement(p, typeName, className, value, event, func) {
		let node = document.createElement(typeName);
		node.classList.add(className);
		if(value != null) node.textContent = value;
		if(func != null && event != null) node.addEventListener(event, func.bind(this), true);
		if(typeName == "input") { node.type = "number"; node.required = true;}
		p.appendChild(node);
		if(event === "canvas" || event === "button") {
			this.eventsCanvas(node);
		}
		return node;
	}
	
	eventsCanvas(node) {
		node.addEventListener("mousedown", this.eventMove.bind(this), true);
		node.addEventListener("mousemove", this.eventMove.bind(this), true);
		node.addEventListener("mousewheel", this.eventWheel.bind(this), true);
	}
	
	///
	/// SETTERS H S L A
	///
	
	setH(value) {
		let valueH = value;
		if(isNaN(valueH)) {
			this.inputH.value = this.H;
		} else {
			this.H = parseInt(valueH);
			if(this.H < 0) this.H = 0;
			if(this.H > 360) this.H = 360;
			this.inputH.value = this.H;
		}
	}
	
	setS(value) {
		let v = value;
		if(isNaN(v)) {
			this.inputS.value = this.S;
		} else {
			this.S = parseInt(v);
			if(this.S < 0) this.S = 0;
			if(this.S > 100) this.S = 100;
			this.inputS.value = this.S;
		}
	}
	
	setL(value) {
		let v = value;
		if(isNaN(v)) {
			this.inputL.value = this.L;
		} else {
			this.L = parseInt(v);
			if(this.L < 0) this.L = 0;
			if(this.L > 100) this.L = 100;
			this.inputL.value = this.L;
		}
	}
	
	setA(value) {
		let v = value;
		if(isNaN(v)) {
			this.inputA.value = this.A;
		} else {
			this.A = parseFloat(v);
			if(this.A < 0) this.A = 0;
			if(this.A > 1.0) this.A = 1.0;
			this.inputA.value = this.A;
		}
	}
	
	///
	/// SETTERS R G B A
	///
	
	setRGBA_R(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_R.value = this.RGBA_R;
		} else {
			this.RGBA_R = parseInt(v);
			if(this.RGBA_R < 0) 	this.RGBA_R = 0;
			if(this.RGBA_R > 255) 	this.RGBA_R = 255;
			this.i_R.value = this.RGBA_R;
		}
		
	}
	
	setRGBA_G(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_G.value = this.RGBA_G;
		} else {
			this.RGBA_G = parseInt(v);
			if(this.RGBA_G < 0) 	this.RGBA_G = 0;
			if(this.RGBA_G > 255) 	this.RGBA_G = 255;
			this.i_G.value = this.RGBA_G;
		}
	}
	
	setRGBA_B(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_B.value = this.RGBA_B;
		} else {
			this.RGBA_B = parseInt(v);
			if(this.RGBA_B < 0) 	this.RGBA_B = 0;
			if(this.RGBA_B > 255) 	this.RGBA_B = 255;
			this.i_B.value = this.RGBA_B
		}
	}
	
	setRGBA_A(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_A.value = this.RGBA_A;
		} else {
			this.RGBA_A = parseFloat(v);
			if(this.RGBA_A < 0) this.RGBA_A = 0;
			if(this.RGBA_A > 1) this.RGBA_A = 1;
			this.i_A.value = this.RGBA_A;
		}
	}
	
	///
	/// SETTERS H E X
	///
	
	setHEX(value) {
		this.HEX = value;
		this.i_HEX.value = this.HEX;
	}
	
	///
	/// SETTERS C M Y K
	///
	
	setCMYK_C(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_C.value = this.CMYK_C;
		} else {
			   this.CMYK_C = parseInt(v);
			if(this.CMYK_C < 0)   this.CMYK_C = 0;
			if(this.CMYK_C > 100) this.CMYK_C = 100;
		}
		this.i_C.value = this.CMYK_C;
	}
	
	setCMYK_M(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_M.value = this.CMYK_M;
		} else {
			   this.CMYK_M = parseInt(v);
			if(this.CMYK_M < 0)   this.CMYK_M = 0;
			if(this.CMYK_M > 100) this.CMYK_M = 100;
		}
		this.i_M.value = this.CMYK_M;
	}
	
	setCMYK_Y(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_Y.value = this.CMYK_Y;
		} else {
			   this.CMYK_Y = parseInt(v);
			if(this.CMYK_Y < 0)   this.CMYK_Y = 0;
			if(this.CMYK_Y > 100) this.CMYK_Y = 100;
		}
		this.i_Y.value = this.CMYK_Y;
	}
	
	setCMYK_K(value) {
		let v = value;
		if(isNaN(v)) {
			this.i_K.value = this.CMYK_K;
		} else {
			   this.CMYK_K = parseInt(v);
			if(this.CMYK_K < 0)   this.CMYK_K = 0;
			if(this.CMYK_K > 100) this.CMYK_K = 100;
		}
		this.i_K.value = this.CMYK_K;
	}
	
	///
	/// SETTERS R A L
	///
	
	setRAL(value) {
		this.RAL = COLOR_PICKER_RAL_CLASSIC_MAP[value];
	}
	
	updateData() {
		if(this.pickColorModalContainer.style.display == "block") {
			this.updH();
			this.updS();
			this.updL();
			this.updA();
		}
		let color = "hsla(" + this.H + ", " + this.S + "%, " + this.L + "%, " + this.A.toFixed(2) + ")";
		this.viewColor.style.background = color;
		this.pickView.style.background = color;
		this.viewColor.title = color;
		this.pickView.title = color;
	}
	
	 updateCanvas(canvasNode, canvasCtx, colorValue) {
		let h = canvasNode.height = canvasNode.offsetHeight;
		let w = canvasNode.width = canvasNode.offsetWidth - 4;
		canvasCtx.fillStyle = colorValue;
		canvasCtx.fillRect(0, 0, w, h);
	}
	
	updH() {
		let ctx = this.canvasHCanvas.getContext('2d');
		let hueGradient = ctx.createLinearGradient(0, 0, this.canvasHCanvas.width, 0);
		hueGradient.addColorStop(0.00, "hsl(360,	100%, 50%)");
		hueGradient.addColorStop(0.17, "hsl(61.2,	100%, 50%)");
		hueGradient.addColorStop(0.33, "hsl(118.8, 	100%, 50%)");
		hueGradient.addColorStop(0.50, "hsl(180, 	100%, 50%)");
		hueGradient.addColorStop(0.67, "hsl(241.2, 	100%, 50%)");
		hueGradient.addColorStop(0.83, "hsl(298.8, 	100%, 50%)");
		hueGradient.addColorStop(1.00, "hsl(0,		100%, 50%)");
		this.updateCanvas(this.canvasHCanvas, ctx, hueGradient);
		this.updatePosH();
		this.inputH.value = this.H;
	}
	
	updS() {
		let ctx = this.canvasSCanvas.getContext('2d');
		let hueGradient = ctx.createLinearGradient(0, 0, this.canvasSCanvas.width, 0);
		hueGradient.addColorStop(0.00, "hsl("+ this.H +"	,0%,		" + this.L + "%)");
		hueGradient.addColorStop(1.00, "hsl("+ this.H +"	,100%,		" + this.L + "%)");
		this.updateCanvas(this.canvasSCanvas, ctx, hueGradient);
		this.updatePosS();
		this.inputS.value = this.S;
	}
	
	updL() {
		let ctx = this.canvasLCanvas.getContext('2d');
		let hueGradient = ctx.createLinearGradient(0, 0, this.canvasLCanvas.width, 0);
		hueGradient.addColorStop(0.00, "hsl(" + this.H + ", " + this.S + "%, 0%)");
		hueGradient.addColorStop(0.50, "hsl(" + this.H + ", " + this.S + "%, 50%)");
		hueGradient.addColorStop(1.00, "hsl(" + this.H + ", " + this.S + "%, 100%)");
		this.updateCanvas(this.canvasLCanvas, ctx, hueGradient);
		this.updatePosL();
		this.inputL.value = this.L;
	}
	
	updA() {
		let ctx = this.canvasACanvas.getContext('2d');
		let hueGradient = ctx.createLinearGradient(0, 0, this.canvasACanvas.width, 0);
		hueGradient.addColorStop(0.00, "hsla(" + this.H + ", " + this.S + "%, " + this.L + "%, 0.0)");
		hueGradient.addColorStop(0.50, "hsla(" + this.H + ", " + this.S + "%, " + this.L + "%, 0.5)");
		hueGradient.addColorStop(1.00, "hsla(" + this.H + ", " + this.S + "%, " + this.L + "%, 1.0)");
		this.updateCanvas(this.canvasACanvas, ctx, hueGradient);
		this.updatePosA();
		this.inputA.value = this.A;
	}
	
	updatePosH() {
		let p = this.canvasHCanvas.width / 360;
		let x = (this.H) * p;
		this.canvasHButton.style.left = this.labelH.offsetWidth + x + "px";
	}
	
	updatePosS() {
		let p = this.canvasSCanvas.width / 100;
		let x = (this.S) * p;
		this.canvasSButton.style.left = this.labelS.offsetWidth + x + "px";
	}
	
	updatePosL() {
		let p = this.canvasLCanvas.width / 100;
		let x = (this.L) * p;
		this.canvasLButton.style.left = this.labelL.offsetWidth + x + "px";
	}
	
	updatePosA() {
		let p = this.canvasACanvas.width / 1;
		let x = (this.A) * p;
		this.canvasAButton.style.left = this.labelA.offsetWidth + x + "px";
	}
	
	getCanvasXPos(obj) {
		let x = 0;
		if (obj.offsetParent) {
			do x += obj.offsetLeft;
			while (obj = obj.offsetParent);
			return x;
		}
	}
	
	getValue(e, canvasNode, maxValue) {
		let posX = this.getCanvasXPos(canvasNode);
		let x = e.clientX - posX;
		x = e.offsetX;
		if(e.target.type === "submit") x = e.target.offsetLeft + e.offsetX - 20;
		let p = x / canvasNode.width;
		return ((maxValue * p));
	}
	
	chooseCanvasValue() {
		this.hslToRgb();
		this.rgbToHex(); 
		this.rgbToCmyk();
		this.checkRAL();
		
		this.updateData();
	}
	
	// EVENTS WHEEL
	eventWheel(e) {
		if(e.path) {
			if(e.path.indexOf(this.canvasHCanvas) !== -1 || e.path.indexOf(this.canvasHButton) !== -1) {
				if(e.wheelDelta > 0) this.setH(this.H + 1);
				else this.setH(this.H - 1);
			} else if(e.path.indexOf(this.canvasSCanvas) !== -1 || e.path.indexOf(this.canvasSButton) !== -1) {
				if(e.wheelDelta > 0) this.setS(this.S + 1);
				else this.setS(this.S - 1);
			} else if(e.path.indexOf(this.canvasLCanvas) !== -1 || e.path.indexOf(this.canvasLButton) !== -1) {
				if(e.wheelDelta > 0) this.setL(this.L + 1);
				else this.setL(this.L - 1);
			} else if(e.path.indexOf(this.canvasACanvas) !== -1 || e.path.indexOf(this.canvasAButton) !== -1) {
				if(e.wheelDelta > 0) this.setA(parseFloat(this.A + 0.1).toFixed(2));
				else this.setA(parseFloat(this.A - 0.1).toFixed(2));
			}
			
			this.chooseCanvasValue();
		}
	}
	
	// EVENTS MOVE
	eventMove(e) {
		if(e.which !== 1) return;
		if(e.path) {
			if(e.path.indexOf(this.canvasHCanvas) !== -1 || e.path.indexOf(this.canvasHButton) !== -1) {
				this.setH(parseInt(this.getValue(e, this.canvasHCanvas, 360)));
			} else if(e.path.indexOf(this.canvasSCanvas) !== -1 || e.path.indexOf(this.canvasSButton) !== -1) {
				this.setS(parseInt(this.getValue(e, this.canvasSCanvas, 100)));
			} else if(e.path.indexOf(this.canvasLCanvas) !== -1 || e.path.indexOf(this.canvasLButton) !== -1) {
				this.setL(parseInt(this.getValue(e, this.canvasLCanvas, 100)));
			} else if(e.path.indexOf(this.canvasACanvas) !== -1 || e.path.indexOf(this.canvasAButton) !== -1) {
				this.setA(parseFloat(this.getValue(e, this.canvasACanvas, 1)).toFixed(2));
			}
			
			this.chooseCanvasValue();
		}
	}
	
	// EVENTS INPUTS
	eventInputHSLA(e) {
		this.setH(this.inputH.value);
		this.setS(this.inputS.value);
		this.setL(this.inputL.value);
		this.setA(this.inputA.value);
		this.chooseCanvasValue();
	}
	
	eventInputRGBA(e) {
		this.setRGBA_R(this.i_R.value);
		this.setRGBA_G(this.i_G.value);
		this.setRGBA_B(this.i_B.value);
		this.setRGBA_A(this.i_A.value);
		
		this.rgbToHsl();
		this.rgbToHex();
		this.rgbToCmyk();
		this.checkRAL();
		
		this.updateData();
	}
	
	eventInputCMYK(e) {
		this.setCMYK_C(this.i_C.value);
		this.setCMYK_M(this.i_M.value);
		this.setCMYK_Y(this.i_Y.value);
		this.setCMYK_K(this.i_K.value);
		
		this.cmykToRgb();
		this.rgbToHsl();
		this.rgbToHex();
		this.checkRAL();
		
		this.updateData();
	}
	
	eventInputHEX(e) {
		this.setHEX(this.i_HEX.value);
		
		this.hexToRgb();
		this.rgbToHsl();
		this.rgbToCmyk();
		this.checkRAL();
		
		this.updateData();
	}
	
	eventInputRAL(e) {
		this.setRAL(this.i_RAL.value);
		if(this.RAL == null) {
			return;
		}
		this.setRGBA_R(this.RAL.r);
		this.setRGBA_G(this.RAL.g);
		this.setRGBA_B(this.RAL.b);
		this.setRGBA_A(1);
		
		this.rgbToHsl();
		this.rgbToHex();
		this.rgbToCmyk();
		
		this.updateData();
	}
	
	eventView(e) {
		this.pickColorModalContainer.style.display = "block";
		this.updateData();
	}
	
	eventOk(e) {
		this.pickColorModalContainer.style.display = "none";
		Rex.callRpcMethod('Widgets', this.id, this.type, 'changeColor', [this.HEX]);
	}
	
	eventHide(e) {
		this.pickColorModalContainer.style.display = "none";
		this.setHEX(this._pickedColor);
		this.hexToRgb();
		this.rgbToHsl();
		this.rgbToCmyk();
		this.checkRAL();
		this.updateData();
	}
	
	hslToRgb() {
		let h = this.H / 360;
		let s = this.S / 100;
		let l = this.L / 100;
		let r, g, b;
		
		if(s == 0) {
			r = g = b = l; // achromatic
		} else {
			function hue2rgb(p, q, t) {
				if(t < 0) t += 1;
				if(t > 1) t -= 1;
				if(t < 1 / 6) return p + (q - p) * 6 * t;
				if(t < 1 / 2) return q;
				if(t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
				return p;
			}
			let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			let p = 2 * l - q;
			r = hue2rgb(p, q, h + 1 / 3);
			g = hue2rgb(p, q, h);
			b = hue2rgb(p, q, h - 1 / 3);
		}
		
		this.setRGBA_R(r * 255);
		this.setRGBA_G(g * 255);
		this.setRGBA_B(b * 255);
		this.setRGBA_A(this.A);
	}
	
	rgbToHsl(){
		let r = this.RGBA_R / 255;
		let g = this.RGBA_G / 255;
		let b = this.RGBA_B / 255;
		
		let max = Math.max(r, g, b), min = Math.min(r, g, b);
		let h, s, l = (max + min) / 2;
		
		if(max == min){
			h = s = 0; // achromatic
		}else{
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			switch(max){
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}
		
		this.setH(h * 360);
		this.setS(s * 100);
		this.setL(l * 100);
		this.setA(this.RGBA_A);
	}
	
	rgbToHex() {
		let r = this.RGBA_R;
		let g = this.RGBA_G;
		let b = this.RGBA_B;
		let a = parseInt(this.RGBA_A * 255);
		
		function componentToHex(v) {
			var hex = v.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}
		this.setHEX(("#" + componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a)));
	}
	
	hexToRgb() {
		let hex = this.HEX;
		// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
		var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
		hex = hex.replace(shorthandRegex, function(m, r, g, b) {
			return r + r + g + g + b + b;
		});	
		
		let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		let result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		
		if(result != null) {
		this.setRGBA_R(parseInt(result[1], 16));
		this.setRGBA_G(parseInt(result[2], 16));
		this.setRGBA_B(parseInt(result[3], 16));
		this.setRGBA_A(1);
		} else if(result2 != null) {
			this.setRGBA_R(parseInt(result2[1], 16));
			this.setRGBA_G(parseInt(result2[2], 16));
			this.setRGBA_B(parseInt(result2[3], 16));
			this.setRGBA_A(parseInt(result2[4], 16) / 255);
		}
	}
	
	rgbToCmyk () {
		let r = this.RGBA_R;
		let g = this.RGBA_G;
		let b = this.RGBA_B;
		
		let computedC = 0;
		let computedM = 0;
		let computedY = 0;
		let computedK = 0;
		
		//remove spaces from input RGB values, convert to int
		r = parseInt( (''+r).replace(/\s/g,''),10 );
		g = parseInt( (''+g).replace(/\s/g,''),10 );
		b = parseInt( (''+b).replace(/\s/g,''),10 );
		
		// BLACK
		if (r == 0 && g == 0 && b == 0) {
			this.setCMYK_C(0);
			this.setCMYK_M(0);
			this.setCMYK_Y(0);
			this.setCMYK_K(1);
		}
		
		computedC = 1 - (r/255);
		computedM = 1 - (g/255);
		computedY = 1 - (b/255);
		
		let minCMY = Math.min(computedC, Math.min(computedM, computedY));
		computedC = (computedC - minCMY) / (1 - minCMY) ;
		computedM = (computedM - minCMY) / (1 - minCMY) ;
		computedY = (computedY - minCMY) / (1 - minCMY) ;
		computedK = minCMY;
		
		this.setCMYK_C(computedC * 100);
		this.setCMYK_M(computedM * 100);
		this.setCMYK_Y(computedY * 100);
		this.setCMYK_K(computedK * 100);
	}
	
	cmykToRgb() {
		let C = this.CMYK_C / 100;
		let M = this.CMYK_M / 100;
		let Y = this.CMYK_Y / 100;
		let K = this.CMYK_K / 100;
		
		let r = 255 * (1 - C) * (1 - K);
		let g = 255 * (1 - M) * (1 - K);
		let b = 255 * (1 - Y) * (1 - K);
		
		this.setRGBA_R(r);
		this.setRGBA_G(g);
		this.setRGBA_B(b);
		this.setRGBA_A(1);
	}
	
	checkRAL() {
		
		for(let k in COLOR_PICKER_RAL_CLASSIC_MAP) {
			let item = COLOR_PICKER_RAL_CLASSIC_MAP[k];
			if(item == null) continue;
			
			if((item.r != this.RGBA_R) || (item.g != this.RGBA_G) || (item.b != this.RGBA_B) || (1 != this.RGBA_A)) continue;
			this.i_RAL.value = k;
			this.setRAL(k);
			return;
		}
		this.i_RAL.value = "none";
	}
	
	onDestroy() {
		if(this.pickColorModalContainer == null) return;
		this.pickColorModalContainer.style.display = "none";
		this.pickColorModalContainer.remove();
		this.pickColorModalContainer = null;
	}
	
}

// Внимание! 
// Цвета на экране монитора ЗНАЧИТЕЛЬНО отличаются от печатных оригиналов из-за особенностей цветопередачи. 
// Данная таблица не может служить онлайн-каталогом и предоставлена только в ознакомительных целях. 
// Цвета RAL не имеют соответствий в системах: CMYK, Pantone, NCS, HTML или в RGB.

COLOR_PICKER_RAL_CLASSIC_MAP = {
	"1000" : { "r":"190", "g":"189", "b":"127", "hex":"#BEBD7F", "name" : "Green beige"},
	"1001" : { "r":"194", "g":"176", "b":"120", "hex":"#C2B078", "name" : "Beige"},
	"1002" : { "r":"198", "g":"166", "b":"100", "hex":"#C6A664", "name" : "Sand yellow"},
	"1003" : { "r":"229", "g":"190", "b":"001", "hex":"#E5BE01", "name" : "Signal yellow"},
	"1004" : { "r":"205", "g":"164", "b":"052", "hex":"#CDA434", "name" : "Golden yellow"},
	"1005" : { "r":"169", "g":"131", "b":"007", "hex":"#A98307", "name" : "Honey yellow"},
	"1006" : { "r":"228", "g":"160", "b":"016", "hex":"#E4A010", "name" : "Maize yellow"},
	"1007" : { "r":"220", "g":"156", "b":"000", "hex":"#DC9D00", "name" : "Daffodil yellow"},
	"1011" : { "r":"138", "g":"102", "b":"066", "hex":"#8A6642", "name" : "Brown beige"},
	"1012" : { "r":"199", "g":"180", "b":"070", "hex":"#C7B446", "name" : "Lemon yellow"},
	"1013" : { "r":"234", "g":"230", "b":"202", "hex":"#EAE6CA", "name" : "Oyster white"},
	"1014" : { "r":"225", "g":"204", "b":"079", "hex":"#E1CC4F", "name" : "Ivory"},
	"1015" : { "r":"230", "g":"214", "b":"144", "hex":"#E6D690", "name" : "Light ivory"},
	"1016" : { "r":"237", "g":"255", "b":"033", "hex":"#EDFF21", "name" : "Sulfur yellow"},
	"1017" : { "r":"245", "g":"208", "b":"051", "hex":"#F5D033", "name" : "Saffron yellow"},
	"1018" : { "r":"248", "g":"243", "b":"053", "hex":"#F8F32B", "name" : "Zinc yellow"},
	"1019" : { "r":"158", "g":"151", "b":"100", "hex":"#9E9764", "name" : "Grey beige"},
	"1020" : { "r":"153", "g":"153", "b":"080", "hex":"#999950", "name" : "Olive yellow"},
	"1021" : { "r":"243", "g":"218", "b":"011", "hex":"#F3DA0B", "name" : "Rape yellow"},
	"1023" : { "r":"250", "g":"210", "b":"001", "hex":"#FAD201", "name" : "Traffic yellow"},
	"1024" : { "r":"174", "g":"160", "b":"075", "hex":"#AEA04B", "name" : "Ochre yellow"},
	"1026" : { "r":"255", "g":"255", "b":"000", "hex":"#FFFF00", "name" : "Luminous yellow"},
	"1027" : { "r":"157", "g":"145", "b":"001", "hex":"#9D9101", "name" : "Curry"},
	"1028" : { "r":"244", "g":"169", "b":"000", "hex":"#F4A900", "name" : "Melon yellow"},
	"1032" : { "r":"214", "g":"174", "b":"001", "hex":"#D6AE01", "name" : "Broom yellow"},
	"1033" : { "r":"243", "g":"165", "b":"005", "hex":"#F3A505", "name" : "Dahlia yellow"},
	"1034" : { "r":"239", "g":"169", "b":"074", "hex":"#EFA94A", "name" : "Pastel yellow"},
	"1035" : { "r":"106", "g":"093", "b":"077", "hex":"#6A5D4D", "name" : "Pearl beige"},
	"1036" : { "r":"112", "g":"083", "b":"053", "hex":"#705335", "name" : "Pearl gold"},
	"1037" : { "r":"243", "g":"159", "b":"024", "hex":"#F39F18", "name" : "Sun yellow"},
	"2000" : { "r":"237", "g":"118", "b":"014", "hex":"#ED760E", "name" : "Yellow orange"},
	"2001" : { "r":"201", "g":"060", "b":"032", "hex":"#C93C20", "name" : "Red orange"},
	"2002" : { "r":"203", "g":"040", "b":"033", "hex":"#CB2821", "name" : "Vermilion"},
	"2003" : { "r":"255", "g":"117", "b":"020", "hex":"#FF7514", "name" : "Pastel orange"},
	"2004" : { "r":"244", "g":"070", "b":"017", "hex":"#F44611", "name" : "Pure orange"},
	"2005" : { "r":"255", "g":"035", "b":"001", "hex":"#FF2301", "name" : "Luminous orange"},
	"2007" : { "r":"255", "g":"164", "b":"032", "hex":"#FFA420", "name" : "Luminous bright orange"},
	"2008" : { "r":"247", "g":"094", "b":"037", "hex":"#F75E25", "name" : "Bright red orange"},
	"2009" : { "r":"245", "g":"064", "b":"033", "hex":"#F54021", "name" : "Traffic orange"},
	"2010" : { "r":"216", "g":"075", "b":"032", "hex":"#D84B20", "name" : "Signal orange"},
	"2011" : { "r":"236", "g":"124", "b":"038", "hex":"#EC7C26", "name" : "Deep orange"},
	"2012" : { "r":"235", "g":"106", "b":"014", "hex":"#E55137", "name" : "Salmon range"},
	"2013" : { "r":"195", "g":"088", "b":"049", "hex":"#C35831", "name" : "Pearl orange"},
	"3000" : { "r":"175", "g":"043", "b":"030", "hex":"#AF2B1E", "name" : "Flame red"},
	"3001" : { "r":"165", "g":"032", "b":"025", "hex":"#A52019", "name" : "Signal red"},
	"3002" : { "r":"162", "g":"035", "b":"029", "hex":"#A2231D", "name" : "Carmine red"},
	"3003" : { "r":"155", "g":"017", "b":"030", "hex":"#9B111E", "name" : "Ruby red"},
	"3004" : { "r":"117", "g":"021", "b":"030", "hex":"#75151E", "name" : "Purple red"},
	"3005" : { "r":"094", "g":"033", "b":"041", "hex":"#5E2129", "name" : "Wine red"},
	"3007" : { "r":"065", "g":"034", "b":"039", "hex":"#412227", "name" : "Black red"},
	"3009" : { "r":"100", "g":"036", "b":"036", "hex":"#642424", "name" : "Oxide re"},
	"3011" : { "r":"120", "g":"031", "b":"025", "hex":"#781F19", "name" : "Brown red"},
	"3012" : { "r":"193", "g":"135", "b":"107", "hex":"#C1876B", "name" : "Beige red"},
	"3013" : { "r":"161", "g":"035", "b":"018", "hex":"#A12312", "name" : "Tomato red"},
	"3014" : { "r":"211", "g":"110", "b":"112", "hex":"#D36E70", "name" : "Antique pink"},
	"3015" : { "r":"234", "g":"137", "b":"154", "hex":"#EA899A", "name" : "Light pink"},
	"3016" : { "r":"179", "g":"040", "b":"033", "hex":"#B32821", "name" : "Coral red"},
	"3017" : { "r":"230", "g":"050", "b":"068", "hex":"#E63244", "name" : "Rose"},
	"3018" : { "r":"213", "g":"048", "b":"050", "hex":"#D53032", "name" : "Strawberry red"},
	"3020" : { "r":"204", "g":"006", "b":"005", "hex":"#CC0605", "name" : "Traffic red"},
	"3022" : { "r":"217", "g":"080", "b":"048", "hex":"#D95030", "name" : "Salmon pink"},
	"3024" : { "r":"248", "g":"000", "b":"000", "hex":"#F80000", "name" : "Luminous red"},
	"3026" : { "r":"254", "g":"000", "b":"000", "hex":"#FE0000", "name" : "Luminous"},
	"3027" : { "r":"197", "g":"029", "b":"052", "hex":"#C51D34", "name" : "Raspberry red"},
	"3028" : { "r":"231", "g":"037", "b":"018", "hex":"#E72512", "name" : "Pure  red"},
	"3031" : { "r":"179", "g":"036", "b":"040", "hex":"#B32428", "name" : "Orient red"},
	"3032" : { "r":"114", "g":"020", "b":"034", "hex":"#721422", "name" : "Pearl ruby red"},
	"3033" : { "r":"180", "g":"076", "b":"067", "hex":"#B44C43", "name" : "Pearl pink"},
	"4001" : { "r":"222", "g":"076", "b":"138", "hex":"#6D3F5B", "name" : "Red lilac"},
	"4002" : { "r":"146", "g":"043", "b":"062", "hex":"#922B3E", "name" : "Red violet"},
	"4003" : { "r":"222", "g":"076", "b":"138", "hex":"#DE4C8A", "name" : "Heather violet"},
	"4004" : { "r":"110", "g":"028", "b":"052", "hex":"#641C34", "name" : "Claret violet"},
	"4005" : { "r":"108", "g":"070", "b":"117", "hex":"#6C4675", "name" : "Blue lilac"},
	"4006" : { "r":"160", "g":"052", "b":"114", "hex":"#A03472", "name" : "Traffic purple"},
	"4007" : { "r":"074", "g":"025", "b":"044", "hex":"#4A192C", "name" : "Purple violet"},
	"4008" : { "r":"140", "g":"086", "b":"138", "hex":"#8C568A", "name" : "Signal violet"},
	"4009" : { "r":"164", "g":"125", "b":"144", "hex":"#A18594", "name" : "Pastel violet"},
	"4010" : { "r":"215", "g":"045", "b":"109", "hex":"#CF3476", "name" : "Telemagenta"},
	"4011" : { "r":"134", "g":"115", "b":"161", "hex":"#8673A1", "name" : "Pearl violet"},
	"4012" : { "r":"108", "g":"104", "b":"129", "hex":"#6C6874", "name" : "Pearl black berry"},
	"5000" : { "r":"042", "g":"046", "b":"075", "hex":"#354D73", "name" : "Violet blue"},
	"5001" : { "r":"031", "g":"052", "b":"056", "hex":"#1F3438", "name" : "Green blue"},
	"5002" : { "r":"032", "g":"033", "b":"079", "hex":"#20214F", "name" : "Ultramarine blue"},
	"5003" : { "r":"029", "g":"030", "b":"051", "hex":"#1D1E33", "name" : "Saphire blue"},
	"5004" : { "r":"032", "g":"033", "b":"079", "hex":"#18171C", "name" : "Black blue"},
	"5005" : { "r":"030", "g":"045", "b":"110", "hex":"#1E2460", "name" : "Signal blue"},
	"5007" : { "r":"062", "g":"095", "b":"138", "hex":"#3E5F8A", "name" : "Brillant blue"},
	"5008" : { "r":"038", "g":"037", "b":"045", "hex":"#26252D", "name" : "Grey blue"},
	"5009" : { "r":"002", "g":"086", "b":"105", "hex":"#025669", "name" : "Azure blue"},
	"5010" : { "r":"014", "g":"041", "b":"075", "hex":"#0E294B", "name" : "Gentian blue"},
	"5011" : { "r":"035", "g":"026", "b":"036", "hex":"#231A24", "name" : "Steel blue"},
	"5012" : { "r":"059", "g":"131", "b":"189", "hex":"#3B83BD", "name" : "Light blue"},
	"5013" : { "r":"037", "g":"041", "b":"074", "hex":"#1E213D", "name" : "Cobalt blue"},
	"5014" : { "r":"096", "g":"111", "b":"140", "hex":"#606E8C", "name" : "Pigeon blue"},
	"5015" : { "r":"034", "g":"113", "b":"179", "hex":"#2271B3", "name" : "Sky blue"},
	"5017" : { "r":"006", "g":"057", "b":"113", "hex":"#063971", "name" : "Traffic blue"},
	"5018" : { "r":"063", "g":"136", "b":"143", "hex":"#3F888F", "name" : "Turquoise blue"},
	"5019" : { "r":"027", "g":"085", "b":"131", "hex":"#1B5583", "name" : "Capri blue"},
	"5020" : { "r":"029", "g":"051", "b":"074", "hex":"#1D334A", "name" : "Ocean blue"},
	"5021" : { "r":"037", "g":"109", "b":"123", "hex":"#256D7B", "name" : "Water blue"},
	"5022" : { "r":"037", "g":"040", "b":"080", "hex":"#252850", "name" : "Night blue"},
	"5023" : { "r":"073", "g":"103", "b":"141", "hex":"#49678D", "name" : "Distant blue"},
	"5024" : { "r":"093", "g":"155", "b":"155", "hex":"#5D9B9B", "name" : "Pastel blue"},
	"5025" : { "r":"042", "g":"100", "b":"120", "hex":"#2A6478", "name" : "Pearl gentian blue"},
	"5026" : { "r":"016", "g":"044", "b":"084", "hex":"#102C54", "name" : "Pearl night blue"},
	"6000" : { "r":"049", "g":"102", "b":"080", "hex":"#316650", "name" : "Patina green"},
	"6001" : { "r":"040", "g":"114", "b":"051", "hex":"#287233", "name" : "Emerald green"},
	"6002" : { "r":"045", "g":"087", "b":"044", "hex":"#2D572C", "name" : "Leaf green"},
	"6003" : { "r":"066", "g":"070", "b":"050", "hex":"#424632", "name" : "Olive green"},
	"6004" : { "r":"031", "g":"058", "b":"061", "hex":"#1F3A3D", "name" : "Blue green"},
	"6005" : { "r":"047", "g":"069", "b":"056", "hex":"#2F4538", "name" : "Moss green"},
	"6006" : { "r":"062", "g":"059", "b":"050", "hex":"#3E3B32", "name" : "Grey olive"},
	"6007" : { "r":"052", "g":"059", "b":"041", "hex":"#343B29", "name" : "Bottle green"},
	"6008" : { "r":"057", "g":"053", "b":"042", "hex":"#39352A", "name" : "Brown green"},
	"6009" : { "r":"049", "g":"055", "b":"043", "hex":"#31372B", "name" : "Fir green"},
	"6010" : { "r":"053", "g":"104", "b":"045", "hex":"#35682D", "name" : "Grass green"},
	"6011" : { "r":"088", "g":"114", "b":"070", "hex":"#587246", "name" : "Reseda green"},
	"6012" : { "r":"052", "g":"062", "b":"064", "hex":"#343E40", "name" : "Black green"},
	"6013" : { "r":"108", "g":"113", "b":"086", "hex":"#6C7156", "name" : "Reed green"},
	"6014" : { "r":"071", "g":"064", "b":"046", "hex":"#47402E", "name" : "Yellow olive"},
	"6015" : { "r":"059", "g":"060", "b":"054", "hex":"#3B3C36", "name" : "Black olive"},
	"6016" : { "r":"030", "g":"089", "b":"069", "hex":"#1E5945", "name" : "Turquoise green"},
	"6017" : { "r":"076", "g":"145", "b":"065", "hex":"#4C9141", "name" : "May green"},
	"6018" : { "r":"087", "g":"166", "b":"057", "hex":"#57A639", "name" : "Yellow green"},
	"6019" : { "r":"189", "g":"236", "b":"182", "hex":"#BDECB6", "name" : "Pastel green"},
	"6020" : { "r":"046", "g":"058", "b":"035", "hex":"#2E3A23", "name" : "Chrome green"},
	"6021" : { "r":"137", "g":"172", "b":"118", "hex":"#89AC76", "name" : "Pale green"},
	"6022" : { "r":"037", "g":"034", "b":"027", "hex":"#25221B", "name" : "Olive drab"},
	"6024" : { "r":"048", "g":"132", "b":"070", "hex":"#308446", "name" : "Traffic green"},
	"6025" : { "r":"061", "g":"100", "b":"045", "hex":"#3D642D", "name" : "Fern green"},
	"6026" : { "r":"001", "g":"093", "b":"082", "hex":"#015D52", "name" : "Opal green"},
	"6027" : { "r":"132", "g":"195", "b":"190", "hex":"#84C3BE", "name" : "Light green"},
	"6028" : { "r":"044", "g":"085", "b":"069", "hex":"#2C5545", "name" : "Pine green"},
	"6029" : { "r":"032", "g":"096", "b":"061", "hex":"#20603D", "name" : "Mint gree"},
	"6032" : { "r":"049", "g":"127", "b":"067", "hex":"#317F43", "name" : "Signal green"},
	"6033" : { "r":"073", "g":"126", "b":"118", "hex":"#497E76", "name" : "Mint turquoise"},
	"6034" : { "r":"127", "g":"181", "b":"181", "hex":"#7FB5B5", "name" : "Pastel turquoise"},
	"6035" : { "r":"028", "g":"084", "b":"045", "hex":"#1C542D", "name" : "Pearl green"},
	"6036" : { "r":"022", "g":"053", "b":"055", "hex":"#193737", "name" : "Pearl opal green"},
	"6037" : { "r":"036", "g":"231", "b":"017", "hex":"#24E711", "name" : "Pure green"},
	"6038" : { "r":"000", "g":"247", "b":"000", "hex":"#00F700", "name" : "Luminous green"},
	"7000" : { "r":"120", "g":"133", "b":"139", "hex":"#78858B", "name" : "Squirrel grey"},
	"7001" : { "r":"138", "g":"149", "b":"151", "hex":"#8A9597", "name" : "Silver grey"},
	"7002" : { "r":"126", "g":"123", "b":"082", "hex":"#7E7B52", "name" : "Olive grey"},
	"7003" : { "r":"108", "g":"112", "b":"089", "hex":"#6C7059", "name" : "Moss grey"},
	"7004" : { "r":"150", "g":"153", "b":"146", "hex":"#969992", "name" : "Signal grey"},
	"7005" : { "r":"100", "g":"107", "b":"099", "hex":"#646B63", "name" : "Mouse grey"},
	"7006" : { "r":"109", "g":"101", "b":"082", "hex":"#6D6552", "name" : "Beige grey"},
	"7008" : { "r":"106", "g":"095", "b":"049", "hex":"#6A5F31", "name" : "Khaki grey"},
	"7009" : { "r":"077", "g":"086", "b":"069", "hex":"#4D5645", "name" : "Green grey"},
	"7010" : { "r":"076", "g":"081", "b":"074", "hex":"#4C514A", "name" : "Tarpaulin grey"},
	"7011" : { "r":"067", "g":"075", "b":"077", "hex":"#434B4D", "name" : "Iron grey"},
	"7012" : { "r":"078", "g":"087", "b":"084", "hex":"#4E5754", "name" : "Basalt grey"},
	"7013" : { "r":"070", "g":"069", "b":"049", "hex":"#464531", "name" : "Brown grey"},
	"7015" : { "r":"067", "g":"071", "b":"080", "hex":"#434750", "name" : "Slate grey"},
	"7016" : { "r":"041", "g":"049", "b":"051", "hex":"#293133", "name" : "Anthracite grey"},
	"7021" : { "r":"035", "g":"040", "b":"043", "hex":"#23282B", "name" : "Black grey"},
	"7022" : { "r":"051", "g":"047", "b":"044", "hex":"#332F2C", "name" : "Umbra grey"},
	"7023" : { "r":"104", "g":"108", "b":"094", "hex":"#686C5E", "name" : "Concrete grey"},
	"7024" : { "r":"071", "g":"074", "b":"081", "hex":"#474A51", "name" : "Graphite grey"},
	"7026" : { "r":"047", "g":"053", "b":"059", "hex":"#2F353B", "name" : "Granite grey"},
	"7030" : { "r":"139", "g":"140", "b":"122", "hex":"#8B8C7A", "name" : "Stone grey"},
	"7031" : { "r":"071", "g":"075", "b":"078", "hex":"#474B4E", "name" : "Blue grey"},
	"7032" : { "r":"184", "g":"183", "b":"153", "hex":"#B8B799", "name" : "Pebble grey"},
	"7033" : { "r":"125", "g":"132", "b":"113", "hex":"#7D8471", "name" : "Cement grey"},
	"7034" : { "r":"143", "g":"139", "b":"102", "hex":"#8F8B66", "name" : "Yellow grey"},
	"7035" : { "r":"215", "g":"215", "b":"215", "hex":"#D7D7D7", "name" : "Light grey"},
	"7036" : { "r":"127", "g":"118", "b":"121", "hex":"#7F7679", "name" : "Platinum grey"},
	"7037" : { "r":"125", "g":"127", "b":"120", "hex":"#7D7F7D", "name" : "Dusty grey"},
	"7038" : { "r":"195", "g":"195", "b":"195", "hex":"#B5B8B1", "name" : "Agate grey"},
	"7039" : { "r":"108", "g":"105", "b":"096", "hex":"#6C6960", "name" : "Quartz grey"},
	"7040" : { "r":"157", "g":"161", "b":"170", "hex":"#9DA1AA", "name" : "Window grey"},
	"7042" : { "r":"141", "g":"148", "b":"141", "hex":"#8D948D", "name" : "Traffic grey A"},
	"7043" : { "r":"078", "g":"084", "b":"082", "hex":"#4E5452", "name" : "Traffic grey B"},
	"7044" : { "r":"202", "g":"196", "b":"176", "hex":"#CAC4B0", "name" : "Silk grey"},
	"7045" : { "r":"144", "g":"144", "b":"144", "hex":"#909090", "name" : "Telegrey 1"},
	"7046" : { "r":"130", "g":"137", "b":"143", "hex":"#82898F", "name" : "Telegrey 2"},
	"7047" : { "r":"208", "g":"208", "b":"208", "hex":"#D0D0D0", "name" : "Telegrey 4"},
	"7048" : { "r":"137", "g":"129", "b":"118", "hex":"#898176", "name" : "Pearl mouse grey"},
	"8000" : { "r":"130", "g":"108", "b":"052", "hex":"#826C34", "name" : "Green brown"},
	"8001" : { "r":"149", "g":"095", "b":"032", "hex":"#955F20", "name" : "Ochre brown"},
	"8002" : { "r":"108", "g":"059", "b":"042", "hex":"#6C3B2A", "name" : "Signal brown"},
	"8003" : { "r":"115", "g":"066", "b":"034", "hex":"#734222", "name" : "Clay brown"},
	"8004" : { "r":"142", "g":"064", "b":"042", "hex":"#8E402A", "name" : "Copper brown"},
	"8007" : { "r":"089", "g":"053", "b":"031", "hex":"#59351F", "name" : "Fawn brown"},
	"8008" : { "r":"111", "g":"079", "b":"040", "hex":"#6F4F28", "name" : "Olive brown"},
	"8011" : { "r":"091", "g":"058", "b":"041", "hex":"#5B3A29", "name" : "Nut brown"},
	"8012" : { "r":"089", "g":"035", "b":"033", "hex":"#592321", "name" : "Red brown"},
	"8014" : { "r":"056", "g":"044", "b":"030", "hex":"#382C1E", "name" : "Sepia brown"},
	"8015" : { "r":"099", "g":"058", "b":"052", "hex":"#633A34", "name" : "Chestnut brown"},
	"8016" : { "r":"076", "g":"047", "b":"039", "hex":"#4C2F27", "name" : "Mahogany brown"},
	"8017" : { "r":"069", "g":"050", "b":"046", "hex":"#45322E", "name" : "Chocolate brown"},
	"8019" : { "r":"064", "g":"058", "b":"058", "hex":"#403A3A", "name" : "Grey brown"},
	"8022" : { "r":"033", "g":"033", "b":"033", "hex":"#212121", "name" : "Black brown"},
	"8023" : { "r":"166", "g":"094", "b":"046", "hex":"#A65E2E", "name" : "Orange brown"},
	"8024" : { "r":"121", "g":"085", "b":"061", "hex":"#79553D", "name" : "Beige brown"},
	"8025" : { "r":"117", "g":"092", "b":"072", "hex":"#755C48", "name" : "Pale brown"},
	"8028" : { "r":"078", "g":"059", "b":"049", "hex":"#4E3B31", "name" : "Terra brown"},
	"8029" : { "r":"118", "g":"060", "b":"040", "hex":"#763C28", "name" : "Pearl copper"},
	"9001" : { "r":"250", "g":"244", "b":"227", "hex":"#FDF4E3", "name" : "Cream"},
	"9002" : { "r":"231", "g":"235", "b":"218", "hex":"#E7EBDA", "name" : "Grey white"},
	"9003" : { "r":"244", "g":"244", "b":"244", "hex":"#F4F4F4", "name" : "Signal white"},
	"9004" : { "r":"040", "g":"040", "b":"040", "hex":"#282828", "name" : "Signal black"},
	"9005" : { "r":"010", "g":"010", "b":"010", "hex":"#0A0A0A", "name" : "Jet black"},
	"9006" : { "r":"165", "g":"165", "b":"165", "hex":"#A5A5A5", "name" : "White aluminium"},
	"9007" : { "r":"143", "g":"143", "b":"143", "hex":"#8F8F8F", "name" : "Grey aluminium"},
	"9010" : { "r":"255", "g":"255", "b":"255", "hex":"#FFFFFF", "name" : "Pure white"},
	"9011" : { "r":"028", "g":"028", "b":"028", "hex":"#1C1C1C", "name" : "Graphite black"},
	"9016" : { "r":"246", "g":"246", "b":"246", "hex":"#F6F6F6", "name" : "Traffic white"},
	"9017" : { "r":"030", "g":"030", "b":"030", "hex":"#1E1E1E", "name" : "Traffic black"},
	"9018" : { "r":"215", "g":"215", "b":"215", "hex":"#D7D7D7", "name" : "Papyrus white"},
	"9022" : { "r":"156", "g":"156", "b":"156", "hex":"#9C9C9C", "name" : "Pearl light grey"},
	"9023" : { "r":"130", "g":"130", "b":"130", "hex":"#828282", "name" : "Pearl dark grey"}
};


class WidgetDiagramHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("div");
		this.addClassName("WidgetDiagram");

		this.header = "Diagram";
		this.needLegend = true;
		this.datas = [];
		this.items = [];
		this.maps = [];
		this.colors = [];

		this.headerContainer = document.createElement("div");
		this.headerContainer.classList.add("HeaderDiagramContainer");
		this.htmlElement.appendChild(this.headerContainer);

		this.headerDiagram = document.createElement("div");
		this.headerDiagram.classList.add("HeaderDiagram");
		this.headerDiagram.innerText = "Diagram:";
		this.headerContainer.appendChild(this.headerDiagram);

		this.buttonSettings = document.createElement("span");
		this.buttonSettings.classList.add("DiagramSetting");
		this.buttonSettings.classList.add("MaterialIcon");
		this.buttonSettings.innerText = "settings";
		this.headerContainer.appendChild(this.buttonSettings);

		this.diagramContainer = document.createElement("div");
		this.diagramContainer.classList.add("DiagramContainer");
		this.htmlElement.appendChild(this.diagramContainer);

		this.diagram = document.createElement("div");
		this.diagram.classList.add("ct-chart");
		this.diagram.classList.add("ct-golden-section");
		this.diagram.classList.add("SVGDiagram");
		this.diagramContainer.appendChild(this.diagram);

		this.legendsContainer = document.createElement("div");
		this.legendsContainer.classList.add("LegendContainer");
		this.diagramContainer.appendChild(this.legendsContainer);

		this.legendElement = document.createElement("span");
		this.legendElement.innerText = "Legends:";
		this.legendsContainer.appendChild(this.legendElement);

		this.buttonSettings.addEventListener("mouseup", (event) => {
			this.settingsPress();
		});
		
		try {
			new ResizeObserver(this.drawDiagram.bind(this)).observe(this.htmlElement);
		} catch(e) {}
	}

	onSetState(state) {
		if(state.header != null) {
			this.header = decodeURIComponent(escape(window.atob(state.header)));
			this.headerDiagram.innerText = this.header;
		}
		if(state.type3D != null) this.type3D = state.type3D;
		if(state.needLegend != null) {
			this.needLegend = state.needLegend;
			if(this.needLegend) {
				this.legendsContainer.style.display = "block";
			}
			else {
				this.legendsContainer.style.display = "none";
			}
		}
		if(state.legends != null && state.legends.length) {
			this.legends = [];
			this.legends = new Array(state.legends[0].length);
			for(let i in state.legends[0]) {
				let dt = new Array(state.legends[0][i].length);
				for(let k in state.legends[0][i]) {
					let data = new DataForDiagram();
					let caption = state.legends[0][i][k].caption;
					try {
						caption = decodeURIComponent(escape(window.atob(caption)));
					}
					catch (e) {
						caption = "Error decode";
					}
					let color = state.legends[0][i][k].color;
					dt[k] = {
						caption: caption,
						color: color
					};
				}
				this.legends[i] = dt;
			}
		}
		if(state.colors != null) this.colors = state.colors;
	}

	onInit() {
		this.diagram.id = `chart${this.widget.id}`;
		this.drawDiagram();
	}

	settingsPress() {
		Rex.callRpcMethod('Widgets', this.id, this.type, 'generateSettings', []);
	}

	drawDiagram(){
		this.clearDiagram();
		this.onDrawLegend();
	}

	clearLegend() {
		while(this.legendsContainer.childNodes.length > 1)
			this.legendsContainer.removeChild(this.legendsContainer.lastChild);
	}

	clearDiagram() {
		while(this.diagram.childNodes.length > 0)
			this.diagram.removeChild(this.diagram.lastChild);
	}

	onDrawLegend() {
		this.clearLegend();
		if(this.legends == null || this.legends.length === 0) return;
		for(let i = 0; i < this.items.length; ++i) {
			if(this.legends[i][0] == null) continue;
			let legend = document.createElement("div");
			legend.classList.add("Legend");
			this.legendsContainer.appendChild(legend);

			let colorBlock = document.createElement("div");
			colorBlock.classList.add("ColorBlock");
			colorBlock.id = `color-block-${this.widget.id}-${i}`;
			legend.appendChild(colorBlock);

			let captionBlock = document.createElement("div");
			captionBlock.classList.add("CaptionBlock");
			captionBlock.id = `caption-block-${this.widget.id}-${i}`;
			legend.appendChild(captionBlock);

			colorBlock.style.backgroundColor = this.legends[i][0].color;
			captionBlock.innerText = this.legends[i][0].caption;

            legend.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`series-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.opacity = 0.5;
                colorBlock.style.opacity = 0.5;
            });

            legend.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`series-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.opacity = null;
                colorBlock.style.opacity = null;
            });
		}
	}
}

class WidgetLineDiagramHtml extends WidgetDiagramHtml {

    constructor(widget) {
        super(widget);
        this.addClassName("WidgetLineDiagram");

        this.nameX = "X";
        this.nameY = "Y";
        this.needSpline = true;
        this.showArea = false;
        this.showOnlyArea = false;
        this.showPoints = true;
        this.needTopAxisX = false;
        this.needRightAxisY = false;
        this.stairStep = false;

        this.startX = 100;
        this.endX = 500;
    }

    onSetState(state) {
        super.onSetState(state);
	    if(state.type == "WidgetSchedule") return;
        if(state.nameX != null) this.nameX = decodeURIComponent(escape(window.atob(state.nameX)));
        if(state.nameY != null) this.nameY = decodeURIComponent(escape(window.atob(state.nameY)));
        if(state.needSpline != null) this.needSpline = state.needSpline;
        if(state.stairStep != null) this.stairStep = state.stairStep;
        if(state.showArea != null) this.showArea = state.showArea;
        if(state.showOnlyArea != null) this.showOnlyArea = state.showOnlyArea;
        if(state.showPoints != null) this.showPoints = state.showPoints;
        if(state.needTopAxisX != null) this.needTopAxisX = state.needTopAxisX;
        if(state.needRightAxisY != null) {
            this.needRightAxisY = state.needRightAxisY;
            if(this.needRightAxisY) this.startX = 20;
            else this.startX = 70;
        }
        if(state.maps != null) {
            this.maps = state.maps;
            if(state.maps.length === 0) {
                this.items = [];
            }
            else {
                this.items = new Array(state.maps[0].length);
                for(let i in state.maps[0]) {
                    let dt = new Array(state.maps[0][i].length);
                    for(let k in state.maps[0][i]) {
                        let data = new DataForDiagram();
                        data.name = state.maps[0][i][k].name;
                        data.name = decodeURIComponent(escape(window.atob(data.name)));
                        data.value = state.maps[0][i][k].value;
                        dt[k] = data;
                    }
                    this.items[i] = dt;
                }
            }
        }
        this.drawDiagram();
    }

    drawDiagram() {
        this.clearDiagram();
        this.onDrawLegend();

        let names = [];
        let series = [];
        for(let item of this.items) {
            if(!item) continue;
            let dots = [];
            for(let i = 0; i < item.length; ++i) {
                if(item[i].value === "NaN")
                    dots.push(null);
                else dots.push(item[i].value);
                let name = item[i].name;
                let index = names.indexOf(name);
                if(index === -1) names.push(name);
            }
            series.push(dots);
        }

        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("ct-chart-line");
        svg.style.width = "100%";
        svg.style.height = "100%";
        this.diagram.appendChild(svg);

        let svgNS = svg.namespaceURI;

        let gridsWidth = svg.clientWidth - 80;
        let gridsHeight = svg.clientHeight - 80;
        if(gridsWidth <= 0 || gridsHeight <= 0) return;

        this.endX = gridsWidth + this.startX;

        if(series.length === 0)
            this.drawEmpty(svgNS, svg, gridsWidth, gridsHeight);
        else this.drawSVG(names, series, svg, svgNS, gridsWidth, gridsHeight);
    }

    drawEmpty(svgNS, svg, gridsWidth, gridsHeight) {
        let wOx = (gridsWidth - 20) / 10;
        let wOy = gridsHeight / 9;

        let names = [];
        for(let i = 0; i < 10; ++i) {
            names.push(i);
        }

        this.drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, 10, 10);
        this.drawLabels(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, 10, 0, 10);
    }

    drawSVG(names, series, svg, svgNS, gridsWidth, gridsHeight) {
        let countLabelY = this.getCountLabelToSize(gridsHeight);

        let wOx = (gridsWidth - 20) / (names.length + 1);
        let wOy = gridsHeight / (countLabelY - 1);

        let min = series[0][0];
        let max = series[0][0];
        for(let i = 0; i < series.length; ++i) {
            for(let j = 0; j < series[i].length; ++j) {
                if(series[i][j] == null) continue;
                if(min > series[i][j])
                    min = series[i][j];
                if(max < series[i][j])
                    max = series[i][j];
            }
        }

        if(Math.abs(min - max) > 100) {
            if(Math.abs(max) > 100) max = Math.round(max * 1.05 / 100  + 0.4) * 100;
            else {
                if(max > 0)
                    max = Math.round(max + 0.4);
                else max = Math.round(max - 0.4);
            }
            if(Math.abs(min) > 100) min = Math.round(min * 1.05 / 100  - 0.4) * 100;
            else {
                min = Math.round(min - 0.4);
            }
        }
        else {
            min = Math.round(min - 0.4);
            if(max > 0)
                max = Math.round(max + 0.4);
            else max = Math.round(max - 0.4);
        }

        let s = Math.abs(max - min);

        let step = s / (countLabelY - 1);

        this.drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, countLabelY, names.length);
        this.drawLine(svgNS, svg, series, gridsHeight, wOx, wOy, s, min, max);
        this.drawLabels(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, countLabelY, min, step);
    }

    drawLine(svgNS, svg, series, gridsHeight, wOx, wOy, s, min, max) {
        if(series == undefined || series.length === 0) return;
        let diagrams = document.createElementNS(svgNS, "g");
        svg.appendChild(diagrams);

        for(let i = 0; i < series.length; ++i) {
            let line = document.createElementNS(svgNS, "g");
            line.classList.add("ct-series");
            line.style.stroke = this.colors[i];
            line.id = `series-${this.widget.id}-${i}`;
            diagrams.appendChild(line);

            let pathArea = undefined;
            if(this.showOnlyArea || this.showArea) {
                pathArea = document.createElementNS(svgNS, "path");
                pathArea.classList.add("ct-area");
                pathArea.style.fill = this.colors[i];
                pathArea.style.fillOpacity = 0.25;
                line.appendChild(pathArea);
            }

            let path = undefined;
            if(!this.showOnlyArea) {
                path = document.createElementNS(svgNS, "path");
                path.classList.add("ct-line");
                line.appendChild(path);
            }

            let x = this.startX;
            let d = "M";
            let seriesPoint = series[i][0];
            let dX = 0;
            if(series[i][0] == null) {
                let k = 1;
                while((seriesPoint == null) && k < series[i].length) {
                    if(series[i][k] != null) {
                        seriesPoint = series[i][k];
                    }
                    else ++k;
                }
                if(seriesPoint == null) continue;
                else dX = k * wOx;
            }
            let dArea = "M";
            dArea += x + dX;
            dArea += ",";
            dArea += gridsHeight + 20;
            dArea += ",L";
            dArea += x + dX;
            dArea += ",";
            dArea += gridsHeight + 20 - (((seriesPoint - min) / (max - min)) * gridsHeight);
            dArea += ",L";
            for(let j = 1; j <= series[i].length; ++j) {
                if(series[i][j - 1] == null) {
                    continue;
                }
                let y1 = gridsHeight + 20 - (((series[i][j - 1] - min) / (max - min)) * gridsHeight);
                let nextSeriesPoint = series[i][j];
                let deltaNextX = wOx;
                if(series[i][j] == null && j !== series[i].length) {
                    let k = j + 1;
                    while((nextSeriesPoint == null) && k < series[i].length) {
                        if(series[i][k] != null) {
                            nextSeriesPoint = series[i][k];
                            deltaNextX += wOx;
                        }
                        else {
                            ++k;
                            deltaNextX += wOx;
                        }
                    }
                    if(nextSeriesPoint == null) continue;
                    // else deltaNextX = (k - j) * wOx;
                }
                let y2 = gridsHeight + 20 - (((nextSeriesPoint - min) / (max - min)) * gridsHeight);
                if(path != undefined) {
                    d += x;
                    d += ",";
                    d += y1;
                    d += ",";
                    if(this.needSpline && j !== series[i].length) {
                        let difference =  deltaNextX / 2;
                        d += "C";
                        d += x + difference;
                        d += ",";
                        d += y1;
                        d += ",";
                        d += x + difference;
                        d += ",";
                        d += y2;
                        d += ",";
                    }
                    else if(this.stairStep && j !== series[i].length) {
                        d += "L";
                        d += x + deltaNextX;
                        d += ",";
                        d += y1;
                        d += ",L";
                        d += x + deltaNextX;
                        d += ",";
                        d += y2;
                        d += ",L";
                    }
                }
                if(pathArea != undefined) {
                    if(this.needSpline) {
                        dArea += x;
                        dArea += ",";
                        dArea += y1;
                        if(j !== series[i].length) {
                            let difference = deltaNextX / 2;
                            dArea += ",C";
                            dArea += x + difference;
                            dArea += ",";
                            dArea += y1;
                            dArea += ",";
                            dArea += x + difference;
                            dArea += ",";
                            dArea += y2;
                            dArea += ",";
                        }
                        else {
                            dArea += ",L";
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                    else if(this.stairStep) {
                        if(j !== series[i].length) {
                            dArea += x + deltaNextX;
                            dArea += ",";
                            dArea += y1;
                            dArea += ",L";
                            dArea += x + deltaNextX;
                            dArea += ",";
                            dArea += y2;
                            dArea += ",L";
                        }
                        else {
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                    else {
                        dArea += x;
                        dArea += ",";
                        dArea += y1;
                        dArea += ",";
                        if(j === series[i].length) {
                            dArea += "L";
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                }

                if(this.showPoints && !this.showOnlyArea) {
                    let point = document.createElementNS(svgNS, "line");
                    point.classList.add("ct-point");
                    line.appendChild(point);

                    point.setAttribute("x1", x);
                    point.setAttribute("x2", x + 0.01);
                    point.setAttribute("y1", y1);
                    point.setAttribute("y2", y1);
                    point.setAttribute("value", series[i][j - 1]);

                    let title = document.createElementNS(svgNS, "title");
                    title.textContent = "Value = " + series[i][j - 1];
                    point.appendChild(title);

                    if(!this.needSpline && this.stairStep && j !== series[i].length) {
                        let point2 = document.createElementNS(svgNS, "line");
                        point2.classList.add("ct-point");
                        line.appendChild(point2);

                        point2.setAttribute("x1", x + wOx);
                        point2.setAttribute("x2", x + wOx + 0.01);
                        point2.setAttribute("y1", y1);
                        point2.setAttribute("y2", y1);
                        point2.setAttribute("value", series[i][j - 1]);

                        let title2 = document.createElementNS(svgNS, "title");
                        title2.textContent = "Value = " + series[i][j - 1];
                        point2.appendChild(title2);
                    }
                }

                x += deltaNextX;
            }
            if(path != undefined)
                path.setAttribute("d", d);
            if(pathArea != undefined)
                pathArea.setAttribute("d", dArea);

            line.addEventListener("mouseover", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = 0.5;
                elementCaption.style.fontWeight = "bold";
                line.style.opacity = 0.5;
            });

            line.addEventListener("mouseout", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = null;
                elementCaption.style.fontWeight = null;
                line.style.opacity = null;
            });
        }
    }

    getCountLabelToSize(size) {
        if(size <= 20) return 1;
        if(size <= 40) return 2;
        let count = 2;
        let flag = false;
        while(!flag) {
            let newCount = (count * 40 - 20) / 20;
            if((size / newCount) <= 40)
                flag = true;
            count = newCount;
        }
        return count;
    }

    drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, countLabelY, countLabelX) {
        let grid = document.createElementNS(svgNS, "g");
        grid.classList.add("ct-grids");
        svg.appendChild(grid);

        //вертикальные линии
        let x = this.startX;
        for(let i = 0; i <= countLabelX; ++i) {
            let line = document.createElementNS(svgNS, "line");
            line.classList.add("ct-grid");
            line.classList.add("ct-vertical");
            line.id = `ct-vertical-${this.widget.id}-${i}`;
            grid.appendChild(line);

            line.setAttribute("x1", x);
            line.setAttribute("x2", x);

            line.setAttribute("y1", 20);
            line.setAttribute("y2", gridsHeight + 20);

            x += wOx;
        }

        //горизонтальные линии
        let y = gridsHeight + 20;
        for(let i = 0; i < countLabelY; ++i) {
            let line = document.createElementNS(svgNS, "line");
            line.classList.add("ct-grid");
            line.classList.add("ct-horizontal");
            line.id = `ct-horizontal-${this.widget.id}-${i}`;
            grid.appendChild(line);

            line.setAttribute("x1", this.startX - 5);
            line.setAttribute("x2", this.endX - 10);

            line.setAttribute("y1", y);
            line.setAttribute("y2", y);

            y -= wOy;
        }
    }

    drawLabels(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, countLabelY, min, step) {
        let lables = document.createElementNS(svgNS, "g");
        lables.classList.add("ct-labels");
        svg.appendChild(lables);

        //подписи оси х
        let x = this.startX - 2;

        for(let i = 0; i < names.length; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", 50);
            foreignObject.setAttribute("width", wOx);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = "50px";
            span.style.width = wOx + "px";
            span.textContent = names[i];

            let title = document.createElementNS(svgNS, "title");
            title.textContent = names[i];
            foreignObject.appendChild(title);

            foreignObject.appendChild(span);
            foreignObject.setAttribute("x", x);
            if(this.needTopAxisX)
                foreignObject.setAttribute("y", 0);
            else foreignObject.setAttribute("y", gridsHeight + 30);

            x += wOx;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }

        //подписи оси y
        let y = gridsHeight + 7;

        for(let i = 0; i < countLabelY; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", wOy);
            foreignObject.setAttribute("width", 50);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = wOy + "px";
            span.style.width = "50px";

            let title = document.createElementNS(svgNS, "title");
            foreignObject.appendChild(title);

            if(countLabelY === 1) {
                span.textContent = min;
                title.textContent = min;
            }
            else {
                span.textContent = min + step * i;
                title.textContent = min + step * i;
            }
            foreignObject.appendChild(span);

            span.setAttribute("height", wOy);
            span.setAttribute("width", 50);
            if(this.needRightAxisY)
                foreignObject.setAttribute("x", this.endX);
            else foreignObject.setAttribute("x", 20);

            foreignObject.setAttribute("y", y);

            y -= wOy;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }
    }
}

/**
 * WidgetBarDiagram
 */

class WidgetBarDiagramHtml extends WidgetLineDiagramHtml {
	constructor(widget) {
		super(widget);
		this.addClassName("WidgetBarDiagram");

		this.stacked = false;
		this.orientation = false;
	}

	onSetState(state) {
		if(state.stacked != null) this.stacked = state.stacked;
		if(state.orientation != null) this.orientation = state.orientation;
		super.onSetState(state);
	}

    drawDiagram(){
        super.drawDiagram();
    }

    drawSVG(names, series, svg, svgNS, gridsWidth, gridsHeight) {
        if(this.orientation)
            this.drawHorizontal(names, series, svg, svgNS, gridsWidth - 20, gridsHeight);
        else this.drawVertical(names, series, svg, svgNS, gridsWidth, gridsHeight);
	}

    drawHorizontal(names, series, svg, svgNS, gridsWidth, gridsHeight) {
        if(this.needRightAxisY) this.startX = 20;
        else this.startX = 70;

        let countLabelX = this.getCountLabelToSize(gridsWidth);

        let wOx = gridsWidth / (countLabelX - 1);
        let wOy = gridsHeight / (names.length + 1);

		let min = series[0][0];
        let max = series[0][0];
        let maxLength = 0;

        if(!this.stacked) {
            for(let i = 0; i < series.length; ++i) {
                for(let j = 0; j < series[i].length; ++j) {
                    if(maxLength < series[i].length)
                        maxLength = series[i].length;
                    if(min > series[i][j])
                        min = series[i][j];
                    if(max < series[i][j])
                        max = series[i][j];
                }
            }
        }
        else {
            let maxElem = series[0][0];
            let maxSum = series[0][0];
            for(let i = 0; i < series.length; ++i) {
                for(let j = 0; j < series[i].length; ++j) {
                    if(maxLength < series[i].length)
                        maxLength = series[i].length;
                }
            }
            for(let i = 0; i < maxLength; ++i) {
                let m = 0;
                for(let j = 0; j < series.length; ++j) {
                    if(series[j][i] == null) continue;
                    if(min > series[j][i])
                        min = series[j][i];
                    if(maxElem < series[j][i])
                        maxElem = series[j][i];
                    m += series[j][i];
                }
                if(maxSum < m)
                    maxSum = m;
            }
            max = (maxElem * series.length - maxSum) < 3 ? maxElem * series.length : maxSum;
        }

        if(Math.abs(min - max) > 100) {
            if(Math.abs(max) > 100) max = Math.round(max * 1.05 / 100  + 0.4) * 100;
            else {
                if(max > 0)
                    max = Math.round(max + 0.4);
                else max = Math.round(max - 0.4);
            }
            if(Math.abs(min) > 100) min = Math.round(min * 1.05 / 100  - 0.4) * 100;
            else {
                min = Math.round(min - 0.4);
            }
        }
        else {
            min = Math.round(min - 0.4);
            if(max > 0)
                max = Math.round(max + 0.4);
            else max = Math.round(max - 0.4);
        }

        let s = Math.abs(max - min);

        let step = s / (countLabelX - 1);

        this.drawGridHorizontal(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, countLabelX, names.length);
        this.drawLineHorizontal(svgNS, svg, series, gridsHeight, wOx, wOy, s, maxLength, gridsWidth, min, max);
        this.drawLabelsHorizontal(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, countLabelX, min, step);
	}

    drawVertical(names, series, svg, svgNS, gridsWidth, gridsHeight) {
        let countLabelY = this.getCountLabelToSize(gridsHeight);

        let wOx = (gridsWidth - 20) / (names.length + 1);
        let wOy = gridsHeight / (countLabelY - 1);

        let min = series[0][0];
        let max = series[0][0];
        let maxLength = 0;

        if(!this.stacked) {
            for(let i = 0; i < series.length; ++i) {
                for(let j = 0; j < series[i].length; ++j) {
                    if(maxLength < series[i].length)
                        maxLength = series[i].length;
                    if(min > series[i][j])
                        min = series[i][j];
                    if(max < series[i][j])
                        max = series[i][j];
                }
            }
        }
        else {
            let maxElem = series[0][0];
            let maxSum = series[0][0];
            for(let i = 0; i < series.length; ++i) {
                for(let j = 0; j < series[i].length; ++j) {
                    if(maxLength < series[i].length)
                        maxLength = series[i].length;
                }
            }
            for(let i = 0; i < maxLength; ++i) {
                let m = 0;
                for(let j = 0; j < series.length; ++j) {
                    if(series[j][i] == null) continue;
                    if(min > series[j][i])
                        min = series[j][i];
                    if(maxElem < series[j][i])
                        maxElem = series[j][i];
                    m += series[j][i];
                }
                if(maxSum < m)
                    maxSum = m;
            }
            max = (maxElem * series.length - maxSum) < 3 ? maxElem * series.length : maxSum;
        }

        if(Math.abs(min - max) > 100) {
            if(Math.abs(max) > 100) max = Math.round(max * 1.05 / 100  + 0.4) * 100;
            else {
                if(max > 0)
                    max = Math.round(max + 0.4);
                else max = Math.round(max - 0.4);
            }
            if(Math.abs(min) > 100) min = Math.round(min * 1.05 / 100  - 0.4) * 100;
            else {
                min = Math.round(min - 0.4);
            }
        }
        else {
            min = Math.round(min - 0.4);
            if(max > 0)
                max = Math.round(max + 0.4);
            else max = Math.round(max - 0.4);
        }

        let s = Math.abs(max - min);

        let step = s / (countLabelY - 1);

        this.drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, countLabelY, names.length);
        this.drawLineVertical(svgNS, svg, series, gridsHeight, wOx, wOy, s, maxLength, min, max);
        this.drawLabels(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, countLabelY, min, step);
	}

    drawGridHorizontal(svgNS, svg, series, gridsHeight, wOx, wOy, countLabelX, countLabelY) {
        let grid = document.createElementNS(svgNS, "g");
        grid.classList.add("ct-grids");
        svg.appendChild(grid);

        //вертикальные линии
        let x = this.startX;
        for(let i = 0; i < countLabelX; ++i) {
            let line = document.createElementNS(svgNS, "line");
            line.classList.add("ct-grid");
            line.classList.add("ct-vertical");
            line.id = `ct-vertical-${this.widget.id}-${i}`;
            grid.appendChild(line);

            line.setAttribute("x1", x);
            line.setAttribute("x2", x);

            line.setAttribute("y1", 20);
            line.setAttribute("y2", gridsHeight + 20);

            x += wOx;
        }

        //горизонтальные линии
        let y = gridsHeight + 20;
        for(let i = 0; i <= countLabelY; ++i) {
            let line = document.createElementNS(svgNS, "line");
            line.classList.add("ct-grid");
            line.classList.add("ct-horizontal");
            line.id = `ct-horizontal-${this.widget.id}-${i}`;
            grid.appendChild(line);

            line.setAttribute("x1", this.startX - 5);
            line.setAttribute("x2", this.endX - 10);

            line.setAttribute("y1", y);
            line.setAttribute("y2", y);

            y -= wOy;
        }
	}

    drawLineVertical(svgNS, svg, series, gridsHeight, wOx, wOy, s, maxLength, min, max) {
        let diagrams = document.createElementNS(svgNS, "g");
        svg.appendChild(diagrams);
        let x = 0;
        let y1 = 0;
        let y2 = 0;
        let arr = [];
        for(let i = 0; i < maxLength; ++i) {
            arr.push(gridsHeight + 20);
        }
        for(let i = 0; i < series.length; ++i) {
            let line = document.createElementNS(svgNS, "g");
            line.classList.add("ct-series");
            line.style.stroke = this.colors[i];
            line.id = `series-${this.widget.id}-${i}`;
            diagrams.appendChild(line);

            let lineWidth = wOx / series.length > 10 ? 10 : wOx / series.length;
            if(this.stacked) wOx > 10 ? lineWidth = 10 : lineWidth = wOx;
            if(this.stacked) {
                x = this.startX  + lineWidth / 2;
                y1 = gridsHeight + 20;
            }
            else {
                x = this.startX + (lineWidth * i) + lineWidth / 2;
                y1 = gridsHeight + 20;
            }

            for(let j = 0; j < series[i].length; ++j) {
                let bar = document.createElementNS(svgNS, "line");
                bar.classList.add("ct-bar");
                if(!this.stacked) bar.style.strokeWidth = lineWidth;
                line.appendChild(bar);

                bar.setAttribute("x1", x);
                bar.setAttribute("x2", x + 0.01);
                if(!this.stacked) {
                    y2 = gridsHeight + 20 - (((series[i][j] - min) / (max - min)) * gridsHeight);
                    bar.setAttribute("y1", y1);
                    bar.setAttribute("y2", y2);
                }
                else {
                    y1 = arr[j];
                    y2 = y1 - (((series[i][j] - min) / (max - min)) * gridsHeight);
                    bar.setAttribute("y1", y1);
                    bar.setAttribute("y2", y2);
                    arr[j] = y2;
                }
                bar.setAttribute("value", series[i][j]);

                let title = document.createElementNS(svgNS, "title");
                title.textContent = "Value = " + series[i][j];
                bar.appendChild(title);

                x += wOx;
            }
            line.addEventListener("mouseover", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = 0.5;
                elementCaption.style.fontWeight = "bold";
            });

            line.addEventListener("mouseout", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = null;
                elementCaption.style.fontWeight = null;
            });
        }
	}

    drawLineHorizontal(svgNS, svg, series, gridsHeight, wOx, wOy, s, maxLength, gridsWidth, min, max) {
        let diagrams = document.createElementNS(svgNS, "g");
        svg.appendChild(diagrams);
        let x1 = 0;
        let x2 = 0;
        let y = gridsHeight + 20;

        let arr = [];
        for(let i = 0; i < maxLength; ++i) {
            arr.push(this.startX);
        }
        for(let i = 0; i < series.length; ++i) {
            let line = document.createElementNS(svgNS, "g");
            line.classList.add("ct-series");
            line.style.stroke = this.colors[i];
            line.id = `series-${this.widget.id}-${i}`;
            diagrams.appendChild(line);

            let lineWidth = wOy / series.length > 10 ? 10 : wOy / series.length;
            if(this.stacked)lineWidth = wOy > 10 ? 10 : wOy;

            if(this.stacked) {
                x1 = this.startX;
                y = gridsHeight + 20 - (lineWidth / 2);
            }
            else {
                y = gridsHeight + 20 - (wOy / series.length) * i - (lineWidth / 2);
                x1 = this.startX;
            }

            for(let j = 0; j < series[i].length; ++j) {
                let bar = document.createElementNS(svgNS, "line");
                bar.classList.add("ct-bar");
                if(!this.stacked) bar.style.strokeWidth = lineWidth;
                line.appendChild(bar);

                bar.setAttribute("y1", y);
                bar.setAttribute("y2", y + 0.01);
                if(!this.stacked) {
                    x2 = this.startX  + (((series[i][j] - min) / (max - min)) * gridsWidth);
                    bar.setAttribute("x1", x1);
                    bar.setAttribute("x2", x2);
                }
                else {
                    x1 = arr[j];
                    x2 = x1 + (((series[i][j] - min) / (max - min)) * gridsWidth);
                    bar.setAttribute("x1", x1);
                    bar.setAttribute("x2", x2);
                    arr[j] = x2;
                }
                bar.setAttribute("value", series[i][j]);

                let title = document.createElementNS(svgNS, "title");
                title.textContent = "Value = " + series[i][j];
                bar.appendChild(title);

                y -= wOy;
            }
            line.addEventListener("mouseover", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = 0.5;
                elementCaption.style.fontWeight = "bold";
            });

            line.addEventListener("mouseout", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = null;
                elementCaption.style.fontWeight = null;
                line.style.opacity = null;
            });
        }
	}

	drawLabelsHorizontal(svgNS, svg, wOx, wOy, names, gridsWidth, gridsHeight, countLabelX, min, step) {
        let lables = document.createElementNS(svgNS, "g");
        lables.classList.add("ct-labels");
        svg.appendChild(lables);

        //подписи оси х
        let x = this.startX - 2;
        for(let i = 0; i < countLabelX; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", 50);
            foreignObject.setAttribute("width", wOx);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = "50px";
            span.style.width = wOx + "px";
            let title = document.createElementNS(svgNS, "title");
            foreignObject.appendChild(title);
            if(countLabelX === 1) {
                span.textContent = min;
                title.textContent = min;
            }
            else {
                title.textContent = min + step * i;
                span.textContent = min + step * i;
            }

            foreignObject.appendChild(span);
            foreignObject.setAttribute("x", x);
            if(this.needTopAxisX)
                foreignObject.setAttribute("y", 0);
            else foreignObject.setAttribute("y", gridsHeight + 30);

            x += wOx;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }

        //подписи оси y
        let y = gridsHeight + 7;
        for(let i = 0; i < names.length; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", wOy);
            foreignObject.setAttribute("width", 50);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = wOy + "px";
            span.style.width = "50px";
            span.textContent = names[i];

            let title = document.createElementNS(svgNS, "title");
            foreignObject.appendChild(title);
            title.textContent = names[i];

            foreignObject.appendChild(span);

            span.setAttribute("height", wOy);
            span.setAttribute("width", 50);
            if(this.needRightAxisY)
                foreignObject.setAttribute("x", this.endX);
            else foreignObject.setAttribute("x", 20);

            foreignObject.setAttribute("y", y);

            y -= wOy;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }
	}
}



'use strict';

class WidgetCircularDiagramHtml extends WidgetDiagramHtml {

    constructor(widget) {
        super(widget);
        this.addClassName("WidgetCirculDiagram");

        this.sectorVis = false;
        this.inPercent = false;
        this.donut = false;
        this.donutWidth = 60;
        this.gauge = false;
    }

    onSetState(state) {
        super.onSetState(state);
        if(state.sectorVis != null) this.sectorVis = state.sectorVis;
        if(state.inPercent != null) this.inPercent = state.inPercent;
        if(state.donut != null) this.donut = state.donut;
        if(state.donutWidth != null) this.donutWidth = state.donutWidth;
        if(state.gauge != null) this.gauge = state.gauge;
        if(state.datas != null) {
            if(state.datas.length === 0) {
                this.items = [];
            }
            else {
                this.datas = state.datas;
                this.items = new Array(state.datas.length);
                for(let i = 0; i < state.datas.length; ++i) {
                    let data = new DataForDiagram();
                    data.name = state.datas[i].name;
                    data.value = state.datas[i].value;
                    this.items[i] = data;
                }
            }
        }
        this.drawDiagram();
    }

    drawDiagram() {
        this.clearDiagram();
        this.onDrawLegend();

        let names = [];
        let series = [];
        let sum = 0;
        for(let item of this.items) {
            if(!item) continue;
            names.push(item.name);
            series.push(item.value);
            sum += item.value;
        }

        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.style.width = "100%";
        svg.style.height = "100%";
        this.diagram.appendChild(svg);

        let svgNS = svg.namespaceURI;

        let gridsWidth = svg.clientWidth - 20;
        let gridsHeight = svg.clientHeight - 20;

        if(gridsWidth <= 0 || gridsHeight <= 0) return;

        if(series.length === 0) return;

        let radius = this.gauge ? Math.min(gridsWidth, gridsHeight * 2) / 2 : Math.min(gridsWidth, gridsHeight) / 2;

        let innerRadius = this.donut ? radius - this.donutWidth : 0;

        let coef = this.gauge ? 180 / sum : 360 / sum;

        let centerPoint = {
            x: gridsWidth / 2 + 10,
            y: this.gauge ? gridsHeight - (gridsHeight - radius) / 2 : gridsHeight / 2 + 10
        };

        let startAngle = this.gauge ? 270 : 0;

        if(series.length === 1 && !this.gauge) {
            this.drawOne(svg, svgNS, radius, innerRadius, centerPoint, series[0], names[0]);
            return;
        }

        let parts = document.createElementNS(svgNS, "g");
        svg.appendChild(parts);

        let labels = document.createElementNS(svgNS, "g");
        svg.appendChild(labels);

        for(let i = 0; i < series.length; ++i) {
            if(series[i] === 0 || series[i] == null) continue;
            let part = document.createElementNS(svgNS, "g");
            part.classList.add("ct-series");
            part.style.fill = this.colors[i];
            part.style.stroke = this.colors[i];
            part.style.strokeWidth = "1";
            part.id = `series-${this.widget.id}-${i}`;
            parts.appendChild(part);

            let path = document.createElementNS(svgNS, "path");
            path.classList.add(this.donut ? "ct-slice-donut-solid" : "ct-slice-pie");
            path.setAttribute("value", series[i]);
            part.appendChild(path);

            let title = document.createElementNS(svgNS, "title");
            title.textContent = "Value = " + series[i];
            path.appendChild(title);

            let angle = series[i] * coef;
            let endAngle = startAngle + angle;

            let startAngleInRadians = this.angleInDegreesToRadians(startAngle);
            let endAngleInRadians = this.angleInDegreesToRadians(endAngle);

            let largeArc = endAngleInRadians - startAngleInRadians > Math.PI;

            let points = this.arc(centerPoint.x, centerPoint.y, startAngleInRadians, endAngleInRadians, radius, innerRadius);

            let pathD = this.getPath(points, radius, largeArc, innerRadius);

            path.setAttribute("d", pathD);

            let angleLabel = startAngle + angle / 2;

            let innerRadiusLabel = this.donut ? radius - this.donutWidth / 2 : radius / 2;
            let coordinateLabel = this.polarToCartesian(centerPoint.x, centerPoint.y, innerRadiusLabel, angleLabel);

            let label = document.createElementNS(svgNS, "text");

            label.classList.add("ct-label");
            label.setAttribute("dx", coordinateLabel.x);
            label.setAttribute("dy", coordinateLabel.y);
            label.setAttribute("text-anchor", "middle");
            if(this.inPercent) {
                let percent = series[i] / sum * 100;
                label.textContent = Math.round(percent * 100) / 100 + "%";
            }
            else label.textContent = names[i];
            labels.appendChild(label);

            startAngle = endAngle;

            part.addEventListener("mouseover", this.hoverRedraw.bind(this, i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc));
            label.addEventListener("mouseover", this.hoverRedraw.bind(this, i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc));


            part.addEventListener("mouseout", this.notHoverRedraw.bind(this, i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc));
            label.addEventListener("mouseout", this.notHoverRedraw.bind(this, i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc));
        }
    }

    hoverRedraw(i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc) {
        let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
        let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
        if(elementColor == null || elementCaption == null) return;
        elementColor.style.opacity = 0.5;
        elementCaption.style.fontWeight = "bold";

        let newPoints = this.arc(centerPoint.x, centerPoint.y, startAngleInRadians, endAngleInRadians, radius + 10, innerRadius);

        let newPathD = this.getPath(newPoints, radius + 10, largeArc, innerRadius);

        path.setAttribute("d", newPathD);

    }

    notHoverRedraw(i, part, path, centerPoint, startAngleInRadians, endAngleInRadians, radius, innerRadius, largeArc) {
        let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
        let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
        if(elementColor == null || elementCaption == null) return;
        elementColor.style.opacity = null;
        elementCaption.style.fontWeight = null;

        let newPoints = this.arc(centerPoint.x, centerPoint.y, startAngleInRadians, endAngleInRadians, radius, innerRadius);

        let newPathD = this.getPath(newPoints, radius, largeArc, innerRadius);

        path.setAttribute("d", newPathD);

    }

    drawOne(svg, svgNS, radius, innerRadius, centerPoint, value, name) {
        let parts = document.createElementNS(svgNS, "g");
        svg.appendChild(parts);

        let labels = document.createElementNS(svgNS, "g");
        svg.appendChild(labels);

        if(value === 0 || value == null) return;

        let part = document.createElementNS(svgNS, "g");
        part.classList.add("ct-series");
        part.id = `series-${this.widget.id}-${0}`;

        parts.appendChild(part);

        let circle = document.createElementNS(svgNS, "circle");
        circle.style.fill = this.donut ? "transparent" : this.colors[0];
        circle.style.stroke = this.donut ? this.colors[0] : "transparent";
        circle.classList.add(this.donut ? "ct-slice-donut-solid" : "ct-slice-pie");
        circle.setAttribute("stroke-width", this.donut ? this.donutWidth : 0);
        circle.setAttribute("r", this.donut ? innerRadius + this.donutWidth / 2 : radius);
        circle.setAttribute("cx", centerPoint.x);
        circle.setAttribute("cy", centerPoint.y);
        part.appendChild(circle);

        let title = document.createElementNS(svgNS, "title");
        title.textContent = "Value = " + value;
        circle.appendChild(title);

        let label = document.createElementNS(svgNS, "text");
        label.classList.add("ct-label");
        label.setAttribute("dx", centerPoint.x);
        label.setAttribute("dy", centerPoint.y);
        label.setAttribute("text-anchor", "middle");
        if(this.inPercent) {
            label.textContent = 100 + "%";
        }
        else label.textContent = name;
        labels.appendChild(label);

        part.addEventListener("mouseover", (event) => {
            let elementColor = document.getElementById(`color-block-${this.widget.id}-${0}`);
            let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${0}`);
            if(elementColor == null || elementCaption == null) return;
            elementColor.style.opacity = 0.5;
            elementCaption.style.fontWeight = "bold";
        });

        part.addEventListener("mouseout", (event) => {
            let elementColor = document.getElementById(`color-block-${this.widget.id}-${0}`);
            let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${0}`);
            if(elementColor == null || elementCaption == null) return;
            elementColor.style.opacity = null;
            elementCaption.style.fontWeight = null;
        });
    }

    angleInDegreesToRadians(angle) {
        return angle * Math.PI / 180.0;
    }

    polarToCartesian(centerX, centerY, radius, angleInDegrees) {
        let angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    }

    getPath(points, outerRadius, largeArc, innerRadius = 0) {
        let d = "M";
        d += points.start.x + ",";
        d += points.start.y;
        d += " A";
        d += outerRadius + ",";
        d += outerRadius;
        d += " 0 ";
        d += largeArc ? "1,1 " : "0,1 ";
        d += points.endOuterArc.x + ",";
        d += points.endOuterArc.y;
        d += " L";
        d += points.startInnerArc.x + ",";
        d += points.startInnerArc.y;
        d += " A";
        d += innerRadius + ",";
        d += innerRadius;
        d += " 0 ";
        d += largeArc ? "1,0 " : "0,0 ";
        d += points.endInnerArc.x + ",";
        d += points.endInnerArc.y;
        d += " Z";

        return d;
    }

    arc(centerX, centerY, startAngle, endAngle, outerRadius, innerRadius = 0) {
        let sinAlpha = Math.sin(startAngle);
        let cosAlpha = Math.cos(startAngle);
        let sinBeta = Math.sin(endAngle);
        let cosBeta = Math.cos(endAngle);

        let points = {};

        points.start = {
            x: centerX + (outerRadius * sinAlpha),
            y: centerY - (outerRadius * cosAlpha)
        };

        points.endOuterArc = {
            x: centerX + (outerRadius * sinBeta),
            y: centerY - (outerRadius * cosBeta)
        };

        points.startInnerArc = {
            x: centerX + (innerRadius * sinBeta),
            y: centerY - (innerRadius * cosBeta)
        };

        points.endInnerArc = {
            x: centerX + (innerRadius * sinAlpha),
            y: centerY - (innerRadius * cosAlpha)
        };

        return points;
    }
}


class WidgetScheduleHtml extends WidgetLineDiagramHtml {

	constructor(widget) {
		super(widget);
		this.addClassName("WidgetSchedule");
 
        this.startX = 100;
        this.endX = 500;
	}

	onSetState(state) {
		super.onSetState(state);
		if(state.nameX != null) this.nameX = decodeURIComponent(escape(window.atob(state.nameX)));
		if(state.nameY != null) this.nameY = decodeURIComponent(escape(window.atob(state.nameY)));
		if(state.needSpline != null) this.needSpline = state.needSpline;
        if(state.stairStep != null) this.stairStep = state.stairStep;
		if(state.showArea != null) this.showArea = state.showArea;
		if(state.showOnlyArea != null) this.showOnlyArea = state.showOnlyArea;
		if(state.showPoints != null) this.showPoints = state.showPoints;
		if(state.needTopAxisX != null) this.needTopAxisX = state.needTopAxisX;
		if(state.needRightAxisY != null) {
            this.needRightAxisY = state.needRightAxisY;
            if(this.needRightAxisY) this.startX = 20;
            else this.startX = 70;
        }
		if(state.maps != null) {
			this.maps = state.maps;
			if(state.maps.length === 0) {
				this.items = [];
			}
			else {
				this.items = new Array(state.maps[0].length);
				for(let i in state.maps[0]) {
					let dt = new Array(state.maps[0][i].length);
					for(let k in state.maps[0][i]) {
						let data = new DataForDiagram();
						data.name = state.maps[0][i][k].name;
						data.value = state.maps[0][i][k].value;
						dt[k] = data;
					}
					this.items[i] = dt;
				}
			}
		}
		this.drawDiagram();
	}

    drawDiagram() {
        this.clearDiagram();
        this.onDrawLegend();

        let series = [];
        for(let item of this.items) {
            if(!item) continue;
            let dots = [];
            for(let i = 0; i < item.length; ++i) {
                let dot = {};
                if(item[i].value === "NaN")
                    dot.y = null;
                else dot.y = item[i].value;
                dot.x = item[i].name;
                dots.push(dot);
            }
            series.push(dots);
        }

        let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add("ct-chart-line");
        svg.style.width = "100%";
        svg.style.height = "100%";
        this.diagram.appendChild(svg);

        let svgNS = svg.namespaceURI;

        let gridsWidth = svg.clientWidth - 80;
        let gridsHeight = svg.clientHeight - 80;
        if(gridsWidth <= 0 || gridsHeight <= 0) return;

        this.endX = gridsWidth + this.startX;

        if(series.length === 0)
            this.drawEmpty(svgNS, svg, gridsWidth, gridsHeight, );
        else this.drawSVG(series, svg, svgNS, gridsWidth, gridsHeight);
    }

    drawEmpty(svgNS, svg, gridsWidth, gridsHeight) {
        let wOx = gridsWidth / 10;
        let wOy = gridsHeight / 9;

        this.drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, 10, 10);
        this.drawLabels(svgNS, svg, wOx, wOy, gridsWidth, gridsHeight, 10, 10, 0, 0, 10, 10);
    }

    drawSVG(series, svg, svgNS, gridsWidth, gridsHeight) {
        let countLabelX = this.getCountLabelToSize(gridsWidth);
        let countLabelY = this.getCountLabelToSize(gridsHeight);

        let wOx = gridsWidth / countLabelX;
        let wOy = gridsHeight / (countLabelY - 1);

        let minX = series[0][0].x;
        let maxX = series[0][0].x;
        let minY = series[0][0].y;
        let maxY = series[0][0].y;
        for(let i = 0; i < series.length; ++i) {
            for(let j = 0; j < series[i].length; ++j) {
                if(series[i][j].y == null || series[i][j].x == null) continue;
                if(minY > series[i][j].y)
                    minY = series[i][j].y;
                if(maxY < series[i][j].y)
                    maxY = series[i][j].y;
                if(minX > series[i][j].x)
                    minX = series[i][j].x;
                if(maxX < series[i][j].x)
                    maxX = series[i][j].x;
            }
        }

        if(Math.abs(minX - maxX) > 100) {
            if(Math.abs(maxX) > 100) maxX = Math.round(maxX * 1.05 / 100  + 0.4) * 100;
            else {
                if(maxX > 0)
                    maxX = Math.round(maxX + 0.4);
                else maxX = Math.round(maxX - 0.4);
            }
            if(Math.abs(minX) > 100) minX = Math.round(minX * 1.05 / 100  - 0.4) * 100;
            else {
                minX = Math.round(minX - 0.4);
            }
        }
        else {
            minX = Math.round(minX - 0.4);
            if(maxX > 0)
                maxX = Math.round(maxX + 0.4);
            else maxX = Math.round(maxX - 0.4);
        }

        if(Math.abs(minY - maxY) > 100) {
            if(Math.abs(maxY) > 100) maxY = Math.round(maxY * 1.05 / 100  + 0.4) * 100;
            else {
                if(maxY > 0)
                    maxY = Math.round(maxY + 0.4);
                else maxY = Math.round(maxY - 0.4);
            }
            if(Math.abs(minY) > 100) minY = Math.round(minY * 1.05 / 100  - 0.4) * 100;
            else {
                minY = Math.round(minY - 0.4);
            }
        }
        else {
            minY = Math.round(minY - 0.4);
            if(maxY > 0)
                maxY = Math.round(maxY + 0.4);
            else maxY = Math.round(maxY - 0.4);
        }

        let sX = Math.abs(maxX - minX);
        let sY = Math.abs(maxY - minY);

        let stepX = sX / (countLabelX - 1);
        let stepY = sY / (countLabelY - 1);

        this.drawGrid(svgNS, svg, gridsWidth, gridsHeight, wOx, wOy, countLabelX, countLabelY);
        this.drawLine(svgNS, svg, series, gridsWidth, gridsHeight, wOx, wOy, sX, sY, minX, maxX, minY, maxY);
        this.drawLabels(svgNS, svg, wOx, wOy, gridsWidth, gridsHeight, countLabelX, countLabelY, minX, minY, stepX, stepY);
    }

    drawLine(svgNS, svg, series, gridsWidth, gridsHeight, wOx, wOy, sX, sY, minX, maxX, minY, maxY) {
        if(series == undefined || series.length === 0) return;
        let diagrams = document.createElementNS(svgNS, "g");
        svg.appendChild(diagrams);

        for(let i = 0; i < series.length; ++i) {
            let line = document.createElementNS(svgNS, "g");
            line.classList.add("ct-series");
            line.style.stroke = this.colors[i];
            line.id = `series-${this.widget.id}-${i}`;
            diagrams.appendChild(line);

            let pathArea = undefined;
            if(this.showOnlyArea || this.showArea) {
                pathArea = document.createElementNS(svgNS, "path");
                pathArea.classList.add("ct-area");
                pathArea.style.fill = this.colors[i];
                pathArea.style.fillOpacity = 0.25;
                line.appendChild(pathArea);
            }

            let path = undefined;
            if(!this.showOnlyArea) {
                path = document.createElementNS(svgNS, "path");
                path.classList.add("ct-line");
                line.appendChild(path);
            }

            let x = this.startX;
            let d = "M";
            let dArea = "M";
            dArea += x;
            dArea += ",";
            dArea += gridsHeight + 20;
            dArea += ",L";
            dArea += x;
            dArea += ",";
            let seriesPoint = series[i][0];
            if(series[i][0].x == null || series[i][0].y == null) {
                let k = 1;
                while((seriesPoint.x == null || seriesPoint.y == null) && k < series[i].length) {
                    if(series[i][k].x != null && series[i][k].y != null)
                        seriesPoint = series[i][k];
                    ++k;
                }
                if(seriesPoint.x == null || seriesPoint.y == null) continue;
            }
            dArea += gridsHeight + 20 - (((seriesPoint.y - minY) / (maxY - minY)) * gridsHeight);
            dArea += ",L";
            for(let j = 1; j <= series[i].length; ++j) {
                if(series[i][j - 1].x == null || series[i][j - 1].y == null) continue;
                let y1 = gridsHeight + 20 - (((series[i][j - 1].y - minY) / (maxY - minY)) * gridsHeight);
                let y2 = 0;
                x = this.startX + (((series[i][j - 1].x - minX) / (maxX - minX)) * (gridsWidth - wOx));
                let x2 = 0;
                if(j !== series[i].length) {
                    let nextSeriesPoint = series[i][j];
                    if(series[i][j].x == null || series[i][j].y == null) {
                        let k = j + 1;
                        while((nextSeriesPoint.x == null || nextSeriesPoint.y == null) && k < series[i].length) {
                            if(series[i][k].x != null && series[i][k].y != null)
                                nextSeriesPoint = series[i][k];
                            ++k;
                        }
                        if(nextSeriesPoint.x == null || nextSeriesPoint.y == null) continue;
                    }
                    x2 = this.startX + (((nextSeriesPoint.x - minX) / (maxX - minX)) * (gridsWidth - wOx))
                    y2 = gridsHeight + 20 - (((nextSeriesPoint.y - minY) / (maxY - minY)) * gridsHeight);
                }
                if(path != undefined) {
                    d += x;
                    d += ",";
                    d += y1;
                    d += ",";
                    if(this.needSpline && j !== series[i].length) {
                        let differenceX = (x2 - x) / 2;
                        let differenceY = (y2 - y1) / 4;
                        d += "C";
                        d += x +  differenceX;
                        d += ",";
                        d += y1 ;
                        d += ",";
                        d += x2 -  differenceX;
                        d += ",";
                        d += y2 ;
                        d += ",";
                    }
                    else if(this.stairStep && j !== series[i].length) {
                        d += "L";
                        d += x2;
                        d += ",";
                        d += y1;
                        d += ",L";
                        d += x2;
                        d += ",";
                        d += y2;
                        d += ",L";
                    }
                }
                if(pathArea != undefined) {
                    if(this.needSpline) {
                        dArea += x;
                        dArea += ",";
                        dArea += y1;
                        if(j !== series[i].length) {
                            let differenceX = (x2 - x) / 2;
                            //let differenceY = (y2 - y1) / 4;
	                        dArea += "C";
	                        dArea += x + differenceX;
	                        dArea += ",";
	                        dArea += y1 ;
	                        dArea += ",";
	                        dArea += x2 -  differenceX;
	                        dArea += ",";
	                        dArea += y2;
	                        dArea += ",";
                         
                        }
                        else {
                            dArea += ",L";
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                    else if(this.stairStep) {
                        if(j !== series[i].length) {

                            dArea += x2;
                            dArea += ",";
                            dArea += y1;
                            dArea += ",L";
                            dArea += x2;
                            dArea += ",";
                            dArea += y2;
                            dArea += ",L";
                        }
                        else {
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                    else {
                        dArea += x;
                        dArea += ",";
                        dArea += y1;
                        dArea += ",";
                        if(j === series[i].length) {
                            dArea += "L";
                            dArea += x;
                            dArea += ",";
                            dArea += gridsHeight + 20;
                            dArea += ",Z";
                        }
                    }
                }

                if(this.showPoints && !this.showOnlyArea) {
                    let point = document.createElementNS(svgNS, "line");
                    point.classList.add("ct-point");
                    line.appendChild(point);

                    point.setAttribute("x1", x);
                    point.setAttribute("x2", x + 0.01);
                    point.setAttribute("y1", y1);
                    point.setAttribute("y2", y1);
                    point.setAttribute("valueX", series[i][j - 1].x);
                    point.setAttribute("valueY", series[i][j - 1].y);

                    let title = document.createElementNS(svgNS, "title");
                    title.textContent = this.nameX + " = " + series[i][j - 1].x + ", " + this.nameY + " = " + series[i][j - 1].y;
                    point.appendChild(title);

                    if(!this.needSpline && this.stairStep && j !== series[i].length) {
                        let point2 = document.createElementNS(svgNS, "line");
                        point2.classList.add("ct-point");
                        line.appendChild(point2);

                        point2.setAttribute("x1", x2);
                        point2.setAttribute("x2", x2 + 0.01);
                        point2.setAttribute("y1", y1);
                        point2.setAttribute("y2", y1);
                        point2.setAttribute("valueX", series[i][j].x);
                        point2.setAttribute("valueY", series[i][j - 1].y);

                        let title2 = document.createElementNS(svgNS, "title");
                        title2.textContent = this.nameX + " = " + series[i][j].x + ", " + this.nameY + " = " + series[i][j - 1].y;
                        point2.appendChild(title2);
                    }
                }
            }
            if(path != undefined)
                path.setAttribute("d", d);
            if(pathArea != undefined)
                pathArea.setAttribute("d", dArea);

            line.addEventListener("mouseover", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = 0.5;
                elementCaption.style.fontWeight = "bold";
                line.style.opacity = 0.5;
            });

            line.addEventListener("mouseout", (event) => {
                let elementColor = document.getElementById(`color-block-${this.widget.id}-${i}`);
                let elementCaption = document.getElementById(`caption-block-${this.widget.id}-${i}`);
                if(elementColor == null || elementCaption == null) return;
                elementColor.style.opacity = null;
                elementCaption.style.fontWeight = null;
                line.style.opacity = null;
            });
        }
    }
    

    drawLabels(svgNS, svg, wOx, wOy, gridsWidth, gridsHeight, countLabelX, countLabelY, minX, minY, stepX, stepY) {
        let lables = document.createElementNS(svgNS, "g");
        lables.classList.add("ct-labels");
        svg.appendChild(lables);

        //подписи оси х
        let x = this.startX - 2;
        for(let i = 0; i < countLabelX; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", 50);
            foreignObject.setAttribute("width", wOx);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = "50px";
            span.style.width = wOx + "px";

            let title = document.createElementNS(svgNS, "title");
            foreignObject.appendChild(title);

            if(countLabelX === 1) {
                span.textContent = minX;
                title.textContent = minX;
            }
            else {
                span.textContent = minX + stepX * i;
                title.textContent = minX + stepX * i;
            }

            foreignObject.appendChild(span);
            foreignObject.setAttribute("x", x);
            if(this.needTopAxisX)
                foreignObject.setAttribute("y", 0);
            else foreignObject.setAttribute("y", gridsHeight + 30);

            x += wOx;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-vertical-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }

        //подписи оси y
        let y = gridsHeight + 7;
        for(let i = 0; i < countLabelY; ++i) {
            let foreignObject = document.createElementNS(svgNS, "foreignObject");
            lables.appendChild(foreignObject);
            foreignObject.setAttribute("height", wOy);
            foreignObject.setAttribute("width", 50);
            foreignObject.style.overflow = "visible";

            let span = document.createElement("span");
            span.classList.add("ct-label");
            span.classList.add("ct-horizontal");
            span.classList.add("ct-end");
            span.style.height = wOy + "px";
            span.style.width = "50px";

            let title = document.createElementNS(svgNS, "title");
            foreignObject.appendChild(title);

            if(countLabelY === 1) {
                span.textContent = minY;
                title.textContent = minY;
            }
            else {
                span.textContent = minY + stepY * i;
                title.textContent = minY + stepY * i;
            }
            foreignObject.appendChild(span);

            span.setAttribute("height", wOy);
            span.setAttribute("width", 50);
            if(this.needRightAxisY)
                foreignObject.setAttribute("x", this.endX);
            else foreignObject.setAttribute("x", 20);

            foreignObject.setAttribute("y", y);

            y -= wOy;

            span.addEventListener("mouseover", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgb(0, 0, 0)';
                span.style.color = 'rgb(0, 0, 0)';
            });

            span.addEventListener("mouseout", (event) => {
                let element = document.getElementById(`ct-horizontal-${this.widget.id}-${i}`);
                if(element == null) return;
                element.style.stroke = 'rgba(0, 0, 0, 0.2)';
                span.style.color = 'rgba(0, 0, 0, 0.4)';
            });
        }
    }

}


class WidgetHintHtml extends WidgetViewHtml {
	
	constructor(widget) {

		super(widget);

		this.createDomElement("div");
		this.addClassName("WidgetHint");
		
		this.contentView = null;

		this.openPos = {
			x : null,
			y : null
		};

		window.addEventListener('resize', (event) => {

			super.posX = this.recalcPosX();
			super.posY = this.recalcPosY();

		});
	}

	appendChild(child) {

		if(Rex.undef(child, "child")) return;

		this.widget.appendChild(Rex.widgets[child.id]);
	}

	checkSelect(event, parentId) {

		if(this.contentView) {

			let ret = this.contentView.checkSelect(event, parentId);

			if(ret)
				return ret;
		}

		return this.hover ? this.widget : undefined;
	}
	
	setContentView(v) {

		if(Rex.undef(v, "view")) return;

		let view = this.contentView;

		if(view == v)
			return;

		this.contentView = v;

		this.htmlElement.appendChild(v.htmlElement);
	}

	set posX(value) {

		this.openPos.x = value;

		super.posX = this.recalcPosX();
	}

	set posY(value) {

		this.openPos.y = value;

		super.posY = this.recalcPosY();;
	}

	set width(value) {

		super.width = value;

		this.recalcPosX();
	}

	set height(value) {

		super.height = value;

		this.recalcPosY();
	}

	getPosParentWidth() {

		return window.innerWidth;

	}

	getPosParentHeight() {

		return window.innerHeight;
	}

	recalcPosX() {

		let x = this.openPos.x || 0;

		let parentWidth = this.getPosParentWidth();

		if(x < 0)
			x = 0;

		if(x > parentWidth)
			x = parentWidth;

		let width = this.htmlElement.offsetWidth;

		if(x <= parentWidth / 2) {

			let freeSpace = parentWidth - x;

			if(width <= freeSpace)
				return x;

			if(width <= parentWidth)
				return parentWidth - width;

			return 0;

		} else {

			if(width <= x)
				return x - width;

			return 0;
		}
	}

	recalcPosY() {

		let y = this.openPos.y || 0;

		let parentHeight = this.getPosParentHeight();

		if(y < 0)
			y = 0;

		if(y > parentHeight)
			y = parentHeight;

		let height = this.htmlElement.offsetHeight;

		if(y <= parentHeight / 2) {

			let freeSpace = parentHeight - y;

			if(height <= freeSpace)
				return y;

			if(height <= parentHeight)
				return parentHeight - height;

			return 0;

		} else {

			if(height <= y)
				return y - height;

			return 0;
		}
	}

}


/* eslint-disable no-console */
/* eslint-disable no-unused-vars */
/* global WidgetViewHtml*/

/**
 * WidgetLabel
 */

class WidgetLinkHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		this.createDomElement("a");
		this.addClassName("WidgetLink");

		// this.a = document.createElement("a");
        // this.htmlElement.appendChild(this.a);
        
        this.a = this.htmlElement;

	}

	onSetState(state) {
		if (state.pressed != null) this.widget.pressed = state.pressed;
		if (state.raisedElevation != null) this.widget.raisedElevation = state.raisedElevation;
		if (state.defaultElevation != null) this.widget.defaultElevation = state.defaultElevation;
		if (state.autoSize != null) this.autoSize = state.autoSize;
		if (state.lessHundred != null) this._lessHundred = state.lessHundred;
		if (state.lineHeight != null) this.widget.lineHeight = state.lineHeight;

		if (state.text != null) this.controlText(state.text);
		if (state.iconName != null) this.controlIconName(state.iconName);
		if (state.verticalTextAlign != null) this.controlVerticalTextAlign(state.verticalTextAlign);
		if (state.horizontalTextAlign != null) this.controlHorizontalTextAlign(state.horizontalTextAlign);
		if (state.fontSize != null) this.controlFontSize();
		if (state.controlWidgetSizeFlag != null) this.ctrlWidgetSize(state.controlWidgetSizeFlag);
		if (state.controlFontSizeState != null) this.ctrlFontSize();
		if (state.breakWordType != null) this.controlBreakWord(state.breakWordType);

		if (state.link != null) {

			try {
				this.a.href = decodeURIComponent(escape(window.atob(state.link)));
			} catch (e) {
				console.log(this.widget.type, "setState->", "Text DecodeError!", e, stateText);
			}

		}
        
		if (state.target != null) {

			switch(state.target) {
			case 0: {
				// Blank
				this.a.target = "_blank";
				break;
			}
			case 1: {
				// Self
				this.a.target = "_self";
				break;
			}
			case 2: {
				// Parent
				this.a.target = "_parent";
				break;
			}
			case 3: {
				// Top
				this.a.target = "_top";
				break;
			}

			}

			// this.a.setAttrebyte("target", state.target);
		}
	}

	controlText(stateText) {
		let text = "";
		try {
			text = decodeURIComponent(escape(window.atob(stateText)));
		} catch (e) {
			console.log(this.widget.type, "setState->", "Text DecodeError!", e, stateText);
			return;
		}

		this.widget.text = text;
		if (this.widget.iconName == "") this.a.textContent = text;
	}

	controlIconName(stateIconName) {
		if (this.widget.iconName == stateIconName) return;
		this.widget.iconName = stateIconName;

		if (this.widget.iconName == "") {
			this.a.textContent = this.widget.text;
			this.a.classList.remove("MaterialIcon");
		} else {
			this.a.textContent = stateIconName;
			this.a.classList.add("MaterialIcon");
		}
	}

	controlVerticalTextAlign(stateTextAlign) {
		if (this.widget.verticalTextAlign == stateTextAlign) return;
		this.widget.verticalTextAlign = stateTextAlign;
		switch (stateTextAlign) {
		case 1: // TEXT TOP
			this.a.style.alignItems = "flex-start";
			break;
		case 2: // TEXT CENTER
			this.a.style.alignItems = "center";
			break;
		case 3: // TEXT BOTTOM
			this.a.style.alignItems = "flex-end";
			break;
		}
	}

	controlHorizontalTextAlign(stateTextAlign) {
		if (this.widget.horizontalTextAlign == stateTextAlign) return;
		this.widget.horizontalTextAlign = stateTextAlign;
		switch (stateTextAlign) { //justify-content: center;
		case 1: // TEXT LEFT
			this.a.style.justifyContent = "flex-start";
			this.a.style.textAlign = "left";
			break;
		case 2: // TEXT CENTER
			this.a.style.justifyContent = "center";
			this.a.style.textAlign = "center";
			break;
		case 3: // TEXT RIGHT
			this.a.style.justifyContent = "flex-end";
			this.a.style.textAlign = "right";
			break;
		}
	}

	controlFontSize(e) {
		if (!this.autoSize) {
			this.htmlElement.style.fontSize = this.fontSize + "px";
			return;
		}
		let html = this.htmlElement;
		const ratio = html.clientWidth < html.clientHeight ? html.clientWidth / html.clientHeight :
			html.clientHeight / html.clientWidth;
		const side = Math.max(html.clientWidth, html.clientHeight);
		const fontSize = side * ratio * 2;
		if (fontSize < 100 && !this._lessHundred) html.style.fontSize = "100%";
		else html.style.fontSize = (fontSize) + "%";
	}

	controlBreakWord(type) {
		if (type === 0) {
			this.htmlElement.style.wordBreak = "normal";
		} else if (type == 1) {
			this.htmlElement.style.wordBreak = "break-all";
		} else if (type == 2) {
			this.htmlElement.style.wordBreak = "keep-all";
		} else if (type == 3) {
			this.htmlElement.style.wordBreak = "break-word";
		}
	}

	set autoSize(value) {
		this._autoSize = value;
		if (!this.autoSize)
			this.htmlElement.style.fontSize = this.fontSize + "px";
		else this.controlFontSize();
	}

	get autoSize() {
		return this._autoSize;
	}

	//This method can be invoked from C++ or neurone only
	ctrlWidgetSize(value) {
		if (value == null) return;
		if (value === 0) return;

		let html = this.htmlElement;
		if (value === 1 || value === 3) {
			while (html.scrollWidth > html.clientWidth) {
				if (html.style.minWidth === html.scrollWidth + "px")
					break;
				html.style.minWidth = html.scrollWidth + "px";
				html.style.maxWidth = html.scrollWidth + "px";
			}
		}
		if (value === 2 || value === 3) {
			while (html.scrollHeight > html.clientHeight) {
				if (html.style.minHeight === html.scrollHeight + "px")
					break;
				html.style.minHeight = html.scrollHeight + "px";
				html.style.maxHeight = html.scrollHeight + "px";
			}
		}
	}

	//This method can be invoked from C++ or neurone only
	ctrlFontSize() {
		let html = this.htmlElement;
		while (html.scrollWidth > html.clientWidth || html.scrollHeight > html.clientHeight) {

			html.style.fontSize = (parseInt(html.style.fontSize) - 1) + "px";
		}
	}

}


/* global WidgetViewHtml Rex*/

// eslint-disable-next-line no-unused-vars
class WidgetJoystickHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);
		
		this.angle = 0;
		this.value = 0;
		this.rad = 0;
		
		this.dragStart = null;
		this.currentPos = {
			x: 0,
			y: 0
		};
		this.maxDiff = 32;
		
		
		this.createDomElement("div");
		this.addClassName("WidgetJoystick");

		this.htmlDownCircle = document.createElement("div");
		this.htmlDownCircle.classList.add("WidgetJoystickDown");

		this.htmlUpCircle = document.createElement("div");
		this.htmlUpCircle.classList.add("WidgetJoystickUp");
		
		//http://www.w3.org/2000/svg 
		let namespaceURL = decodeURIComponent(escape(window.atob("aHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmc=")));
		this.htmlSVG = document.createElementNS(namespaceURL, "svg");
		this.htmlSVG.classList.add("Joy_SVG");
		
		this.htmlPath = document.createElementNS(namespaceURL, "path");
		this.htmlPath.setAttribute("class", "Joy_Path");
		
		// this.htmlPath2 = document.createElementNS(namespaceURL, "path");
		// this.htmlPath2.setAttribute("class", "Joy_Path");
		
		this.htmlC1 = document.createElementNS(namespaceURL, "circle");
		this.htmlC1.setAttribute("class", "Joy_C1");
		
		this.htmlC2 = document.createElementNS(namespaceURL, "circle");
		this.htmlC2.setAttribute("class", "Joy_C2");
		
		
		this.htmlDownCircle.appendChild(this.htmlSVG);
		this.htmlSVG.appendChild(this.htmlC1);
		this.htmlSVG.appendChild(this.htmlPath);
		// this.htmlSVG.appendChild(this.htmlPath2);
		this.htmlSVG.appendChild(this.htmlC2);
		
		this.htmlElement.appendChild(this.htmlDownCircle);
		this.htmlDownCircle.appendChild(this.htmlUpCircle);
		
		// SVG GRAGIENT
		this.htmlGradient = document.createElementNS(namespaceURL, "radialGradient");
		this.htmlGradient.setAttribute("id", "joy_color_" + this.widget.id);
		this.stop1 = document.createElementNS(namespaceURL, "stop");
		this.stop1.setAttribute("offset", 0);
		this.stop1.setAttribute("stop-color", "rgba(55, 55, 55, 1)");
		this.stop2 = document.createElementNS(namespaceURL, "stop");
		this.stop2.setAttribute("offset", 100);
		this.stop2.setAttribute("stop-color", "rgba(105, 105, 105, 0.94)");
		
		this.htmlGradient.appendChild(this.stop1);
		this.htmlGradient.appendChild(this.stop2);
		this.htmlSVG.appendChild(this.htmlGradient);
		
		this.htmlUpCircle.xNew = 0;
		this.htmlUpCircle.yNew = 0;
		
		this.htmlC1.setAttribute("fill", "url(#" + "joy_color_" + this.widget.id + ")");
		this.htmlC2.setAttribute("fill", "url(#" + "joy_color_" + this.widget.id + ")");
		this.htmlPath.setAttribute("fill", "url(#" + "joy_color_" + this.widget.id + ")");
		// this.htmlPath2.setAttribute("fill", "url(#" + "joy_color_" + this.widget.id + ")");
		
		try {
			new ResizeObserver(this.controlResize.bind(this)).observe(this.htmlElement);
		// eslint-disable-next-line no-empty
		} catch (e) { }
		
	}
	
	controlResize() {
		const val = Math.min(this.htmlElement.offsetWidth, this.htmlElement.offsetHeight);
		
		this.htmlDownCircle.style.width = val + "px";
		this.htmlDownCircle.style.height = val + "px";
		
		this.htmlUpCircle.style.left = "calc(50% - " + val / 2 + "px)";
		this.htmlUpCircle.style.top = "calc(50% - " + val / 2 + "px)";
		
		const val2 = Math.round(val * 0.5);
		
		this.htmlUpCircle.style.width = val2+ "px";
		this.htmlUpCircle.style.height = val2 + "px";
		
		this.htmlUpCircle.style.left = "calc(50% - " + val2 / 2 + "px)";
		this.htmlUpCircle.style.top = "calc(50% - " + val2 / 2 + "px)";
		
		this.maxDiff = val * 0.4;
		
		this.path1Eps = this.maxDiff / 3 + 10;
		this.path2Eps = this.maxDiff / 3.5 + 10
		
		this.p1x = this.htmlSVG.clientWidth / 2;
		this.p1y = this.htmlSVG.clientWidth / 2;
		
		this.htmlC1.setAttribute("cx", this.p1x);
		this.htmlC1.setAttribute("cy", this.p1y);
		this.htmlC1.setAttribute("r", this.path1Eps);
		
		this.v1 = val;
		this.v2 = val2;
		
		this.updateSvg();
		
		
	}
	
	updateSvg() {
		
		this.p2x = this.p1x + 0 + this.htmlUpCircle.xNew;
		this.p2y = this.p1y + 0 + this.htmlUpCircle.yNew;
		
		this.htmlC2.setAttribute("cx", this.p2x);
		this.htmlC2.setAttribute("cy", this.p2y);
		this.htmlC2.setAttribute("r", this.path2Eps);

		
		const p1x1 = this.path1Eps * Math.cos((this.rad - 90)) + this.p1x;
		const p1y1 = this.path1Eps * Math.sin((this.rad - 90)) + this.p1x;
		
		const p1x2 = this.path1Eps * Math.cos((this.rad + 90)) + this.p1x;
		const p1y2 = this.path1Eps * Math.sin((this.rad + 90)) + this.p1x;
		
		const rQ = this.path1Eps * 1.5;
		const c1x1 = rQ * Math.cos((this.rad + Math.PI)) + this.p1x;
		const c1y1 = rQ * Math.sin((this.rad + Math.PI)) + this.p1x;
		
		const p2x1 = this.path2Eps * Math.cos((this.rad - 90)) + this.htmlUpCircle.xNew+ this.p1x; 
		const p2y1 = this.path2Eps * Math.sin((this.rad - 90)) + this.htmlUpCircle.yNew+ this.p1x;

		const p2x2 = this.path2Eps * Math.cos((this.rad + 90)) + this.htmlUpCircle.xNew+ this.p1x;
		const p2y2 = this.path2Eps * Math.sin((this.rad + 90)) + this.htmlUpCircle.yNew+ this.p1x;
		
		let d = (
			
			"M " + p1x1 + " " + p1y1 +
			
			" Q " + c1x1 + " " + c1y1 +
			"  " + p1x2 + " " + p1y2 +
			
			" M " + p1x2 + " " + p1y2 +
			" L " + p2x2 + " " + p2y2+
			" L " + p2x1 + " " + p2y1 +
			" L " + p1x1 + " " + p1y1
			
		);
		
		this.htmlPath.setAttribute("d", d);
		
	}
	
	onMouseDown(x, y, event) {
		
		this.pressedEvent = true;
		this.htmlUpCircle.style.transition = "0s";
		
		if (event.changedTouches) {
			this.dragStart = {
				x: event.changedTouches[0].clientX,
				y: event.changedTouches[0].clientY,
			};
			return;
		}
		this.dragStart = {
			x: event.clientX,
			y: event.clientY,
		};
	}
	
	onMouseMove(x, y, event) {
		if (!this.pressedEvent) {
			return;
		}
		if (this.dragStart === null) {
			return;
		}
		
		if (event.changedTouches) {
			event.clientX = event.changedTouches[0].clientX;
			event.clientY = event.changedTouches[0].clientY;
		}
		const xDiff = event.clientX - this.dragStart.x;
		const yDiff = event.clientY - this.dragStart.y;
		const angle = Math.atan2(yDiff, xDiff);
		const distance = Math.min(this.maxDiff, Math.hypot(xDiff, yDiff));

		const xNew = distance * Math.cos(angle);
		const yNew = distance * Math.sin(angle);
		
		this.htmlUpCircle.xNew = xNew;
		this.htmlUpCircle.yNew = yNew;
		this.htmlUpCircle.style.transform = `translate3d(${xNew}px, ${yNew}px, 0px)`;
		this.currentPos = {
			x: xNew,
			y: yNew
		};
		
		const v = distance / this.maxDiff;
		const aRad = Math.atan2(-yDiff, -xDiff);
		const a = 1 - aRad * 180 / Math.PI + 180;
		
		this.angle = a;
		this.value = v;
		this.rad = angle;
		
		Rex.callRpcMethod("Widgets", this.id, this.type, "changeJoystick", [a, v]);
		
		this.updateSvg();
		
	}
	
	onMouseUp() {
		
		this.pressedEvent = false;
		
		if (this.dragStart === null) return;
		
		this.htmlUpCircle.style.transition = ".2s";
		this.htmlUpCircle.style.transform = "translate3d(0px, 0px, 0px)";
		this.dragStart = null;
		this.currentPos = {
			x: 0,
			y: 0
		};
		
		Rex.callRpcMethod("Widgets", this.id, this.type, "changeJoystick", [0.0, 0.0]);
		
		this.htmlUpCircle.xNew = 0;
		this.htmlUpCircle.yNew = 0;
		
		this.angle = 0;
		this.value = 0;
		
		
		this.updateSvg();
		
	}
	
}

class WidgetCorrespondentAccountHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);
        this.createDomElement("div");
        this.addClassName("WidgetCorrespondentAccount");

        this._$titleDiv = null;
        this._$numberAccountDiv = null;
        this._$nameAccountDiv = null;
        this._$debitDiv = null;
        this._$creditDiv = null;
        this._$totalDebitDiv = null;
        this._$totalCreditDiv = null;
        this._$debitTransactionsDiv = null;
        this._$creditTransactionsDiv = null;
        this._$openingBalanceDiv = null;
        this._$openingBalanceTwoDiv = null;
        this._$totalBalanceDiv = null;
        this._$totalBalanceTwoDiv = null;
        this._$sumDebitDiv = null;
        this._$sumCreditDiv = null;

        this._$headerLine = null;
        this._$debitLine = null;
        this._$centerLine = null;
        this._$creditLine = null;

        this.makeHtml();
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }


    onSetState(state) {
        if(state.nameAccount != null) {
            this.widget.nameAccount = decodeURIComponent(escape(window.atob(state.nameAccount)));
            if(this._$nameAccountDiv != null) this._$nameAccountDiv.innerText = this.widget.nameAccount;
        }
        if(state.numberAccount != null) {
            this.widget.numberAccount = state.numberAccount;
            if(this._$numberAccountDiv != null) this._$numberAccountDiv.innerText = "Счет: " + this.widget.numberAccount;
        }
        if(state.correspondentAccountType != null) {
            this.widget.correspondentAccountType = state.correspondentAccountType;
            this.removeChildrenHtml(this._$debitDiv);
            this.removeChildrenHtml(this._$creditDiv);
            this.removeChildrenHtml(this._$totalDebitDiv);
            this.removeChildrenHtml(this._$totalCreditDiv);
            this.makeContent();
        }
        if(state.openingBalance != null) {
            this.widget.openingBalance = state.openingBalance;
            if(this._$openingBalanceDiv !== null) this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);
            this.makeTotal();
        }
        if(state.openingBalanceTwo != null) {
            this.widget.openingBalanceTwo = state.openingBalanceTwo;
            if(this._$openingBalanceTwoDiv !== null) this._$openingBalanceTwoDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalanceTwo);
            this.makeTotal();
        }
        if(state.closingBalance != null) {
            this.widget.closingBalance = state.closingBalance;
            if(this.widget.correspondentAccountType === 4) {
                this.makeTotal();
            }

        }
        if(state.closingBalanceTwo != null) {
            this.widget.closingBalanceTwo = state.closingBalanceTwo;
            if(this.widget.correspondentAccountType === 4) {
                this.makeTotal();
            }
        }
        if(state.debitTransactions != null) {
            this.widget.debitTransactions = state.debitTransactions;
            this.removeChildrenHtml(this._$debitTransactionsDiv);
            this.makeContentDebit();
            this.makeTotal();

            this._$sumCreditDiv.innerText = "Окр.: " + this.getTotalCredit();
            if(this._$sumDebitDiv != null) this._$sumDebitDiv.innerText = "Одеб.: " + this.numberFormat(this.getTotalDebit());
        }
        if(state.creditTransactions != null) {
            this.widget.creditTransactions = state.creditTransactions;
            this.removeChildrenHtml(this._$creditTransactionsDiv);
            this.makeContentCredit();
            this.makeTotal();
            if(this._$sumCreditDiv != null) this._$sumCreditDiv.innerText = "Окр.: " + this.numberFormat(this.getTotalCredit());
        }

        if(state.colorLine != null) {
            this.widget.colorLine = state.colorLine;
            if(this._$headerLine != null) this._$headerLine.style.backgroundColor = this.widget.colorLine;
            if(this._$debitLine != null) this._$debitLine.style.backgroundColor = this.widget.colorLine;
            if(this._$centerLine != null) this._$centerLine.style.backgroundColor = this.widget.colorLine;
            if(this._$centerLine != null) this._$creditLine.style.backgroundColor = this.widget.colorLine;
        }
    }

    makeHtml() {
        this.makeHeader();

        this._$headerLine = this.addElement("div", "CorrespondentAccountLineH", this.htmlElement);
        if(this.widget.colorLine != null && this.widget.colorLine !== "") this._$headerLine.style.backgroundColor = this.widget.colorLine;

        this.makeMainDiv();

        this.makeContent();
    }

    makeHeader() {
        let headerDiv = this.addElement("div", "CorrespondentAccountHeader", this.htmlElement);

        let debitDiv = this.addElement("div", "CorrespondentAccountSideHeader", headerDiv);
        debitDiv.innerText = "Дебет";

        this._$titleDiv = this.addElement("div", "CorrespondentAccountTitle", headerDiv);

        this._$numberAccountDiv = this.addElement("div", "CorrespondentAccountTitleChild", this._$titleDiv);
        this._$numberAccountDiv.innerText = "Счет: " + this.widget.numberAccount;

        this._$nameAccountDiv = this.addElement("div", "CorrespondentAccountTitleChild", this._$titleDiv);
        this._$nameAccountDiv.innerText = this.widget.nameAccount;

        let creditDiv = this.addElement("div", "CorrespondentAccountSideHeader", headerDiv);
        creditDiv.innerText = "Кредит";
    }

    makeMainDiv() {
        let mainDiv = this.addElement("div", "CorrespondentAccountMain", this.htmlElement);
        this.htmlElement.appendChild(mainDiv);

        //левая часть
        let leftDiv = this.addElement("div", "CorrespondentAccountMainLR", mainDiv);

        this._$debitDiv = this.addElement("div", "CorrespondentAccountDCDiv", leftDiv);

        this._$sumDebitDiv = this.addElement("div", "CorrespondentAccountTransaction", leftDiv);
        this._$sumDebitDiv.style.height = 42 + "px";
        this._$sumDebitDiv.innerText = "Одеб.: " + this.numberFormat(this.getTotalDebit());

        this._$debitLine = this.addElement("div", "CorrespondentAccountLineH", leftDiv);

        this._$totalDebitDiv = this.addElement("div", "CorrespondentAccountTotal", leftDiv);

        //центральная линия
        this._$centerLine = this.addElement("div", "CorrespondentAccountLineV", mainDiv);
        if(this.widget.colorLine != null && this.widget.colorLine !== "") this._$centerLine.style.backgroundColor = this.widget.colorLine;

        //правая часть
        let rightDiv = this.addElement("div", "CorrespondentAccountMainLR", mainDiv);

        this._$creditDiv = this.addElement("div", "CorrespondentAccountDCDiv", rightDiv);

        this._$sumCreditDiv = this.addElement("div", "CorrespondentAccountTransaction", rightDiv);
        this._$sumCreditDiv.style.height = 42 + "px";
        this._$sumCreditDiv.innerText = "Окр.: " + this.numberFormat(this.getTotalCredit());

        this._$creditLine = this.addElement("div", "CorrespondentAccountLineH", rightDiv);
        if(this.widget.colorLine != null && this.widget.colorLine !== "") this._$creditLine.style.backgroundColor = this.widget.colorLine;

        this._$totalCreditDiv = this.addElement("div", "CorrespondentAccountTotal", rightDiv);
    }

    makeContent() {
        if(this._$creditDiv == null || this._$debitDiv == null) return;
        switch(this.widget.correspondentAccountType) {
            case 0:
                this.makeActive();
                break;
            case 1:
                this.makePassive();
                break;
            case 2:
                this.makeActivePassiveUnilateralDebit();
                break;
            case 3:
                this.makeActivePassiveUnilateralCredit();
                break;
            case 4:
                this.makeActivePassiveBilateral();
                break;
        }
        this.makeTotal();
    }

    makeActive() {
        this._$openingBalanceDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$debitDiv);
        this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);

        this._$debitTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$debitDiv);
        this.makeContentDebit();

        this._$creditTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$creditDiv);
        this.makeContentCredit();
    }

    makePassive() {
        this._$openingBalanceDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$creditDiv);
        this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);

        this._$debitTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$debitDiv);
        this.makeContentDebit();

        this._$creditTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$creditDiv);
        this.makeContentCredit();
    }

    makeActivePassiveUnilateralDebit() {
        this._$openingBalanceDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$debitDiv);
        this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);

        this._$debitTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$debitDiv);
        this.makeContentDebit();

        this._$creditTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$creditDiv);
        this.makeContentCredit();
    }

    makeActivePassiveUnilateralCredit() {
        this._$openingBalanceDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$creditDiv);
        this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);

        this._$debitTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$debitDiv);
        this.makeContentDebit();

        this._$creditTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$creditDiv);
        this.makeContentCredit();
    }

    makeActivePassiveBilateral() {
        this._$openingBalanceDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$debitDiv);
        this._$openingBalanceDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalance);

        this._$debitTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$debitDiv);
        this.makeContentDebit();

        this._$openingBalanceTwoDiv = this.addElement("div", "CorrespondentAccountTransaction", this._$creditDiv);
        this._$openingBalanceTwoDiv.innerText = "Снач. = " + this.numberFormat(this.widget.openingBalanceTwo);

        this._$creditTransactionsDiv = this.addElement("div", "CorrespondentAccountTransactions", this._$creditDiv);
        this.makeContentCredit();
    }

    makeContentDebit() {
        if(this._$debitTransactionsDiv == null || this.widget.debitTransactions == null) return;
        for(let transaction of this.widget.debitTransactions) {
            let debitTransaction = this.addElement("div", "CorrespondentAccountTransaction", this._$debitTransactionsDiv);

            let numberDiv = this.addElement("div", "CorrespondentAccountNumberT", debitTransaction);
            numberDiv.innerText = "(" + transaction.numberTransaction + ") ";

            let amountDiv = this.addElement("div", "CorrespondentAccountAmountT", debitTransaction);
            amountDiv.innerText = this.numberFormat(transaction.transactionAmount);

            debitTransaction.addEventListener("mouseup", (e) => {
                if (e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpTransaction', [transaction.numberTransaction]);
            });
        }
    }

    makeContentCredit() {
        if(this._$creditTransactionsDiv == null || this.widget.creditTransactions == null) return;
        for(let transaction of this.widget.creditTransactions) {
            let creditTransaction = this.addElement("div", "CorrespondentAccountTransaction", this._$creditTransactionsDiv);

            let numberDiv = this.addElement("div", "CorrespondentAccountNumberT", creditTransaction);
            numberDiv.innerText = "(" + transaction.numberTransaction + ") ";

            let amountDiv = this.addElement("div", "CorrespondentAccountAmountT", creditTransaction);
            amountDiv.innerText = this.numberFormat(transaction.transactionAmount);

            creditTransaction.addEventListener("mouseup", (e) => {
                if (e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpTransaction', [transaction.numberTransaction]);
            });
        }
    }

    makeTotal() {
        if(this._$totalBalanceDiv != null) this._$totalBalanceDiv.remove();
        this._$totalBalanceDiv = document.createElement("div");
        this._$totalBalanceDiv.classList.add("CorrespondentAccountTotal");
        switch(this.widget.correspondentAccountType) {
            case 0:
                this._$totalBalanceDiv.innerText = "Скон. = " + this.numberFormat(this.getClosingBalance());
                this._$totalDebitDiv.appendChild(this._$totalBalanceDiv);
                break;
            case 1:
                this._$totalBalanceDiv.innerText = "Скон. = " + this.numberFormat(this.getClosingBalance());
                this._$totalCreditDiv.appendChild(this._$totalBalanceDiv);
                break;
            case 2:
                this._$totalBalanceDiv.innerText = "Скон. = " + this.numberFormat(this.getClosingBalance());
                this._$totalCreditDiv.appendChild(this._$totalBalanceDiv);
                break;
            case 3:
                this._$totalBalanceDiv.innerText = "Скон. = " + this.numberFormat(this.getClosingBalance());
                this._$totalDebitDiv.appendChild(this._$totalBalanceDiv);
                break;
            case 4:
                this._$totalBalanceDiv.innerText = "Скон. = " + this.numberFormat(this.widget.closingBalance);
                this._$totalDebitDiv.appendChild(this._$totalBalanceDiv);

                if(this._$totalBalanceTwoDiv != null) this._$totalBalanceTwoDiv.remove();
                this._$totalBalanceTwoDiv = this.addElement("div", "CorrespondentAccountTotal", this._$totalCreditDiv);
                this._$totalBalanceTwoDiv.innerText = "Скон. = " + this.numberFormat(this.widget.closingBalanceTwo);
                break;
        }
    }

    removeChildrenHtml(elem) {
        if(elem == null) return;
        while(elem.lastChild) {
            elem.removeChild(elem.lastChild);
        }
    }

    getTotalDebit() {
        if(this.widget.debitTransactions == null) return 0;
        let total = 0;
        for(let transaction of this.widget.debitTransactions) {
            total += transaction.transactionAmount;
        }
        return total;
    }

    getTotalCredit() {
        if(this.widget.creditTransactions == null) return 0;
        let total = 0;
        for(let transaction of this.widget.creditTransactions) {
            total += transaction.transactionAmount;
        }
        return total;
    }

    getClosingBalance() {
        let total = 0;
        switch(this.widget.correspondentAccountType) {
            case 0:
                total = this.widget.openingBalance + this.getTotalDebit() - this.getTotalCredit();
                break;
            case 1:
                total = this.widget.openingBalance + this.getTotalCredit() - this.getTotalDebit();
                break;
            case 2:
                total = this.getTotalCredit() - (this.widget.openingBalance + this.getTotalDebit());
                break;
            case 3:
                total = this.getTotalCredit() - (this.widget.openingBalance + this.getTotalDebit());
                break;
            case 4:
                break;
        }
        return total;
    }

    numberFormat(_number) {
        if(_number == null) return _number;
        return _number.toLocaleString();
    }
}

class WidgetMessagesViewerHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 1;
        this.showScroll = false;

        this.optionsWithWeek = {
            weekday: "long",
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };

        this.optionsDay = {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };

        this.optionsTime = {
            hour: "numeric",
            minute: "numeric"
        };

        this.createDomElement("div");
        this.addClassName("WidgetMessagesViewer");

        this.containerMessages = document.createElement("div");
        this.containerMessages.classList.add("MessagesContainer");
        this.containerMessages.style.backgroundImage = "url(" + this.widget.backgroundImage + ")";
        this.htmlElement.appendChild(this.containerMessages);

        this.containerMessages.addEventListener("scroll", function (event) {
            const maxScrollPos = this.containerMessages.scrollHeight - this.containerMessages.clientHeight;
            const currentPos = this.containerMessages.scrollTop;
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));

        try {
            new ResizeObserver(this.isShowScroll.bind(this)).observe(this.htmlElement);
        } catch(e) { }
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if(state.backgroundImage != null) {
            this.widget.backgroundImage = state.backgroundImage;
            if(this.containerMessages != null) this.containerMessages.style.backgroundImage = "url(" + this.widget.backgroundImage + ")";
        }
        if(state.colorIncomingMessages != null) {
            this.widget.colorIncomingMessages = state.colorIncomingMessages;
            this.htmlElement.style.setProperty("--color-incoming-messages", state.colorIncomingMessages);
        }
        if(state.colorTextMessages != null) {
            this.widget.colorTextMessages = state.colorTextMessages;
            this.htmlElement.style.setProperty("--color-text-messages", state.colorTextMessages);
        }
        if(state.colorDate != null) {
            this.widget.colorDate = state.colorDate;
            this.htmlElement.style.setProperty("--color-date", state.colorDate);
        }
        if(state.colorSenderName != null) {
            this.widget.colorSenderName = state.colorSenderName;
            this.htmlElement.style.setProperty("--color-sender-name", state.colorSenderName);
        }
        if(state.colorOutgoingMessages != null) {
            this.widget.colorOutgoingMessages = state.colorOutgoingMessages;
            this.htmlElement.style.setProperty("--color-outgoing-messages", state.colorOutgoingMessages);
        }
        if(state.scrollPos != null) this.scrollPos = state.scrollPos;
        if(state.showSendersAvatar != null) {
            this.widget.showSendersAvatar = state.showSendersAvatar;
            this.createMessages();
        }
        if(state.messages != null) {
            this.widget.messages = JSON.parse(JSON.stringify(state.messages));
            for(let index in state.messages) {
                this.widget.messages[index].text = this.decodeText(state.messages[index].text);

                let fullDate = this.widget.messages[index].date.split(" ");
                let date = new Date(fullDate[0] + "T" + fullDate[1]);
                this.widget.messages[index].date = date;

                this.widget.messages[index].sendersName = this.decodeText(state.messages[index].sendersName);

            }
            this.widget.sortMessagesByTime();
            this.createMessages();
            this.scrollPos = this.scrollPos;
        }
        if(state.changeStateMessages != null) {
            this.widget.changeStateMessages = state.changeStateMessages;
            this.changeStatusMessages();
            this.widget.changeStateMessages = [];
        }
    }

    onInit() {
        this.scrollPos = 1;
    }

    changeStatusMessages() {
        if(this.widget.changeStateMessages.length === 0) return;
        for(let i = 0; i < this.widget.changeStateMessages.length; ++i) {
            let mess = this.widget.changeStateMessages[i];
            if(mess == null) continue;
            let htmlElemStatus = document.getElementById(`${this.id}_${mess.id}`);
            if(htmlElemStatus == null) continue;
            if(mess.state === 1)
                htmlElemStatus.innerText = "done";
            else if(mess.state === 2)
                htmlElemStatus.innerText = "done_all";
            else if(mess.state === 3) {
                htmlElemStatus.innerText = "done_all";
                htmlElemStatus.style.color = "limegreen";
            }
        }

    }

    createMessages() {
        if(this.containerMessages != null) {
            while(this.containerMessages.childNodes.length)
                this.containerMessages.removeChild(this.containerMessages.firstChild);
        }
        if(this.widget.messages == null) return;
        for(let i = 0; i < this.widget.messages.length; ++i) {
            let message = this.widget.messages[i];

            if(i === 0) {
                let dateContainerDiv = this.addElement("div", "MessagesViewerDateContainer", this.containerMessages);

                let dateDiv = this.addElement("div", "MessagesViewerDate", dateContainerDiv);
                dateDiv.innerText = message.date.toLocaleString("ru", this.optionsWithWeek);
            }
            else {
                let prevMessage = this.widget.messages[i - 1];
                if(message.date.toLocaleString("ru", this.optionsDay) !== prevMessage.date.toLocaleString("ru", this.optionsDay)) {
                    let dateContainerDiv = this.addElement("div", "MessagesViewerDateContainer", this.containerMessages);

                    let dateDiv = this.addElement("span", "MessagesViewerDate", dateContainerDiv);
                    dateDiv.innerText = message.date.toLocaleString("ru", this.optionsWithWeek);
                }
            }
            if(message.state === 0) {
                let incomingMessageContDiv = this.addElement("div", "MessageContainer", this.containerMessages);

                if(this.widget.showSendersAvatar) {
                    let avatarDiv = this.addElement("div", "AvatarMessage", incomingMessageContDiv);
                    avatarDiv.style.backgroundImage = `url(${message.sendersAvatar})`;
                }

                let incomingMessageDiv = this.addElement("div", "IncomingMessage", incomingMessageContDiv);

                let contDiv = this.addElement("div", "MessageStatusContainer", incomingMessageDiv);

                let nameSenderDiv = this.addElement("div", "MessageSendersName", contDiv);
                nameSenderDiv.innerText = message.sendersName;

                let timeDiv = this.addElement("div", "MessageTime", contDiv);
                timeDiv.innerText = message.date.toLocaleString("ru", this.optionsTime);

                let textMessageDiv = this.addElement("div", "MessageText", incomingMessageDiv);
                textMessageDiv.innerHTML = message.text;

                incomingMessageDiv.addEventListener("mouseup", (e) => {
                    Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpMessage', [message.id, e.button]);
                });
            }
            else {
                let outgoingMessageContDiv = this.addElement("div", "MessageContainer", this.containerMessages);
                outgoingMessageContDiv.style.justifyContent = "flex-end";

                let outgoingMessageDiv = this.addElement("div", "OutgoingMessage", outgoingMessageContDiv);

                let statusDiv = this.addElement("div", "MessageStatusContainer", outgoingMessageDiv);

                let timeDiv = this.addElement("div", "MessageTime", statusDiv);
                timeDiv.innerText = message.date.toLocaleString("ru", this.optionsTime);

                let deliveredDiv = this.addElement("div", "MessageDelivered", statusDiv);
                deliveredDiv.id = `${this.id}_${message.id}`;
                if(message.state === 1)
                    deliveredDiv.innerText = "done";
                else if(message.state === 2)
                    deliveredDiv.innerText = "done_all";
                else if(message.state === 3) {
                    deliveredDiv.innerText = "done_all";
                    deliveredDiv.style.color = "limegreen";
                }

                let textMessageDiv = this.addElement("div", "MessageText", outgoingMessageDiv);
                textMessageDiv.innerHTML = message.text;

                if(this.widget.showSendersAvatar) {
                    let avatarDiv = this.addElement("div", "AvatarMessage", outgoingMessageContDiv);
                    avatarDiv.style.backgroundImage = `url(${message.sendersAvatar})`;
                }

                outgoingMessageDiv.addEventListener("mouseup", (e) => {
                    Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpMessage', [message.id, e.button]);
                });
            }
        }
    }

    isShowScroll() {
        if(this.containerMessages == null) return;
        let scrollShow;
        if(this.containerMessages.scrollHeight === 0) scrollShow = false;
        else scrollShow = this.containerMessages.scrollHeight !== this.containerMessages.clientHeight;
        if(scrollShow !== this.showScroll) {
            this.showScroll = scrollShow;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'changeShowScroll', [this.showScroll]);
        }
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.containerMessages == null) return;
        this._scrollPos = value;

        this.isShowScroll();

        const maxScrollPos = this.containerMessages.scrollHeight - this.containerMessages.clientHeight;
        const currentScrollPos = value * maxScrollPos;
        if(this.containerMessages.scrollTop === currentScrollPos) return;
        this.containerMessages.scrollTop = currentScrollPos;


    }

    get scrollPos() {
        return this._scrollPos;
    }
}

class WidgetTransactionsHistoryHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;
        this.options = {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };
        this.optionsTime = {
            hour: "numeric",
            minute: "numeric"
        };

        this.createDomElement("div");
        this.addClassName("WidgetTransactionsHistory");

        this.lastTransactionContainerDiv = null;

        this.containerTransactions = document.createElement("div");
        this.containerTransactions.classList.add("TransactionsContainer");
        this.htmlElement.appendChild(this.containerTransactions);

        this.containerTransactions.addEventListener("scroll", function(event) {
            const maxScrollPos = this.containerTransactions.scrollHeight - this.containerTransactions.clientHeight;
            const currentPos = this.containerTransactions.scrollTop;
            if(maxScrollPos === currentPos) {
                this.createTransactions();
                this.containerTransactions.scrollTop = currentPos;
            }
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if(state.searchParameters != null) {
            this.widget.searchParameters = state.searchParameters;
            if(this.widget.searchParameters.type === 2) {
                this.widget.searchParameters.name = this.decodeText(state.searchParameters.name);
            }
            this.searchShow();
        }
        if(state.transactions != null) {
            this.widget.transactions = JSON.parse(JSON.stringify(state.transactions));
            for(let index in state.transactions) {
                this.widget.transactions[index].name = this.decodeText(state.transactions[index].name);

                this.widget.transactions[index].category = this.decodeText(state.transactions[index].category);

                let date = new Date(this.widget.transactions[index].unixDate * 1000);
                this.widget.transactions[index].unixDate = date;

            }
            this.widget.sortTransactionsByTime();
            // this.createTransactions();
            this.searchShow();
            this.scrollPos = this.scrollPos;
        }
    }

    onInit() {
        this.scrollPos = 0;
    }

    createTransactions() {
        if(this.containerTransactions != null && this.widget.countView === 0) {
            while(this.containerTransactions.childNodes.length)
                this.containerTransactions.removeChild(this.containerTransactions.firstChild);
        }
        if(this.widget.searchResult == null || this.widget.searchResult.length === 0) return;
        let j = this.widget.countView;
        if(this.widget.countView === this.widget.searchResult.length) return;
        if(this.widget.countView === 0) {
            if(this.widget.searchResult.length >= 8)
                this.widget.countView = 8;
            else this.widget.countView = this.widget.searchResult.length;
        }
        else {
            if(this.widget.searchResult.length >= this.widget.countView + 8)
                this.widget.countView += 8;
            else this.widget.countView = this.widget.searchResult.length;
        }
        let transactionContainerDiv = null;
        if(j === 0 ) {
            transactionContainerDiv = this.addElement("div", "TransactionContainer", this.containerTransactions);
        }

        for(let i = j; i < this.widget.countView; ++i) {
            let transaction = this.widget.searchResult[i];
            let oneTransactionContainerDiv = document.createElement("div");
            oneTransactionContainerDiv.classList.add("OneTransactionContainer");
            oneTransactionContainerDiv.id = `${this.id}_${transaction.id}_transaction`;
            
            if(i === 0) {                
                let dateContainerDiv = this.addElement("div", "TransactionDateContainer", transactionContainerDiv);
                
                let dateDiv = this.addElement("span", "TransactionDate", dateContainerDiv);
                dateDiv.innerText = "Дата: " + transaction.unixDate.toLocaleString("ru", this.options);
                
                transactionContainerDiv.id = `${this.id}_${transaction.unixDate.toDateString()}_transactionByDate`;
                this.lastTransactionContainerDiv = transactionContainerDiv;
            }
            else {
                let prevTransaction = this.widget.searchResult[i - 1];
                
                if(transaction.unixDate.toLocaleString("ru", this.options) !== prevTransaction.unixDate.toLocaleString("ru", this.options)) {
                    
                    transactionContainerDiv = this.addElement("div", "TransactionContainer", this.containerTransactions);
                    transactionContainerDiv.id = `${this.id}_${transaction.unixDate.toDateString()}_transactionByDate`;
                    this.lastTransactionContainerDiv = transactionContainerDiv;
                    
                    let dateContainerDiv = this.addElement("div", "TransactionDateContainer", this.lastTransactionContainerDiv);
                    
                    let dateDiv = this.addElement("span", "TransactionDate", dateContainerDiv);
                    dateDiv.innerText = "Дата: " + transaction.unixDate.toLocaleString("ru", this.options);
                }
            }
            this.lastTransactionContainerDiv.appendChild(oneTransactionContainerDiv);

            let containerHeader = this.addElement("div", "TransactionHeader", oneTransactionContainerDiv);

            let timeDiv = this.addElement("div", "TransactionHeaderTime", containerHeader);
            timeDiv.innerText = "Время: " + transaction.unixDate.toLocaleString("ru", this.optionsTime);

            let categoryDiv = this.addElement("div", "TransactionHeaderCategory", containerHeader);
            categoryDiv.innerText = "Категория: " + transaction.category;

            let containerData = this.addElement("div", "TransactionData", oneTransactionContainerDiv);

            let nameDiv = this.addElement("div", "TransactionDataName", containerData);

            let typeDiv = this.addElement("div", "TransactionDataType", containerData);

            let amountDiv = document.createElement("div");
            containerData.appendChild(amountDiv);

            switch(transaction.type) {
                case 0:
                    typeDiv.innerText = "Входящий перевод";
                    nameDiv.innerText = "Отправитель: " + transaction.name;
                    amountDiv.classList.add("TransactionDataAmountIn");
                    amountDiv.innerText = "+" + transaction.amount.toLocaleString() + " руб.";
                    break;
                case 1:
                    typeDiv.innerText = "Исходящий перевод";
                    nameDiv.innerText = "Получатель: " + transaction.name;
                    amountDiv.classList.add("TransactionDataAmountOut");
                    amountDiv.innerText = "-" + transaction.amount.toLocaleString() + " руб.";
                    break;
            }

            oneTransactionContainerDiv.addEventListener("mouseup", (e) => {
                if (e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpTransaction', [transaction.id]);
            });
        }
    }

    searchShow() {
        this.widget.searchResult = [];
        this.widget.countView = 0;
        this.lastTransactionContainerDiv = null;
        this.scrollPos = 0;
        switch(this.widget.searchParameters.type) {
            case 0:
                this.showUnSearch();
                break;
            case 1:
                this.showSearchByDate();
                break;
            case 2:
                this.showSearchByName();
                break;
            case 3:
                this.showSearchByAmount();
                break;
        }
    }

    showUnSearch() {
        if(this.widget.transactions == null || this.widget.transactions.length === 0) {
            this.widget.searchResult = [];
        }
        else {
            this.widget.searchResult = this.widget.transactions;
        }
        this.createTransactions();
    }

    // yyyy-MM-dd
    showSearchByDate() {
        if(this.widget.transactions == null || this.widget.transactions.length === 0) {
            this.widget.searchResult = [];
        }

        else {
            let date = this.widget.searchParameters.year + "-" + this.widget.searchParameters.month + "-" + this.widget.searchParameters.day;
            date = new Date(date);

            for(let i = 0; i < this.widget.transactions.length; ++i) {
                let transaction = this.widget.transactions[i];
                if(transaction.unixDate.toLocaleString("ru", this.options) === date.toLocaleString("ru", this.options)) {
                    this.widget.searchResult.push(transaction);
                }
            }
        }
        this.createTransactions();
    }

    showSearchByName() {
        if(this.widget.transactions == null || this.widget.transactions.length === 0) {
            this.widget.searchResult = [];
        }
        else {
            let name = this.widget.searchParameters.name.toLowerCase();
            if(name.length < 3) {
                this.widget.searchResult = this.widget.transactions;
            }
            else {
                for(let i = 0; i < this.widget.transactions.length; ++i) {
                    let transaction = this.widget.transactions[i];

                    let nameTrans = transaction.name.toLowerCase();
                    if(nameTrans.indexOf(name) !== -1) {
                        this.widget.searchResult.push(transaction);
                    }
                }
            }
        }
        this.createTransactions();
    }

    showSearchByAmount() {
        if(this.widget.transactions == null || this.widget.transactions.length === 0) {
            this.widget.searchResult = [];
        }
        else {
            for(let i = 0; i < this.widget.transactions.length; ++i) {
                let transaction = this.widget.transactions[i];

                if(transaction.amount >= this.widget.searchParameters.amountStart && transaction.amount <= this.widget.searchParameters.amountEnd) {
                    this.widget.searchResult.push(transaction);
                }
            }
        }
        this.createTransactions();
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.containerTransactions == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.containerTransactions.scrollHeight - this.containerTransactions.clientHeight;
        this.containerTransactions.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }
}

class WidgetTaxiOrdersHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;
        this.options = {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: "numeric",
            minute: "numeric"
        };

        this.createDomElement("div");
        this.addClassName("WidgetTaxiOrders");

        this.containerOrders = document.createElement("div");
        this.containerOrders.classList.add("OrdersContainer");
        this.htmlElement.appendChild(this.containerOrders);

        this.containerOrders.addEventListener("scroll", function(event) {
            const maxScrollPos = this.containerOrders.scrollHeight - this.containerOrders.clientHeight;
            const currentPos = this.containerOrders.scrollTop;
            if(maxScrollPos === currentPos) {
                this.containerOrders.scrollTop = currentPos;
            }
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if(state.orders != null) {
            this.clearOrders();
            if(this.widget.orders == null) this.widget.orders = [];
            this.widget.orders = JSON.parse(JSON.stringify(state.orders));
            for(let index in state.orders) {
                this.widget.orders[index].nameTaxi = this.decodeText(state.orders[index].nameTaxi);

                this.widget.orders[index].startAddress = this.decodeText(state.orders[index].startAddress);

                this.widget.orders[index].startAddressComment = this.decodeText(state.orders[index].startAddressComment);

                if(this.widget.orders[index].time !== "") {
                    let fullDate = this.widget.orders[index].time.split(" ");
                    let date = new Date(fullDate[0] + "T" + fullDate[1]);
                    this.widget.orders[index].time = date;
                }

                if(this.widget.orders[index].way != null) {
                    for(let i in this.widget.orders[index].way) {
                        this.widget.orders[index].way[i] = this.decodeText(state.orders[index].way[i]);
                    }
                }

            }
            this.widget.addOrders = this.widget.orders;
            this.createOrders();
            this.widget.addOrders = [];
            this.scrollPos = this.scrollPos;
        }
        if(state.addOrders != null) {
            if(this.widget.orders == null) return;
            this.widget.addOrders = JSON.parse(JSON.stringify(state.addOrders));
            for(let index in state.addOrders) {
                this.widget.addOrders[index].nameTaxi = this.decodeText(state.addOrders[index].nameTaxi);

                this.widget.addOrders[index].startAddress = this.decodeText(state.addOrders[index].startAddress);

                this.widget.addOrders[index].startAddressComment = this.decodeText(state.addOrders[index].startAddressComment);

                if(this.widget.addOrders[index].time !== "") {
                    let fullDate = this.widget.addOrders[index].time.split(" ");
                    let date = new Date(fullDate[0] + "T" + fullDate[1]);
                    this.widget.addOrders[index].time = date;
                }

                if(this.widget.addOrders[index].way != null) {
                    for(let i in this.widget.addOrders[index].way) {
                        this.widget.addOrders[index].way[i] = this.decodeText(state.addOrders[index].way[i]);
                    }
                }
                this.widget.orders.push(this.widget.addOrders[index]);

            }
            this.createOrders();
            this.widget.addOrders = [];
            this.scrollPos = this.scrollPos;
        }

        if(state.deleteOrders != null && this.widget.deleteOrders != null && this.widget.order != null) {
            this.widget.deleteOrders = state.deleteOrders;
            this.removeOrders();
            for(let i = 0; i < this.widget.deleteOrders.length; ++i) {
                let id = this.widget.deleteOrders[i];
                for(let j = 0; j < this.widget.orders.length; ++j) {
                    let order = this.widget.orders[j];
                    if(order.id === id) {
                        this.widget.orders.splice(j, 1);
                        break;
                    }
                }
            }
        }

        if(state.clearAll != null && this.widget.orders != null && this.widget.orders.length !== 0) {
            if(state.clearAll) this.clearOrders();
        }
    }

    onInit() {
        this.scrollPos = 0;
    }

    createOrders() {
        if(this.widget.addOrders == null || this.widget.addOrders.length === 0) return;

        for(let i = 0; i < this.widget.addOrders.length; ++i) {
            let order = this.widget.addOrders[i];
            let oneOrderContainerDiv = document.createElement("div");
            oneOrderContainerDiv.classList.add("OneOrderContainer");
            oneOrderContainerDiv.id = `${this.id}_${order.id}_order`;
            this.containerOrders.insertBefore(oneOrderContainerDiv, this.containerOrders.firstChild);

            oneOrderContainerDiv.addEventListener("mouseup", (e) => {
                if (e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpOrder', [order.id]);
            });

            let headerContainer = this.addElement("div", "TaxiOrderHeader", oneOrderContainerDiv);

            let nameDiv = this.addElement("div", "TaxiOrderHeaderName", headerContainer);
            switch(order.type) {
                case 0:
                    nameDiv.innerText = order.nameTaxi + ", " + "Эконом";
                    break;
                case 1:
                    nameDiv.innerText = order.nameTaxi + ", " + "Комфорт";
                    break;
                case 2:
                    nameDiv.innerText = order.nameTaxi + ", " + "Бизнес";
                    break;
                case 3:
                    nameDiv.innerText = order.nameTaxi + ", " + "Минивен";
                    break;
                case 4:
                    nameDiv.innerText = order.nameTaxi + ", " + "Грузовое";
                    break;
                case 5:
                    nameDiv.innerText = order.nameTaxi + ", " + "Лимузин";
                    break;
            }

            let costDiv = this.addElement("div", "TaxiOrderHeaderCost", headerContainer);
            costDiv.innerText = order.cost + "₽";

            if(order.needAppointedTime) {
                let dateContainerDiv = this.addElement("div", "TaxiOrderTime", oneOrderContainerDiv);
                dateContainerDiv.innerText = order.time.toLocaleString("ru", this.options);
            }

            let wayDiv = this.addElement("div", "TaxiOrderWay", oneOrderContainerDiv);

            let startWayDiv = this.addElement("div", "TaxiOrderPointWay", wayDiv);

            let startAddrDiv = this.addElement("div", "TaxiOrderPointWay", startWayDiv);
            startAddrDiv.innerText = "◉ " + order.startAddress;

            if(order.startAddressComment !== "") {
                let startAddrCommentDiv = this.addElement("div", "TaxiOrderPointWayComment", startWayDiv);
                startAddrCommentDiv.innerText = "  " + order.startAddressComment;
            }

            if(order.way.length === 0) return;
            for(let j = 0; j < order.way.length - 1; ++j) {
                let intermediatePointDiv = this.addElement("div", "TaxiOrderIntermediatePointWay", wayDiv);
                intermediatePointDiv.innerText = "○ " + order.way[j];
            }

            let endPointDiv = this.addElement("div", "TaxiOrderPointWay", wayDiv);
            endPointDiv.innerText = "● " + order.way[order.way.length - 1];
        }
    }

    removeOrders() {
        for(let i in this.widget.deleteOrders) {
            let element = document.getElementById(`${this.id}_${this.widget.deleteOrders[i]}_order`);
            if(element == null) continue;
            this.containerOrders.removeChild(element);
        }
    }

    clearOrders() {
        if(this.containerOrders != null) {
            while(this.containerOrders.childNodes.length)
                this.containerOrders.removeChild(this.containerOrders.firstChild);
        }
        this.widget.orders = [];
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.containerOrders == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.containerOrders.scrollHeight - this.containerOrders.clientHeight;
        this.containerOrders.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }
}

class WidgetContactsForTransactionsHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;

        this.createDomElement("div");
        this.addClassName("WidgetContactsForTransactions");

        this.containerContacts = document.createElement("div");
        this.containerContacts.classList.add("ContactsContainer");
        this.htmlElement.appendChild(this.containerContacts);

        this.containerContacts.addEventListener("scroll", function (event) {
            const maxScrollPos = this.containerContacts.scrollHeight - this.containerContacts.clientHeight;
            const currentPos = this.containerContacts.scrollTop;
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if(state.searchParameters != null) {
            this.widget.searchParameters = state.searchParameters;
            if(this.widget.searchParameters.type === 1) {
                this.widget.searchParameters.name = this.decodeText(state.searchParameters.name);
            }
            this.createContacts();
        }

        if(state.contacts != null) {
            this.widget.contacts = JSON.parse(JSON.stringify(state.contacts));
            for(let index in state.contacts) {
                this.widget.contacts[index].name = this.decodeText(state.contacts[index].name);
            }
            this.widget.sortContactsByName();
            this.createContacts();
            this.scrollPos = this.scrollPos;
        }
    }

    onInit() {
        this.scrollPos = 0;
    }

    createContacts() {
        if(this.containerContacts != null) {
            while(this.containerContacts.childNodes.length)
                this.containerContacts.removeChild(this.containerContacts.firstChild);
        }
        if(this.widget.contacts == null) return;

        for(let i = 0; i < this.widget.contacts.length; ++i) {
            let contact = this.widget.contacts[i];
            if(this.widget.searchParameters.type === 1) {
                let name = this.widget.searchParameters.name.toLowerCase();
                if(name.length >= 3) {
                    let nameCont = contact.name.toLowerCase();
                    if(nameCont.indexOf(name) === -1) continue;
                }
            }

            let oneContactDiv = this.addElement("div", "OneContactDiv", this.containerContacts);

            let iconDiv = this.addElement("div", "IconContact", oneContactDiv);
            iconDiv.innerText = "account_circle";

            let contactDiv = this.addElement("div", "ContactDiv", oneContactDiv);

            let userDiv = this.addElement("div", "ContactFieldNameDiv", contactDiv);
            userDiv.innerText = "Пользователь:";

            let userNameDiv = this.addElement("div", "ContactFieldValueDiv", contactDiv);
            userNameDiv.innerText = contact.name;
            userNameDiv.style.fontWeight = "bold";

            let phoneDiv = this.addElement("div", "ContactFieldNameDiv", contactDiv);
            phoneDiv.innerText = "Номер телефона:";

            let phoneNumberDiv = this.addElement("div", "ContactFieldValueDiv", contactDiv);
            phoneNumberDiv.innerText = contact.phoneNumber;

            let accountDiv = this.addElement("div", "ContactFieldNameDiv", contactDiv);
            accountDiv.innerText = "Счет:";

            let accountNameDiv = this.addElement("div", "ContactFieldValueDiv", contactDiv);
            accountNameDiv.innerText = contact.account;

            oneContactDiv.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpContact', [contact.id]);
            });
        }
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.containerContacts == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.containerContacts.scrollHeight - this.containerContacts.clientHeight;
        this.containerContacts.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }
}

class WidgetContactsHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;

        this.createDomElement("div");
        this.addClassName("WidgetContacts");

        this.containerContacts = document.createElement("div");
        this.containerContacts.classList.add("WC-ContactsContainer");
        this.htmlElement.appendChild(this.containerContacts);

        this.containerContacts.addEventListener("scroll", function (event) {
            const maxScrollPos = this.containerContacts.scrollHeight - this.containerContacts.clientHeight;
            const currentPos = this.containerContacts.scrollTop;
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch (e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if (state.searchParameters != null) {
            this.widget.searchParameters = state.searchParameters;
            if (this.widget.searchParameters.type === 1) {
                this.widget.searchParameters.name = this.decodeText(state.searchParameters.name);
            }
            this.createContacts();
        }

        if (state.contacts != null) {
            this.widget.contacts = JSON.parse(JSON.stringify(state.contacts));
            for (let index in state.contacts) {
                this.widget.contacts[index].name = this.decodeText(state.contacts[index].name);
                this.widget.contacts[index].text = this.decodeText(state.contacts[index].text);
            }
            this.widget.sortContactsByName();
            this.createContacts();
            this.scrollPos = this.scrollPos;
        }
        if (state.showStatus != null) {
            this.widget.showStatus = state.showStatus;
            this.widget.sortContactsByName();
            this.createContacts();
            this.scrollPos = this.scrollPos;
        }
        if (state.changesStatus != null) {
            for (let item of state.changesStatus) {
                for (let contact of this.widget.contacts) {
                    if (contact.id !== item.id) continue;
                    contact.status = item.status;

                    if (this.widget.showStatus) {
                        let statusDiv = document.getElementById(`${this.id}_${contact.id}_userStatus`);
                        if (statusDiv == null) continue;
                        switch (contact.status) {
                            case 0:
                                statusDiv.style.backgroundColor = "green";
                                break;
                            case 1:
                                statusDiv.style.backgroundColor = "yellow";
                                break;
                            case 2:
                                statusDiv.style.backgroundColor = "red";
                                break;
                            case 3:
                                statusDiv.style.backgroundColor = "gray";
                                break;
                        }
                    }
                }
            }
        }
        if (state.changesAvatar != null) {
            for (let item of state.changesAvatar) {
                for (let contact of this.widget.contacts) {
                    if (contact.id !== item.id) continue;
                    contact.avatar = item.avatar;

                    let avatarDiv = document.getElementById(`${this.id}_${contact.id}_userAvatar`);
                    if (avatarDiv == null) continue;

                    if (contact.avatar == "") {
                        avatarDiv.className = "WC-IconContact";
                        avatarDiv.style.backgroundImage = null;
                        avatarDiv.innerText = "account_circle";
                    }
                    else {
                        avatarDiv.className = "WC-AvatarContact";
                        avatarDiv.style.backgroundImage = `url(${contact.avatar})`;
                        avatarDiv.innerText = "";
                    }
                }
            }
        }

        if (state.changesName != null) {
            for (let item of state.changesName) {
                for (let contact of this.widget.contacts) {
                    if (contact.id !== item.id) continue;
                    let name = this.decodeText(item.name);
                    contact.name = name;

                    let userNameDiv = document.getElementById(`${this.id}_${contact.id}_userName`);
                    if (userNameDiv == null) continue;

                    userNameDiv.innerText = contact.name;
                }
            }
        }

        if (state.changesText != null) {
            for (let item of state.changesText) {
                for (let contact of this.widget.contacts) {
                    if (contact.id !== item.id) continue;
                    let text = this.decodeText(item.text);
                    contact.text = text;

                    let textDiv = document.getElementById(`${this.id}_${contact.id}_text`);
                    if (textDiv == null) continue;

                    textDiv.id = `${this.id}_${contact.id}_text`;
                    textDiv.innerText = contact.text;
                }
            }
        }

    }

    onInit() {
        this.scrollPos = 0;
    }

    createContacts() {
        if (this.containerContacts != null) {
            while (this.containerContacts.childNodes.length)
                this.containerContacts.removeChild(this.containerContacts.firstChild);
        }
        if (this.widget.contacts == null) return;

        for (let i = 0; i < this.widget.contacts.length; ++i) {
            let contact = this.widget.contacts[i];
            if (this.widget.searchParameters.type === 1) {
                let name = this.widget.searchParameters.name.toLowerCase();
                // if (name.length >= 3) {
                let nameCont = contact.name.toLowerCase();
                if (nameCont.indexOf(name) === -1) continue;
                // }
            }

            let oneContactDiv = this.addElement("div", "WC-OneContactDiv", this.containerContacts);

            let avatarContainer = this.addElement("div", "WC-AvatarContactContainer", oneContactDiv);

            if (contact.avatar == "") {
                let avatarDiv = this.addElement("div", "WC-IconContact", avatarContainer);
                avatarDiv.id = `${this.id}_${contact.id}_userAvatar`;
                avatarDiv.innerText = "account_circle";
            }
            else {
                let avatarDiv = this.addElement("div", "WC-AvatarContact", avatarContainer);
                avatarDiv.style.backgroundImage = `url(${contact.avatar})`;
                avatarDiv.id = `${this.id}_${contact.id}_userAvatar`;
            }

            if (this.widget.showStatus) {
                let statusDiv = this.addElement("div", "WC-UserStatus", avatarContainer);
                statusDiv.id = `${this.id}_${contact.id}_userStatus`;
                switch (contact.status) {
                    case 0:
                        statusDiv.style.backgroundColor = "green";
                        break;
                    case 1:
                        statusDiv.style.backgroundColor = "yellow";
                        break;
                    case 2:
                        statusDiv.style.backgroundColor = "red";
                        break;
                    case 3:
                        statusDiv.style.backgroundColor = "gray";
                        break;
                }
            }

            let contactDiv = this.addElement("div", "WC-ContactDiv", oneContactDiv);

            let userNameDiv = this.addElement("div", "WC-ContactFieldValueDiv", contactDiv);
            userNameDiv.id = `${this.id}_${contact.id}_userName`;
            userNameDiv.innerText = contact.name;
            userNameDiv.style.fontWeight = "bold";

            let textDiv = this.addElement("div", "WC-ContactTextDiv", contactDiv);
            textDiv.id = `${this.id}_${contact.id}_text`;
            textDiv.innerText = contact.text;

            oneContactDiv.addEventListener("mouseup", (e) => {
                if (e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpContact', [contact.id]);
            });
        }
    }

    set scrollPos(value) {
        if (value < 0 || value > 1 || this.containerContacts == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.containerContacts.scrollHeight - this.containerContacts.clientHeight;
        this.containerContacts.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }
}

class WidgetShoppingBasketHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;
        this.count = 0;

        this.createDomElement("div");
        this.addClassName("WidgetShoppingBasket");

        this.containerBasket = document.createElement("div");
        this.containerBasket.classList.add("BasketContainer");
        this.htmlElement.appendChild(this.containerBasket);

        this.containerBasket.addEventListener("scroll", function (event) {
            const maxScrollPos = this.containerBasket.scrollHeight - this.containerBasket.clientHeight;
            const currentPos = this.containerBasket.scrollTop;
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    onSetState(state) {
        if(state.sellers != null) {
            this.widget.sellers = JSON.parse(JSON.stringify(state.sellers));
            for(let index in state.sellers) {
                let name = "";
                try {
                    name = decodeURIComponent(escape(window.atob(state.sellers[index].name)));
                }
                catch(e) {
                    console.log(this.widget.type, "setState->", "Text DecodeError!", e, state.sellers[index].name);
                    continue;
                }
                this.widget.sellers[index].name = name;

                if(this.widget.sellers[index].products != null) {
                    for(let i in this.widget.sellers[index].products) {
                        this.widget.sellers[index].products[i].name = this.decodeText(state.sellers[index].products[i].name);

                        this.widget.sellers[index].products[i].description = this.decodeText(state.sellers[index].products[i].description);

                        if(this.widget.sellers[index].products[i].delivered != null) {
                            for(let j in this.widget.sellers[index].products[i].delivered) {
                                this.widget.sellers[index].products[i].delivered[j].name = this.decodeText(state.sellers[index].products[i].delivered[j].name);

                                this.widget.sellers[index].products[i].delivered[j].terms = this.decodeText(state.sellers[index].products[i].delivered[j].terms);
                            }
                        }
                    }
                }
            }
            this.createBasket();
            this.scrollPos = this.scrollPos;
        }

        if(state.changeProductsPrice != null) {
            for(let item of state.changeProductsPrice) {
                for(let seller of this.widget.sellers) {
                    if(seller.id !== item.sellerId) continue;
                    for(let product of seller.products) {
                        if(product.id !== item.productId) continue;
                        product.price = item.price;
                        let discPrice = (product.price / 100) * (100 - product.discount);
                        let discPriceSpan = document.getElementById(`${this.id}_${seller.id}_${product.id}_discountPriceSpan`);
                        if(discPriceSpan == null) continue;
                        discPriceSpan.innerText = discPrice.toLocaleString() + " руб.";

                        let priceWithoutDiscountDiv = document.getElementById(`${this.id}_${seller.id}_${product.id}_PriceWithoutDiscountDiv`);
                        if(priceWithoutDiscountDiv == null) continue;
                        priceWithoutDiscountDiv.innerText = product.price.toLocaleString() + " руб./шт.";

                        this.changeResultPriceSeller(seller);
                    }
                }
            }
            this.changeResultPrice();
        }
        if(state.changesDeliveredPrice != null) {
            for(let item of state.changesDeliveredPrice) {
                for(let seller of this.widget.sellers) {
                    if(seller.id !== item.sellerId) continue;
                    for(let product of seller.products) {
                        if(product.id !== item.productId) continue;
                        for(let delivered of product.delivered) {
                            if(delivered.id !== item.deliveredId) continue;
                            delivered.price = item.price;

                            if(product.currentDeliveredId !== item.deliveredId) continue;

                            let deliveredPriceDiv = document.getElementById(`${this.id}_${seller.id}_${product.id}_SellerDeliveredProductPriceDiv`);
                            if(deliveredPriceDiv == null) continue;
                            deliveredPriceDiv.innerText = delivered.price === 0 ? "Бесплатная доставка" : delivered.price.toLocaleString() + " руб.";

                            this.changeResultPriceSeller(seller);
                        }
                    }
                }
            }
            this.changeResultPrice();
        }
        if(state.changeDeleteDelivered != null) {
            for(let item of state.changeDeleteDelivered) {
                for(let i = 0; i < this.widget.sellers.length; ++i) {
                    let seller = this.widget.sellers[i];
                    if(seller.id !== item.sellerId) continue;
                    for(let j = 0; j < seller.products.length; ++j) {
                        let product = seller.products[j];
                        if(product.id !== item.productId) continue;
                        for(let k = 0; k < product.delivered.length; ++k) {
                            let delivered = product.delivered[k];
                            if(delivered.id !== item.deliveredId) continue;
                            if(product.currentDeliveredId === item.deliveredId) {
                                if(i === 0) product.currentDeliveredId = product.delivered[1].id;
                                else product.currentDeliveredId = product.delivered[0].id;
                            }

                            product.delivered.splice(k, 1);
                            break;
                        }

                        let deliveredContainerDiv = document.getElementById(`${this.id}_${seller.id}_${product.id}_SellerDeliveredProductContainerDiv`);
                        if(deliveredContainerDiv == null) continue;
                        while(deliveredContainerDiv.childNodes.length)
                            deliveredContainerDiv.removeChild(deliveredContainerDiv.firstChild);

                        let deliveredSelect = this.addElement("select", "SellerDeliveredProductSelect", deliveredContainerDiv);
                        deliveredSelect.id = `${seller.id}_${product.id}_SellerDeliveredProductSelect`;

                        let textTerms = "";
                        let priceDelivered = 0;
                        for(let k = 0; k < product.delivered.length; ++k) {
                            let delivered = product.delivered[k];
                            let deliveredOption = this.addElement("option", "SellerDeliveredProductOption", deliveredSelect);
                            deliveredOption.value = delivered.name;
                            deliveredOption.innerText = delivered.name;
                            deliveredOption.id = delivered.id;

                            if(delivered.id == product.currentDeliveredId) {
                                deliveredSelect.selectedIndex = k;
                                textTerms = delivered.terms;
                                priceDelivered = delivered.price;
                            }
                        }

                        let deliveredPriceDiv = this.addElement("div", "SellerDeliveredProductPriceDiv", deliveredContainerDiv);
                        deliveredPriceDiv.id = `${this.id}_${seller.id}_${product.id}_SellerDeliveredProductPriceDiv`;
                        deliveredPriceDiv.innerText = priceDelivered === 0 ? "Бесплатная доставка" : priceDelivered.toLocaleString() + " руб.";

                        let deliveredTermsDiv = this.addElement("div", "SellerDeliveredProductTermsDiv", deliveredContainerDiv);
                        deliveredTermsDiv.innerText = textTerms;

                        deliveredSelect.addEventListener("change", function (e) {
                            let newSelectedIndex = Number.parseInt(e.srcElement.selectedIndex);
                            let deliveredId = e.srcElement[newSelectedIndex].id;

                            let delivered;
                            for(let l = 0; l < product.delivered.length; ++l) {
                                if(product.delivered[l].id == deliveredId) {
                                    delivered = product.delivered[l];
                                    break;
                                }
                            }

                            deliveredPriceDiv.innerText = delivered.price === 0 ? "Бесплатная доставка" : delivered.price.toLocaleString() + " руб.";
                            deliveredTermsDiv.innerText = delivered.terms;

                            this.widget.sellers[i].products[j].currentDeliveredId = deliveredId;
                            product.currentDeliveredId = deliveredId;

                            this.changeResultPriceSeller(seller);
                            this.changeResultPrice();

                            Rex.callRpcMethod('Widgets', this.id, this.type, 'changeDelivered', [seller.id, product.id, deliveredId]);
                        }.bind(this));

                        this.changeResultPriceSeller(seller);
                    }
                }
            }
            this.changeResultPrice();
        }
    }

    onInit() {
        this.scrollPos = 0;
    }

    createBasket() {
        if(this.containerBasket != null) {
            while(this.containerBasket.childNodes.length)
                this.containerBasket.removeChild(this.containerBasket.firstChild);
        }
        if(this.widget.sellers == null || this.widget.sellers.length === 0) return;
        this.count = 0;

        for(let i = 0; i < this.widget.sellers.length; ++i) {
            let seller = this.widget.sellers[i];
            if(seller == null || seller.products == null || seller.products.length === 0) continue;


            //seller
            this.createSeller(seller, i);

            //------------------- end seller
        }

        // result
        this.createResult();

        //------------------------ end result
    }

    createSeller(seller, i) {
        let sellerDiv = this.addElement("div", "SellerDiv", this.containerBasket);

        //seller header
        this.createSellerHeader(seller, sellerDiv);
        //----------------- end seller header

        //column seller
        this.createColumnSeller(sellerDiv);
        //------------------ end column seller

        for(let j = 0; j < seller.products.length; ++j) {
            let product = seller.products[j];
            if(product == null) continue;

            //product            
            this.createProduct(seller, product, sellerDiv, i, j);
            //-------------------- end product
            this.count++;
        }

        //result seller
        this.createResultSeller(seller, sellerDiv);

        //------------------- end result seller
    }

    createSellerHeader(seller, sellerDiv) {
        let sellerHeaderDiv = this.addElement("div", "SellerHeaderDiv", sellerDiv);

        let sellerHeaderNameContDiv = this.addElement("div", "SellerHeaderNameContainerDiv", sellerHeaderDiv);

        let sellerHeaderNameTDiv = this.addElement("div", "SellerHeaderNameTDiv", sellerHeaderNameContDiv);
        sellerHeaderNameTDiv.innerText = "Продавец: ";

        let sellerHeaderNameDiv = this.addElement("div", "SellerHeaderNameDiv", sellerHeaderNameContDiv);
        sellerHeaderNameDiv.innerText = seller.name;

        sellerHeaderNameDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpSeller', [seller.id]);
        });

        let writeToSellerContDiv = this.addElement("div", "WriteToSellerDivContainerDiv", sellerHeaderDiv);

        let writeToSellerBtnDiv = this.addElement("div", "HeaderWriteToSellerBtnDiv", writeToSellerContDiv);
        writeToSellerBtnDiv.innerText = "mail";

        let writeToSellerDiv = this.addElement("div", "HeaderWriteToSellerDiv", writeToSellerContDiv);
        writeToSellerDiv.innerText = "Написать продавцу!";

        writeToSellerContDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpWriteToSeller', [seller.id]);
        });
    }

    createColumnSeller(sellerDiv) {
        let columnContainerDiv = this.addElement("div", "ColumnContainerDiv", sellerDiv);

        let nameProductTDiv = this.addElement("div", "SellerNameProductTDiv", columnContainerDiv);
        nameProductTDiv.innerText = "Наименование товара и описание";

        let countTDiv = this.addElement("div", "SellerCountProductTDiv", columnContainerDiv);
        countTDiv.innerText = "Количество";

        let priceTDiv = this.addElement("div", "SellerPriceProductTDiv", columnContainerDiv);
        priceTDiv.innerText = "Цена";

        let deliveredTDiv = this.addElement("div", "SellerDeliveredProductTDiv", columnContainerDiv);
        deliveredTDiv.innerText = "Условия доставки";
    }

    createProduct(seller, product, sellerDiv, i, j) {
        let productDiv = this.addElement("div", "ProductDiv", sellerDiv);

        //название и изображение
        this.createNameAndImageProduct(seller, product, productDiv);

        //количество
        this.createCountProduct(seller, product, productDiv, i, j);

        //стоимость
        this.createPriceProduct(seller, product, productDiv);

        //условия доставки
        this.createProductDelivered(seller, product, productDiv, i, j);

        //кнопка удаления
        let removeBtnContainerDiv = this.addElement("div", "SellerRemoveProductContainerDiv", productDiv);

        let removeBtnDiv = this.addElement("div", "RemoveBtnDiv", removeBtnContainerDiv);
        removeBtnDiv.innerText = "Удалить";

        removeBtnDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpRemoveProduct', [seller.id, product.id]);
        });
    }

    createNameAndImageProduct(seller, product, productDiv) {
        let nameProductContainerDiv = this.addElement("div", "SellerNameProductContainerDiv", productDiv);

        let imgProductDiv = this.addElement("div", "ImgProductDiv", nameProductContainerDiv);
        imgProductDiv.style.backgroundImage = `url(${product.image})`;

        let nameAndDescProductDiv = this.addElement("div", "NameAndDescriptionProductDiv", nameProductContainerDiv);

        let nameProductDiv = this.addElement("div", "NameProductDiv", nameAndDescProductDiv);
        nameProductDiv.innerText = product.name;

        let descriptionProductDiv = this.addElement("div", "DescriptionProductDiv", nameAndDescProductDiv);
        descriptionProductDiv.innerText = product.description;

        imgProductDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpProduct', [seller.id, product.id]);
        });

        nameProductDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpProduct', [seller.id, product.id]);
        });
    }

    createCountProduct(seller, product, productDiv, i, j) {
        let countContainerDiv = this.addElement("div", "SellerCountProductContainerDiv", productDiv);

        let countProductSpin = this.addElement("input", "CountProductInput", countContainerDiv);
        countProductSpin.type = "number";
        countProductSpin.required = true;
        countProductSpin.step = 1;
        countProductSpin.min = 0;
        countProductSpin.max = product.maxCount;
        countProductSpin.value = product.count;

        let countTDiv = this.addElement("div", "CountProductTDiv", countContainerDiv);
        countTDiv.innerText = "шт.";

        countProductSpin.addEventListener("change", function (e) {
            let newCount = Number.parseInt(e.srcElement.value);
            if(newCount < 0) {
                countProductSpin.value = 0;
                newCount = 0;
            }
            if(newCount > product.maxCount) {
                countProductSpin.value = product.maxCount;
                newCount = product.maxCount;
            }

            this.widget.sellers[i].products[j].count = newCount;
            // seller.products[j].count = newCount;
            product.count = newCount;
            this.changeResultPriceSeller(seller);
            this.changeResultPrice();

            Rex.callRpcMethod('Widgets', this.id, this.type, 'changeProductCount', [seller.id, product.id, newCount]);
        }.bind(this));
    }

    createPriceProduct(seller, product, productDiv) {
        let priceContainerDiv = this.addElement("div", "SellerPriceProductContainerDiv", productDiv);

        let priceProductDiv = this.addElement("div", "PriceProductDiv", priceContainerDiv);

        let discPrice = (product.price / 100) * (100 - product.discount);

        let priceP = document.createElement("span");
        priceP.id = `${this.id}_${seller.id}_${product.id}_discountPriceSpan`;
        priceP.innerText = discPrice.toLocaleString() + " руб.";
        priceP.style.fontSize = "16px";
        priceP.style.fontWeight = "bold";
        priceProductDiv.appendChild(priceP);

        let priceUnitP = this.addElement("span", "PriceUnitP", priceProductDiv);
        priceUnitP.innerText = "/шт.";

        let priceWithoutDiscountDiv = this.addElement("div", "PriceWithoutDiscountDiv", priceContainerDiv);
        priceWithoutDiscountDiv.id = `${this.id}_${seller.id}_${product.id}_PriceWithoutDiscountDiv`;
        priceWithoutDiscountDiv.innerText = product.price.toLocaleString() + " руб./шт.";

        let discountDiv = this.addElement("div", "DiscountDiv", priceContainerDiv);
        discountDiv.innerText = product.discount + " % OFF";
    }

    createProductDelivered(seller, product, productDiv, i, j) {
        let deliveredContainerDiv = this.addElement("div", "SellerDeliveredProductContainerDiv", productDiv);
        deliveredContainerDiv.id = `${this.id}_${seller.id}_${product.id}_SellerDeliveredProductContainerDiv`;

        let deliveredSelect = this.addElement("select", "SellerDeliveredProductSelect", deliveredContainerDiv);
        deliveredSelect.id = `${seller.id}_${product.id}_SellerDeliveredProductSelect`;

        let textTerms = "";
        let priceDelivered = 0;
        for(let k = 0; k < product.delivered.length; ++k) {
            let delivered = product.delivered[k];
            let deliveredOption = this.addElement("option", "SellerDeliveredProductOption", deliveredSelect);
            deliveredOption.value = delivered.name;
            deliveredOption.innerText = delivered.name;
            deliveredOption.id = delivered.id;

            if(delivered.id == product.currentDeliveredId) {
                deliveredSelect.selectedIndex = k;
                textTerms = delivered.terms;
                priceDelivered = delivered.price;
            }
        }

        let deliveredPriceDiv = this.addElement("div", "SellerDeliveredProductPriceDiv", deliveredContainerDiv);
        deliveredPriceDiv.id = `${this.id}_${seller.id}_${product.id}_SellerDeliveredProductPriceDiv`;
        deliveredPriceDiv.innerText = priceDelivered === 0 ? "Бесплатная доставка" : priceDelivered.toLocaleString() + " руб.";

        let deliveredTermsDiv = this.addElement("div", "SellerDeliveredProductTermsDiv", deliveredContainerDiv);
        deliveredTermsDiv.innerText = textTerms;

        deliveredSelect.addEventListener("change", function (e) {
            let newSelectedIndex = Number.parseInt(e.srcElement.selectedIndex);
            let deliveredId = e.srcElement[newSelectedIndex].id;

            let delivered;
            for(let l = 0; l < product.delivered.length; ++l) {
                if(product.delivered[l].id == deliveredId) {
                    delivered = product.delivered[l];
                    break;
                }
            }

            deliveredPriceDiv.innerText = delivered.price === 0 ? "Бесплатная доставка" : delivered.price.toLocaleString() + " руб.";
            deliveredTermsDiv.innerText = delivered.terms;

            this.widget.sellers[i].products[j].currentDeliveredId = deliveredId;
            product.currentDeliveredId = deliveredId;

            this.changeResultPriceSeller(seller);
            this.changeResultPrice();

            Rex.callRpcMethod('Widgets', this.id, this.type, 'changeDelivered', [seller.id, product.id, deliveredId]);
        }.bind(this));
    }

    createResultSeller(seller, sellerDiv) {
        let resultCostSeller = this.getCostOfAllGoodsSeller(seller);

        let resultDiv = this.addElement("div", "SellerResultDiv", sellerDiv);

        let resultLeftDiv = this.addElement("div", "SellerResultLeftDiv", resultDiv);

        let resultRightDiv = this.addElement("div", "SellerResultRightDiv", resultDiv);

        // result price seller
        this.createResultCostSeller(seller, resultRightDiv, resultCostSeller);
        //----------------- end result price seller

        let costResultDiv = this.addElement("div", "SellerResultPriceDiv", resultRightDiv);

        let costResultTSpan = this.addElement("span", "SellerResultSpan", costResultDiv);
        costResultTSpan.innerText = "Общая стоимость:";

        let costResultSpan = this.addElement("span", "SellerFinalResultSpan", costResultDiv);
        costResultSpan.id = `${this.id}_${seller.id}_SellerFinalResultSpan`;
        costResultSpan.innerText = resultCostSeller.result.toLocaleString() + " руб.";

        let orderFromSellerBtnDiv = this.addElement("div", "OrderFromSellerBtnDiv", resultRightDiv);

        let orderFromSellerBtn = this.addElement("div", "OrderFromSellerBtn", orderFromSellerBtnDiv);
        orderFromSellerBtn.innerText = "Заказать у этого продавца";

        orderFromSellerBtn.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpPlaceOrderWithSeller', [seller.id]);
        });
    }

    createResultCostSeller(seller, resultRightDiv, resultCostSeller) {
        let resultPriceDiv = this.addElement("div", "SellerResultPriceDiv", resultRightDiv);

        let costDiv = this.addElement("div", "SellerCostDiv", resultPriceDiv);

        let costTSpan = this.addElement("span", "SellerResultSpan", costDiv);
        costTSpan.innerText = "Стоимость:";

        let costSpan = this.addElement("span", "SellerResultSpan", costDiv);
        costSpan.id = `${this.id}_${seller.id}_SellerResultSpan`;
        costSpan.innerText = resultCostSeller.cost.toLocaleString() + " руб.";
        costSpan.style.fontSize = "13px";
        costSpan.style.fontWeight = "bold";
        costSpan.style.opacity = "1";

        let costDeliveredDiv = this.addElement("div", "SellerCostDeliveredDiv", resultPriceDiv);

        let costDelTSpan = this.addElement("span", "SellerResultSpan", costDeliveredDiv);
        costDelTSpan.innerText = "Стоимость доставки:";

        let costDelSpan = this.addElement("span", "SellerResultSpan", costDeliveredDiv);
        costDelSpan.id = `${this.id}_${seller.id}_SellerCostDeliveredDiv`;
        costDelSpan.innerText = resultCostSeller.costDelivered.toLocaleString() + " руб.";
        costDelSpan.style.fontSize = "13px";
        costDelSpan.style.fontWeight = "bold";
        costDelSpan.style.opacity = "1";

        let economyDiv = this.addElement("div", "SellerEconomyDiv", resultPriceDiv);
        economyDiv.innerText = "(Вы экономите: " + resultCostSeller.economy.toLocaleString() + " руб.)";
        economyDiv.id = `${this.id}_${seller.id}_SellerEconomyDiv`;
    }

    createResult() {
        let resultAllDiv = this.addElement("div", "SellerResultAllDiv", this.containerBasket);

        let resultLeftDiv = this.addElement("div", "SellerResultAllLeftDiv", resultAllDiv);

        let removeAllDiv = this.addElement("div", "RemoveAllBtnDiv", resultLeftDiv);
        removeAllDiv.innerText = "Удалить все";

        removeAllDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpRemoveAll', []);
        });

        let resultRightDiv = this.addElement("div", "SellerResultAllRightDiv", resultAllDiv);

        this.createResultCost(resultRightDiv);

        let orderBtnDiv = this.addElement("div", "OrderFromSellerBtnDiv", resultRightDiv);

        let orderBtn = this.addElement("div", "OrderBtn", orderBtnDiv);
        orderBtn.innerText = "Оформить заказ";

        orderBtnDiv.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpPlaceOrder', []);
        });
    }

    createResultCost(resultRightDiv) {
        let resultCostAll = this.getCostOfAllSellers();

        let resCostDiv = this.addElement("div", "SellerResultAllCostDiv", resultRightDiv);

        let resCostTSpan = this.addElement("span", "SellerResultSpan", resCostDiv);
        resCostTSpan.innerText = "Стоимость (" + this.count.toLocaleString() + " товара(ов)): ";

        let resCostSpan = this.addElement("span", "SellerResultSpan", resCostDiv);
        resCostSpan.id = `${this.id}_ResultCostSpan`;
        resCostSpan.innerText = resultCostAll.cost.toLocaleString() + " руб.";
        resCostSpan.style.fontSize = "14px";
        resCostSpan.style.fontWeight = "bold";
        resCostSpan.style.opacity = "1";

        let resCostDeliveredDiv = this.addElement("div", "SellerResultAllCostDiv", resultRightDiv);

        let resCostDeliveredTSpan = this.addElement("span", "SellerResultSpan", resCostDeliveredDiv);
        resCostDeliveredTSpan.innerText = "Стоимость доставки: ";

        let resCostDeliveredSpan = this.addElement("span", "SellerResultSpan", resCostDeliveredDiv);
        resCostDeliveredSpan.id = `${this.id}_ResultCostDeliveredSpan`;
        resCostDeliveredSpan.innerText = resultCostAll.costDelivered.toLocaleString() + " руб.";
        resCostDeliveredSpan.style.fontSize = "14px";
        resCostDeliveredSpan.style.fontWeight = "bold";
        resCostDeliveredSpan.style.opacity = "1";

        let resEconomyDiv = this.addElement("div", "SellerResultAllCostDiv", resultRightDiv);

        let resEconomyTSpan = this.addElement("span", "SellerResultSpan", resEconomyDiv);
        resEconomyTSpan.innerText = "Скидки продавца: ";

        let resEconomySpan = this.addElement("span", "SellerResultSpan", resEconomyDiv);
        resEconomySpan.id = `${this.id}_ResultEconomySpan`;
        resEconomySpan.innerText = "-" + resultCostAll.economy.toLocaleString() + " руб.";
        resEconomySpan.style.fontSize = "14px";
        resEconomySpan.style.fontWeight = "bold";
        resEconomySpan.style.opacity = "1";

        let resAllDiv = this.addElement("div", "SellerResultAllCostDiv", resultRightDiv);

        let resAllTSpan = this.addElement("span", "SellerResultSpan", resAllDiv);
        resAllTSpan.innerText = "Общая сумма: ";
        resAllTSpan.style.fontSize = "15px";

        let resAllSpan = this.addElement("span", "SellerFinalResultSpan", resAllDiv);
        resAllSpan.id = `${this.id}_ResultAllSpan`;
        resAllSpan.innerText = resultCostAll.result.toLocaleString() + " руб.";
        resAllSpan.style.fontSize = "16px";
        resAllSpan.style.fontWeight = "bold";
        resAllSpan.style.opacity = "1";
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.containerBasket == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.containerBasket.scrollHeight - this.containerBasket.clientHeight;
        this.containerBasket.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }

    changeResultPriceSeller(seller) {
        let result = this.getCostOfAllGoodsSeller(seller);

        let elemPrice = document.getElementById(`${this.id}_${seller.id}_SellerResultSpan`);
        if(elemPrice != null) {
            elemPrice.innerText = result.cost.toLocaleString() + " руб.";
        }

        let elemEconomy = document.getElementById(`${this.id}_${seller.id}_SellerEconomyDiv`);
        if(elemEconomy != null) {
            elemEconomy.innerText = "(Вы экономите: " + result.economy.toLocaleString() + " руб.)";
        }

        let elemPriceDel = document.getElementById(`${this.id}_${seller.id}_SellerCostDeliveredDiv`);
        if(elemPriceDel != null) {
            elemPriceDel.innerText = result.costDelivered.toLocaleString() + " руб.";
        }

        let elemResultSellerPrice = document.getElementById(`${this.id}_${seller.id}_SellerFinalResultSpan`);
        if(elemResultSellerPrice != null) {
            elemResultSellerPrice.innerText = result.result.toLocaleString() + " руб.";
        }
    }

    changeResultPrice() {
        let resultAll = this.getCostOfAllSellers();

        let elemResultPrice = document.getElementById(`${this.id}_ResultCostSpan`);
        if(elemResultPrice != null) {
            elemResultPrice.innerText = resultAll.cost.toLocaleString() + " руб.";
        }

        let elemResultPriceDel = document.getElementById(`${this.id}_ResultCostDeliveredSpan`);
        if(elemResultPriceDel != null) {
            elemResultPriceDel.innerText = resultAll.costDelivered.toLocaleString() + " руб.";
        }

        let elemResultEconomy = document.getElementById(`${this.id}_ResultEconomySpan`);
        if(elemResultEconomy != null) {
            elemResultEconomy.innerText = "-" + resultAll.economy.toLocaleString() + " руб.";
        }

        let elemResultResult = document.getElementById(`${this.id}_ResultAllSpan`);
        if(elemResultResult != null) {
            elemResultResult.innerText = resultAll.result.toLocaleString() + " руб.";
        }
    }

    getCostOfAllGoodsSeller(seller) {
        let result = {};
        let cost = 0;
        let costDelivered = 0;
        let economy = 0;
        if(seller == null || seller.products == null || seller.products.length === 0) {
            result = {
                cost: 0,
                costDelivered: 0,
                economy: 0,
                result: 0
            };
            return result;
        }
        for(let i = 0; i < seller.products.length; ++i) {
            let product = seller.products[i];
            if(product == null) continue;
            let discPrice = (product.price / 100) * (100 - product.discount);
            cost += discPrice * product.count;
            economy += (product.price - discPrice) * product.count;

            for(let k = 0; k < product.delivered.length; ++k) {
                let delivered = product.delivered[k];
                if(delivered.id == product.currentDeliveredId) {
                    if(product.count !== 0)
                        costDelivered += delivered.price;
                    break;
                }
            }
        }
        let res = costDelivered + cost;
        result = {
            cost: cost,
            costDelivered: costDelivered,
            economy: economy,
            result: res
        };
        return result;
    }

    getCostOfAllSellers() {
        let result = {};
        let cost = 0;
        let costDelivered = 0;
        let economy = 0;
        if(this.widget.sellers == null || this.widget.sellers.length === 0) {
            result = {
                cost: 0,
                costDelivered: 0,
                economy: 0,
                result: 0
            };
            return result;
        }
        for(let i = 0; i < this.widget.sellers.length; ++i) {
            let seller = this.widget.sellers[i];
            if(seller == null || seller.products == null || seller.products.length === 0) continue;
            for(let j = 0; j < seller.products.length; ++j) {
                let product = seller.products[j];
                if(product == null) continue;
                let discPrice = (product.price / 100) * (100 - product.discount);
                cost += discPrice * product.count;
                economy += (product.price - discPrice) * product.count;

                for(let k = 0; k < product.delivered.length; ++k) {
                    let delivered = product.delivered[k];
                    if(delivered.id == product.currentDeliveredId) {
                        if(product.count !== 0)
                            costDelivered += delivered.price;
                        break;
                    }
                }
            }
        }
        let res = costDelivered + cost;
        result = {
            cost: cost,
            costDelivered: costDelivered,
            economy: economy,
            result: res
        };
        return result;
    }
}

class WidgetNewsFeedHtml extends WidgetViewHtml {

    constructor(widget) {
        super(widget);

        this._scrollPos = 0;
        this.anonymous = true;
        this.userId = "";
        this.news = [];
        this.addedNews = [];
        this.addComments = [];

        this.createDomElement("div");
        this.addClassName("WidgetNewsFeed");

        this.options = {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: "numeric",
            minute: "numeric"
        };

        this.newsContainer = document.createElement("div");
        this.newsContainer.classList.add("NewsContainer");
        this.htmlElement.appendChild(this.newsContainer);

        this.newsContainer.addEventListener("scroll", function (event) {
            const maxScrollPos = this.newsContainer.scrollHeight - this.newsContainer.clientHeight;
            const currentPos = this.newsContainer.scrollTop;
            if(maxScrollPos === currentPos) {
                this.newsContainer.scrollTop = currentPos;
            }
            Rex.callRpcMethod("Widgets", this.id, this.type, "setScrollPos", [currentPos / maxScrollPos]);
        }.bind(this));
    }

    addElement(type, className, parentElement) {
        let element = document.createElement(type);
        element.classList.add(className);
        parentElement.appendChild(element);
        return element;
    }

    decodeText(text) {
        let decodeText = "";
        try {
            decodeText = decodeURIComponent(escape(window.atob(text)));
        }
        catch(e) {
            console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
            decodeText = "Error";
        }
        return decodeText;
    }

    set scrollPos(value) {
        if(value < 0 || value > 1 || this.newsContainer == null) return;
        this._scrollPos = value;
        const maxScrollPos = this.newsContainer.scrollHeight - this.newsContainer.clientHeight;
        this.newsContainer.scrollTop = value * maxScrollPos;
    }

    get scrollPos() {
        return this._scrollPos;
    }

    sortByTime(array) {
        array.sort(function (a, b) {
            return a.date.getTime() - b.date.getTime();
        });
    }

    onSetState(state) {
        if(state.news != null) {
            let scrollPosition = 0;
            if(this.newsContainer != null) scrollPosition = this.newsContainer.scrollTop;
            this.news = JSON.parse(JSON.stringify(state.news));
            for(let index in state.news) {
                this.news[index].userName = this.decodeText(state.news[index].userName);

                this.news[index].text = this.decodeText(state.news[index].text);

                this.news[index].senderName = this.decodeText(state.news[index].senderName);

                let fullDate = this.news[index].date.split(" ");
                let date = new Date(fullDate[0] + "T" + fullDate[1]);
                this.news[index].date = date;

                if(this.news[index].comments != null) {
                    for(let i in this.news[index].comments) {
                        this.news[index].comments[i].userName = this.decodeText(state.news[index].comments[i].userName);

                        this.news[index].comments[i].text = this.decodeText(state.news[index].comments[i].text);

                        this.news[index].comments[i].opponentName = this.decodeText(state.news[index].comments[i].opponentName);

                        let fullDateC = this.news[index].comments[i].date.split(" ");
                        let dateC = new Date(fullDateC[0] + "T" + fullDateC[1]);
                        this.news[index].comments[i].date = dateC;
                    }
                    this.sortByTime(this.news[index].comments);
                }
            }
            if(this.newsContainer != null) {
                while(this.newsContainer.childNodes.length)
                    this.newsContainer.removeChild(this.newsContainer.firstChild);
            }
            this.addedNews = this.news;
            this.sortByTime(this.news);
            this.createNews();
            this.addedNews = [];
            this.scrollPos = this.scrollPos;
            if(this.newsContainer != null) this.newsContainer.scrollTop = scrollPosition;
        }

        if(state.addedNews != null) {
            let scrollPosition = 0;
            if(this.newsContainer != null) scrollPosition = this.newsContainer.scrollTop;
            this.addedNews = JSON.parse(JSON.stringify(state.addedNews));
            for(let index in state.addedNews) {
                this.addedNews[index].userName = this.decodeText(state.addedNews[index].userName);

                this.addedNews[index].text = this.decodeText(state.addedNews[index].text);

                this.addedNews[index].senderName = this.decodeText(state.addedNews[index].senderName);

                let fullDate = this.addedNews[index].date.split(" ");
                let date = new Date(fullDate[0] + "T" + fullDate[1]);
                this.addedNews[index].date = date;

                if(this.addedNews[index].comments != null) {
                    for(let i in this.addedNews[index].comments) {
                        this.addedNews[index].comments[i].userName = this.decodeText(state.addedNews[index].comments[i].userName);

                        this.addedNews[index].comments[i].text = this.decodeText(state.addedNews[index].comments[i].text);

                        this.addedNews[index].comments[i].opponentName = this.decodeText(state.addedNews[index].comments[i].opponentName);

                        let fullDateC = this.addedNews[index].comments[i].date.split(" ");
                        let dateC = new Date(fullDateC[0] + "T" + fullDateC[1]);
                        this.addedNews[index].comments[i].date = dateC;
                    }
                    this.sortByTime(this.addedNews[index].comments);
                }
                this.news.push(this.addedNews[index]);
            }
            this.sortByTime(this.addedNews);
            this.createNews();
            this.addedNews = [];
            this.scrollPos = this.scrollPos;
            this.newsContainer.scrollTop = scrollPosition;
        }

        if(state.addComments != null) {
            let scrollPosition = 0;
            if(this.newsContainer != null) scrollPosition = this.newsContainer.scrollTop;
            this.addComments = JSON.parse(JSON.stringify(state.addComments));
            for(let index in state.addComments) {
                if(this.addComments[index].comments != null) {
                    for(let i in this.addComments[index].comments) {
                        this.addComments[index].comments[i].userName = this.decodeText(state.addComments[index].comments[i].userName);

                        this.addComments[index].comments[i].text = this.decodeText(state.addComments[index].comments[i].text);

                        this.addComments[index].comments[i].opponentName = this.decodeText(state.addComments[index].comments[i].opponentName);

                        let fullDateC = this.addComments[index].comments[i].date.split(" ");
                        let dateC = new Date(fullDateC[0] + "T" + fullDateC[1]);
                        this.addComments[index].comments[i].date = dateC;
                    }
                }
                for(let i = 0; i < this.news.length; ++i) {
                    let news = this.news[i];
                    if(this.addComments[index].id !== news.id) continue;
                    for(let comment of this.addComments[index].comments) {
                        news.comments.push(comment);
                    }
                    this.sortByTime(news.comments);

                    if(!news.showComment) continue;
                    let commentsContainer = document.getElementById(`${this.id}_${news.id}_CommentsContainer`);
                    if(commentsContainer == null) continue;
                    if(commentsContainer != null) {
                        while(commentsContainer.childNodes.length)
                            commentsContainer.removeChild(commentsContainer.firstChild);
                    }
                    for(let j = 0; j < news.comments.length; ++j) {
                        let comment = news.comments[j];
                        if(comment == null) continue;
                        this.createOneComment(news, comment, commentsContainer);
                    }
                    this.createShowMoreComment(news, commentsContainer);
                }
            }
            this.scrollPos = this.scrollPos;
            this.newsContainer.scrollTop = scrollPosition;
            this.addComments = [];
        }
        if(state.deletedNews != null) {
            for(let item of state.deletedNews) {
                for(let i = 0; i < this.news.length; ++i) {
                    let news = this.news[i];
                    if(news.id !== item.newsId) continue;
                    this.news.splice(i, 1);

                    let oneNewsContainerDiv = document.getElementById(`${this.id}_${item.newsId}_news`);
                    if(oneNewsContainerDiv == null) continue;
                    oneNewsContainerDiv.remove();

                    break;
                }
            }
        }
        if(state.removeComments != null) {
            for(let item of state.removeComments) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    for(let i = 0; i < news.comments.length; ++i) {
                        let comment = news.comments[i];
                        if(comment.id !== item.commentId) continue;

                        news.comments.splice(i, 1);

                        let oneCommentContainer = document.getElementById(`${this.id}_${news.id}_${item.commentId}_comment`);
                        if(oneCommentContainer == null) continue;
                        oneCommentContainer.remove();

                        break;
                    }

                    let showMoreConainer = document.getElementById(`${this.id}_${news.id}_showMore`);
                    if(showMoreConainer == null) continue;
                    if(news.comments.length < news.countComments)
                        showMoreConainer.style.display = "block";
                    else showMoreConainer.style.display = "none";
                }
            }
        }
        if(state.changesCountLikeNews != null) {
            for(let item of state.changesCountLikeNews) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    news.countLike = item.countLike;
                    let newCountLikeElement = document.getElementById(`${this.id}_${news.id}_countLike`);
                    if(newCountLikeElement == null) continue;
                    newCountLikeElement.innerText = item.countLike === 0 ? "" : item.countLike.toLocaleString();
                }
            }
        }
        if(state.changesCountRepostNews != null) {
            for(let item of state.changesCountRepostNews) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    news.countRepost = item.countRepost;
                    let repostCount = document.getElementById(`${this.id}_${news.id}_countRepost`);
                    if(repostCount == null) continue;
                    repostCount.innerText = item.countRepost.toLocaleString();
                }
            }
        }
        if(state.changesCountCommentsNews != null) {
            for(let item of state.changesCountCommentsNews) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    news.countComments = item.countComments;
                    let commentCount = document.getElementById(`${this.id}_${news.id}_commentCount`);
                    if(commentCount == null) continue;
                    commentCount.innerText = news.countComments === 0 ? "" : news.countComments.toLocaleString();

                    let showMoreConainer = document.getElementById(`${this.id}_${news.id}_showMore`);
                    if(showMoreConainer == null) continue;
                    if(news.comments.length < news.countComments)
                        showMoreConainer.style.display = "block";
                    else showMoreConainer.style.display = "none";
                }
            }
        }
        if(state.changesYouLikeNews != null) {
            for(let item of state.changesYouLikeNews) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    news.youLike = item.youLike;
                    let likeIcon = document.getElementById(`${this.id}_${news.id}_likeIcon`);
                    if(likeIcon == null) continue;
                    if(news.youLike && !this.anonymous) {
                        likeIcon.innerText = "favorite";//если есть лайк пользователя
                        likeIcon.style.color = "red";
                        likeIcon.style.opacity = 1;
                    }
                    else {
                        likeIcon.innerText = "favorite_border";
                        likeIcon.style.color = "inherit";
                        likeIcon.style.opacity = 0.3;
                    }
                }
            }
        }
        if(state.changesCountLikeComment != null) {
            for(let item of state.changesCountLikeComment) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    for(let comment of news.comments) {
                        if(comment.id !== item.commentId) continue;
                        comment.countLike = item.countLike;
                        let newCountLikeElement = document.getElementById(`${this.id}_${news.id}_${comment.id}_countLike`);
                        if(newCountLikeElement == null) continue;
                        newCountLikeElement.innerText = item.countLike === 0 ? "" : item.countLike.toLocaleString();
                    }
                }
            }
        }
        if(state.changesYouLikeComment != null) {
            for(let item of state.changesYouLikeComment) {
                for(let news of this.news) {
                    if(news.id !== item.newsId) continue;
                    for(let comment of news.comments) {
                        if(comment.id !== item.commentId) continue;
                        comment.youLike = item.youLike;
                        let likeIcon = document.getElementById(`${this.id}_${news.id}_${comment.id}_likeIcon`);
                        if(likeIcon == null) continue;
                        if(comment.youLike && !this.anonymous) {
                            likeIcon.innerText = "favorite";//если есть лайк пользователя
                            likeIcon.style.color = "red";
                            likeIcon.style.opacity = 1;
                        }
                        else {
                            likeIcon.innerText = "favorite_border";
                            likeIcon.style.color = "inherit";
                            likeIcon.style.opacity = 0.3;
                        }
                    }
                }
            }
        }

        if(state.clearAll != null && this.news != null && this.news.length !== 0) {
            if(state.clearAll) this.clearNews();
        }
    }

    onInit() {
        this.scrollPos = 0;
        if(this.newsContainer != null) {
            while(this.newsContainer.childNodes.length)
                this.newsContainer.removeChild(this.newsContainer.firstChild);
        }
        this.addedNews = this.news;
        this.createNews();
        this.addedNews = [];
        this.scrollPos = this.scrollPos;
    }

    clearNews() {
        if(this.newsContainer != null) {
            while(this.newsContainer.childNodes.length)
                this.newsContainer.removeChild(this.newsContainer.firstChild);
        }
        this.news = [];
    }

    createNews() {
        if(this.addedNews == null || this.addedNews.length === 0) return;
        for(let i = 0; i < this.addedNews.length; ++i) {
            let news = this.addedNews[i];
            if(news == null) continue;
            this.createOneNews(news);
        }
    }

    createOneNews(news) {
        let oneNewsContainerDiv = document.createElement("div");
        oneNewsContainerDiv.classList.add("OneNewsContainer");
        oneNewsContainerDiv.id = `${this.id}_${news.id}_news`;
        this.newsContainer.insertBefore(oneNewsContainerDiv, this.newsContainer.firstChild);

        //header
        this.createHeaderNews(news, oneNewsContainerDiv);

        //news
        let messagesNewsContainer = this.addElement("div", "MessagesNewsContainer", oneNewsContainerDiv);

        if(news.text != "") {
            let textNews = this.addElement("div", "TextNews", messagesNewsContainer);
            textNews.innerText = news.text;
        }

        if(news.image != "") {
            let imageNews = this.addElement("div", "ImageNews", messagesNewsContainer);
            imageNews.style.backgroundImage = `url(${news.image})`;

            imageNews.addEventListener("mouseup", (e) => {
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpImageNews', [news.id, e.button]);
            });
        }

        //sender name
        if(news.isShowSenderName) {
            let senderContainer = this.addElement("div", "SenderNewsContainer", messagesNewsContainer);

            let iconSender = this.addElement("div", "SenderNewsIcon", senderContainer);
            iconSender.innerText = "person";

            let nameSender = this.addElement("div", "SenderNewsName", senderContainer);
            nameSender.innerText = news.senderName;

            nameSender.addEventListener("mouseup", (e) => {
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [news.senderId, e.button]);
            });

            iconSender.addEventListener("mouseup", (e) => {
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [news.userId, e.button]);
            });
        }

        //down bar
        this.createDownBarNews(news, oneNewsContainerDiv);

        //comments
        if(!news.showComment || this.anonymous) return;
        let commentsContainer = this.addElement("div", "NewsCommentsContainer", oneNewsContainerDiv);
        commentsContainer.id = `${this.id}_${news.id}_CommentsContainer`;

        this.sortByTime(news.comments);

        for(let j = 0; j < news.comments.length; ++j) {
            let comment = news.comments[j];
            if(comment == null) continue;
            this.createOneComment(news, comment, commentsContainer);
        }
        this.createShowMoreComment(news, commentsContainer);
    }

    createHeaderNews(news, oneNewsContainerDiv) {
        let headerNewsContainer = this.addElement("div", "HeaderNewsContainer", oneNewsContainerDiv);

        let headerUserAvatar = this.addElement("div", "NewsUserAvatar", headerNewsContainer);
        headerUserAvatar.style.backgroundImage = `url(${news.userAvatar})`;

        headerUserAvatar.addEventListener("mouseup", (e) => {
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [news.userId, e.button]);
        });

        let headerDataContainer = this.addElement("div", "HeaderDataContainer", headerNewsContainer);

        let headerUserName = this.addElement("div", "HeaderUserName", headerDataContainer);
        headerUserName.innerText = news.userName;

        headerUserName.addEventListener("mouseup", (e) => {
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [news.userId, e.button]);
        });

        let headerDate = this.addElement("div", "HeaderDate", headerDataContainer);
        headerDate.innerText = news.date.toLocaleString("ru", this.options);

        //menu
        this.createNewsMenu(news, headerNewsContainer);
    }

    createNewsMenu(news, headerNewsContainer) {
        let headerMenu = this.addElement("div", "NewsHeaderMenuContainer", headerNewsContainer);

        let headerMenuBtn = this.addElement("div", "NewsHeaderMenu", headerMenu);
        headerMenuBtn.innerText = "expand_more";

        let headerMenuItmContainer = this.addElement("div", "NewsHeaderMenuContainer-child", headerMenu);

        if(news.userId === this.userId) {
            let menuItem2 = this.addElement("div", "NewsHeaderMenuItem", headerMenuItmContainer);
            menuItem2.innerText = "Удалить";

            menuItem2.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpDeleteNews', [news.id]);
            });
        }
        else {
            let menuItem1 = this.addElement("div", "NewsHeaderMenuItem", headerMenuItmContainer);
            menuItem1.innerText = "Пожаловаться";

            menuItem1.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpReportNews', [news.id]);
            });
        }
    }

    createDownBarNews(news, oneNewsContainerDiv) {
        let downBarContainer = this.addElement("div", "NewsDownBarContainer", oneNewsContainerDiv);

        //like
        let likeContainer = this.addElement("div", "DownBarNewsElementContainer", downBarContainer);
        likeContainer.title = "Нравится";

        likeContainer.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpLikeNews', [news.id]);
        });

        let likeIcon = this.addElement("div", "DownBarIcon", likeContainer);
        likeIcon.id = `${this.id}_${news.id}_likeIcon`;
        if(news.youLike && !this.anonymous) {
            likeIcon.innerText = "favorite";//если есть лайк пользователя
            likeIcon.style.color = "red";
            likeIcon.style.opacity = 1;
        }
        else likeIcon.innerText = "favorite_border";

        let countLike = news.countLike;

        let likeCount = this.addElement("div", "DownBarCount", likeContainer);
        likeCount.id = `${this.id}_${news.id}_countLike`;
        likeCount.innerText = countLike === 0 ? "" : countLike.toLocaleString();

        if(news.showComment && !this.anonymous) {
            //comment
            let commentContainer = this.addElement("div", "DownBarNewsElementContainer", downBarContainer);
            commentContainer.title = "Комментарий";

            commentContainer.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpCommentsNews', [news.id]);
            });

            let commentIcon = this.addElement("div", "DownBarIcon", commentContainer);
            commentIcon.innerText = "chat_bubble_outline";

            let commentCount = this.addElement("div", "DownBarCount", commentContainer);
            commentCount.id = `${this.id}_${news.id}_commentCount`;
            commentCount.innerText = news.countComments === 0 ? "" : news.countComments.toLocaleString();
        }

        //repost
        let repostContainer = this.addElement("div", "DownBarNewsElementContainer", downBarContainer);
        repostContainer.title = "Поделиться";

        repostContainer.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpRepostNews', [news.id]);
        });

        let repostIcon = this.addElement("div", "DownBarIcon", repostContainer);
        repostIcon.innerText = "reply";

        let countRepost = news.countRepost;

        let repostCount = this.addElement("div", "DownBarCount", repostContainer);
        repostCount.id = `${this.id}_${news.id}_countRepost`;
        repostCount.innerText = countRepost === 0 ? "" : countRepost.toLocaleString();

        //не удалять! Это для отображения количества просмотров. Пока нет, но потом нужно будет!!!!!

        //view
        // let viewContainer = this.addElement("div", "DownBarNewsViewContainer", downBarContainer);
        // // viewContainer.id = `${this.id}_${news.id}_news`;

        // let viewtIcon = this.addElement("div", "DownBarViewIcon", viewContainer);
        // // viewtIcon.id = `${this.id}_${news.id}_news`;
        // viewtIcon.innerText = "remove_red_eye";

        // let countView = 1050;

        // let viewCount = this.addElement("div", "DownBarViewCount", viewContainer);
        // // viewCount.id = `${this.id}_${news.id}_news`;
        // viewCount.innerText = countView === 0 ? "" : countView.toLocaleString();
    }

    createOneComment(news, comment, commentsContainer) {
        let oneCommentContainer = document.createElement("div");
        oneCommentContainer.classList.add("NewsOneCommentContainer");
        oneCommentContainer.id = `${this.id}_${news.id}_${comment.id}_comment`;
        if(comment.isAnswer) {
            oneCommentContainer.classList.add("NewsOneCommentContainerAnswer");
            let element = document.getElementById(`${this.id}_${news.id}_${comment.idAnswerComment}_comment`);
            if(element == null) return;
            let elementNext = element;
            let elementPrev = null;
            while(elementNext != null) {
                elementPrev = elementNext;
                elementNext = elementNext.nextSibling;
                if(elementNext == null)
                    commentsContainer.insertBefore(oneCommentContainer, elementPrev.nextSibling);
            }

        }
        else commentsContainer.appendChild(oneCommentContainer);

        //avatar
        let senderCommentAvatar = this.addElement("div", "NewsUserCommentAvatar", oneCommentContainer);
        senderCommentAvatar.style.backgroundImage = `url(${comment.userAvatar})`;

        senderCommentAvatar.addEventListener("mouseup", (e) => {
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [comment.userId, e.button]);
        });

        //dataComment
        this.createDataComment(news, comment, oneCommentContainer);

    }

    createDataComment(news, comment, oneCommentContainer) {
        let dataCommentContainer = this.addElement("div", "NewsDataCommentContainer", oneCommentContainer);

        //header
        this.createHeaderComment(news, comment, dataCommentContainer);

        //body comment
        this.createBodyComment(news, comment, dataCommentContainer);

        //down bar
        this.createDownBarComment(news, comment, dataCommentContainer);
    }

    createHeaderComment(news, comment, dataCommentContainer) {
        let headerCommentContainer = this.addElement("div", "NewsHeaderCommentContainer", dataCommentContainer);

        let commentSenderName = this.addElement("div", "NewsCommentSenderName", headerCommentContainer);

        let commentSenderNameSpan = this.addElement("div", "NewsCommentSenderNameSpan", commentSenderName);
        commentSenderNameSpan.innerText = comment.userName;

        commentSenderNameSpan.addEventListener("mouseup", (e) => {
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [comment.userId, e.button]);
        });

        let headerCommentBtn = this.addElement("div", "NewsCommentHeaderBtn", headerCommentContainer);
        if(comment.userId === this.userId || news.userId === this.userId) {
            headerCommentBtn.title = "Удалить";
            headerCommentBtn.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpDeleteComment', [news.id, comment.id]);
            });
        }
        else {
            headerCommentBtn.title = "Пожаловаться";
            headerCommentBtn.addEventListener("mouseup", (e) => {
                if(e.button !== 0) return;
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpReportComment', [news.id, comment.id]);
            });
        }
        headerCommentBtn.innerText = "clear";
    }

    createBodyComment(news, comment, dataCommentContainer) {
        let textComment = this.addElement("div", "NewsCommentText", dataCommentContainer);

        if(comment.isAnswer) {
            let opponentNameSpan = this.addElement("span", "NewsCommentOpponentNameSpan", textComment);
            opponentNameSpan.innerText = comment.opponentName + ", ";

            opponentNameSpan.addEventListener("mouseup", (e) => {
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpUser', [comment.opponentId, e.button]);
            });
        }

        if(comment.text != "") {
            let commentTextSpan = document.createElement("span");
            commentTextSpan.innerText = comment.text;
            textComment.appendChild(commentTextSpan);
        }

        if(comment.image != "") {
            let imageComment = this.addElement("div", "NewsCommentImage", textComment);
            imageComment.style.backgroundImage = `url(${comment.image})`;

            imageComment.addEventListener("mouseup", (e) => {
                Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpImageComment', [news.id, comment.id, e.button]);
            });
        }
    }

    createDownBarComment(news, comment, dataCommentContainer) {
        let commentDownBarContainer = this.addElement("div", "NewsCommentDownBarContainer", dataCommentContainer);

        let dateComment = this.addElement("div", "NewsCommentDownBarDate", commentDownBarContainer);
        dateComment.innerText = comment.date.toLocaleString("ru", this.options);

        let answerCommentCont = this.addElement("div", "NewsCommentDownBarAnswerContainer", commentDownBarContainer);

        let answerComment = this.addElement("div", "NewsCommentDownBarAnswer", answerCommentCont);
        answerComment.innerText = "Ответить";

        answerComment.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpAnswer', [news.id, comment.id, comment.userId]);
        });

        let countLikeDownBarCommentContainer = this.addElement("div", "NewsDownBarCountLikeCommentContainer", commentDownBarContainer);

        let countLikeCommentContainer = this.addElement("div", "NewsCountLikeCommentContainer", countLikeDownBarCommentContainer);
        countLikeCommentContainer.title = "Нравится";

        countLikeCommentContainer.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpLikeComment', [news.id, comment.id]);
        });

        let likeCommentIcon = this.addElement("div", "DownBarCommentIcon", countLikeCommentContainer);
        likeCommentIcon.id = `${this.id}_${news.id}_${comment.id}_likeIcon`;
        if(comment.youLike) {
            likeCommentIcon.innerText = "favorite";//если есть лайк пользователя
            likeCommentIcon.style.color = "red";
            likeCommentIcon.style.opacity = 1;
        }
        else likeCommentIcon.innerText = "favorite_border";

        let likeCommentCount = this.addElement("div", "DownBarCommentCount", countLikeCommentContainer);
        likeCommentCount.id = `${this.id}_${news.id}_${comment.id}_countLike`;
        likeCommentCount.innerText = comment.countLike === 0 ? "" : comment.countLike.toLocaleString();
    }

    createShowMoreComment(news, commentsContainer) {
        let showMoreConainer = this.addElement("div", "NewsShowMoreConainer", commentsContainer);
        showMoreConainer.id = `${this.id}_${news.id}_showMore`;

        if(news.comments.length < news.countComments)
            showMoreConainer.style.display = "block";
        else showMoreConainer.style.display = "none";

        let showMoreSpan = this.addElement("div", "NewsShowMoreSpan", showMoreConainer);
        showMoreSpan.innerText = "Показать следующие комментарии";

        showMoreSpan.addEventListener("mouseup", (e) => {
            if(e.button !== 0) return;
            Rex.callRpcMethod('Widgets', this.id, this.type, 'mouseUpShowMore', [news.id]);
        });
    }
}

class WidgetSideBarsHtml extends WidgetViewHtml {

	constructor(widget) {
		super(widget);

		this.showRightPanel = true;
		this.showLeftPanel = true;
		this.leftWidget = -1;
		this.rightWidget = -1;
		this.centerWidget = -1;
		this.leftContainerWidth = "25%";
		this.leftContainerMaxWidth = "290px";
		this.rightContainerWidth = "25%";
		this.rightContainerMaxWidth = "290px";
		this.buttonSize = "290px";

		this.createDomElement("div");
		this.addClassName("WidgetSideBars");

		this.buttonsContainer = this.leftBtnContainer = document.createElement("div");
		this.buttonsContainer.classList.add("WSB-buttons-container");
		this.htmlElement.appendChild(this.buttonsContainer);

		this.openContentBtn = document.createElement("div");
		this.openContentBtn.classList.add("material-icons", "WSB-OpenContentBtn");
		this.openContentBtn.textContent = "menu";
		this.openContentBtn.title = "Скрыть боковые панели";
		this.buttonsContainer.appendChild(this.openContentBtn);

		this.leftBtnContainer = document.createElement("div");
		this.leftBtnContainer.classList.add("WSB-custom-buttons-container");
		this.buttonsContainer.appendChild(this.leftBtnContainer);

		this.leftContainer = document.createElement("div");
		this.leftContainer.classList.add("WSB-LeftContainer", "min-width-style");
		this.htmlElement.appendChild(this.leftContainer);

		this.centerContainer = document.createElement("div");
		this.centerContainer.classList.add("WSB-CenterContainer");
		this.htmlElement.appendChild(this.centerContainer);

		this.rightContainer = document.createElement("div");
		this.rightContainer.classList.add("WSB-RightContainer", "min-width-style");
		this.htmlElement.appendChild(this.rightContainer);

		this.openContentBtn.addEventListener("click", this.toggleSideBars.bind(this));
	}

	addElement(type, className, parentElement) {
		let element = document.createElement(type);
		element.classList.add(className);
		parentElement.appendChild(element);
		return element;
	}

	decodeText(text) {
		let decodeText = "";
		try {
			decodeText = decodeURIComponent(escape(window.atob(text)));
		}
		catch (e) {
			console.log(this.widget.type, "setState->", "Text DecodeError!", e, text);
			decodeText = "Error";
		}
		return decodeText;
	}

	onSetState(state) {
		if (state.leftWidget != null) {
			this.setLeftWidget();
		}
		if (state.centerWidget != null) {
			this.setCenterWidget();
		}
		if (state.rightWidget != null) {
			this.setRightWidget();
		}
		if (state.showLeftPanel != null) {
			this.visibleLeftPanel();
		}
		if (state.showRightPanel != null) {
			this.visibleRightPanel();
		}
		if (state.leftContainerWidth != null) {
			this.updateLeftContainerWidth();
		}
		if (state.leftContainerMaxWidth != null) {
			this.updateLeftContainerMaxWidth();
		}
		if (state.rightContainerMaxWidth != null) {
			this.updateRightContainerWidth();
		}
		if (state.rightContainerMaxWidth != null) {
			this.updateRightContainerMaxWidth();
		}
		if (state.buttonSize != null) {
			this.htmlElement.style.setProperty("--sb-button-size", this.buttonSize);
		}
		if (state.customButtons) {
			this.updateCustomButtons();
		}
		if (state.toggleSB != null) {
			if (!state.toggleSB && this.leftContainer.classList.contains("hidden-side-bar")) {
				this.leftContainer.classList.remove("hidden-side-bar");
				this.rightContainer.classList.remove("hidden-side-bar");
				this.openContentBtn.classList.remove("WSB-OpenContentBtn-rotate");
				this.openContentBtn.title = "Скрыть боковые панели";
				this.centerContainer.classList.remove("WSB-CenterContainer-compact");
				this.centerContainer.classList.remove("WSB-CenterContainer-compact-onclick");
				this.leftBtnContainer.classList.toggle("zero-size");
				setTimeout(() => {
					this.rightContainer.classList.toggle("min-width-style");
					this.leftContainer.classList.toggle("min-width-style");
					this.buttonsContainer.classList.toggle("hide-panel");
					this.leftBtnContainer.classList.toggle("zero-size");
				}, 300);
			} else if (state.toggleSB && !this.leftContainer.classList.contains("hidden-side-bar")) {
				this.leftContainer.classList.add("hidden-side-bar");
				this.rightContainer.classList.add("hidden-side-bar");
				this.openContentBtn.classList.add("WSB-OpenContentBtn-rotate");
				this.openContentBtn.title = "Показать боковые панели";
				this.centerContainer.classList.add("WSB-CenterContainer-compact");
				this.centerContainer.classList.add("WSB-CenterContainer-compact-onclick");
				this.leftBtnContainer.classList.toggle("zero-size");

				this.rightContainer.classList.toggle("min-width-style");
				this.leftContainer.classList.toggle("min-width-style");
				setTimeout(() => {
					this.buttonsContainer.classList.toggle("hide-panel");
					this.leftBtnContainer.classList.toggle("zero-size");
				}, 300);
			}
		}
	}

	onInit() {
		if (this.leftWidget != -1) this.setLeftWidget();
		if (this.centerWidget != -1) this.setCenterWidget();
		if (this.rightWidget != -1) this.setRightWidget();
		this.updateCustomButtons();
	}

	appendChild(child) {
		if (child.id == this.leftWidget) {
			this.leftContainer.appendChild(child);
		}
		if (child.id == this.centerWidget) {
			this.centerContainer.appendChild(child);
		}
		if (child.id == this.rightWidget) {
			this.rightContainer.appendChild(child);
		}
	}

	removeChilds(parent) {
		for (let child of parent.childNodes)
			child.remove();
	}

	setLeftWidget() {
		this.removeChilds(this.leftContainer);
		if (this.leftWidget != -1 && Rex.widgets != null && Rex.widgets[this.leftWidget]) {
			this.leftContainer.appendChild(Rex.widgets[this.leftWidget].view.htmlElement);
			this.updateLeftContainerMaxWidth();
			this.updateLeftContainerWidth();
		}
	}

	setCenterWidget() {
		this.removeChilds(this.centerContainer);
		if (this.centerWidget != -1 && Rex.widgets != null && Rex.widgets[this.centerWidget]) {
			this.centerContainer.appendChild(Rex.widgets[this.centerWidget].view.htmlElement);
		}
	}

	setRightWidget() {
		this.removeChilds(this.rightContainer);
		if (this.rightWidget != -1 && Rex.widgets != null && Rex.widgets[this.rightWidget]) {
			this.rightContainer.appendChild(Rex.widgets[this.rightWidget].view.htmlElement);
			this.updateRightContainerWidth();
			this.updateRightContainerMaxWidth();
		}
	}

	updateLeftContainerWidth() {
		this.htmlElement.style.setProperty("--sb-left-panel-width", this.leftContainerWidth);
	}

	updateRightContainerWidth() {
		this.htmlElement.style.setProperty("--sb-right-panel-width", this.rightContainerWidth);
	}

	updateLeftContainerMaxWidth() {
		this.htmlElement.style.setProperty("--sb-left-panel-max-width", this.leftContainerMaxWidth);
	}

	updateRightContainerMaxWidth() {
		this.htmlElement.style.setProperty("--sb-right-panel-max-width", this.rightContainerMaxWidth);
	}

	visibleLeftPanel() {
		if (this.showLeftPanel) {
			this.leftContainer.classList.remove("hiddenPanel");
			this.openContentBtn.classList.remove("hiddenPanel");
		}
		else {
			if (!this.leftContainer.classList.contains("hiddenPanel"))
				this.leftContainer.classList.add("hiddenPanel");
			if (!this.showRightPanel)
				this.openContentBtn.classList.add("hiddenPanel");
		}
	}

	visibleRightPanel() {
		if (this.showRightPanel) {
			this.rightContainer.classList.remove("hiddenPanel");
			this.openContentBtn.classList.remove("hiddenPanel");
		}
		else {
			if (!this.rightContainer.classList.contains("hiddenPanel"))
				this.rightContainer.classList.add("hiddenPanel");
			if (!this.showLeftPanel)
				this.openContentBtn.classList.add("hiddenPanel");
		}
	}

	toggleSideBars() {
		if (this.leftContainer.classList.contains("hidden-side-bar")) {
			this.leftContainer.classList.remove("hidden-side-bar");
			this.rightContainer.classList.remove("hidden-side-bar");
			this.openContentBtn.classList.remove("WSB-OpenContentBtn-rotate");
			this.openContentBtn.title = "Скрыть боковые панели";
			this.centerContainer.classList.remove("WSB-CenterContainer-compact");
			this.centerContainer.classList.remove("WSB-CenterContainer-compact-onclick");
			this.leftBtnContainer.classList.toggle("zero-size");
			setTimeout(() => {
				this.rightContainer.classList.toggle("min-width-style");
				this.leftContainer.classList.toggle("min-width-style");

				this.buttonsContainer.classList.toggle("hide-panel");
				this.leftBtnContainer.classList.toggle("zero-size");
			}, 300);
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "pressHiddenButton", [true]);

		} else {
			this.leftContainer.classList.add("hidden-side-bar");
			this.rightContainer.classList.add("hidden-side-bar");
			this.openContentBtn.classList.add("WSB-OpenContentBtn-rotate");
			this.openContentBtn.title = "Показать боковые панели";
			this.centerContainer.classList.add("WSB-CenterContainer-compact");
			this.centerContainer.classList.add("WSB-CenterContainer-compact-onclick");
			this.leftBtnContainer.classList.toggle("zero-size");

			this.rightContainer.classList.toggle("min-width-style");
			this.leftContainer.classList.toggle("min-width-style");
			setTimeout(() => {
				this.buttonsContainer.classList.toggle("hide-panel");
				this.leftBtnContainer.classList.toggle("zero-size");
			}, 300);
			Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "pressHiddenButton", [false]);
		}
	}

	updateCustomButtons() {
		if (this.buttonsContainer == null) return;

		for (let i = 0; i < this.leftBtnContainer.childNodes.length; ++i) {
			let btn = this.leftBtnContainer.childNodes[i];
			if (btn == null) continue;
			btn.remove();
			i--;
		}

		if (null == this.customButtons)
			return;

		for (let key of Object.keys(this.customButtons)) {
			let btn = this.customButtons[key];
			if (null == btn)
				continue;

			let elem = document.createElement("span");
			elem.classList.add("material-icons", "WSB-custom-button");
			elem.title = btn.buttonName;
			elem.innerText = btn.iconName;
			this.leftBtnContainer.appendChild(elem);

			elem.addEventListener("click", () => {
				Rex.callRpcMethod("Widgets", this.widget.id, this.widget.type, "pressCustomButton", [btn.buttonName]);
			});
		}

	}
}

/**
 * Created by ALLekSSSanDR on 21.12.2017.
 */


/**
 * WebScene
 * @constructor
 */
class WebScene {
	
	constructor() {
		this._$needUpdate = false;
		this.widgets = [];
		this._$gui = new WebGui();
		Rex.otherGui.push(this._$gui);
		this.loop();
	}
	
	loop() {
		window.requestAnimationFrame(function() {
			this.loop();
			this.generateUpdate();
		}.bind(this));
	}

	getGui() {
		return this._$gui;
	}
	
	addWidget(widget) {
		//проверка на наличие в this.widgets
		if(this.widgets.indexOf(widget) != -1) return;
		this.widgets.push(widget);
		widget.setScene(this);
	}
	
	contains(widget){
		return this.widgets.indexOf(widget) !== -1;
	}
	
	generateConstructor() {
		let state = "";
		if(Rex.gui === undefined) {
			state = "Rex.gui.update(";
			state = this._$gui.generateConstructor(state);
			state += ");";
		}
		state += "Rex.widgets = {";
		for(let i = 0; i < this.widgets.length; ++i) {
			state += "'" + this.widgets[i]._$id + "':";
			state = this.widgets[i].generateConstructor(state);
			if(i != this.widgets.length - 1) state += ",";
			this.widgets[i].flags.clearFlags();
		}
		state += "}";
		let temp = Rex.widgets;
		needCreate(btoa("Rex.scene = new Scene();" + state));
		for(let key in temp) {
			let widget = Rex.widgets[key];
			if(widget === undefined) {
				Rex.widgets[key] = temp[key];
			}
		}
		return state;
	}
	
	generateUpdate() {
		if(Rex.scene === undefined) return;
		if(!this._$needUpdate) return;
		let state = "{";
		if(!this._$gui.flags.isEmpty()) {
			state += "\"gui\":";
			state = this._$gui.generateState(state);
			state += ",";
			this._$gui.flags.clearFlags();
		}
		state += "\"widgets\":{";
		for(let i = 0; i < this.widgets.length; ++i) {
			let widget = this.widgets[i];
			if(widget._$needDestroy) continue;
			if(widget.flags.isEmpty()) continue;
			state += "\"" + widget._$id + "\":";
			state = widget.generateState(state);
			if(i != this.widgets.length - 1) state += ",";
			widget.flags.clearFlags();
		}
		if (state[state.length - 1] == ',') state = state.slice(0, -1);
		state += "}}";
		needUpdate(JSON.parse(state));
		this._$needUpdate = false;
	}
	
	update(object, name) {
		if(object === undefined) return;
		object.flags.addFlag(name);
		this._$needUpdate = true;
	}
	
	updateAll() {
		for(let i = 0; i < this.widgets.length; ++i) {
			this.widgets[i].flags.addFlag("All");
		}
		this._$needUpdate = true;
	}
	
	findObject(id) {
		for(let i = 0; i < this.widgets.length; ++i){
			if (this.widgets[i]._$id == id) return this.widgets[i];
		}
		return undefined;
	}
	
	cleanUp() {
		if(Rex.scene === undefined) return;
		let state = "{";
		state += "\"destroyed\":[";
		let strarr = "";
		for(let i = 0; i < this.widgets.length; ++i) {
			let widget = this.widgets[i];
			if(!widget._$destroyed) continue;
			if(strarr.length!==0) strarr += ",";
			strarr += "\"" + widget._$id + "\"";
		}
		state += strarr;
		state += "]}";
		
		for(let i = 0; i < this.widgets.length; ++i) {
			let widget = this.widgets[i];
			if(!widget._$destroyed) continue;
			this.widgets.splice(i, 1);
			--i;
		}
		
		needUpdate(JSON.parse(state));
	}
	
}


var webIds = 0;
getId = function() {
	return "web" + webIds++;
};

class WebBase extends BaseObject {
	
	constructor() {
		super();
		this._$id = getId();
		this._$parent = undefined;
		this._$children = [];
		this._$name = "";
		this._$scene = undefined;
		this._$needDestroy = false;
	}
	
	getID() {
		return this._$id;
	}
	
	setTypeName(value) {
		this._$typeName = value;
	}
	
	getTypeName() {
		return "Object";
	}
	
	addParent(value) {
		if(this._$parent === value) return;
		this._$parent = value;
	}
	
	getParent() {
		return this._$parent;
	}
	
	setParent(parent) {
		//тут нужен именно такой сет парент. если у кого есть вопросы - к Горбатову на согласование.
		//будущий Горбатов или тот, кому пришлось это править: надеюсь ты разберешься. говнокод, но вроде понять можно.
		if(parent == undefined || parent == Rex.webScene) {
			this._$parent = undefined;
			Rex.webScene.addWidget(this);
		} else {
			if(!parent.includeWidget(this)) {
				//console.error("ERROR! In " + parent.getTypeName() + " can't add Widget");
			}
			
		}
	}
	
	getParentRoot() {
		let tmp = this;
		if(tmp == undefined) return undefined;
		while(tmp.hasParent()) {
			if(!tmp.getParent()) return tmp;
			tmp = tmp.getParent();
		}
		return tmp;
	}
	
	hasParent() {
		return this._$parent != undefined;
	}
	
	getChildren() {
		return this._$children;
	}
	
	addChild(child) {
		if(child === undefined) return false;
		if(this.getChildren().indexOf(child) !== -1) return false;
		this.getChildren().push(child);
		child.addParent(this);
		child.setScene(this.getScene());
		return true;
	}
	
	replaceChild(i, child) {
		if(child == undefined) return undefined;
		let oldChild = undefined;
		if(i > 0 && i < this._$children.length) {
			oldChild = this._$children[i];
			this._$children[i] = child;
		}
		if(child._$scene == undefined) child.setScene(this._$scene);
		if(oldChild != undefined) oldChild.setParent(undefined);
		
		return oldChild;
	}
	
	insertChild(i, child) {
		if(child == undefined) return;
		this._$children.splice(i, 0, child);
		if(child._$parent !== this) child.setParent(this);
		if(child._$scene == undefined) child.setScene(this._$scene);
	}
	
	getChild(i) {
		return this._$children[i];
	}
	
	getNumChildren() {
		return this._$children.length;
	}
	
	setName(value) {
		if(this._$name === value) return;
		this._$name = value;
	}
	
	getName() {
		return this._$name;
	}
	
	getParentName() {
		if(this._$parent == undefined) return undefined;
		return this._$parent.name();
	}
	
	getScene() {
		return this._$scene;
	}
	
	setScene(scene) {
		if(scene == undefined || scene === this._$scene) return;
		this._$scene = scene;
		if(!scene.contains(this)) scene.addWidget(this);
		
		this.onSetScene(scene);
		
		for(let child of this._$children) {
			if(!scene.contains(child)) scene.addWidget(child);
		}
	}
	
	onSetScene(scene) {}
	
	setNeedDestroy(value) {
		if(value != this._$needDestroy) {
			this._$needDestroy = value;
			for(let i = 0; i < this._$children.length; ++i) {
				this.getChild(i)._$needDestroy = value;
			}
		}
	}
	
	getNeedDestroy() {
		return this._$needDestroy;
	}
	
	isNeedDestroy() {
		return false;
	}
	
	destroy() {
		super.destroy();
		if((this._$parent != undefined) && (!this._$parent._$destroyed)) this._$parent.destroy();
		for(let i = 0; i < this._$children.length; ++i) {
			if(this._$children[i]._$destroyed) continue;
			this._$children[i].destroy();
		}
		Rex.webScene.cleanUp();
	}
	
	onDestroy() {}
	
	setAutoUpdateScene(value) {
		//TODO
		for(let i = 0; i < this._$children.length; ++i) {
			this._$children[i].setAutoUpdateScene(value);
		}
	}
	
	mouseDoubleClick(){}
	
}

/**
 * Created by ALLekSSSanDR on 21.12.2017.
 */
	
class WebGui extends WebBase {
	
	constructor() {
		super();
		this._$id = "webGui0";
		this._$focusWidget = undefined;
		this._$hoverWidget = undefined;
		this._$menu = undefined;
		this._$selectWidgets = [];
		this.flags = new SuperUpdate(true);
		this._$permanentFocus = false;
	}
	
	getTypeName() {
		return "Gui";
	}
	
	generateConstructor(state) {
		state += "new Gui(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	generateState(state) {
		state += "{";
		state += "\"id\":";
		state += "\"" + this._$id + "\"";
		state += ",\"type\":";
		state += "\"" + this.getTypeName() + "\"";
		
		if(this.flags.hasFlag(GuiUpdate.HoverWidget) && this._$hoverWidget !== undefined) {
			state += ",\"hovered\":";
			state += "\"" + this._$hoverWidget._$id + "\"";
		}
		
		if(this.flags.hasFlag(GuiUpdate.FocusWidget) && this._$focusWidget !== undefined) {
			state += ",\"focused\":";
			state += "\"" + this._$focusWidget._$id + "\"";
		}
		
		if(this.flags.hasFlag(GuiUpdate.PopUpMenu)) {
			state += ",\"menuId\":";
			if(this._$menu) state += "\"" + this._$focusWidget._$id + "\"";
			else state += "\"" + (-1) + "\"";
		}
		
		if(this.flags.hasFlag(GuiUpdate.PermanentFocus)) state += ",\"permanent\":" + this._$permanentFocus;
		if(this.flags.hasFlag(GuiUpdate.SelectWidgets)) state += ",\"selectWidgets\":[" + JSON.stringify(this._$selectWidgets) + "]";
		
		state += "}";
		return state;
	}
	
	setHoverWidget(hover) {
		if(this._$hoverWidget == hover) return;
		if(this._$hoverWidget !== undefined) {
			this._$hoverWidget.setGuiHovered(false);
			this.run("onHoveredWidget", this._$hoverWidget, false);
		}
		if(hover !== undefined) this._$hoverWidget = hover;
		else this.clearHover();
		if(this._$hoverWidget !== undefined) {
			this._$hoverWidget.setGuiHovered(true);
			this.run("onHoveredWidget", this._$hoverWidget, true);
		}
		if(this._$hoverWidget !== undefined && this._$hoverWidget.isNeedDestroy()) this._$hoverWidget = undefined;
		Rex.webScene.update(this, GuiUpdate.HoverWidget);
	}
	
	getHoverWidget() {
		return this._$hoverWidget;
	}
	
	setFocusWidget(focus) {
		if(this._$permanentFocus) return;
		if(this._$focusWidget == focus) return;
		if(this._$focusWidget !== undefined) this._$focusWidget.setGuiFocused(false);
		if(focus !== undefined) this._$focusWidget = focus;
		else this.clearFocus();
		this.run("onFocusedWidget", this._$focusWidget, true);
		if(this._$focusWidget !== undefined) this._$focusWidget.setGuiFocused(true);
		if(this._$focusWidget !== undefined && this._$focusWidget.isNeedDestroy()) {
			this.setHoverWidget(undefined);
			this._$focusWidget = undefined;
		}
		Rex.webScene.update(this, GuiUpdate.FocusWidget);
	}
	
	getFocusWidget() {
		return this._$focusWidget;
	}
	
	setFocusWidgetPermanentById(id) {
		this._$permanentFocus = false;
		this.setFocusWidgetById(id);
		this.setPermanentFocus(true);
	}
	
	setFocusWidgetPermanent(focus) {
		this._$permanentFocus = false;
		this.setFocusWidget(focus);
		this.setPermanentFocus(true);
	}
	
	setPermanentFocus(value) {
		if(this._$permanentFocus == value) return;
		this._$permanentFocus = value;
		Rex.webScene.update(this, GuiUpdate.PermanentFocus);
	}
	
	setHoverWidgetById(id) {
		if(!isNaN(id)) return;
		this._$hoverWidget = Rex.webScene.findObject(id);
		Rex.webScene.update(this, GuiUpdate.HoverWidget);
	}
	
	setFocusWidgetById(id) {
		if(!isNaN(id)) return;
		this._$focusWidget = Rex.webScene.findObject(id);
		if(this._$focusWidget != null) this._$focusWidget.setGuiFocused(true);
		Rex.webScene.update(this, GuiUpdate.FocusWidget);
	}
	
	popMenu(senderId, x, y) {
		let sender = Rex.webScene.findObject(senderId);
		if(!sender) return;
		if(this._$menu !== undefined) {
			this._$menu.destroy();
			this._$menu = undefined;
		}
		this._$menu = new WebWidgetPopUpMenu();
		this._$menu.setVisible(false);
		this._$menu.setPos(x, y);
		this.onGenerateMenu(this._$menu, sender);
		sender.generateMenu(this._$menu);
		if(!this._$menu.getNumChildren()) {
			this._$menu.destroy();
			this.clearMenu();
			Rex.webScene.update(this, GuiUpdate.PopUpMenu);
			return;
		}
		this._$menu.setOrder(500);
		this._$menu.setVisible(true);
		this.setFocusWidget(this._$menu);
		Rex.webScene.update(this, GuiUpdate.PopUpMenu);
		//		Rex.webScene.update(menu, "All");
	}
	
	onGenerateMenu(menu, sender) {
		menu.setTypeView(sender.getTypeView());
		
		//Пример создания popUpMenu и работы с ним
		//		for (let i = 0; i < 5; ++i) {
		//			menu.addItem(`Item ${i}`);
		//		}
		//
		//		let a = menu.addItem("It2msssssssssssssssssssssssssssssssssssssssssssssssssssssssaaaaaaa");
		//		a.setIcon("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTOzQckz8akzRolOdcjMMT8B8SrkTbi7_sMyo6gRUYGieg_X4_qSQ");
		//		menu.addItem("It3m");
		//		let sm1 = menu.addSubMenu("SubIt3m1");
		//		sm1.setIcon("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTOzQckz8akzRolOdcjMMT8B8SrkTbi7_sMyo6gRUYGieg_X4_qSQ");
		//		sm1.setIconAlign(1);
		//		let item = sm1.getMenu().addItem("tree2Item1");
		//		item.setIcon("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTOzQckz8akzRolOdcjMMT8B8SrkTbi7_sMyo6gRUYGieg_X4_qSQ");
		//		item.setIconAlign(2);
		//		let sm3 = menu.addSubMenu("SubIt3m1");
		//		sm3.setIcon("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTOzQckz8akzRolOdcjMMT8B8SrkTbi7_sMyo6gRUYGieg_X4_qSQ");
		//		sm3.setIconAlign(3);
		//		sm3.getMenu().addItem("tree2Item1");
		//		sm3.getMenu().addItem("tree2Item3");
		//		sm3.getMenu().addItem("tree2Item4");
		//		sm3.getMenu().addItem("tree2Item5");
		//		let sm2 = sm1.getMenu().addSubMenu("tree2SUBItem2");
		//		sm2.getMenu().addItem("LAST_IT>>1");
		//		sm2.getMenu().addItem("LAST_IT>>@");
		//		sm2.getMenu().addItem("LAST_IT>>#");
		//		sm2.getMenu().addItem("LAST_IT>>$");
		//		sm1.getMenu().addItem("tree2Item3");
		//		sm1.getMenu().addItem("tree2Item4");
		//		sm1.getMenu().addItem("tree2Item5");
		//		menu.addItem("It4m");
	}
	
	clearHover() {
		this._$hoverWidget = undefined;
	}
	
	clearFocus() {
		if(this._$focusWidget != null) this._$focusWidget.setGuiFocused(false);
		this._$focusWidget = undefined;
		if(this._$menu != null) {
			this._$menu.destroy();
			this._$menu = undefined;
		}
	}
	
	clearMenu() {
		this._$menu = undefined;
	}
	
	clear() {
		if(this._$hoverWidget != undefined) {
			this._$hoverWidget = undefined;
			this._$hoverWidget.run("onHoveredWidget", true);
		}
		
		if(this._$focusWidget != undefined) {
			this._$focusWidget = undefined;
			this._$focusWidget.run("onFocusedWidget", true);
		}
		
		if(this._$menu) {
			this._$menu = undefined;
		}
		
		if(this._$permanentFocus) {
			this._$permanentFocus = false;
		}
		Rex.webScene.update("All")
	}
	
	setSelectWidgets(select) {
		this._$selectWidgets = JSON.parse(select);
		Rex.webScene.update(this, GuiUpdate.SelectWidgets);
	}
	
	save() {
		this.run("save");
	}
	
	paste(x, y) {
	
	}
	
	drop(id, data) {
	
	}
	
}

/**
 * Created by ALLekSSSanDR on 21.12.2017.
 */

class SuperUpdate {
	constructor(value) {
		this.all = value;
		this.flags = [];
	}
	
	addFlag(flag) {
		if(flag === "All") this.all = true;
		else this.flags.push(flag);
	}
	
	clearFlags() {
		this.flags = [];
		this.all = false;
	}
	
	hasFlag(flag) {
		if(this.all) return true;
		return this.flags.includes(flag);
	}
	
	isEmpty() {
		if(this.all) return false;
		return this.flags.length == 0;
	}
	
}

var BaseUpdate  = {
	None		:"None",
	Visible		:"Visible",
	Position	:"Position",
	Size		:"Size",
	Editable	:"Editable",
	Order		:"Order",
	Draggable	:"Draggable",
	Transform	:"Transform",
	Elevation	:"Elevation",
	Header		:"Header",
	Text		:"Text",
	Children	:"Children",
	Styles		:"Style"
};

var GuiUpdate = {
	None			: "None",
	FocusWidget		: "FocusWidget",
	HoverWidget		: "HoverWidget",
	PopUpMenu		: "PopUpMenu",
	PermanentFocus	: "PermanentFocus",
	SelectWidgets	: "SelectWidgets",
	Styles			: "Styles"
};

var LabelUpdate = {
	AutoFontSize	: "AutoFontSize",
	AutoHeight		: "AutoHeight",
	Align			: "Align",
	Bold			: "Bold",
	Italic			: "Italic",
	Color			: "Color",
	FontSize		: "FontSize"
};

var ImageUpdate = {
	ImageData   : "ImageData",
	ImageId		: "ImageId",
	Position	: "Position",
	Icon 		: "Icon"
};

var ButtonUpdate = {
	Press		: "Press",
	IconAlign	: "IconAlign"
};

var ToggleUpdate = {
	Checked : "Checked",
	IconAlign	: "IconAlign"
};

var RadioButtonUpdate = {
	Checked : "Checked",
	IconAlign	: "IconAlign"
};

var SwitchUpdate = {
	Enable		: "Enable",
	Pressed		: "Pressed",
	On			: "On",
	Off			: "Off"
};

var CheckBoxUpdate = {
	Checked     : "Checked",
	IconAlign	: "IconAlign"
};

var InputUpdate = {
	CursorPosition	: "CursorPosition",
	SelectPosition	: "SelectPosition",
	Valid			: "Valid"
};

var ScrollUpdate = {
	Type			: "Type",
	ArrowStep		: "ArrowStep",
	MouseStep		: "MouseStep",
	ContentSize		: "ContentSize",
	ArrowVisible	: "ArrowVisible"
};

var ScrollAreaUpdate = {
	HorizontalScroll: "HorizontalScroll",
	VerticalScroll	: "VerticalScroll",
	HorizontalShow	: "HorizontalShow",
	VerticalShow	: "VerticalShow",
	ContentLayout	: "ContentLayout"
};

var TextAreaUpdate = {
	CursorPosition	: "CursorPosition",
	SelectPosition	: "SelectPosition",
	GlobalSelect	: "GlobalSelect",
	CursorLine		: "CursorLine",
	SelectLine		: "SelectLine",
	FontSize		: "FontSize",
	TextAlign		: "TextAlign",
	LineHeight		: "LineHeight",
	Bold			: "Bold",
	Italic			: "Italic"
};

var LayoutUpdate = {
	Orientation 	: "Orientation"
};

var LayoutGridUpdate = {
	Items: "Items"
};

var ListUpdate = {
	CurrentItem	: "CurrentItem",
	HeightItem	: "HeightItem",
	Selected	: "Selected",
	Selection	: "Selection",
	MultiSelect	: "MultiSelect"
};

var WindowUpdate = {
	EnableHeader :	"EnableHeader",
	NeedAttach   :	"NeedAttach",
	Align		:"Align",
	SizePolicy	:"SizePolicy",
	NeedUnAttach :	"NeedUnAttach"
};

var SpinBoxUpdate = {
	Value	: "Value",
	Step	: "Step",
	Enter	: "Enter"
};

var TabUpdate = {
	CurrentTab		: "CurrentTab",
	HeaderLayout	: "HeaderLayout",
	Count			: "Count"
};

var MenuUpdate = {
	ParentMenuId : "ParentMenuId",
	ItemWidth	 : "ItemWidth",
	ItemHeight	 : "ItemHeight",
	IconAlign	: "IconAlign"
};

var StickUpdate = {
	CurrentButton: "CurrentButton"
};

var ComboBoxUpdate = {
	Expanded		: "Expanded",
	ExpandedHeight	: "ExpandedHeight",
	CurrentItem		: "CurrentItem"
};

var SpacerUpdate = {
	Depress		: "Depress",
	Orientation	: "Orientation"
};

var TreeUpdate = {
	UpdateHoveredItem	: "UpdateHoveredItem",
	UpdateSelectedItem	: "UpdateSelectedItem",
	RemoveItem			: "RemoveItem",
	UpdateItem			: "UpdateItem"
};

var SliderUpdate = {
	Start		: "Start",
	End			: "End",
	Min			: "Min",
	Max			: "Max",
	Value		: "Value",
	Real		: "Real",
	Step		: "Step",
	Numerical	: "Numerical",
	Type		: "Type",
	Tooltip		: "Tooltip",
	Limits		: "Limits",
	Double		: "Double"
};

var ConstructorUpdate = {
	Hovered		: "Hovered",
	Focused		: "Focused",
	AlignWidgets: "AlignWidgets"
};

var CalendarUpdate = {
	CalendarType : "CalendarType",
	Day			:"Day",
	Month		:"Month",
	Year		:"Year",
	SecondaryDay : "SecondaryDay",
	SecondaryMonth : "SecondaryMonth",
	SecondaryYear : "SecondaryYear",
	Events : "Events",
	Holidays: "Holidays"
};

var TimeUpdate = {
	SelectedType: "SelectedType", 
	Hours: "Hours", 
	Minutes: "Minutes", 
	Seconds: "Seconds",
	SecondaryHours: "SecondaryHours", 
	SecondaryMinutes: "SecondaryMinutes", 
	SecondarySeconds: "SecondarySeconds"
};

var ToolBoxUpdate = {
	Pages 					: "Pages",
	MaxHeightButtons 		: "MaxHeightButtons",
	AutoHide 				: "AutoHide"
};

var FrameUpdate = {
	Src : "Src"
};

var TableUpdate = {
	IsNumberSort 	: "IsNumberSort",
	Data			: "Data",
	NeedHeadRow		: "NeedHeadRow",
	NeedBorder		: "NeedBorder",
	FixHeadRow		: "FixHeadRow",
	Meta			: "Meta",
	NeedRowsNumber	: "NeedRowsNumber",
	NeedResize		: "NeedResize"
};

/**
 * Created by ALLekSSSanDR on 21.12.2017.
 */
var WidgetHorizontalAlign = {
	None: 0,
	Left: 1,
	Center: 2,
	Right: 3
};

var WidgetVerticalAlign = {
	None: 0,
	Top: 1,
	Center: 2,
	Bottom: 3
};

var WidgetSizePolicy = {
	Fixed: 0,
	Minimal: 1,
	FullScreen: 2,
	Expand: 3
};

class WebWidget extends WebBase {
	
	constructor(parent) {
		super();
		this._$visible = true;
		this._$editable = false;
		this._$draggable = false;
		this._$posX = 0;
		this._$posY = 0;
		this._$elevation = 0;
		this._$width = 88.0;
		this._$height = 36.0;
		this._$minWidth = 0;
		this._$minHeight = 0;
		this._$maxWidth = 100000.0;
		this._$maxHeight = 100000.0;
		this._$paddingLeft = 0.0;
		this._$paddingRight = 0.0;
		this._$paddingTop = 0.0;
		this._$paddingBottom = 0.0;
		this._$marginLeft = 0.0;
		this._$marginRight = 0.0;
		this._$marginTop = 0.0;
		this._$marginBottom = 0.0;
		this._$order = 0;
		this._$styleName = this.getTypeName();
		this._$styleToChildren = false;
		this._$hint = "";
		this._$customStyle = {};
		this._$typeView = "html";

		this.flags = new SuperUpdate(true);

	}

	getTypeName() {
		return "Widget";
	}

	getGui() {
		return this.scene == undefined ? undefined : this._$scene._$gui;
	}

	update(flag) {
		Rex.webScene.update(this, flag);
		this.onUpdate(flag);
	}
	
	// ?? блядь, сука, у нас половина виджетов на этой хуйне завязано
	// кто нибудь вообще проверял, что они работают? ебаный насос, че началось-то?
	onUpdate(flag){}
	
	addAttribute(name,value){
		if (this._$customStyle[name] != value){
			this._$customStyle[name] = value;
			this.update(BaseUpdate.Styles);
		}
	}
	
	generateConstructor(state) {
		this.flags.addFlag("All");
		return this.onGenerateConstructor(state);
	}
	
	onGenerateConstructor(state) {
		state += "new Widget(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	generateState(state) {
		state += "{";
		
		state += "\"id\":";
		state += "\"" + this._$id + "\"";
		state += ",\"type\":\"";
		state += this.getTypeName();
		state += "\"";
		state += ",\"typeView\":\"";
		state += this._$typeView;
		state += "\"";
		
		if(this._$name.length != 0) {
			state += ",\"name\":\"";
			state += this._$name;
			state += "\"";
		}
		
		if(this._$hint && this._$hint.length != 0) {
			state += ",\"hint\":\"";
			state += btoa(unescape(encodeURIComponent(this._$hint))) + "\"";
		}
		
		if(this.flags.hasFlag(BaseUpdate.Position)) {
			state += ",\"posX\":";
			state += this._$posX;
			state += ",\"posY\":";
			state += this._$posY;
		}
		
		if(this.flags.hasFlag(BaseUpdate.Elevation)) state += ",\"elevation\":" + this._$elevation;
		
		if(this.flags.hasFlag(BaseUpdate.Size)) {
			state += ",\"width\":";
			state += this._$width;
			state += ",\"height\":";
			state += this._$height;
			
			state += ",\"minWidth\":";
			state += this._$minWidth;
			state += ",\"minHeight\":";
			state += this._$minHeight;
			
			state += ",\"maxWidth\":";
			state += this._$maxWidth;
			state += ",\"maxHeight\":";
			state += this._$maxHeight;
			
			state += ",\"paddingLeft\":";
			state += this._$paddingLeft;
			state += ",\"paddingRight\":";
			state += this._$paddingRight;
			state += ",\"paddingTop\":";
			state += this._$paddingTop;
			state += ",\"paddingBottom\":";
			state += this._$paddingBottom;
			
			state += ",\"marginLeft\":";
			state += this._$marginLeft;
			state += ",\"marginRight\":";
			state += this._$marginRight;
			state += ",\"marginTop\":";
			state += this._$marginTop;
			state += ",\"marginBottom\":";
			state += this._$marginBottom;
		}
		
		if(this.flags.hasFlag(BaseUpdate.Styles)) state += ",\"customStyle\":" + JSON.stringify(this._$customStyle);
		
		if(this.flags.hasFlag(BaseUpdate.Order)) state += ",\"order\":" + this._$order;
		if(this.flags.hasFlag(BaseUpdate.Visible)) state += ",\"visible\":" + this._$visible;
		if(this.flags.hasFlag(BaseUpdate.Editable)) state += ",\"editable\":" + this._$editable;
		if(this.flags.hasFlag(BaseUpdate.Draggable)) state += ",\"draggable\":" + this._$draggable;
		//
		// if(updateState.getFlags() != ~0 && updateState.is(WidgetUpdate::Transform)) {
		//  	state += ",\"transform\":[";
		//  	GlobeXY::convert(transform, state);
		//  	state += "]";
		// }
		if(this._$parent == undefined)
			state += ",\"parentId\":-1";
		else {
			state += ",\"parentId\":";
			state += "\"" + this._$parent.getID() + "\"";
		}
		
		if(this._$styleName.length) state += ",\"styleName\":\"" + this._$styleName + "\"";
		
		state += ",\"styleToChildren\":";
		state += this._$styleToChildren;
		
		if(this.flags.hasFlag(BaseUpdate.Children)) {
			if(this._$children.length) {
				state += ",\"children\":[";
				for(let i = 0; i < this._$children.length; ++i) {
					state += "\"" + this._$children[i]._$id + "\"";
					if(i != this._$children.length - 1) state += ",";
				}
				state += "]";
			} else {
				state += ",\"children\":[]";
			}
		}
		state = this.onGenerateState(state);
		
		state += "}";
		
		return state;
	}
	
	onGenerateState(state) {
		return state;
	}

	setPos(x, y) {
		if(this._$posX == x && this._$posY == y) return;
		this.run("onSetPos", x, y);
		if(this._$posX != x) {
			this._$posX = x;
			this.run("onChangePosX", x);
		}
		if(this._$posY != y) {
			this._$posY = y;
			this.run("onChangePosY", y);
		}
		this.update(BaseUpdate.Position);
	}
	
	setPosX(x) {
		if(this._$posX == x) return;
		this._$posX = x;
		this.run("onChangePosX", x);
		this.update(BaseUpdate.Position);
	}
	
	getPosX() {
		return this._$posX;
	}
	
	setPosY(y) {
		if(this._$posY == y) return;
		this._$posY = y;
		this.run("onChangePosY", y);
		this.update(BaseUpdate.Position);
	}
	
	getPosY() {
		return this._$posY;
	}
	
	setElevation(_elevation) {
		if(this._$elevation == _elevation) return;
		this._$elevation = _elevation;
		this.update(BaseUpdate.Elevation);
	}
	
	getElevation() {
		return this._$elevation;
	}
	
	setSize(w, h) {
		if(this._$width == w && this._$height == h) return;
		if(this._$width !== w) this.run("onChangeWidth", w);
		if(this._$height !== h) this.run("onChangeHeight", h);
		this._$width = w;
		this._$height = h;
		this.update(BaseUpdate.Size);
	}
	
	setWidth(w) {
		if(this._$width == w || w < 0) return;
		this._$width = w;
		this.run("onChangeWidth", w);
		this.update(BaseUpdate.Size);
	}
	
	getWidth() {
		return this._$width;
	}
	
	setHeight(h) {
		if(this._$height == h || h < 0) return;
		this._$height = h;
		this.run("onChangeHeight", h);
		this.update(BaseUpdate.Size);
	}

	getHeight() {
		return this._$height;
	}
	
	setOrder(o) {
		if(this._$order == o) return;
		this._$order = o;
		//горбатов: я закоментил этот код. если у вас бомбануло - подойдите и объясните, зачем это надо.
		//for(let i = 0; i < this._$children.length; ++i) {
		//	this._$children[i].setOrder(this._$order);
		//}
		this.update(BaseUpdate.Order);
	}
	
	getOrder() {
		return this._$order;
	}
	
	setText() {}

	getText() {
		return "";
	}
	
	setHeader() {}

	getHeader() {
		return "";
	}
	
	setStyleName(s) {
		if(this.styleName === s) return;
		this._$styleName = s;
		this.run("onChangeStyleName", s);
		this.onSetStyleName(s);
		this.update("All");
	}
	
	getStyleName() {
		return this._$styleName;
	}
	
	isStyleToChildren() {
		return this._$styleToChildren;
	}
	
	setStyleToChildren(value) {
		if(this._$styleToChildren == value) return;
		this._$styleToChildren = value;
		this.run("onChangeStyleToChildren", value);
		this.update("All");
	}
	
	onSetStyleName(value) {}
	
	setMinMaxGeometry(minWidth,maxWidth, minHeigth, maxHeigth){
		if (minWidth) this.setMinWidth(minWidth);
		if (maxWidth) this.setMaxWidth(maxWidth);
		if (minHeigth) this.setMinHeight(minHeigth);
		if (maxHeigth) this.setMaxHeight(maxHeigth);
	}
	
	setMinWidth(value) {
		if(this._$minWidth == value) return;
		this._$minWidth = value;
		this.run("onChangeMinWidth", value);
		this.update(BaseUpdate.Size);
	}
	
	getMinWidth() {
		return this._$minWidth;
	}
	
	setMinHeight(value) {
		if(this._$minHeight == value) return;
		this._$minHeight = value;
		this.run("onChangeMinHeight", value);
		this.update(BaseUpdate.Size);
	}
	
	getMinHeight() {
		return this._$minHeight;
	}
	
	setMaxWidth(value) {
		if(this._$maxWidth == value) return;
		this._$maxWidth = value;
		this.run("onChangeMaxWidth", value);
		this.update(BaseUpdate.Size);
	}
	
	getMaxWidth() {
		return this._$maxWidth;
	}
	
	setMaxHeight(value) {
		if(this._$maxHeight == value) return;
		this._$maxHeight = value;
		this.run("onChangeMaxHeight", value);
		this.update(BaseUpdate.Size);
	}
	
	getMaxHeight() {
		return this._$maxHeight;
	}
	
	setPadding(left, right, top, bottom) {
		this._$paddingLeft = left;
		this._$paddingRight = right;
		this._$paddingTop = top;
		this._$paddingBottom = bottom;
		this.update(BaseUpdate.Size);
	}
	
	setMargin(left, right, top, bottom) {
		this._$marginLeft = left;
		this._$marginRight = right;
		this._$marginTop = top;
		this._$marginBottom = bottom;
		this.update(BaseUpdate.Size);
	}

	setTypeView(value) {
		if(value != this._$typeView) {
			this._$typeView = value;
			for(let i = 0; i < this._$children.length; ++i) {
				this.getChild(i)._$typeView = value;
			}
		}
	}

	getTypeView() {
		return this._$typeView;
	}

	getCustomStyle() {
		this.update(BaseUpdate.Styles);
		return this._$customStyle;
	}
	
	setHint(h) {
		this._$hint = h;
	}
	
	getHint() {
		return this._$hint;
	}
	
	setGeometry(x, y, w, h) {
		if(this._$posX !== x || this._$posY !== y) {
			if (this._$posX !== x)
				this.run("onChangePosX", x);
			if (this._$posY !== y)
				this.run("onChangePosY", y);
			this._$posX = x;
			this._$posY = y;
			this.update(BaseUpdate.Position);
		}
		if(this._$width !== w || this._$height !== h) {
			if(this._$width !== w)
				this.run("onChangeWidth", w);
			if(this._$height !== h)
				this.run("onChangeHeight", h);
			this._$width = w;
			this._$height = h;
			this.update(BaseUpdate.Size);
		}
	}
	
	setHovered(hovered) {
		let gui = this._$scene.getGui();
		if(gui == undefined) return;
		hovered ? gui.setHoverWidget(this) : gui.setHoverWidget(undefined);
	}
	
	setGuiHovered(hovered) {}
	
	isHovered() {
		return this.getGui() == undefined ? false : this.getGui().getHoverWidget() === this;
	}
	
	setFocused(focused) {
		let gui = this._$scene.getGui();
		if(gui == undefined) return;
		focused ? gui.setFocusWidget(this) : gui.setFocusWidget(undefined);
	}
	
	setGuiFocused(focused) {}
	
	isFocused() {
		return this.getGui() == undefined ? false : this.getGui().getFocusWidget() === this;
	}
	
	isSelected() {
		return this.getGui() == undefined ? false : this.getGui().checkSelect(this.getID());
	}
	
	isVisible() {
		return this._$visible;
	}
	
	setVisible(v) {
		if(this._$visible == v) return;
		this._$visible = v;
		this.run("onVisible", v);
		for(let i = 0; i < this._$children.length; ++i) {
			this._$children[i].setVisible(this._$visible);
		}
		this.update(BaseUpdate.Visible);
	}
	
	isEditable() {
		return this._$editable;
	}
	
	setEditable(e) {
		if(this._$editable == e) return;
		this._$editable = e;
		let t = new WebWidget();
		for(let i = 0; i < this._$children.length; ++i) {
			t = this._$children[i]; //TODO правильный перевод?
			if(t != undefined) t.setEditable(this._$editable);
		}
		this.update(BaseUpdate.Editable);
	}
	
	setDraggable(d) {
		if(this._$draggable == d) return;
		this._$draggable = d;
		this.update(BaseUpdate.Draggable);
	}
	
	isDraggable() {
		return this._$draggable;
	}
	
	generateProperties(properties) {
		
	}

	generateMenu(menu) {
		if (menu == undefined) {
			console.log("%s -> Menu is nullptr\n");
			return;
		}
		this.onGenerateMenu(menu);
	}


	includeWidget(widget) {
		if(widget == undefined || widget == this) return false;
		let tp = widget.getParent();
		if(tp)
			if(!tp.extractWidget(widget)) return false;
		if(this.onIncludeWidget(widget)) {
			this.run("onIncludeWidget", widget, true);
			this.update(BaseUpdate.Children);
			return true;
		}
		else {
			this.run("onIncludeWidget", widget, false);
			return false;
		}
	}

	extractWidget(widget) {
		if(widget == undefined || widget == this) return false;
		let root = this.getParentRoot();
		if(root == undefined) return this.onExtractWidget(widget);
		return root.onExtractWidget(widget);
	}

	removeWidget(widget) {
		if(widget == undefined || widget == this) return false;
		if(this.extractWidget(widget)) {
			widget.destroy();
			return true;
		}
		return false;
	}

	extractInternal(widget) {
		if(WebWidget.prototype.onExtractWidget.call(this,widget)) return true;
		for(let i = 0; i < this._$children.length; ++i) {
			let w = this.getChild(i);
			if(w === undefined) continue;
			if(w.onExtractWidget(widget)) return true;
		}
		return false;
	}

	includeWidgetByName(name) {}

	extractWidgetByName(name) {}

	cleanWidget() {
		return this.onCleanWidget();
	}

	destroy() {
		super.destroy();
		if(this.getGui() != undefined) {
			if(this.getGui().getFocusWidget() === this || this.getGui().getHoverWidget() === this) {
				this.getGui().clear();
			}
		}
	}

	onAlign() {}

	onGenerateMenu(menu) {}

	onDestroy(){}

	drag(data) {
		this.run("onDrag", data);
	}

	drop(data) {
		this.run("onDrop", data);
	}

	onIncludeWidget(widget) {
		this.addChild(widget);
		this.update(BaseUpdate.Children);
		return true;
	}

	onExtractWidget(widget) {
		let i = this._$children.indexOf(widget);
		if(i != -1) {
			let child = this._$children.splice(i, 1)[0];
			child._$parent = undefined;
			child.update(BaseUpdate.Children);
			this.update(BaseUpdate.Children);
			return true;
		}
		return false;
	}

	onCleanWidget() {
		return true;
	}

	onSetScene(scene) {
		this.update("All");
	}
	
	onViewInit(){
		//console.log("я заиинитился, забирай меня, чмо! ", document.getElementById(this.getID()));
	}
}

/**
 * Created by 2rneps on 21.12.2017.
 */

class WebWidgetLabel extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$text = "";
		this._$fontSize = -1;
		this._$autoHeight = false;
		this._$textAlign = WidgetHorizontalAlign.Center;
		this._$italicFont = false;
		this._$styleName = this.getTypeName();
		this._$boldFont = false;
		this._$colorText = "";
		this._$autoFontSize = false;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetLabel";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetLabel(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(BaseUpdate.Text)) state += ",\"text\":\"" + btoa(unescape(encodeURIComponent(this._$text))) + "\"";
		if(this.flags.hasFlag(LabelUpdate.FontSize)) state += ",\"fontSize\":" + this._$fontSize;
		if(this.flags.hasFlag(LabelUpdate.Bold)) state += ",\"boldFont\":" + this._$boldFont;
		if(this.flags.hasFlag(LabelUpdate.Italic)) state += ",\"italicFont\":" + this._$italicFont;
		if(this.flags.hasFlag(LabelUpdate.Align)) state += ",\"textAlign\":" + this._$textAlign;
		if(this.flags.hasFlag(LabelUpdate.Color)) state += ",\"colorText\":\"" + this._$colorText + "\"";
		if (this.flags.hasFlag(LabelUpdate.AutoFontSize)) state += ",\"autoFontSize\":" + this._$autoFontSize;
		if (this.flags.hasFlag(LabelUpdate.AutoHeight)) state += ",\"autoHeight\":" + this._$autoHeight;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetLabel can not has children.');
		widget.destroy();
		return false;
	}
	
	setText(text) {
		if(this._$text == text) return;
		this._$text = text;
		this.update(BaseUpdate.Text);
	}
	
	getText() {return this._$text;}

	setFontSize(fontSize) {
		if (this._$fontSize == fontSize) return;
		this._$fontSize = fontSize;
		this.update(LabelUpdate.FontSize);
	}

	setItalic(value) {
		if(this._$italicFont == value) return;
		this._$italicFont = value;
		this.update(LabelUpdate.Italic);
	}
	
	setBoldFont(_boldFont) {
		if(this._$boldFont == _boldFont) return;
		this._$boldFont = _boldFont;
		this.update(LabelUpdate.Bold);
	}
	
	setColorText(_colorText) {
		if(this._$colorText == _colorText) return;
		this._$colorText = _colorText;
		this.update(LabelUpdate.Color);
	}

	setAutoFontSize(_autoFontSize) {
		if (this._$autoFontSize == _autoFontSize) return;
		this._$autoFontSize = _autoFontSize;
		this.run("onChangeAutoFontSize", _autoFontSize);
		this.update(LabelUpdate.AutoFontSize);
	}
	
	setTextAlign(align) {
		if(this._$textAlign == align || align > 4 || align < 0) return;
		this._$textAlign = align;
		this.update(LabelUpdate.Align);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget() {
		this.setText("");
		return true;
	}
}

/**
 * Created by prg-15 on 23.12.2017.
 */

class WebWidgetButton extends WebWidget {
	
	constructor(parent) {
		super(parent);
		this._$pressed = false;
		this._$minWidth = 88;
		this._$minHeight = 36;
		this._$defaultElevation = 2;
		this._$raisedElevation = 4;
		this._$elevation = this._$defaultElevation;
		this._$styleName = this.getTypeName();
		this._$iconAlign = WidgetHorizontalAlign.None;
		this._$label = undefined;
		this._$icon = undefined;
		this.setParent(parent);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetButton(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(ButtonUpdate.Press)) state += ",\"pressed\":" + this._$pressed;
		if(this.flags.hasFlag(BaseUpdate.Elevation)) {
			state += ",\"raisedElevation\":" + this._$raisedElevation;
			state += ",\"defaultElevation\":" + this._$defaultElevation;
		}
		if(this.flags.hasFlag(ButtonUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}

	getTypeName() {
		return "WidgetButton";
	}
	
	addChild(widget) {
		// if(!widget) return false;
		// if(widget === this._$icon || widget === this._$label) super.addChild(widget);
		// else {
		// 	console.error('WebWidgetButton can not has children.');
		// 	widget.destroy();
		// }
		return false;
	}
	
	setText(text) {
		if(this._$label === undefined) return;
		this._$label.setText(text);
	}
	
	setIconByName(name_material_icon){
		this._$icon.setIcon(name_material_icon);
		this.setIconAlign(WidgetHorizontalAlign.Left);
	}
	
	getLabel() {
		return this._$label;
	}
	
	getText() {
		return this._$label._$text;
	}
	
	setIcon(icon) {
		// this._$icon.setIcon(icon);
	}

	setIconFromImageData(data) {
		// this._$icon.setImageData(data);
	}
	
	getIcon() {
		return this._$icon;
	}
	
	getIconAlign() {
		return this._$iconAlign;
	}
	
	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.run("onChangeIconAlign", align);
		this.update(ButtonUpdate.IconAlign);
	}
	
	setRaisedElevation(_raisedElevation, _defaultElevation) {
		if(_defaultElevation == -1) {
			this._$defaultElevation = this._$elevation;
		}
		else {
			this._$defaultElevation = _defaultElevation;
			this._$elevation = this._$defaultElevation;
		}
		this._$raisedElevation = _raisedElevation;
		this.update(BaseUpdate.Elevation);
	}

	isPressed() {
		return this._$pressed;
	}

	press() {
		if(this._$pressed) return;
		if(this._$elevation != this._$raisedElevation) {
			this._$elevation = this._$raisedElevation;
			this.update(BaseUpdate.Elevation);
		}
		this._$pressed = true;
		this.onPress(this._$pressed);
	}

	unpress() {
		if(!this._$pressed) return;
		if(this._$defaultElevation != this._$elevation) {
			this._$elevation = this._$defaultElevation;
			this.update(BaseUpdate.Elevation);
		}
		this._$pressed = false;
		this.onPress(this._$pressed);
	}

	onPress(pressed) {
		this.run("onPress", pressed);
		this.update(ButtonUpdate.Press);
	}
	
	onSetScene(scene) {
		// if(this._$icon === undefined) {
		// 	this._$icon = new WebWidgetImage();
		// 	this.addChild(this._$icon);
		// }
		// if(this._$label === undefined) {
		// 	this._$label = new WebWidgetLabel();
		// 	this.addChild(this._$label);
		// }
		super.onSetScene(scene);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onSetStyleName(styleName) {
		//if(this._$label == undefined) return;
		//this._$label.setStyleName(styleName);
		//if(this._$icon == undefined) return;
		//this._$icon.setStyleName(styleName);
	}

	onCleanWidget() {
		if(this.icon.cleanWidget() && this.label.cleanWidget()) return true;
		return false;
	}
}


/**
 * Created by prg-15 on 23.12.2017.
 */

var PositionImage = {
	Stretch : 0, // растянуть
	Centered : 1, // по центру
	Filling : 2, // заполнение
	ToSize : 3 // по размеру
};

class WebWidgetImage extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$position = 0;
		this._$isIcon = false;
		this._$icon = "";
		this._$styleName = this.getTypeName();
		this._$imageData = '';
		this._$imageId = -1;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetImage";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetImage(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(ImageUpdate.ImageId)) state += ",\"imageId\":\"" + this._$imageId + "\"";
		if(this.flags.hasFlag(ImageUpdate.Icon)) 	state += ",\"icon\":\"" + this._$icon + "\"";
		if(this.flags.hasFlag(ImageUpdate.ImageId) || this.flags.hasFlag(ImageUpdate.Icon)) state += ",\"isIcon\":" + this._$isIcon;

		if(this.flags.hasFlag(ImageUpdate.Position)) state += ",\"position\":" + this._$position;
		if(this.flags.hasFlag(ImageUpdate.ImageData)) Rex.images[this._$imageId].setState({"data" : this._$imageData});
		return state;
	}

	addChild(widget) {
		if(!widget) return false;
		console.log('WebWidgetImage can not has children.');
		widget.destroy();
		return false;
	}
	
	onSetScene(scene) {
		if(Rex.images === undefined) {
			Rex.images = {};
		}
		this._$imageId = this._$id + "image";
		Rex.images[this._$imageId] = new Rex.Image({"id" : this._$imageId, "data" : this._$imageData});
		super.onSetScene(scene);
	}
	
	setImageData(data) {
		if(data != "" && data != null) {
			this._$imageData = data;
			this.update(ImageUpdate.ImageData);
			this.update(ImageUpdate.ImageId);
		}
	}
	
	setIcon(value){
		if(this._$icon == value) return;
		this._$icon = value;
		this._$isIcon = true;
		this.run("onChangeIcon", this, value);
		this.update(ImageUpdate.Icon);
	}
	
	setPositionImage(value) {
		if((0 > value) || (value > 3)) return;
		if(this._$position == value) return;
		this._$position = value;
		this.run("onChangePositionImage", this, value);
		this.update(ImageUpdate.Position);
	}

	getPositionImage() {
		return this._$position;
	}
	
	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget() {
		this.setImageData("");
		return true;
	}

	onDestroy() {}

}

/**
 * Created by prg-15 on 23.12.2017.
 */
class WebWidgetToggle extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$checked = false;
		this._$iconAlign = 0;
		this._$icon = undefined;
		this._$label = undefined;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetToggle";
	}
	
	onSetScene() {
		if(this._$icon === undefined) {
			this._$icon = new WebWidgetImage();
			this.addChild(this._$icon);
			this._$icon.setScene();
		}
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel();
			this.addChild(this._$label);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
	}

	setText(text) {
		if(this._$label == undefined) {
			this._$label = new WebWidgetLabel(this);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left)
		}
		if(text != this._$label.getText()) {
			this._$label.setText(text);
			this.run("onSetText", text);
		}
	}

	getText() {
		return this._$label == undefined ? "" : this._$label.getText();
	}

	onGenerateConstructor(state) {
		state += "new WidgetToggle(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(ToggleUpdate.Checked)) state += ",\"checked\":" + this._$checked;
		if(this.flags.hasFlag(ToggleUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$icon || widget === this._$label) super.addChild(widget);
		else {
			console.error('WebWidgetToggle can not has children.');
			widget.destroy();
			return false;
		}
	}

	getLabel() {
		return this._$label;
	}

	setIcon(icon) {
		this._$icon.setImageData(icon);
	}

	getIcon() {
		return this._$icon;
	}

	getIconAlign() {
		return this._$iconAlign;
	}

	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.run("onChangeIconAlign", align);
		this.update(ToggleUpdate.iconAlign);
	}
	
	setChecked(v) {
		if(this._$checked == v) return;
		this._$checked = v;
		this.run("onChecked", v);
		this.update(ToggleUpdate.Checked);
	}
	
	isChecked() {
		return this._$checked;
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget() {
		this._$icon.cleanWidget();
		this._$label.cleanWidget();
		return true;
	}
}

/**
 * Created by prg-15 on 23.12.2017.
 */
class WebWidgetRadioButton extends  WebWidget {
	constructor(parent) {
		super(parent);
		this._$styleName = this.getTypeName();
		this._$checked = false;
		this._$iconAlign = 0;
		this._$icon = undefined;
		this._$label = undefined;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetRadioButton";
	}
	
	onSetScene() {
		if(this._$icon === undefined) {
			this._$icon = new WebWidgetImage();
			this.addChild(this._$icon);
			this._$icon.setScene();
		}
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel();
			this.addChild(this._$label);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetRadioButton(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(RadioButtonUpdate.Checked))  state += ",\"checked\":" + this._$checked;
		if(this.flags.hasFlag(RadioButtonUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if (widget === this._$icon || widget === this._$label) super.addChild(widget);
		else {
			console.error('WebWidgetRadioButton can not has children.');
			widget.destroy();
			return false;
		}
	}
	
	setText(text) {
		if(this._$label == undefined) {
			this._$label = new WebWidgetLabel(this);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
		if(text !== undefined && text != this._$label.getText()) {
			this._$label.setText(text);
			this.run("onSetText", text);
		}
	}

	getLabel() {
		return this._$label;
	}

	getText() {
		return this._$label == undefined ? "" : this._$label.getText();
	}

	setIcon(icon) {
		this._$icon.setImageData(icon);
	}

	getIcon() {
		return this._$icon;
	}

	getIconAlign() {
		return this._$iconAlign;
	}

	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.run("onChangeIconAlign", align);
		this.update(RadioButtonUpdate.IconAlign);
	}
	
	setChecked(v) {
		if(this._$checked == v) return;
		this._$checked = v;
		this.run("onCheked", v);
		this.update(RadioButtonUpdate.Checked);
	}

	isChecked() {
		return this._$checked;
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget() {
		this._$icon.cleanWidget();
		this._$label.cleanWidget();
		return true;
	}
}

/**
 * Created by prg-15 on 24.12.2017.
 */
class WebWidgetSwitch extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$enable = false;
		this._$pressed = false;
		this._$textOn = "ON";
		this._$textOff = "OFF";
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetSwitch";
	}

	onGenerateConstructor(state) {
		state += "new WidgetSwitch(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(SwitchUpdate.Enable))  state += ",\"enable\":" + this._$enable;
		if(this.flags.hasFlag(SwitchUpdate.Pressed))  state += ",\"pressed\":" + this._$pressed;
		if(this.flags.hasFlag(SwitchUpdate.On))  state += ",\"textOn\":\"" + this._$textOn + "\"";
		if(this.flags.hasFlag(SwitchUpdate.Off))  state += ",\"textOff\":\"" + this._$textOff + "\"";
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetSwitch can not has children.');
		widget.destroy();
		return false;
	}
	
	setEnableSwitch(e) {
		if(this._$enable === e) return;
		this._$enable = e;
		this.run("onChangeEnable", e);
		this.update(SwitchUpdate.Enable);
	}

	isEnableSwitch() {
		return this._$enable;
	}
	
	setPressed(p) {
		if(this._$pressed === p) return;
		this._$pressed = p;
		this.run("onChangePressed", p);
		this.update(SwitchUpdate.Pressed);
	}

	isPressed() {
		return this._$pressed;
	}

	getTextOn() {
		return this._$textOn;
	}

	setTextOn(value) {
		if(value = this._$textOn) return;
		this._$textOn = value;
		this.run("onChangeTextOn", value);
		this.update(SwitchUpdate.On);
	}

	getTextOff() {
		return this._$textOff;
	}

	setTextOff(value) {
		if(value = this._$textOff) return;
		this._$textOff = value;
		this.run("onChangeTextOff", value);
		this.update(SwitchUpdate.Off);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}
}

/**
 * Created by prg-15 on 24.12.2017.
 */
class WebWidgetCheckBox extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$checked = false;
		this._$iconAlign = WidgetHorizontalAlign.None;
		this._$icon = undefined;
		this._$label = undefined;
		this._$styleName = this.getTypeName();
		this._$minWidth = 88;
		this._$minHeight = 36;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetCheckBox";
	}
	
	onSetScene(scene) {
		if(this._$icon === undefined) {
			this._$icon = new WebWidgetImage();
			this.addChild(this._$icon);
		}
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel();
			this.addChild(this._$label);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
		super.onSetScene(scene);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetCheckBox(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(CheckBoxUpdate.Checked)) state += ",\"checked\":" + this._$checked;
		if(this.flags.hasFlag(CheckBoxUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$icon || widget === this._$label) super.addChild(widget);
		else {
			console.error('WebWidgetCheckBox can not has children.');
			widget.destroy();
			return false;
		}
	}
	
	setChecked(v) {
		if(this._$checked === v) return;
		this._$checked = v;
		this.onChecked(v);
		this.run("onChecked", v);
		this.update(CheckBoxUpdate.Checked);
	}

	onChecked(v) {}

	isChecked() {
		return this._$checked;
	}

	setText(text) {
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel(this);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
		this._$label.setText(text);
		this.run("onSetText", text);
	}

	getLabel() {
		return this._$label;
	}

	getText() {
		return this._$label == undefined ? "" : this._$label.getText();
	}

	setIcon(icon) {
		this._$icon.setImageData(icon);
	}

	getIcon() {
		return this.icon;
	}

	getIconAlign() {
		return this._$iconAlign;
	}

	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.run("onChangeIconAlign", align);
		this.update(CheckBoxUpdate.IconAlign);
	}
	
	setAlignText(align) {
		if(!this._$label) return;
		this._$label.setTextAlign(align);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget() {
		if(this._$icon.cleanWidget() && this._$label.cleanWidget()) return true;
		return false;
	}

}

/**
 * Created by semyon on 05.01.2018.
 */
class WebWidgetComboBox extends WebWidget {

	constructor(parent) {
		super(parent );
		this._$header = "";
		this._$expanded = false;
		this._$init = false;
		this._$expandedHeight = -1;
		this._$items = undefined;
		this._$styleName = this.getTypeName();
		this._$minHeight = 45;
		this._$maxHeight = 45;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetComboBox";
	}

	addItem(item) {
		if (this._$items === undefined) return false;
		return this._$items.addItem(item);
	}

	addTextItem(text) {
		if(this._$items == undefined) return undefined;
		let label = new WebWidgetLabel();
		this._$items.addItem(label);
		label.setText(text);
		return label;
	}

	setCurrentItem(currentItem) {
		if (this._$items === undefined) return;
		if (this._$items.isMultiSelect()) return;
		if ((currentItem < 0) || (currentItem > this._$items.getCountItems() - 1)) return;
		if (currentItem != this._$items.getCurrentItem()) this._$items.setCurrentItem(currentItem);
		this.setExpanded(false);
		this.run("onSetItem", currentItem);
		this.onSetCurrentItem(currentItem);
		this.update(ComboBoxUpdate.CurrentItem);
	}

	getCurrentItem() {
		if(this._$items == undefined) return -1;
		return this._$items.getCurrentItem();
	}

	getCurrentItemText() {
		if(this._$items == undefined) return "";
		if(this.getCurrentItem() == -1) return "";
		return this._$items.getCurrentItemText();
	}

	getCurrentWidget() {
		if(this._$items == undefined) return undefined;
		return this._$items.getCurrentItemAsWidget();
	}

	setHeader(h) {
		if (this._$header == h) return;
		this._$header = h;
		this.run("onChangeHeader", h);
		this.update(BaseUpdate.Header);
	}

	getHeader() {
		return this._$header;
	}

	setExpandedHeight(h) {
		if (this._$expandedHeight == h) return;
		this._$expandedHeight = h;
		this.run("onChangeExpandedHeight", h);
		this._$items.setHeight(this._$expandedHeight);
		this.update(ComboBoxUpdate.ExpandedHeight);
	}

	getExpandedHeight() {
		return this._$expandedHeight;
	}

	setExpanded(e) {
		if (this._$expanded == e) return;
		this._$expanded = e;
		this.run("onChangeExpanded", e);
		this.update(ComboBoxUpdate.Expanded);
	}

	isExpanded() {
		return this._$expanded;
	}

	onGenerateConstructor(state) {
		state += "new WidgetComboBox(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this.flags.hasFlag(BaseUpdate.Header)) state += ",\"header\":\"" + this._$header + "\"";
		if (this.flags.hasFlag(ComboBoxUpdate.Expanded)) state += ",\"expanded\":" + this._$expanded;
		if (this.flags.hasFlag(ComboBoxUpdate.ExpandedHeight)) state += ",\"expandedHeight\":" + this._$expandedHeight;
		if (this.flags.hasFlag(ComboBoxUpdate.CurrentItem)) state += ",\"currentItem\":" + this._$items.getCurrentItem();
		return state;
	}

	onSetScene(scene) {
		if (this._$items !== undefined) return;
		this._$items = new WebWidgetList();
		this.addChild(this._$items);
		this._$items.setMultiSelection(false);
		this._$items.getScrollArea().getVerticalScroll().setArrowsVisible(true);
		this._$items.setElevation(4);
		super.onSetScene(scene);
	}

	onSetCurrentItem(currentItem) {}

	onDestroy() {}

	onUpdate(mask) {
		if(!this._$init) {
			this.connect(this._$items, "onChangeItem", (item) => {
				this.setExpanded(false);
				this.setCurrentItem(item);
			});
			this.connect(this._$scene.getGui(), "onFocusedWidget", (w, flag) => {
				if(w == undefined) {
					this.setExpanded(false);
					return;
				}
				if(!this.isFocused() && !this._$items.isFocused()) this.setExpanded(false);
			});
			this._$init = true;
		}
	}

	onIncludeWidget(widget) {
		if (this._$items == undefined) return false;
		return this.addItem(widget);
	}

	onExtractWidget(widget) {
		if (widget == this._$items) return false;
		return this.extractInternal(widget);
	}

	onCleanWidget() {
		if(this._$items.cleanWidget()){
			this.update(ComboBoxUpdate.CurrentItem);
			return true;
		}
		return false;
	}

}

/**
 * Created by semyon on 24.12.2017.
 */

//TODO взять regExpы из базы
var TypeValidate = {
	Non: 0,
	ReliabilityPassword: 1,
	Email: 2,
	ColorCode16: 3,
	IPv4: 4,
	IPv6: 5,
	PhoneNumber: 6,
	DateDDMMYYYYDots: 7,
	DateDDMMYYYYSlash: 8,
	DateDDMMYYYYDash: 9,
	TimeHHMMSS: 10,
	DateTime: 11,
	CreditCard: 12,
	Numerical: /^\d+$/,
	CvcCode: 14,
	NumderAndLetterLatin: 15,
	NumderAndLetterLatinKiril: 16,
	ZipCodeRus: 17,
	Custom: 18,
	NumericalDouble: 19,
	NumericalInteger: 20
};

class WebWidgetInput extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$text = "";
		this._$header = "";
		this._$cursorPosition = 0;
		this._$selectPosition = -1;
		this._$typeValidate = TypeValidate.Non;
		this._$regularExp = ".*?";
		this._$valid = true;
		this._$styleName = this.getTypeName();
		
		this._$minHeight = 36;
		this._$maxHeight = 36;
		this._$minWidth = 88;
		this.setParent(parent);
	}

	getTypeName() {
		return"WidgetInput";
	}
	
	setTypeValidate(type) {
		if(this._$typeValidate == type) return;
		this._$typeValidate = type;
		this.run("onChangeTypeValidate", type);
		this._$regularExp = TypeValidate[type];
		this.run("onChangeRegExp", this._$regularExp);
	}

	getTypeValidate() {
		return this._$typeValidate;
	}
	
	setRegularExp(expression) {
		if(this._$regularExp == expression) return;
		this._$regularExp = expression;
		this._$typeValidate = TypeValidate.Custom;
		this.run("onChangeRegExp", expression);
		this.run("onChangeTypeValidate", this._$typeValidate);
	}

	getRegularExp() {
		return this._$regularExp;
	}

	checkValidText(text) {
		if(this._$typeValidate == TypeValidate.Non) return true;
		let ret = false;
		try {
			let rul = new RegExp(this._$regularExp);
			ret = rul.test(text);
		} catch(e) {
			console.log(e);
		}
		return ret;
	}

	isValid() {
		return this._$valid;
	}

	setText(t) {
		if(this._$text == t) return;
		this._$valid = this.checkValidText(t);
		this.update(InputUpdate.Valid);
		this._$text = t;
		this.run("onChangeText", this._$text);
		this.onSetText(this._$text);
		this.update(BaseUpdate.Text);
	}

	getText() {
		return this._$text;
	}

	onSetText(t) {}
	
	setHeader(h) {
		if(this._$header == h) return;
		this._$header = h;
		this.run("onChangeHeader", h);
		this.update(BaseUpdate.Header);
	}

	getHeader() {
		return this._$header;
	}

	getCursorPosition() {
		return this._$cursorPosition;
	}

	getSelectPosition() {
		return this._$selectPosition;
	}
	
	/**
	 * @param {boolean} value нажата или отжата. то что отжта не придет никогда, поэтому тру всегда
	 */
	pressEnter(value) {
		this.run("onPressEnter", value);
		this.update(BaseUpdate.Text);
	}
	
	setParameters(text, cursorPos, selectPos) {
		if(this._$text != text) {
			this.setText(text);
		}
		if(this._$cursorPosition != cursorPos) {
			this._$cursorPosition = cursorPos;
			this.update(InputUpdate.CursorPosition);
		}
		if(this._$selectPosition != selectPos) {
			this._$selectPosition = selectPos;
			this.update(InputUpdate.SelectPosition);
		}
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetInput(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(InputUpdate.CursorPosition)) state += ",\"cursorPosition\":" + this._$cursorPosition;
		if(this.flags.hasFlag(InputUpdate.SelectPosition)) state += ",\"selectPosition\":" + this._$selectPosition;
		state += ",\"flagUpdate\":" + true;
		if(this.flags.hasFlag(BaseUpdate.Text)) state += ",\"Ctext\":\"" + btoa(unescape(encodeURIComponent(this._$text))) + "\"";
		if(this.flags.hasFlag(BaseUpdate.Header)) state += ",\"Cheader\":\"" + btoa(unescape(encodeURIComponent(this._$header))) + "\"";
		if(this.flags.hasFlag(InputUpdate.Valid)) {
			state += ",\"valid\":" + this._$valid;
		}
		state += ",\"regularExp\":\"" + btoa(this._$regularExp) + "\"";
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetInput can not has children.');
		widget.destroy();
		return false;
	}
	
	onIncludeWidget(widget) {
		return false;
	}
	
	onCleanWidget() {
		this.setText("");
		return true;
	}
	
	onExtractWidget(widget) {
		return false;
	}

	onChangeCursorPosition(value){
		return false;
	}
	
}

/**
 * Created by semyon on 04.01.2018.
 */
var SliderType = {
	Vertical: 0,
	Horizontal: 1
};
	
class WebWidgetSlider extends WebWidget {
	
	constructor(parent) {
		super(parent);
		this._$value = 0.0;
		this._$valueReal = 0;
		this._$minValue = 0;
		this._$maxValue = 100;
		this._$double = false;
		this._$secondaryValueStart = 1000000000.0;
		this._$secondaryValueEnd = 1000000000.0;
		this._$showTooltip = true;
		this._$showLimits = true;
		this._$header = "";
		this._$sliderType = SliderType.Horizontal;
		this._$step = 0;
		this._$numeralAfterPoint = 2;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetSlider";
	}

	setDouble(value) {
		if (this._$double == value) return;
		this._$double = value;
		this.update(SliderUpdate.Double);
	}

	getDouble() {
		return this._$double;
	}

	setSliderType(type) {
		if (this._$sliderType == type) return;
		this._$sliderType = type;
		this.update(SliderUpdate.Type);
	}

	getSliderType() {
		return this._$sliderType;
	}

	setHeader(h) {
		if (this._$header == h) return;
		this._$header = h;
		this.run("onChangeHeader", h);
		this.update(BaseUpdate.Header);
	}

	getHeader() {
		return this._$header;
	}

	setSecondaryValueStart(s) {
		if (this._$secondaryValueStart == s) return;
		this._$secondaryValueStart = s;
		this.run("onChangeSecondaryValueStart", s);
		this.update(SliderUpdate.Start);
	}

	getSecondaryValueStart() {
		return this._$secondaryValueStart;
	}

	setSecondaryValueEnd(s) {
		if (this._$secondaryValueEnd == s) return;
		this._$secondaryValueEnd = s;
		this.run("onChangeSecondaryValueend", s);
		this.update(SliderUpdate.End);
	}

	getSecondaryValueEnd() {
		return this._$secondaryValueEnd;
	}

	setMinValue(v) {
		if (this._$minValue == v || v >= this._$maxValue) return;
		this._$minValue = v;
		this.run("onChangeMinValue", v);
		this.update(SliderUpdate.Min);
	}

	getMinValue() {
		return this._$minValue;
	}

	setMaxValue(v) {
		if (this._$maxValue == v || v <= this._$minValue) return;
		this._$maxValue = v;
		this.run("onChangeMaxValue", v);
		this.update(SliderUpdate.Max);
	}

	getMaxValue() {
		return this._$maxValue;
	}

	setValue(v) {
		if (this._$value == v || v < 0 || v > 1) return;
		this._$value = v;
		let size = this._$maxValue - this._$minValue;
		let valueR = this._$minValue + size * v;
		if (valueR != this._$valueReal) this.setValueReal(valueR);
		this.run("onChangeValue", v);
		this.update(SliderUpdate.Value);
	}

	getValue() {
		return this._$value;
	}

	setValueReal(v) {
		if (this._$valueReal == v) return;
		if (v > this._$maxValue) v = this._$maxValue;
		if (v < this._$minValue) v = this._$minValue;
		this._$valueReal = v;
		let valueF = (v - this._$minValue) / (this._$maxValue - this._$minValue);
		if (valueF != this._$value) this.setValue(valueF);
		this.run("onChangeValueReal", v);
		this.update(SliderUpdate.Real);
	}

	getValueReal() {
		return this._$valueReal;
	}

	setShowTooltip(b) {
		if (this._$showTooltip == b) return;
		this._$showTooltip = b;
		this.run("onChangeShowTooltip", b);
		this.update(SliderUpdate.Tooltip);
	}

	isShowTooltip() {
		return this._$showTooltip;
	}

	setShowLimits(b) {
		if (this._$showLimits == b) return;
		this._$showLimits = b;
		this.run("onChangeShowLimits", b);
		this.update(SliderUpdate.Limits);
	}

	isShowLimits() {
		return this._$showLimits;
	}

	setNumeralAfterPoint(value) {
		if (this._$numeralAfterPoint == value) return;
		this._$numeralAfterPoint = value;
		this.update(SliderUpdate.Numerical);
	}

	getNumeralAfterPoint() {
		return this._$numeralAfterPoint;
	}

	setStep(value) {
		if (this._$step == value) return;
		this._$step = value;
		this.update(SliderUpdate.Step);
	}

	getStep() {
		return this._$step;
	}

	onGenerateConstructor(state) {
		state += "new WidgetSlider(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this.flags.hasFlag(SliderUpdate.Start)) state += ",\"secondaryValueStart\":" + this._$secondaryValueStart;
		if (this.flags.hasFlag(SliderUpdate.End)) state += ",\"secondaryValueEnd\":" + this._$secondaryValueEnd;
		if (this.flags.hasFlag(SliderUpdate.Min)) state += ",\"minValue\":" + this._$minValue;
		if (this.flags.hasFlag(SliderUpdate.Max)) state += ",\"maxValue\":" + this._$maxValue;
		if (this.flags.hasFlag(SliderUpdate.Value)) state += ",\"value\":" + this._$value;
		if (this.flags.hasFlag(SliderUpdate.Real)) state += ",\"valueReal\":" + this._$valueReal;
		if (this.flags.hasFlag(SliderUpdate.Step)) state += ",\"step\":" + this._$step;
		if (this.flags.hasFlag(SliderUpdate.Numerical)) state += ",\"numeralAfterPoint\":" + this._$numeralAfterPoint;
		if (this.flags.hasFlag(SliderUpdate.Type)) state += ",\"sliderType\":" + this._$sliderType;
		if (this.flags.hasFlag(SliderUpdate.Tooltip)) state += ",\"showTooltip\":" + this._$showTooltip;
		if (this.flags.hasFlag(SliderUpdate.Limits)) state += ",\"showLimits\":" + this._$showLimits;
		if (this.flags.hasFlag(BaseUpdate.Header)) state += ",\"header\":\"" + this._$header + "\"";
		if (this.flags.hasFlag(SliderUpdate.Double)) state += ",\"double\":" + this._$double;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetSlider can not has children.');
		widget.destroy();
		return false;
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

}

/**
 * Created by prg-15 on 24.12.2017.
 */
var ScrollType = {
	Vertical: 0,
	Horizontal: 1
};

class WebWidgetScroll extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$scrollType = ScrollType.Vertical;
		this._$mouseScrollingStep = 36;
		this._$arrowsScrollingStep = 72;
		this._$contentSize = 100;
		this._$arrowsVisible = false;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetScroll";
	}

	getScrollType() {
		return this._$scrollType;
	}

	setScrollType(value) {
		if(this._$scrollType === value) return;
		this._$scrollType = value;
		this.update(ScrollUpdate.Type);
	}

	getMouseScrollingStep() {
		return this._$mouseScrollingStep;
	}

	setMouseScrollingStep(value) {
		if(this._$mouseScrollingStep === value) return;
		this._$mouseScrollingStep = value;
		this.update(ScrollUpdate.MouseStep);
	}

	getArrowsScrollingStep() {
		return this._$arrowsScrollingStep;
	}

	setArrowsScrollingStep(value) {
		if(this._$arrowsScrollingStep === value) return;
		this._$arrowsScrollingStep = value;
		this.update(ScrollUpdate.ArrowStep);

	}

	getContainerSize() {
		return this._$contentSize;
	}

	setContentSize(value) {
		if(this._$contentSize === value) return;
		this._$contentSize = value;
		this.update(ScrollUpdate.ContentSize);
	}

	getArrowsVisible() {
		return this._$arrowsVisible;
	}

	setArrowsVisible(value) {
		if(this._$arrowsVisible === value) return;
		this._$arrowsVisible = value;
		this.update(ScrollUpdate.ArrowVisible);
	}

	onGenerateConstructor(state) {
		state += "new WidgetScroll(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if(this.flags.hasFlag(ScrollUpdate.Type)) state += ",\"scrollType\":" + this._$scrollType;
		if(this.flags.hasFlag(ScrollUpdate.ArrowStep)) state += ",\"arrowsScrollingStep\":" + this._$arrowsScrollingStep;
		if(this.flags.hasFlag(ScrollUpdate.mouseScrollingStep)) state += ",\"mouseScrollingStep\":" + this._$mouseScrollingStep;
		if(this.flags.hasFlag(ScrollUpdate.ContentSize)) state += ",\"contentSize\":" + this._$contentSize;
		if(this.flags.hasFlag(ScrollUpdate.ArrowVisible)) state += ",\"arrowsVisible0or1\":" + this._$arrowsVisible ? 1 : 0;
		return state;
	}

	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetScroll can not has children.');
		widget.destroy();
		return false;
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

}

/**
 * Created by semyon on 26.12.2017.
 */
var ShowScroll = {
	Never	: 0,
	Always	: 1,
	AsNeed	: 2
};

class WebWidgetScrollArea extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$horizontalScroll = undefined;
		this._$verticalScroll = undefined;
		this._$horizontalScrollShow = ShowScroll.AsNeed;
		this._$verticalScrollShow = ShowScroll.AsNeed;
		this._$contentLayout = undefined;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetScrollArea";
	}

	getHorizontalScrollShow() {
		return this._$horizontalScrollShow;
	}

	setHorizontalScrollShow(type) {
		this._$horizontalScrollShow = type;
		this.update(ScrollAreaUpdate.HorizontalShow);
	}

	getVerticalScrollShow() {
		return this._$verticalScrollShow;
	}

	setVerticalScrollShow(type) {
		this._$verticalScrollShow = type;
		this.update(ScrollAreaUpdate.VerticalShow);
	}

	getContentLayout() {
		return this._$contentLayout;
	}

	setContentLayout(_contentLayout) {
		if (this._$contentLayout === undefined) return;
		this.replaceChild(0, _contentLayout);
		this._$contentLayout.setParent(undefined);
		this._$contentLayout.destroy();
		this._$contentLayout = _contentLayout;
		this.update(ScrollAreaUpdate.ContentLayout);
	}

	getHorizontalScroll() {
		return this._$horizontalScroll;
	}

	getVerticalScroll() {
		return this._$verticalScroll;
	}

	onSetScene(scene) {
		if (this._$contentLayout === undefined) {
			this._$contentLayout = new WebWidgetLayout();
			this.addChild(this._$contentLayout);
			this.update(ScrollAreaUpdate.ContentLayout);
		}
		if (this._$verticalScroll === undefined) {
			this._$verticalScroll = new WebWidgetScroll();
			this.addChild(this._$verticalScroll);
			this._$verticalScroll.setScrollType(ScrollType.Vertical);
			this.update(ScrollAreaUpdate.VerticalScroll);
		}
		if (this._$horizontalScroll === undefined) {
			this._$horizontalScroll = new WebWidgetScroll();
			this.addChild(this._$horizontalScroll);
			this._$horizontalScroll.setScrollType(ScrollType.Horizontal);
			this.update(ScrollAreaUpdate.HorizontalScroll);
		}
		super.onSetScene(scene);
	}

	onGenerateConstructor(state) {
		state += "new WidgetScrollArea(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this._$verticalScroll === undefined || this._$horizontalScroll === undefined) return;
		if (this.flags.hasFlag(ScrollAreaUpdate.HorizontalScroll)) state += ",\"horizontalScroll\":\"" + this._$horizontalScroll.getID() + "\"";
		if (this.flags.hasFlag(ScrollAreaUpdate.VerticalScroll)) state += ",\"verticalScroll\":\"" + this._$verticalScroll.getID() + "\"";
		if (this.flags.hasFlag(ScrollAreaUpdate.HorizontalShow)) state += ",\"horizontalScrollShow\":" + this._$horizontalScrollShow;
		if (this.flags.hasFlag(ScrollAreaUpdate.VerticalShow)) state += ",\"verticalScrollShow\":" + this._$verticalScrollShow;
		if (this.flags.hasFlag(ScrollAreaUpdate.ContentLayout)) state += ",\"contentLayout\":\"" + this._$contentLayout.getID() + "\"";
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$contentLayout || widget === this._$verticalScroll || widget === this._$horizontalScroll) super.addChild(widget);
		else {
			console.error('WebWidgetScrollArea can not has children. Please use includeWidget!');
			widget.destroy();
			return false;
		}
	}

	onExtractWidget(widget) {
		if (widget == this._$contentLayout || widget == this._$verticalScroll || widget == this._$horizontalScroll) return false;
		return this.extractInternal(widget);
	}

	onIncludeWidget(widget) {
		if (this._$contentLayout == undefined) return false;
		return this._$contentLayout.includeWidget(widget);
	}
	
	onCleanWidget() {
		return this._$contentLayout.cleanWidget();
	}
	
}

/**
 * Created by semyon on 05.01.2018.
 */
class WebWidgetSpacer extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$depress = true;
		this._$orientation = OrientationType.Horizontal;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetSpacer";
	}

	setDepress(_depress) {
		if (this._$depress == _depress) return;
		this._$depress = _depress;
		this.update(SpacerUpdate.Depress);
	}

	isDepress() {
		return this._$depress;
	}

	setOrientation(_orientation) {
		if (this._$orientation == _orientation) return;
		this._$orientation = _orientation;
		this.update(SpacerUpdate.Orientation);
	}

	getOrientation() {
		return this._$orientation;
	}

	onGenerateState(state) {
		if (this.flags.hasFlag(SpacerUpdate.Depress)) state += ",\"depress\":" + this._$depress;
		if (this.flags.hasFlag(SpacerUpdate.Orientation)) state += ",\"orientation\":" + this._$orientation;
		return state;
	}

	onGenerateConstructor(state) {
		state += "new WidgetSpacer(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetSpacer can not has children.');
		widget.destroy();
		return false;
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

}

/**
 * Created by semyon on 26.12.2017.
 */
class WebWidgetSpinBox extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$input = undefined;
		this._$value = 0;
		this._$oldValue = 0;
		this._$step = 1;
		this._$pressEnter = false;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetSpinBox";
	}

	connectToInput(input) {
		this.addChild(input);
		input.setTypeValidate(TypeValidate.Numerical);
		this.connect(input, "onChangeText", (input, press) => {
			if (press) {
				let old = this._$oldValue;
				if(input.getText() == "" || !input.isValid()) {
					this._$oldValue = 0;
				} else if (!isNaN(Number(input.getText()))) {
					this._$oldValue = Number(input.getText());
				} else {
					this._$value = this._$oldValue;
				}
				if (this._$oldValue != old) {
					this._$pressEnter = press;
					this.setValue([this._$oldValue]);
					this.update(SpinBoxUpdate.Value);
					this.update(SpinBoxUpdate.Enter);
				}
			}
		});
	}

	setHeader(header) {
		this._$input.setHeader(header);
	}

	getHeader() {
		return this._$input == undefined ? "" : this._$input.getHeader();
	}

	setValue(v) {
		if (this._$value == v) return;
		this._$value = v;
		this.onSetValue(v);
		this.run("onChangeSpinValue", v);
		if(this._$input !== undefined) this._$input.setText(v);
		this.update(SpinBoxUpdate.Value);
	}

	getValue() {
		return this._$value;
	}

	setStep(s) {
		if (this._$step == s) return;
		this._$step = s;
		this.update(SpinBoxUpdate.Step);
	}

	getStep() {
		return this._$step;
	}

	onGenerateConstructor(state) {
		state += "new WidgetSpinBox(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this.flags.hasFlag(SpinBoxUpdate.Enter)) state += ",\"pressEnter\":" + this._$pressEnter;
		if (this.flags.hasFlag(SpinBoxUpdate.Value)) state += ",\"value\":" + this._$value;
		if (this.flags.hasFlag(SpinBoxUpdate.Step)) state += ",\"step\":" + this._$step;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$input) super.addChild(widget);
		else {
			console.error('WebWidgetSpinBox can not have children.');
			widget.destroy();
			return false;
		}
	}

	onSetScene(scene) {
		if (this._$input === undefined) {
			this._$input = new WebWidgetInput();
			this.connectToInput(this._$input);
		}
		super.onSetScene(scene);
	}
	
	onUpdate(mask) {
		this._$input.setText(this._$value);
	}

	onSetValue(value) {}

	onExtractWidget(widget) {
		return false;
	}

	onIncludeWidget(widget) {
		return false;
	}
	
	onCleanWidget() {
		this._$input.cleanWidget();
		this.setValue(0);
		return true;
	}
	
}

/**
 * Created by prg-15 on 24.12.2017.
 */
class WebWidgetTextArea extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$text = "";
		this._$header = "";
		this._$textAlign = "left";
		this._$cursorPosition = 0;
		this._$selectPosition = -1;
		this._$globalSelectPosition = -1;
		this._$cursorLine = 0;
		this._$selectLine = 0;
		this._$fontSize = 20;
		this._$scroll = undefined;
		this._$lineHeight = 0;
		this._$bold = false;
		this._$italic = false;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetTextArea";
	}
	
	onSetScene(scene) {
		if(this._$scroll === undefined) {
			this._$scroll = new WebWidgetScroll();
			this.addChild(this._$scroll);
			this._$scroll.setArrowsVisible(true);
		}
		super.onSetScene(scene);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetTextArea(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(TextAreaUpdate.CursorPosition)) state += ",\"cursorPosition\":" + this._$cursorPosition;
		if(this.flags.hasFlag(TextAreaUpdate.SelectPosition)) state += ",\"selectPosition\":" + this._$selectPosition;
		if(this.flags.hasFlag(TextAreaUpdate.GlobalSelect)) state += ",\"globalSelectPosition\":" + this._$globalSelectPosition;
		if(this.flags.hasFlag(TextAreaUpdate.CursorLine)) state += ",\"cursorLine\":" + this._$cursorLine;
		if(this.flags.hasFlag(TextAreaUpdate.SelectLine)) state += ",\"selectLine\":" + this._$selectLine;
		if(this.flags.hasFlag(TextAreaUpdate.FontSize)) state += ",\"fontSize\":" + this._$fontSize;
		if(this.flags.hasFlag(TextAreaUpdate.TextAlign)) state += ",\"textAlign\":\"" + this._$textAlign + "\"";
		if(this.flags.hasFlag(TextAreaUpdate.LineHeight)) state += ",\"lineHeight\":" + this._$lineHeight;
		if(this.flags.hasFlag(TextAreaUpdate.Bold)) state += ",\"bold\":" + this._$bold;
		if(this.flags.hasFlag(TextAreaUpdate.Italic)) state += ",\"italic\":" + this._$italic;
		if(this.flags.hasFlag(BaseUpdate.Text)) state += ",\"text\":\"" + btoa(unescape(encodeURIComponent(this._$text))) + "\"";
		if(this.flags.hasFlag(BaseUpdate.Header)) state += ",\"header\":\"" + this._$header + "\"";
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$scroll) super.addChild(widget);
		else {
			console.error('WebWidgetTextArea can not has children.');
			widget.destroy();
			return false;
		}
	}
	
	setText(text) {
		if(this._$text == text) return;
		this._$text = text;
		this.update(BaseUpdate.Text);
	}

	getText() {
		return this._$text;
	}

	setHeader(header) {
		if(this._$header === header) return;
		this._$header = header;
		this.update(BaseUpdate.Header);
	}

	getHeader() {
		return this._$header;
	}

	setParameters(t, cursorPos, selectPos, globalSelectPos, cursorL, selectL) {
		if (this._$cursorPosition !== cursorPos){
			this._$cursorPosition = cursorPos;
			this.update(TextAreaUpdate.CursorPosition);
		}

		if (this._$selectPosition !== selectPos){
			this._$selectPosition = selectPos;
			this.update(TextAreaUpdate.SelectPosition);
		}

		if (this._$globalSelectPosition !== globalSelectPos){
			this._$globalSelectPosition = globalSelectPos;
			this.update(TextAreaUpdate.GlobalSelectPosition);
		}

		if (this._$cursorLine !== cursorL){
			this._$cursorLine = cursorL;
			this.update(TextAreaUpdate.CursorLine);
		}

		if (this._$selectLine !== selectL){
			this._$selectLine = selectL;
			this.update(TextAreaUpdate.SelectLine);
		}

		this.setText(t);
	}
	
	setCursorPosition(cursorPos) {
		if(this._$cursorPosition = cursorPos) return;
		this._$cursorPosition = cursorPos;
		this.update(TextAreaUpdate.CursorPosition);
	}

	getCursorPosition() {
		return this._$cursorPosition;
	}

	setSelectPosition(selectPos) {
		if(this._$selectPosition == selectPos) return;
		this._$selectPosition = selectPos;
		this.update(TextAreaUpdate.SelectPosition);
	}

	getSelectPosition() {
		return this._$selectPosition;
	}

	setGlobalSelectPosition(globalSelectPos) {
		if(this._$globalSelectPosition == globalSelectPos) return;
		this._$globalSelectPosition = globalSelectPos;
		this.update(TextAreaUpdate.GlobalSelect);
	}

	getGlobalSelectPosition() {
		return this._$globalSelectPosition;
	}

	setCursorLine(cursorL) {
		if(this._$cursorLine == cursorL) return;
		this._$cursorLine = cursorL;
		this.update(TextAreaUpdate.CursorLine);
	}

	getCursorLine() {
		return this._$cursorLine;
	}

	setSelectLine(selectL) {
		if(this._$selectLine == selectL) return;
		this._$selectLine = selectL;
		this.update(TextAreaUpdate.SelectLine);
	}

	getSelectLine() {
		return this._$selectLine;
	}

	isBold() {
		return this._$bold;
	}

	setBold(value) {
		if(this._$bold == value) return;
		this._$bold = value;
		this.update(TextAreaUpdate.Bold);
	}

	isItalic() {
		return this._$italic;
	}

	setItalic(value) {
		if(this._$italic == value) return;
		this._$italic = value;
		this.update(TextAreaUpdate.Italic);
	}
	
	setFontSize(fontS) {
		if(this._$fontSize == fontS) return;
		this._$fontSize = fontS;
		this.update(TextAreaUpdate.FontSize);
	}

	getFontSize() {
		return this._$fontSize;
	}

	getTextAlign() {
		return this._$textAlign;
	}

	setTextAlign(value) {
		if(this._$textAlign == value) return;
		this._$textAlign = value;
		this.run("onChangeTextAlign", value);
		this.update(TextAreaUpdate.TextAlign);
	}

	getLineHeight() {
		return this._$lineHeight;
	}

	setLineHeight(value) {
		if(this._$lineHeight == value) return;
		this._$lineHeight = value;
		this.run("onChangeLineHeight", value);
		this.update(TextAreaUpdate.LineHeight);
	}
	
	appendText(text) {
		this._$text += text;
		this.run("onChangeText", this._$text);
		this.update(BaseUpdate.Text);
	}

	onUpdate() {
		this._$scroll.setScrollType(ScrollType.Vertical);
		this._$scroll.setVisible(false);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}

	onCleanWidget(){
		this.setText("");
		return true;
	}
	
}

/**
 * Created by semyon on 26.12.2017.
 */
class Page {

	constructor() {
		this._$show = true;
		this._$title = "";
		this._$page = undefined;
		this._$widget = undefined;
		this._$minHeight = 0;
		this._$maxHeight = 0;
	}

}

class WebWidgetToolBox extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$autoHide = false;
		this._$minButtonsHeight = 50;
		this._$scrollArea = undefined;
		this._$pages = [];
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetToolBox";
	}

	onSetScene(scene) {
		if (this._$scrollArea === undefined) {
			this._$scrollArea = new WebWidgetScrollArea();
			this.addChild(this._$scrollArea);
		}
		super.onSetScene(scene);
	}

	addPage(name, widget) {
		if (widget == undefined) return false;
		if (this._$scrollArea == undefined) return false;
		let contentLayout = this._$scrollArea.getContentLayout();
		let button = new WebWidgetButton();
		contentLayout.addWidget(button);
		contentLayout.addWidget(widget);
		button.setText(name);
		button.setMinHeight(this._$minButtonsHeight);
		button.setMaxHeight(this._$minButtonsHeight);
		let newPage = new Page();
		newPage._$show = !this._$autoHide;
		newPage._$page = button;
		newPage._$widget = widget;
		newPage._$title = name;
		newPage._$minHeight = widget._$minHeight;
		newPage._$maxHeight = widget._$maxHeight;
		this._$pages.push(newPage);
		this.makeConnectPage(button);
		this._$scrollArea.update("All");
		this.update(ToolBoxUpdate.Pages);
		return true;
	}

	removePage(page) {
		if (page < 0 || page >= this._$pages.length) return false;
		let p = this._$pages[page];
		this._$scrollArea.removeWidget(p._$page);
		this._$scrollArea.removeWidget(p._$widget);
		let index = this._$pages.indexOf(p);
		if(index != -1) this._$pages.splice(index, 1);
		return true;
	}

	getPage(index) {
		if (index < 0 || index >= this._$pages.length) return undefined;
		return this._$pages[index];
	}

	getWidget(index) {
		if (index < 0 || index >= this._$pages.length) return undefined;
		return this._$pages[index]._$widget;
	}

	setMinPageControlHeight(value) {
		if (this._$minButtonsHeight == value) return;
		this._$minButtonsHeight = value;
		for (let i = 0; i < this._$pages.length; i++) {
			this._$pages[i]._$page.setMinHeight(value);
		}
		this.run("onChangeMaxHeightButtons", value);
		this.update(ToolBoxUpdate.MaxHeightButtons);
	}

	getMinPageControlHeight() {
		return this._$minButtonsHeight;
	}

	getPageTitle(page) {
		if(this._$scrollArea == undefined) return "";
		if(this._$pages.length <= page || page < 0) return "";
		return this._$pages[page]._$title;
	}

	setPageTitle(page, title) {
		if (this._$scrollArea == undefined) return;
		if (this._$pages.length <= page || page < 0) return;
		this._$pages[page]._$title = title;
		this._$pages[page]._$page.setText(title);
	}

	getNumPages() {
		if (this._$scrollArea == undefined) return 0;
		return this._$pages.length;
	}

	setShowing(page, flag) {
		if (this._$scrollArea === undefined) return;
		if (this._$pages.length <= page || page < 0) return;
		let p = this._$pages[page];
		if (!flag) {
			p._$minHeight = p._$widget.getMinHeight();
			p._$maxHeight = p._$widget.getMaxHeight();
		}
		p._$show = flag;
		p._$widget.setVisible(flag);
		if (flag) {
			p._$widget.setMinHeight(p._$minHeight);
			p._$widget.setMaxHeight(p._$maxHeight);
		} else {
			p._$widget.setMinHeight(0);
			p._$widget.setMaxHeight(0);
		}
	}

	isShowPage(page) {
		if (this._$scrollArea === undefined) return false;
		if (this._$pages.length <= page || page < 0) return false;
		return this._$pages[page]._$show;
	}

	getAutoHide() {
		return this._$autoHide;
	}

	setAutoHide(_autoHide) {
		if (this._$autoHide == _autoHide) return;
		this._$autoHide = _autoHide;
		this.run("onChangeAutoHide", _autoHide);
		this.update(ToolBoxUpdate.AutoHide);
	}

	addWidget(widget) {
		if (widget === undefined) return;
		if (this._$scrollArea == undefined) return;
		this.addPage(widget.getName(), widget);
	}

	setShowingAll(flag) {
		for (let i = 0; i < this._$pages.length; i++) {
			this._$pages[i]._$show = flag;
			this._$pages[i]._$widget.setVisible(flag);
			if (flag) {
				this._$pages[i]._$widget.setMinHeight(this._$pages[i]._$minHeight);
				this._$pages[i]._$widget.setMaxHeight(this._$pages[i]._$maxHeight);
			} else {
				this._$pages[i]._$widget.setMinHeight(0);
				this._$pages[i]._$widget.setMaxHeight(0);
			}
		}
	}

	onGenerateConstructor(state) {
		state += "new WidgetToolBox(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this._$scrollArea === undefined) return state;
		if (this._$pages.length == 0) return state;
		if(this.flags.hasFlag(ToolBoxUpdate.Pages) || this.flags.hasFlag(ToolBoxUpdate.AutoHide) || this.flags.hasFlag(ToolBoxUpdate.MaxHeightButtons)) {
			state += ",\"pages\":[";
			for (let i = 0; i < this._$pages.length; ++i) {
				let p = this._$pages[i];
				if (p === undefined) continue;
				if (p._$page === undefined) continue;
				if (p._$widget === undefined) continue;
				if (i == 0) state += "{";
				else state += ",{";
				state += "\"show\":" + p._$show;
				state += ",\"title\":\"" + p._$title + "\"";
				state += ",\"page\":\"" + p._$page.getID() + "\"";
				state += ",\"widget\":\"" + p._$widget.getID() + "\"";
				state += ",\"min\":" + p._$minHeight;
				state += ",\"max\":" + p._$maxHeight;
				state += "}";
			}
			state += "]";
		}
		return state;
	}

	onIncludeWidget(widget) {
		if (this._$scrollArea == undefined) return false;
		return this.addPage(widget.getName(), widget);
	}

	onExtractWidget(_widget) {
		if (_widget == this._$scrollArea) return false;
		for (let i = 0; i < this.getNumPages(); ++i) {
			let p = this._$pages[i];
			if (p._$page == _widget) return false;
			if (p._$widget == _widget) {
				if (!this._$scrollArea.getContentLayout().extractInternal(p._$page) || !this._$scrollArea.getContentLayout().extractInternal(p._$widget))
					console.log("Error: extract fail");
				let index = this._$pages.indexOf(p);
				if(index != -1) this._$pages.splice(index, 1);
				p._$page.setParent(undefined);
				p._$page.destroy();
				return true;
			}
		}
		return this.extractInternal(_widget);
	}

	onCleanWidget() {
		 while (this.getNumPages() > 0) {
		 	if (!this.removeWidget(this._$pages[this.getNumPages() - 1]._$widget)) return false;
		 }
		 return true;
	}

	makeConnectPage(button) {
		if (button == undefined) return;
		this.connect(button, "onPress", (pressed) => {
			if(pressed) return;
			let index = this._$scrollArea.getContentLayout().getChildren().indexOf(button);
			let page = (index * 0.5) | 0;
			if (this.autoHide) this.setShowingAll(false);
			if (this._$pages[page].show) {
				this.setShowing(page, false);
			} else {
				this.setShowing(page, true);
			}
		});
	}

}

/**
 * Created by semyon on 28.12.2017.
 */
class WebWidgetTab extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$currentTab = -1;
		this._$header = undefined;
		this._$items = [];
		this._$styleName = this.getTypeName();
		this._$countTab = 0;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetTab";
	}

	addTabItem(name, widget) {
		if (this._$header === undefined) return undefined;
		let button = new WebWidgetButton();
		this._$header.addWidget(button);
		button.setMinHeight(5);
		button.setMinWidth(50);
		//button.setMaxWidth(264);
		button.setRaisedElevation(0, 0);
		let newWdg;
		if (widget === undefined) {
			newWdg = new WidgetLayoutVertical();
		} else {
			newWdg = widget;
		}
		this.addChild(newWdg);
		this._$items.push(newWdg);
		this._$countTab++;
		this.update(TabUpdate.Count);
		this.update(BaseUpdate.Children);
		button.setText(name);
		button.setStyleName("WidgetButtonTab");
		this.connect(button, "onPress", (pressed) => {
			if(pressed) return;
			let index = this._$header.getChildren().indexOf(button);
			this.setCurrentTab(index);
		});
		this.setCurrentTab(this._$items.length - 1);
		return newWdg;
	}

	setCurrentTab(index) {
		if (this._$currentTab == index || index > this._$items.length || index < -1) return;
		if ((this._$currentTab != -1) && (this._$header.getNumChildren() > this._$currentTab)) {
			if (this._$header.getChild(this._$currentTab) == undefined) return;
			this._$header.getChild(this._$currentTab).setStyleName("WidgetButtonTab");
		}
		this._$currentTab = index;
		for (let i = 0; i < this._$items.length; ++i) {
			if (i == index) this._$items[i].setVisible(true);
			else this._$items[i].setVisible(false);
		}
		if (this._$currentTab != -1) {
			this._$header.getChild(this._$currentTab).setStyleName("WidgetButtonTabSelect");
		}
		this.update(TabUpdate.CurrentTab);
	}

	getCurrentTab() {
		return this._$currentTab;
	}

	removeTab(index) {
		if (this._$items === undefined || this._$items.length === 0) return false;
		let item = this._$items[index];
		if (item == undefined) return false;
		item.setParent(undefined);
		item.destroy();
		this._$items.remove(index);
		let e = this._$header.getChild(index);
		if (!this._$header.extractInternal(e)) return false;
		e.destroy();
		if (this._$items !== undefined) this.setCurrentTab(0);
		else this.setCurrentTab(-1);
		this._$countTab--;
		this.update(TabUpdate.Count);
		this.update(TabUpdate.CurrentTab);
		this.update(BaseUpdate.Children);
		return true;
	}

	getNumTabs() {
		if(this._$header == undefined) return 0;
		return this._$header.getNumChildren();
	}

	setTabTitle(index, title) {
		if (this._$header === undefined) return;
		this._$header.getChild(index).setText(title);
		this.update(BaseUpdate.Header);
	}

	getTabTitle(index) {
		if(this._$header == undefined) return;
		return this._$header.getChild(index).getText();
	}

	getTab(index) {
		if(index >= 0 && index < this._$items.length) {
			return this._$items[index];
		}
		return undefined;
	}

	onSetScene(scene) {
		if (this._$header === undefined) {
			this._$header = new WebWidgetLayoutHorizontal();
			this.addChild(this._$header);
			this._$header.setHeight(48);
			this.update(TabUpdate.HeaderLayout);
		}
	}

	onGenerateConstructor(state) {
		state += "new WidgetTab(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if (this.flags.hasFlag(TabUpdate.CurrentTab)) {
			state += ",\"currentTab\":" + this._$currentTab;
			if (this._$currentTab == -1) state += ",\"currentTabId\": -1";
			else if (this._$currentTab >= 0 && this._$currentTab < this._$items.length) state += ",\"currentTabId\":\"" + this._$items[this._$currentTab].getID() + "\"";
		}
		if (this.flags.hasFlag(TabUpdate.HeaderLayout)) {
			if (this._$header !== undefined) state += ",\"headerLayoutId\":\"" + this._$header.getID() + "\"";
		}
		if (this.flags.hasFlag(TabUpdate.Count)) {
			state += ",\"countTab\":" + this._$countTab;
		}
		// saving
		return state;
	}

	onSetFlag(flag) {
		//TODO ПЕРЕНЕСТИ С C++
	}

	onIncludeWidget(widget) {
		if (this.addTabItem(widget.getName(), widget) == undefined) return false;
		return true;
	}

	onExtractWidget(widget) {
		if (widget == this._$header) return false;
		if (this._$items.length !== 0) {
			for (let i = 0; i < this._$header.getNumChildren(); ++i) {
				let b = this._$header.getChild(i);
				if (b == widget) return false;
			}
			for (let i = 0; i < this._$header.getNumChildren(); ++i) {
				let item = this._$items[i];
				if (item == widget) {
					if (this._$items.length > 1) this.setCurrentTab(0);
					else this.setCurrentTab(-1);
					item.setParent(undefined);
					this._$items.splice(i, 1);
					let e = this._$header.getChild(i);
					if (!this._$header.extractInternal(e)) return false;
					e.destroy();
					this.update(BaseUpdate.Children);
					return true;
				}
			}
		}
		return this.extractInternal(widget);
	}

	onCleanWidget() {
		while (this.getNumTabs() > 0) {
			if (!this.removeWidget(this._$items[this._$items.length - 1])) return false;
		}
		return true;
	}
}

/**
 * Created by prg-15 on 24.12.2017.
 */
var OrientationType = {
	Vertical	: 0,
	Horizontal	: 1
};


class WebWidgetLayout extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$styleName = this.getTypeName();
		this._$baseLayoutOrientation = 0;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetLayout";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetLayout(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(LayoutUpdate.Orientation)) state += ",\"baseLayoutOrientation\":" + this._$baseLayoutOrientation;
		return state;
	}

	addWidget(widget) {
		if (!this.addChild(widget)) return false;
		this.update(BaseUpdate.Children);
		return true;
	}

	setBaseOrientation(orientationType) {
		if (this._$baseLayoutOrientation == orientationType) return;
		this._$baseLayoutOrientation = orientationType;
		this.update(LayoutUpdate.Orientation);
	}

	getBaseOrientation() {
		return this._$baseLayoutOrientation
	}

	onExtractWidget(widget) {
		return this.extractInternal(widget);
	}

	onIncludeWidget(widget) {
		return this.addWidget(widget);
	}

	onCleanWidget() {
		while (this._$children.length > 0) {
			if(!this.removeWidget(this._$children[0])) return false;
		}
		return true;
	}

}

/**
 * Created by semyon on 25.12.2017.
 */
class WebWidgetLayoutGrid extends WebWidgetLayout {

	constructor(parent) {
		super(parent);
		this._$items = {};
		this._$countRow = 1;
		this._$countCol = 1;
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetLayoutGrid(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if (this.flags.hasFlag(LayoutGridUpdate.Items)) {
			state += ",\"items\":[";
			for (let i = 0; i < this._$countRow; i++) {
				if (i != 0) state += ",";
				state += "[";
				for (let j = 0; j < this._$countCol; j++) {
					if (j != 0) state += ",";
					let wdg = this.getWidget(i, j);
					if (wdg == undefined) state += "null";
					else state += "\"" + wdg.getID() + "\"";
				}
				state += "]";
			}
			state += "]";
			state += ",\"countRow\":" + this._$countRow;
			state += ",\"countCol\":" + this._$countCol;
		}
		return state;
	}

	getWidget(row, col) {
		if (this._$items[row] !== undefined) {
			if (this._$items[row][col] !== undefined) return this._$items[row][col];
		}
		return undefined;
	}

	addWidget(widget, row, col) {
		if (widget == undefined) return false;
		if (row < 0 || col < 0) return false;
		this.addChild(widget);
		if (this._$items[row] !== undefined) {
			if (this._$items[row][col] !== undefined) this.extractWidget(this._$items[row][col]);
		}
		if (this._$items[row] === undefined) this._$items[row] = {};
		this._$items[row][col] = widget;
		if (row >= this._$countRow) this._$countRow = ++row;
		if (col >= this._$countCol) this._$countCol = ++col;
		this.update(LayoutGridUpdate.Items);
		this.update(BaseUpdate.Children);
		widget.update(BaseUpdate.Position);
		return true;
	}

	getTypeName() {
		return "WidgetLayoutGrid";
	}

	getCountCol() {
		return this._$countCol;
	}

	setCountCol(value) {
		if (this._$countCol == value) return;
		this.countCol = value;
		this.run("onChangeCols", value);
	}

	getCountRow() {
		return this._$countRow;
	}

	setCountRow(value) {
		if (this._$countRow == value) return;
		this._$countRow = value;
		this.run("onChangeRows", value);
	}

	deletionWidget(widget) {
		for (let i = 0; i < this._$countCol; ++i) {
			for (let j = 0; j < this._$countRow; ++j) {
				let w = this.getWidget(j, i);
				if (w == undefined) continue;
				if (w.getID() == widget.getID()) {
					this._$items[j][i] = undefined;
					return;
				}
			}
		}
	}

	onIncludeWidget(widget) {
		for(let i = 0; i < this._$countCol; ++i) {
			for(let j = 0; j < this._$countRow; ++j) {
				if(this.getWidget(j, i) == undefined) return this.addWidget(widget, j, i);
			}
		}
		return this.addWidget(widget, this._$countRow, this._$countCol);
	}

	onExtractWidget(widget) {
		let result = this.extractInternal(widget);
		if (!result) return false;
		this.update(LayoutGridUpdate.Items);
		return true;
	}

}

/**
 * Created by semyon on 25.12.2017.
 */
class WebWidgetLayoutHorizontal extends WebWidgetLayout {

	constructor(parent) {
		super(parent);
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetLayoutHorizontal";
	}

	onGenerateConstructor(state) {
		state += "new WidgetLayoutHorizontal(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
}

/**
 * Created by semyon on 25.12.2017.
 */
class WebWidgetLayoutVertical extends WebWidgetLayout {

	constructor(parent) {
		super(parent);
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetLayoutVertical";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetLayoutVertical(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
}

/**
 * Created by semyon on 25.12.2017.
 */
class WebWidgetLoader extends WebWidgetButton {
	constructor(parent) {
		super(parent);
		this._$text = "Choose file";
		this._$styleName = "WidgetButton";
	}

	getTypeName() {
		return "WidgetLoader";
	}

	onGenerateConstructor(state) {
		state += "new WidgetLoader(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		state = super.onGenerateState(state);
		if(this.flags.hasFlag(BaseUpdate.Text)) state += ",\"text\":\"" + this._$text + "\"";
		return state;
	}
	
	setText(t) {
		if(this._$text == t) return;
		this._$text = t;
		if(this.getLabel() != "") super.setText(t);
		this.update(BaseUpdate.Text);
	}

	getText() {
		return this._$text;
	}

	loadFile(f) {
		let file = null;
		try {
			file = JSON.parse(f);
			file = file.files;
		} catch(e) {
			file = undefined;
		}
		this.run("Load", file);
	}

}

/**
 * Created by semyon on 25.12.2017.
 */
class WebWidgetList extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$currentItem = -1;
		this._$multiSelect = false;
		this._$selected = true;
		this._$heightItem = -1;
		this._$scrollArea = undefined;
		this._$elevation = 0;
		this._$styleName = this.getTypeName();
		this._$select = [];
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetList";
	}

	getSelect() {
		return this._$select;
	}
	
	onSetScene(scene) {
		if(this._$scrollArea != undefined) return;
		this._$scrollArea = new WebWidgetScrollArea();
		this.addChild(this._$scrollArea);
		super.onSetScene(scene);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetList(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(ListUpdate.CurrentItem)) state += ",\"currentItem\":" + this._$currentItem;
		if(this.flags.hasFlag(ListUpdate.HeightItem)) state += ",\"heightItem\":" + this._$heightItem;
		if(this.flags.hasFlag(ListUpdate.Selected)) state += ",\"selected\":" + this._$selected;
		if(this.flags.hasFlag(ListUpdate.MultiSelect)) state += ",\"multiSelect\":" + this._$multiSelect;
		if(this.flags.hasFlag(ListUpdate.Selection)) {
			state += ",\"selection\":[";
			for(let i = 0; i < this._$select.length; ++i) {
				state += this._$select[i];
				if(i !== this._$select.length - 1) state += ",";
			}
			state += "]";
		}
		return state;
	}

	addItem(item){
		if (item == undefined) return false;
		if (this._$scrollArea == undefined) return false;
		let result = this._$scrollArea.getContentLayout().addWidget(item);
		if(this._$heightItem != -1){
			item.setMinHeight(this._$heightItem);
			item.setMaxHeight(this._$heightItem);
		}
		return result;
	}

	getCountItems() {
		if(this._$scrollArea == undefined) return 0;
		return this._$scrollArea.getContentLayout().getNumChildren();
	}

	getCurrentItem() {
		return this._$currentItem;
	}

	getCurrentItemAsWidget() {
		if(this._$currentItem == -1) return undefined;
		if(this._$scrollArea == undefined) return undefined;
		let content = this._$scrollArea.getContentLayout();
		if(content == undefined) return undefined;
		if(content.getNumChildren() < this._$currentItem) return undefined;
		return content.getChild(this._$currentItem);
	}

	getCurrentItemText() {
		if(this._$currentItem == -1) return "";
		if(this._$scrollArea == undefined) return "";
		let content = this._$scrollArea.getContentLayout();
		if(content == undefined) return "";
		return content.getChild(this._$currentItem).getText();
	}

	setMultiSelection(value) {
		if(this._$multiSelect === value) return;
		this._$multiSelect = value;
		this.run("onChangeMultiSelect", value);
		this.update(ListUpdate.MultiSelect);
	}

	isMultiSelect() {
		return this._$multiSelect;
	}

	getScrollArea() {
		return this._$scrollArea;
	}

	setHeightItem(value) {
		if(value < 0) return;
		if(this._$heightItem === value) return;
		this._$heightItem = value;
		for(let i = 0; i < this._$scrollArea.getContentLayout().getNumChildren(); ++i) {
			let child = this._$scrollArea.getContentLayout().getChild(i);
			if(child == undefined) continue;
			child.setMinHeight(value);
			child.setMaxHeight(value);
		}
		this.run("onChangeHeightItem", value);
		this.update(ListUpdate.HeightItem);
	}

	getHeightItem() {
		return this._$heightItem;
	}

	setSelected(value) {
		if(this._$selected == value) return;
		this._$selected = value;
		this.run("onChangeSelected", value);
		this.update(ListUpdate.Selected);
	}

	isSelected() {
		return this._$selected;
	}

	addToSelection(index) {
		if((!this._$multiSelect) && (this._$currentItem == index)) return false;
		if(this._$multiSelect) {
			if(this._$select.indexOf(index) !== -1) {
				this._$select.push(index);
				this.update(ListUpdate.Selection);
				return true;
			}
		}
		return false;
	}

	removeItem(index) {
		let item = this._$scrollArea.getContentLayout().getChildren().splice(index, 1);
		item[0].setParent(null);
		item[0].destroy();
		this._$currentItem = -1;
		this.update(ListUpdate.CurrentItem);
		this._$scrollArea.getContentLayout().update(BaseUpdate.Children);
	}
	
	setCurrentItem(current){
		if (this._$scrollArea == undefined) return ;
		if ((current < 0) || (current > this._$scrollArea.getContentLayout().getNumChildren() - 1)) return;
		if ((!this.isMultiSelect()) && (this._$currentItem == current)) return;
		let remove = false;
		if (this.isMultiSelect()) remove = this.removeFromSelection(current);
		if (!remove){
			this._$currentItem = current;
			if (this.isMultiSelect()){
				if (!this._$select.indexOf(current) == -1) this._$select.push(current);
				else {
					let i = this._$select.indexOf(current);
					if(i != -1) this._$select.splice(i, 1);
				}
			}
			else {
				this._$select = [];
				this._$select.push(current);
				this.run("onChangeItem", current);
			}
		}
		this.update(ListUpdate.CurrentItem);
		this.update(ListUpdate.Selection);
	}

	removeFromSelection(index){
		if (index < 0) return false;
		if (index == this._$currentItem) this._$currentItem = -1;
		if (this._$select.length > 0){
			for (let i of this._$select){
				if (i == index){
					this._$select.splice(this._$select.indexOf(i),1);
					if (this._$select.length > 0) this._$currentItem = this._$select[this._$select.length - 1];
					this.update(ListUpdate.CurrentItem);
					this.update(ListUpdate.Selection);
					return true;
				}
			}
		}
		return false;
	}

	clearSelection(){
		this._$select = [];
		this._$currentItem = -1;
		this.update(ListUpdate.CurrentItem);
		this.update(ListUpdate.Selection);
	}

	onIncludeWidget(widget) {
		return this.addItem(widget);
	}

	onExtractWidget(widget) {
		if(widget == this._$scrollArea) return false;
		if(this._$scrollArea.getContentLayout().getChildren().indexOf(widget) != -1) {
			this.clearSelection();
			return this._$scrollArea.getContentLayout().extractInternal(widget);
		}
		return this.extractInternal(widget);
	}

	onCleanWidget() {
		return this._$scrollArea.getContentLayout().cleanWidget();
	}

}

/**
 * Created by prg-15 on 27.12.2017.
 */

class WebWidgetWindow extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$titleText = "Window";
		this._$mainLayout = undefined;
		this._$enableHeader = false;
		this._$needAttach = true;
		this._$needUnAttach = true;
		this._$styleName = this.getTypeName();
		this._$paddingLeft = 10;
		this._$paddingRight = 10;
		this._$paddingTop = 10;
		this._$paddingBottom = 10;
		this._$elevation = 8;
		this._$horizontalAlignType = WidgetHorizontalAlign.None;
		this._$verticalAlignType = WidgetVerticalAlign.None;
		this._$horzontalSizePolicy = WidgetSizePolicy.Fixed;
		this._$verticalSizePolicy = WidgetSizePolicy.Fixed;
		
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetWindow";
	}

	addWidget(widget){
		if (this._$mainLayout == undefined) return false;
		this._$mainLayout.addWidget(widget);
		this.update(BaseUpdate.Children);
		return true;
	}

	setEnableHeader(value){
		if (this._$enableHeader == value) return;
		this._$enableHeader = value;
		// if (value) this.setPadding(10,10,25,10);
		// else this.setPadding(10,10,10,10);
		this.run("onEnableHeader", value);
		this.update(WindowUpdate.EnableHeader);
	}

	isEnableHeader() {
		return this._$enableHeader;
	}

	setAttach(value){
		if (this._$needAttach == value) return;
		this._$needAttach = value;
		this.run("onChangeNeedAttach", value);
		this.update(WindowUpdate.NeedAttach);
	}

	isAttach() {
		return this._$needAttach;
	}

	setDetach(value){
		if (this._$needUnAttach == value) return;
		this._$needUnAttach = value;
		this.run("onChangeNeedUnAttach", value);
		this.update(WindowUpdate.NeedUnAttach);
	}

	isDetach() {
		return this._$needUnAttach;
	}

	setHeader(text){
		if (this._$titleText == text) return;
		this._$titleText = text;
		this.update(BaseUpdate.Header);
	}

	getHeader() {
		return this._$titleText;
	}

	getMainLayout() {
		return this._$mainLayout;
	}

	closeWindow() {
		console.log("Close Window!");
		this.run("CloseWindow");
	}

	minimizeWindow() {
		console.log("Minimize Window!");
		this.run("MinimizeWindow");
	}

	maximizeWindow(maxSize) {
		console.log("Maximize Window!", maxSize);
		this.run("MaximizeWindow", maxSize);
	}

	getHorizontalAlignType() {
		return this._$horizontalAlignType;
	}
	
	setHorizontalAlignType(alignType) {
		if(this._$horizontalAlignType == alignType) return;
		this._$horizontalAlignType = alignType;
		this.run("onChangeHorizontalAlignType", alignType);
		this.update(WindowUpdate.Align);
		if(alignType == WidgetHorizontalAlign.None)this.update(BaseUpdate.Position);
	}
	
	getVerticalAlignType() {
		return this._$verticalAlignType;
	}
	
	setVerticalAlignType(alignType) {
		if(this._$verticalAlignType == alignType) return;
		this._$verticalAlignType = alignType;
		this.run("onChangeVerticalAlignType", alignType);
		this.update(WindowUpdate.Align);
		if(alignType == WidgetVerticalAlign.None) this.update(BaseUpdate.Position);
	}
	
	setWidgetAlign(horizontalAlign, verticalAlign) {
		if(this._$horizontalAlignType != horizontalAlign) {
			this._$horizontalAlignType = horizontalAlign;
			this.run("onChangeHorizontalAlignType", horizontalAlign);
			this.update(WindowUpdate.Align);
			if(horizontalAlign == WidgetHorizontalAlign.None)this.update(BaseUpdate.Position);
		}
		if(this._$verticalAlignType != verticalAlign) {
			this._$verticalAlignType = verticalAlign;
			this.run("onChangeVerticalAlignType", verticalAlign);
			this.update(WindowUpdate.Align);
			if(verticalAlign == WidgetVerticalAlign.None) this.update(BaseUpdate.Position);
		}
	}
	
	setHorizontalSizePolicy(sizePolicy) {
		if(this._$horzontalSizePolicy != sizePolicy) {
			this._$horzontalSizePolicy = sizePolicy;
			this.run("onChangeHorizontalSizePolicy", sizePolicy);
			this.update(WindowUpdate.SizePolicy);
			if(sizePolicy == WidgetSizePolicy.Fixed || sizePolicy == WidgetSizePolicy.Expand) {
				this.update(BaseUpdate.Size);
			}
		}
	}
	
	getHorizontalSizePolicy() {
		return this._$horzontalSizePolicy;
	}
	
	setVerticalSizePolicy(sizePolicy) {
		if(this._$verticalSizePolicy != sizePolicy) {
			this._$verticalSizePolicy = sizePolicy;
			this.run("onChangeVerticalSizePolicy", sizePolicy);
			this.update(WindowUpdate.SizePolicy);
			if(sizePolicy == WidgetSizePolicy.Fixed || sizePolicy == WidgetSizePolicy.Expand) {
				this.update(BaseUpdate.Size);
			}
		}
	}
	
	getVerticalSizePolicy() {
		return this._$verticalSizePolicy;
	}
	
	setSizePolicy(hSizePolicy, vSizePolicy) {
		if(this._$horzontalSizePolicy != hSizePolicy) {
			this._$horzontalSizePolicy = hSizePolicy;
			this.run("onChangeHorizontalSizePolicy", hSizePolicy);
			this.update(WindowUpdate.SizePolicy);
			if(hSizePolicy == WidgetSizePolicy.Fixed || hSizePolicy == WidgetSizePolicy.Expand) {
				this.update(BaseUpdate.Size);
			}
		}
		if(this._$verticalSizePolicy != vSizePolicy) {
			this._$verticalSizePolicy = vSizePolicy;
			this.run("onChangeVerticalSizePolicy", vSizePolicy);
			this.update(WindowUpdate.SizePolicy);
			if(vSizePolicy == WidgetSizePolicy.Fixed || vSizePolicy == WidgetSizePolicy.Expand) {
				this.update(BaseUpdate.Size);
			}
		}
	}

	onSetScene(scene){
		if(this._$mainLayout !== undefined) return;
		this._$mainLayout = new WebWidgetLayoutVertical(this);
		this.addChild(this._$mainLayout);
		 super.onSetScene(scene);
	}

	onGenerateConstructor(state) {
		state += "new WidgetWindow(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state){
		if (this.flags.hasFlag(BaseUpdate.Header)) state += ",\"titleText\":\"" + btoa(unescape(encodeURIComponent(this._$titleText))) + "\"";
		if (this.flags.hasFlag(WindowUpdate.EnableHeader)) state += ",\"enableHeader\":" + this._$enableHeader;
		if (this.flags.hasFlag(WindowUpdate.NeedAttach)) state += ",\"needAttach\":" + this._$needAttach;
		if (this.flags.hasFlag(WindowUpdate.NeedUnAttach)) state += ",\"needUnAttach\":" + this._$needUnAttach;
		if(this.flags.hasFlag(WindowUpdate.Align)) {
			state += ",\"horizontalAlignType\":";
			state += this._$horizontalAlignType;
			state += ",\"verticalAlignType\":";
			state += this._$verticalAlignType;
		}
		if(this.flags.hasFlag(WindowUpdate.SizePolicy)) {
			state += ",\"horizontalSizePolicy\":";
			state += this._$horzontalSizePolicy;
			state += ",\"verticalSizePolicy\":";
			state += this._$verticalSizePolicy;
		}
		return state;
	}

	onExtractWidget(widget) {
		if (widget == this._$mainLayout) return false;
		return this._$mainLayout.extractInternal(widget);
	}

	onIncludeWidget(widget) {
		if (this._$mainLayout == undefined) return false;
		return this.addWidget(widget);
	}

	onCleanWidget() {
		return this._$mainLayout.cleanWidget();
	}

}

/**
 * Created by prg-15 on 28.12.2017.
 */
class WebWidgetMenuItem extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$styleName = "WidgetPopUpMenu";
		this._$iconAlign = 0;
		this._$icon = undefined;
		this._$label = undefined;
		this.setParent(parent);
		this.connect(this, "Destroy", () => {this._$parent.destroy();});
	}
	
	getTypeName() {
		return "WidgetMenuItem";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetMenuItem(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(MenuUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}
	
	setCaption(c) {
		if(this._$label === undefined) return;
		this._$label.setText(c);
	}
	
	pressed() {
		this.run("onPressed");
		this.run("Destroy");
		this.onPressed();
	}
	
	onPressed() {
	}
	
	onDestroy() {
		this._$label.destroy();
		this._$icon.destroy();
		this._$destroyed = true;
		
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$icon || widget === this._$label) super.addChild(widget);
		else {
			console.error('WebWidgetMenuItem can not has children.');
			widget.destroy();
			return false;
		}
	}
	
	setIcon(icon) {
		this._$icon.setImageData(icon);
	}
	
	getIcon() {
		return this._$icon;
	}
	
	setIconByName(name_material_icon){
		this._$icon.setIcon(name_material_icon);
		this.setIconAlign(WidgetHorizontalAlign.Left);
	}
	
	getLabel() {
		return this._$label;
	}
	
	getCaption() {
		return this._$label.getText();
	}
	
	getIconAlign() {
		return this._$iconAlign;
	}
	
	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.update(MenuUpdate.IconAlign);
	}
	
	onSetScene() {
		if(this._$icon === undefined) {
			this._$icon = new WebWidgetImage();
			this.addChild(this._$icon);
			this._$icon.setScene();
		}
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel();
			this.addChild(this._$label);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
	}
	
}

class WebWidgetInvestmentMenuItem extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$menu = undefined;
		this._$styleName = "WidgetPopUpMenu";
		this._$iconAlign = 0;
		this._$icon = undefined;
		this._$label = undefined;
		this.setParent(parent);
	}
	
	getTypeName() {
		return "WidgetInvestmentMenuItem";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetInvestmentMenuItem(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		state += ",\"menuId\":\"" + this._$menu.getID() + "\"";
		if(this.flags.hasFlag(MenuUpdate.IconAlign)) state += ",\"iconAlign\":" + this._$iconAlign;
		return state;
	}
	
	onSetScene() {
		this._$menu = new WebWidgetPopUpMenu();
		this._$menu.setVisible(false);
		if(this._$icon === undefined) {
			this._$icon = new WebWidgetImage();
			this.addChild(this._$icon);
			this._$icon.setScene();
		}
		if(this._$label === undefined) {
			this._$label = new WebWidgetLabel();
			this.addChild(this._$label);
			this._$label.setTextAlign(WidgetHorizontalAlign.Left);
		}
	}
	
	onExtractWidget(widget) {
		return false;
	}
	
	onDestroy() {
		this._$label.destroy();
		this._$icon.destroy();
		this._$destroyed = true;
		if(this._$menu != undefined) this._$menu.destroyMenu();
	}
	
	onSetStyleName(styleName) {
		if(this._$menu === undefined) return;
		for(let i = 0; i < this._$menu._$children.length; ++i)
			this._$menu._$children[i].setStyleName(styleName);
	}
	
	onIncludeWidget() {
		return false;
	}
	
	setCaption(c) {
		if(this._$label === undefined) return;
		this._$label.setText(c);
	}
	
	addChild(widget) {
		if(!widget) return false;
		if(widget === this._$icon || widget === this._$label) super.addChild(widget);
		else {
			console.error('WebWidgetInvestmentMenuItem can not has children.');
			widget.destroy();
			return false;
		}
	}
	
	setIcon(icon) {
		this._$icon.setImageData(icon);
	}
	
	getIcon() {
		return this._$icon;
	}
	
	setIconByName(name_material_icon){
		this._$icon.setIcon(name_material_icon);
		this.setIconAlign(WidgetHorizontalAlign.Left);
	}
	
	getLabel() {
		return this._$label;
	}
	
	getCaption() {
		return this._$label.getText();
	}
	
	getIconAlign() {
		return this._$iconAlign;
	}
	
	setIconAlign(align) {
		if(this._$iconAlign == align) return;
		this._$iconAlign = align;
		this.update(MenuUpdate.IconAlign);
	}
	
	getMenu() {
		return this._$menu;
	}
	
}

class WebWidgetPopUpMenu extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$itemHeight = 25;
		this._$itemWidth = 200;
		this._$parentMenu = undefined;
		this._$styleName = this.getTypeName();
		this._$elevation = 8;
		this._$styleToChildren = true;
		this._$order = 500;
		
		this.setParent(parent);
	}
	
	getTypeName() {
		return "WidgetPopUpMenu";
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetPopUpMenu(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(MenuUpdate.ParentMenuId)) {
			if(this._$parentMenu !== undefined) state += ",\"parentMenuId\":\"" + this._$parentMenu.getID() + "\"";
			else state += ",\"parentMenuId\":\"-1\"";
		}
		if(this.flags.hasFlag(MenuUpdate.ItemWidth)) state += ",\"itemWidth\":" + this._$itemWidth;
		if(this.flags.hasFlag(MenuUpdate.ItemHeight)) state += ",\"itemHeight\":" + this._$itemHeight;
		return state;
		
	}
	
	onDestroy() {
		let root = undefined;
		let tmp = this._$parentMenu;
		while(tmp) {
			if(!tmp._$parentMenu) root = tmp;
			tmp = tmp._$parentMenu;
		}
		if(root !== undefined) {
			root.destroyMenu();
		}
		else this.destroyMenu();
	}
	
	destroyMenu() {
		this._$destroyed = true;
		for(let i = 0; i < this._$children.length; ++i) {
			if(this._$children[i] === undefined) continue;
			this._$children[i].onDestroy();
		}
		this.run("onDestroy");
	}
	
	onExtractWidget(widget) {
		return false;
	}
	
	onIncludeWidget(widget) {
		return false;
	}
	
	onSetStyleName(styleName) {
		for(let i = 0; i < this._$children.length; ++i) {
			if(this._$children[i] === undefined) continue;
			this._$children[i].setStyleName(this._$styleName);
		}
	}
	
	setItemHeight(height) {
		if(height === 0 || height == this._$itemHeight) return;
		this._$itemHeight = height;
	}
	
	setItemWidth(width) {
		if(width == 0 || width == this._$itemWidth) return;
		this._$itemWidth = width;
	}
	
	setParentMenu(p) {
		this._$parentMenu = p;
	}
	
	addItem(itemCaption) {
		let temp = new WebWidgetMenuItem();
		this.addChild(temp);
		temp._$typeView = this._$typeView;
		temp.setStyleName(this._$styleName);
		temp.setCaption(itemCaption);
		this.setHeight(this._$children.length * this._$itemHeight);
		for(let i = 0; i < this._$children.length; ++i) {
			if(this._$children[i] === undefined) continue;
			this._$children[i].setHeight(this._$itemHeight);
		}
		this.update(BaseUpdate.Children);
		return temp;
	}
	
	addSubMenu(itemCaption) {
		let temp = new WebWidgetInvestmentMenuItem();
		this.addChild(temp);
		temp._$typeView = this._$typeView;
		temp._$menu.setParentMenu(this);
		temp._$menu.setOrder(this._$order + 1);
		temp.setCaption(itemCaption);
		temp.setStyleName(this._$styleName);
		temp._$menu.setStyleName(this._$styleName);
		temp._$menu.setElevation(this._$elevation + 1);
		this.setHeight(this._$children.length * this._$itemHeight);
		for(let i = 0; i < this._$children.length; ++i) {
			if(this._$children[i] === undefined) continue;
			this._$children[i].setHeight(this._$itemHeight);
		}
		this.update(BaseUpdate.Children);
		return temp;
	}
	
	clearMenu(){
		console.warn("САНЯ, ТЫ НЕ ПРАВ! webwidget не доделал!");
	}
	
}

/**
 * Created by prg-15 on 30.12.2017.
 */
var ButtonsStick = {
	Up		: 0,
	Down	: 1,
	Left	: 2,
	Right	: 3,
	Enter	: 4,
	None	: 5
};

function fromEnumStick(value) {
	for(let key in ButtonsStick) {
		if(ButtonsStick[key] === value) return ButtonsStick[key];
	}
}

class WebWidgetStick extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$styleName = this.getTypeName();
		this._$currentButton = ButtonsStick.None;
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetStick";
	}

	press(b) {
		this._$currentButton = fromEnumStick(b);
		this.run("onPress", this._$currentButton);
		this.update(StickUpdate.CurrentButton);
	}

	isPressed() {
		return this._$currentButton != Buttons.None;
	}

	unpress() {
		this._$currentButton = ButtonsStick.None;
		this.update(StickUpdate.CurrentButton);
	}

	getPressedButton() {
		return this._$currentButton;
	}

	onGenerateConstructor(state){
		state += "new WidgetStick(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state){
		if (this.flags.hasFlag(StickUpdate.CurrentButton)) state += ",\"currentButton\":" + this._$currentButton;
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetStick can not has children.');
		widget.destroy();
		return false;
	}

	onIncludeWidget(widget){
		return false;
	}

	onExtractWidget(widget){
		return false;
	}

}

/**
 * Created by semyon on 05.01.2018.
 */
var DialogType = {
	Info	: 0,
	Warning	: 1,
	Error	: 2
};

class WebWidgetDialog extends WebWidgetWindow {

	constructor(parent) {
		super(parent);
		this._$autoClose = true;
		this._$modal = false;
		this._$widget = undefined;
		this._$buttons = undefined;
		this._$elevation = 24;
		this._$styleName = this.getTypeName();
	}

	setAutoClose(value) {
		this._$autoClose = value;
	}

	onClose(btnName, widget) {
		this.runNow("onAccept", btnName, widget);
		if(this._$autoClose) this.destroy();
	}
	
	/**
	 * метод создания диалога
	 * @param {string} header заголовок окна. сейчас почему-то не отображается
	 * @param {WebWidget} _widget виджет, который отображать
	 * @param {string[]} buttonNames массив имен для кнопок
	 * @param {DialogType} [type] тип. чем отличаются не знаю
	 * @return {WebWidgetDialog}
	 *
	 * @example
	 * let widget = new WebWidgetLabel();
	 * ...
	 * let dialog = WebWidgetDialog.create("helloworld!", widget, ['close','ok']);
	 * dialog.setAutoClose(false);
	 * this.connect(dialog, "onAccept", (name,widget)=>{
	 * 	if(name == 'ok'){
	 * 		...
	 * 	}
	 * 	if(name == 'close'){
	 * 		...
	 * 	}
	 * 	this.dialog.destroy();
	 * });
	 */
	static create(header, _widget, buttonNames) {
		
		let dialog = new WebWidgetDialog();
		dialog.setHeader(header);
		dialog.setWidth(500);
		dialog.setHeight(600);
		dialog.btns = buttonNames;

		// for (let i = 0; i < buttonNames.length; ++i) {
		// 	let btn = new WebWidgetButton(layoutButtons);
		// 	if (buttonNames[i] === "") continue;
		// 	btn.setRaisedElevation(0, 0);
		// 	btn.getLabel().setBoldFont(true);
		// 	btn.setStyleName("WidgetButtonWithoutbackground");
		// 	btn.setText(buttonNames[i]);
		// 	btn.setMinWidth('"min-content"');
		// 	dialog.connect(btn, "onPress", function (p) {
		// 		if (p) return;
		// 		if (btn.getText().length === 0) return;
		// 		dialog.onClose(btn.getText(), dialog.getWidget());
		// 	});
		// }
		return dialog;
	}

	getTypeName() {
		return "WidgetDialog";
	}

	setWidget(_widget) {
		if (_widget == undefined) return;
		if (this._$widget == _widget) return;
		if (this._$widget != undefined) {
			this._$widget.setParent(undefined);
			this._$widget.destroy();
		}
		this._$widget = _widget;
		this.addWidget(_widget);
	}

	getWidget() {
		if(this._$widget == undefined) return undefined;
		return this._$widget;
	}

	setModal(flag) {
		if (this._$modal == flag) return;
		this._$modal = flag;
	}

	onGenerateConstructor(state) {
		state += "new WidgetDialog(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		// state = super.onGenerateState(state);
		// state += ",\"modal\":" + this._$modal;
		// //TODO сделать то же самое в плюсах:
		// state += ",\"buttons\":\"" + this._$buttons.getID() + "\"";
		// state += ",\"widgetId\":\"" + this._$widget.getID() + "\"";
		
		state += ",\"buttonNames\": [";
		for(let i = 0; i < this.btns.length; ++i) {
			if(i == 0) state += "\"" + this.btns[i] + "\"";
			else state += ",\"" + this.btns[i] + "\"";
		}
		state += "]";
		
		return state;
	}

	onExtractWidget(_widget) {
		if (this._$widget == _widget) return false;
		return super.onExtractWidget(_widget);
	}

	onIncludeWidget(widget) {
		this.setWidget(widget);
		return true;
	}

}

/**
 * Created by semyon on 05.01.2018.
 */

/**
 * клас диалога. НЕ НЬЮКАЙ ЕГО. юзай метод {@link WebWidgetDialogInput.create}
 * @event onAccept при закрытии диалога. параметры btnText - имя кнопки и text - текст инпута
 * @event onInfo при попытке закрыть диалог с пустым инпутом. параметры btnText - имя кнопки
 * @private
 */
class WebWidgetDialogInput extends WebWidgetWindow {

	constructor(parent) {
		super(parent);
		this._$autoClose = true;
		this._$modal = false;
		this._$input = undefined;
		this._$buttons = undefined;
		this._$elevation = 24;
		this._$styleName = "WidgetDialog";
	}

	setAutoClose(value) {
		this._$autoClose = value;
	}
	
	onClose(btnName, text) {
		this.run("onAccept", btnName, text);
		if(this._$autoClose) this.destroy();
	}

	onInfo(btnName) {
		this.run("onInfo", btnName);
	}
	
	/**
	 * создает диалог с инпутом.
	 * @param {string} windowHeader заголовок окна
	 * @param {string} textHeader заголовок инпута
	 * @param {string[]} buttonNames массив имен для кнопок
	 * @param {DialogType} [type] тип. чем они отличаются не знаю
	 * @return {WebWidgetDialogInput}
	 * @example
	 * let dialog = WebWidgetDialogInput.create("helloworld!", "enter you name", ['close','ok']);
	 * dialog.setAutoClose(false);
	 * this.connect(dialog, "onAccept", (name,text)=>{
	 * 	if(name == 'ok'){
	 * 		if (text == 'саша' || text == 'паша') console.log(`привет, ${text}!`);
	 * 		...
	 * 	}
	 * 	if(name == 'close'){
	 * 		...
	 * 	}
	 * 	this.dialog.destroy();
	 * });
	 * this.connect(dialog, "onInfo", (name)=>{
	 * 	if(name == 'ok'){
	 * 		console.log('введите текст!');
	 * 		return;
	 * 	}
	 * 	this.dialog.destroy();
	 * });
	 */
	static create(windowHeader, textHeader,  buttonNames, type = DialogType.Info) {

		let layoutBackground = new WebWidgetLayoutVertical();
		layoutBackground.setOrder(999999);
		layoutBackground.setStyleName("WidgetLayoutShadow");

		let spacer1 = new WebWidgetSpacer(layoutBackground);
		spacer1.setOrientation(OrientationType.Vertical);
		
		let dialog = new WebWidgetDialogInput(layoutBackground);
		dialog.setHeader(windowHeader);

		let spacer2 = new WebWidgetSpacer(layoutBackground);
		spacer2.setOrientation(OrientationType.Vertical);

		let spacerInput = new WebWidgetSpacer();
		dialog.addWidget(spacerInput);
		spacerInput.setOrientation(OrientationType.Vertical);

		let input = new WebWidgetInput();
		dialog.setInput(input);
		input.setHeader(textHeader);
		input.setMinHeight(50);
		input.setMaxHeight(50);
		 input.setFocused(true);
		
		dialog.connect(input, "onPressEnter", (p)=> {
			if (!p) return;
			let text = input._$text;
			if (text.length == 0) return;
			dialog.onClose("Enter", text);
		});

		let spacerInput2 = new WebWidgetSpacer();
		dialog.addWidget(spacerInput2);
		spacerInput2.setOrientation(OrientationType.Vertical);

		let layoutButtons = new WebWidgetLayoutHorizontal();
		dialog.addWidget(layoutButtons);
		dialog._$buttons = layoutButtons;//TODO
		layoutButtons.setMaxHeight(36);
		layoutButtons.setMinHeight(36);

		let spacerButtons = new WebWidgetSpacer(layoutButtons);
		spacerButtons.setOrientation(OrientationType.Horizontal);

		for (let i = 0; i < buttonNames.length; ++i) {
			let btn = new WebWidgetButton(layoutButtons);
			if (buttonNames[i] === "") continue;
			btn.setRaisedElevation(0, 0);
			btn.setMinWidth(100);
			btn.getLabel().setBoldFont(true);
			btn.setStyleName("WidgetButtonWithoutbackground");
			btn.setText(buttonNames[i]);
			dialog.connect(btn, "onPress", (p) => {
				if (p) return;
				if (input.getText().length == 0) {
					dialog.onInfo(btn.getText());
					return;
				}
				dialog.onClose(btn.getText(), input.getText());
			});
		}
		return dialog;
	}

	setText(text) {
		if (this._$input === undefined) {
			this.setHeader("");
			return;
		}
		this._$input.setText(text);
	}

	setModal(flag) {
		if (this._$modal == flag) return;
		this._$modal = flag;
	}

	setInput(widget) {
		if (widget === undefined) return;
		if (this._$input == widget) return;
		if (this._$input !== undefined) {
			this._$input.setParent(undefined);
			this._$input.destroy();
		}
		this._$input = widget;
		this.addWidget(widget);
	}

	getInput() {
		return this._$input;
	}

	getText() {
		return this._$input == undefined ? "" : this._$input.getText();
	}

	getTypeName() {
		return "WidgetDialogInput";
	}

	onGenerateConstructor(state) {
		state += "new WidgetDialogInput(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		state = super.onGenerateState(state);
		state += ",\"modal\":" + this._$modal;
		//TODO повторить в плюсах:
		state += ",\"input\":\"" + this._$input.getID() + "\"";
		state += ",\"buttons\":\"" + this._$buttons.getID() + "\"";
		return state;
	}

	//onExtractWidget(widget) {
	//	if (widget == this._$input) return false;
	//	return super.onExtractWidget(widget);
	//}
	
}



/**
 * Created by semyon on 05.01.2018.
 */

/**
 * клас диалога. НЕ НЬЮКАЙ ЕГО. юзай метод {@link WebWidgetDialogText.create}
 * @event onAccept при закрытии диалога. один параметр - имя кнопки, которой закрыли
 * @private
 */
class WebWidgetDialogText extends WebWidgetWindow {

	constructor(parent) {
		super(parent);
		this._$autoClose = true;
		this._$modal = false;
		this._$label = undefined;
		this._$buttons = undefined;
		this._$elevation = 24;
		this._$styleName = "WidgetDialog";
	}

	getTypeName() {
		return "WidgetDialogText";
	}

	setAutoClose(value) {
		this._$autoClose = value;
	}

	onClose(btnName) {
		this.runNow("onAccept", btnName);
		if(this._$autoClose) this.destroy();
	}
	
	/**
	 * создает диалог с текстом. типа инфо
	 * @param {string} header заголовок
	 * @param {string} text текст
	 * @param {string[]} buttonNames массив имен кнопок
	 * @param {DialogType} type тип. в чем разница не знаю
	 * @return {WebWidgetDialogText}
	 * @example
	 * см. {@link WebWidgetDialog}
	 */
	static create(header, text, buttonNames, type = DialogType.Info) {

		let layoutBackground = new WebWidgetLayoutVertical();
		layoutBackground.setOrder(999999);
		layoutBackground.setStyleName("WidgetLayoutShadow");

		let spacer1 = new WebWidgetSpacer(layoutBackground);
		spacer1.setOrientation(OrientationType.Vertical);
		
		let widgetDialog = new WebWidgetDialogText(layoutBackground);
		widgetDialog.setHeader(header);

		let spacer2 = new WebWidgetSpacer(layoutBackground);
		spacer2.setOrientation(OrientationType.Vertical);

		let lab = new WebWidgetLabel();
		widgetDialog.setLabel(lab);
		lab.setText(text);
		lab.setMinHeight(50);

		let layoutButtons = new WebWidgetLayoutHorizontal(widgetDialog);
		widgetDialog._$buttons = layoutButtons;//TODO
		layoutButtons.setMaxHeight(50);
		layoutButtons.setMinHeight(50);

		let spacerButtons = new WebWidgetSpacer(layoutButtons);
		spacerButtons.setOrientation(OrientationType.Horizontal);

		for (let i = 0; i < buttonNames.length; ++i) {
			let btn = new WebWidgetButton(layoutButtons);
			if (buttonNames[i] === "") continue;
			btn.setRaisedElevation(0, 0);
			btn.getLabel().setBoldFont(true);
			btn.setStyleName("WidgetButtonWithoutbackground");
			btn.setText(buttonNames[i]);
			widgetDialog.connect(btn, "onPress", (p) => {
				if (p) return;
				if (btn.getText().length === 0) return;
				widgetDialog.onClose(btn.getText());
			});
		}
		return widgetDialog;
	}

	setModal(flag) {
		if (this._$modal == flag) return;
		this._$modal = flag;
	}

	setLabel(widget) {
		if (widget == undefined) return;
		if (this._$label == widget) return;
		if (this._$label !== undefined) {
			this._$label.setParent(undefined);
			this._$label.destroy();
		}
		this._$label = widget;
		this.addWidget(widget);
	}

	getLabel() {
		return this._$label;
	}

	onGenerateConstructor(state) {
		state += "new WidgetDialogText(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		state = super.onGenerateState(state);
		state += ",\"modal\":" + this._$modal;
		//TODO повторить в плюсах:
		state += ",\"label\":\"" + this._$label.getID() + "\"";
		state += ",\"buttons\":\"" + this._$buttons.getID() + "\"";
		return state;
	}

	//onExtractWidget(widget) {
	//	if (widget === this._$label) return false;
	//	return this._$label.extractWidget(widget);
	//}

}

class WebWidgetTreeItem extends BaseObject {
	
	constructor() {
		super();
		this._$id = -1;
		this._$depth = 0;
		this._$expand = true;
		this._$canDestroy = true;
		this._$text = "";
		this._$iconText = "";
		this._$expandIcon = "keyboard_arrow_down";
		this._$noExpandIcon ="keyboard_arrow_right";
		this._$children = [];
		this._$userData = undefined;
		this._$tree = undefined;
		this._$widget = undefined;
		this._$parent = undefined;
	}
	
	getId() {
		return this._$id;
	}
	
	setWidget(widget) {
		this._$widget = widget;
		this._$tree.addChild(widget);
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	getWidget() {
		return this._$widget;
	}
	
	getTree() {
		return this._$tree;
	}
	
	setText(text) {
		if(this._$tree == null) {
			console.log("Tree not exist. Add item in tree.\n");
			return;
		}
		if(this._$text == text) return;
		this._$text = text;
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	getText() {
	return this._$text;
	}
	
	setIconByName(iconText) {
		this._$iconText = iconText;
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	getIconByName() {
		return this._$iconText;
	}
	
	setParent(parent) {
		parent._$tree.addItem(this, parent.getId());
	}
	
	getParent() {
		return this._$parent;
	}
	
	setUserData(userData) {
		this._$userData = userData;
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	getUserData() {
		return this._$userData;
	}
	
	setIconExpand(expand, noExpand) {
		this._$expandIcon = expand;
		this._$noExpandIcon = noExpand;
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	setExpanded(expanded) {
		if(this.isExpanded() == expanded) return;
		this._$expand = expanded;
		this._$tree.setExpandedItem(this._$id, expanded);
	}
	
	isExpanded(){
		return this._$expand;
	}
	
	expandAll(expand) {
		this.setExpanded(expand);
		for(let i of this._$children) {
			i.expandAll(expand);
		}
	}
	
	setCanDestroy(canDestroy) {
		this._$canDestroy = canDestroy;
		for(let child of this._$children) {
			child.setCanDestroy(canDestroy);
		}
	}
	
	isCanDestroy() {
		return this._$canDestroy;
	}
	
	addChild(child) {
		child._$parent = this;
		this._$children.push(child);
		child.updateDepth();
		this._$tree.addNeedUpdate(child);
		this._$tree.addNeedUpdate(this);
		this._$tree.update(TreeUpdate.UpdateItem);
	}
	
	getChild(index){
		if (this._$children.length <= index) return null;
		return this._$children[index];
	}
	
	getNumChildren() {
		return this._$children.length;
	}
	
	generateMenu(menu) {
		if(this._$children.length != 0) {
			let item = menu.addItem("collapse all");
			this.connect(item, "onPressed", () => {
				this.expandAll(false);
			});
			item = menu.addItem("expand all");
			this.connect(item, "onPressed", () => {
				this.expandAll(true);
			});
		}
		let item = menu.addItem("Collapse all items in tree");
		this.connect(item, "onPressed", () => {
			this._$tree.expandAllItemsInTree(false);
		});
		item = menu.addItem("Expand all items in tree");
		this.connect(item, "onPressed", () => {
			this._$tree.expandAllItemsInTree(true);
		});
		this.onGenerateMenu(menu);
	}
	
	drop(posX, posY) {
		this.run("onDrop", this, posX, posY);
	}
	
	mouseDown(button) {
		this.onMouseDown(button);
	}
	
	mouseUp(button) {
		this.onMouseUp(button);
	}
	
	mouseDoubleClick() {
		this.onMouseDoubleClick();
	}
	
	updateDepth() {
		let item = this;
		while(item != null) {
			this._$depth++;
			item = item._$parent;
		}
	}
	
	generateState(state) {
		if(this._$tree == null) {
			console.log("Tree not exist. Add item in tree.\n");
			return;
		}
		state += "\"id\":" + this._$id;
		state += ",\"text\":\"" + btoa(unescape(encodeURIComponent(this._$text))) + "\"";
		state += ",\"expandIcon\":\"" + this._$expandIcon + "\"";
		state += ",\"noExpandIcon\":\"" + this._$noExpandIcon + "\"";
		state += ",\"iconText\":\"" + this._$iconText + "\"";
		state += ",\"parentId\":" + (this._$parent == null ? -1 : this._$parent.getId());
		state += ",\"depth\":" + this._$depth;
		state += ",\"expanded\":" + this._$expand;
		state += ",\"widgetId\":\"" + (this._$widget == null ? -1 : this._$widget.getID()) + "\"";
		if(this._$children.length) {
			state += ",\"children\":[";
			for(let i = 0; i < this._$children.length; ++i) {
				let child = this._$children[i];
				state += child.getId();
				if(i != this._$children.length - 1) state += ",";
			}
			state += "]";
		} else {
			state += ",\"children\":[]";
		}
		return state;
		
	}
	
	onDestroy() {
		if(this._$tree._$needUpdate.indexOf(this) != -1) {
			this._$tree.addNeedRemove(this._$id);
		}
		this._$tree = null;
		this._$widget = null;
		this._$parent = null;
		this._$children = null;
		this._$userData = null;
	}
	
	
	onMouseDown(button) {
	//logf(Error, "onMouseDown %d %s\n", int(button), text.get());
	}
	
	onMouseUp(button) {
	//logf(Error, "onMouseUp %d %s\n", int(button), text.get());
	}
	
	onMouseDoubleClick() {
		//logf(Error, "onMouseDoubleClick %s\n", text.get());
	}
	
	onGenerateMenu(menu) {}
}

class WebWidgetTree extends WebWidget {
	
	constructor(parent) {
		super(parent);
		
		this._$itemLastId = 0;
		this._$hoveredItemId = -1;
		this._$selectedItemId = -1;
		this._$items = new Map();
		this._$needUpdate = [];
		this._$needRemove = [];
		
		this.setParent(parent);
	}
	
	addItemInMap(item) {
		item._$id = this._$itemLastId++;
		item._$tree = this;
		this._$items.set(item.getId(),item);
		this.addNeedUpdate(item);
	}
	
	getTypeName() {
		return "WidgetTree";
	}
	
	setExpandedItem(itemId, expanded) {
		let item = this.findItem(itemId);
		if(item == null) return;
		item.setExpanded(expanded);
		this.addNeedUpdate(item);
		this.update(TreeUpdate.UpdateItem);
	}
	
	setHoveredItem(itemId) {
		if(this._$hoveredItemId == itemId) return;
		this._$hoveredItemId = itemId;
		this.update(TreeUpdate.UpdateHoveredItem);
	}
	
	getHoveredItem(){
		return this.findItem(this._$hoveredItemId);
	}
	
	setSelectedItem(itemId) {
		if(this._$selectedItemId == itemId) return;
		this._$selectedItemId = itemId;
		this.update(TreeUpdate.UpdateSelectedItem);
	}
	
	getSelectedItem() {
		return this.findItem(this._$selectedItemId);
	}
	
	mouseDownItem(button) {
		if (!this._$items.has(this._$hoveredItemId)) return;
		this._$items.get(this._$hoveredItemId).mouseDown(button);
		this.setSelectedItem(this._$hoveredItemId);
		this.run("PressDown", this, this._$items.get(this._$hoveredItemId));
	}
	
	mouseUpItem(button) {
		if (!this._$items.has(this._$hoveredItemId)) return;
		this._$items.get(this._$hoveredItemId).mouseUp(button);
		this.run("PressUp", this, this._$items.get(this._$hoveredItemId));
	}
	
	mouseDoubleClickItem() {
		if (!this._$items.has(this._$hoveredItemId)) return;
		this._$items.get(this._$hoveredItemId).mouseDoubleClick();
		this.run("DoubleClick", this, this._$items.get(this._$hoveredItemId));
	}
	
	addItem(item, parentId = -1) {
		if(this._$items.has(item.getId())){
			console.log("Can't add item, item with id(", parentId, ") exist in tree.\n");
			return false;
		}
		let parent = parentId == -1 ? null : this.findItem(parentId);
		if(parentId != -1 && parent == null) {
			console.log("Can't find parent with id(", parentId, ").\n");
			return false;
		}
		if(parent != null) {
			parent.addChild(item);
		}
		this.addItemInMap(item);
		this.update(BaseUpdate.Children);
		this.update(TreeUpdate.UpdateItem);
		return true;
	}
	
	addItemByText(text, parentId = -1) {
		let parent = parentId == -1 ? null : this.findItem(parentId);
		if(parentId != -1 && parent == null) {
			console.log("Can't find parent with id(", parentId, ").\n");
			return null;
		}
		let item = new WebWidgetTreeItem();
		if(parent != null) {
			parent.addChild(item);
		}
		item._$text = text;
		this.addItemInMap(item);
		this.update(BaseUpdate.Children);
		this.update(TreeUpdate.UpdateItem);
		return item;
	}
	
	findItem(id) {
		if(this._$items.has(id)) return this._$items.get(id);
		return null;
	}
	
	getItems() {
		return this._$items;
	}
	
	removeItem(id) {
		let item = this.findItem(id);
		if(item == null) {
			console.log("Can't find item with id(", id, ")");
			return false;
		}
		if(!item.isCanDestroy()) {
			console.log("Can't destroy item with id(", id, ")");
			return false;
		}
		this.addNeedRemove(id);
		if(item._$parent != null) {
			let find = item._$parent._$children.indexOf(item);
			item._$parent._$children.splice(find, 1);
			this.addNeedUpdate(item._$parent);
			this.update(TreeUpdate.UpdateItem);
		}
		if(item._$widget != null) {
			item._$widget.setParent(null);
			item._$widget.destroy();
		}
		item.run("onDeleteItem", item);
		while(item._$children.length ) {
			let child = item._$children[0];
			child._$parent = null;
			let find = item._$children.indexOf(child);
			item._$children.splice(find, 1);
			if(!this.removeItem(child.getId())) break;
		}
		if(item._$children.length) {
			console.log("Can't remove all childs item with id(", id, ")");
			return false;
		}
		if(this._$needRemove.indexOf(id) === -1) this.addNeedRemove(id);
		this._$items.delete(id);
		item.destroy();
		this.update(BaseUpdate.Children);
		this.update(TreeUpdate.RemoveItem);
		return true;
	}
	
	removeAll() {
		return this.onCleanWidget();
	}
	
	expandAllItemsInTree(expand) {
		for(let item of this._$items.values()) {
			item.expandAll(expand);
		}
	}
	
	addNeedUpdate(item){
		if(!item) return;
		if(this._$needRemove.indexOf(item.getId()) > -1) return;
		if(this._$needUpdate.indexOf(item) > -1) return;
		this._$needUpdate.push(item);
	}
	addNeedRemove(_id) {
	if(this._$needRemove.indexOf(_id) > -1) return;
	let item = this.findItem((_id));
	let find = this._$needUpdate.indexOf(item);
	if(find > -1) this._$needUpdate.splice(find, 1);
	this._$needRemove.push(_id);
}

	onGenerateConstructor(constructor) {
		for(let item of this._$items) {
			if(!this._$needUpdate.has(item)) this._$needUpdate.push(item);
		}
		constructor += "new WidgetTree(";
		constructor = this.generateState(constructor);
		constructor += ")";
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(TreeUpdate.UpdateHoveredItem)) state += ",\"hoveredItemId\":" + this._$hoveredItemId;
		if(this.flags.hasFlag(TreeUpdate.UpdateSelectedItem)) state += ",\"selectedItemId\":" + this._$selectedItemId;
		
		if(this.flags.hasFlag(TreeUpdate.UpdateItem) && (this._$needUpdate.length != 0)) {
			state += ",\"updates\":[";
			let i = 0;
			while(this._$needUpdate.length) {
				if(!i) state += "{";
				else state += ",{";
				state = this._$needUpdate[0].generateState(state);
				let find = this._$needUpdate.indexOf(this._$needUpdate[0]);
				this._$needUpdate.splice(find, 1);
				state += "}";
				i++;
			}
			state += "]";
		}
		if(this.flags.hasFlag(TreeUpdate.RemoveItem) && (this._$needRemove.length != 0)) {
			state += ",\"needRemove\":[";
			for(let i = 0; i < this._$needRemove.length; i++) {
				if(i) state += ",";
				state += this._$needRemove[i];
			}
			state += "]";
			this._$needRemove.length = 0;
		}
		return state;
	}
	
	onDestroy() {
		this.removeAll();
	}
	
	onGenerateMenu(menu) {
		let item = this.findItem(this._$hoveredItemId);
		if(item == null) return;
		item.generateMenu(menu);
	}
	
	onExtractWidget(widget) {
		return false;
	}
	
	onIncludeWidget(widget){
		return false;
	}
	
	onCleanWidget(){
		for(let item of this._$items.values()) {
			item.setCanDestroy(true);
			this.removeItem(item.getId());
		}
		if(this._$items.size) {
			console.log("Can't items tree with id(", this._$id, ")");
			return false;
		}
		this._$needUpdate.length = 0;
		this._$items.clear();
		this._$itemLastId = 0;
	}
}

/**
 * Created by semyon on 30.12.2017.
 */
class WebWidgetConstructor extends WebWidget {

	constructor(parent) {
		super(parent);
		this._$hoveredWidget = undefined;
		this._$memoryPosX = 0;
		this._$memoryPosY = 0;
		this._$needCorrectChilds = false;
		this._$alignWidgets = true;
		this._$imageData = "";
		this._$lastFocused = undefined;
		this._$focusedWidget = undefined;
		this._$focusedWidgets = [];
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "Constructor";
	}

	moveToFront(w) {
		if (w == undefined) return;
		w.setParent(undefined);
		this.addChild(w);
		this.update(BaseUpdate.Children);
	}

	moveToBackground(w) {
		if (w == undefined) return;
		 let i = this._$children.indexOf(w);
		 if(i === -1) return;
		 this._$children.splice(i, 1);
		 this._$children.splice(0, 0, w);
		this.update(BaseUpdate.Children);
	}

	checkSelectInherit(ww, x, y) {
		let c = ww._$children;
		for (let o in c) {
			let w = o;
			if (x > w.getPosX() && x < w.getPosX() + w.getWidth() && y > w.getPosY() && y < w.getPosY() + w.getHeight()) {
				let c = this.checkSelectInherit(w, (x - w.getPosX()) / w.getWidth(), (y - w.getPosY()) / w.getHeight());
				if (c != undefined) return c;
				return w;
			}
		}
		return undefined;
	}

	checkSelect(newW, x, y) {
		for (let i = this._$children.length - 1; i > -1; --i) {
			let w = this._$children[i];
			if (newW === w) continue;
			if (x > w.getPosX() && x < w.getPosX() + w.getWidth() && y > w.getPosY() && y < w.getPosY() + w.getHeight()) {
				let c = this.checkSelectInherit(w, (x - w.getPosX()) / w.getWidth(), (y - w.getPosY()) / w.getHeight());
				if (c != undefined) return c;
				return w;
			}
		}
		return undefined;
	}

	clearWidgets() {
		let t = undefined;
		 while (this._$children.length > 0) {
		 	t = this._$children[0];
		 	t.setParent(undefined);
		 	t.destroy();
		 }
		this.update(BaseUpdate.Children);
	}

	addWidget(widget) {
		this.addChild(widget);
		this.run("onAddChild", widget);
		this.update(BaseUpdate.Children);
	}

	onGenerateMenu(menu) {
		if (this._$focusedWidgets.length == 1) {
			let widget = this.getFocusedWidget();
			if(widget == undefined) return;
			this.connect(menu.addItem("Move to Front"), "Pressed", () => {
				if(widget == undefined) return;
				this.moveToFront(widget);
			});
			this.connect(menu.addItem("Move to Background"), "Pressed", () => {
				if (widget == undefined) return;
				this.moveToBackground(widget);
			});
			this.connect(menu.addItem("Delete"), "Pressed", () => {
				if (widget == undefined) return;
				this.destroyWidgetById(widget.id);
			});
		} else {
			this.connect(menu.addItem("Delete All"), "Pressed", () => {
				this.clearWidgets();
			});
		}
	}

	onDrop(sender, json, data) {
		if (this.isEditable()) return;
		let buttonType = "WidgetButton";
		let senderTypeName = sender.getTypeName();
		if (senderTypeName === buttonType) {
			sender.unpress();
			console.error("Error", this._$children[this._$children.length - 1].getTypeName(), this._$children.length);
			let newChild = this._$children[this._$children.length - 1];
			this.assert(newChild != undefined);
			console.error("Error! JsonData^ ", json);
			let cc = this.checkSelect(newChild, json.posX, json.posY);
			if (cc != undefined) if (cc.includeWidget(newChild)) return;
			newChild.setPos(json.posX, json.posY);
			newChild.setFocused(false);
		}
	}

	onIncludeWidget(widget) {
		this.addWidget(widget);
		return true;
	}

	onExtractWidget(widget) {
		if (super.extractInternal(widget)) {
			this.run("onExtractChild", widget);
			return true;
		}
		return false;
	}

	onGenerateConstructor(state) {
		state += "new Constructor(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onSetScene() {
		super.onSetScene();
		if (this._$parent != undefined) {
			let lay = this.getParent();
			if (lay.getParent() != undefined) {
				let window = lay.getParent();
				if (window === undefined) return;
				this.connect(window, "correctChildPos", (x, y) => {
					let dx = x - this._$memoryPosX;
					let dy = y - this._$memoryPosY;
					this._$memoryPosX = x;
					this._$memoryPosY = y;
					if (this._$needCorrectChilds) this.correctPositionsWidgets(dx, dy);
					else this._$needCorrectChilds = true;
				});
			}
		}
	}

	onGenerateState(state) {
		if (this._$hoveredWidget !== undefined) state += ",\"hovered\":\"" + this._$hoveredWidget.getID() + "\"";
		else state += ",\"hovered\":" + "-1";
		if (this.flags.hasFlag(ConstructorUpdate.Focused)) {
			if (this._$focusedWidget !== undefined) state += ",\"focused\":\"" + this._$focusedWidget.getID() + "\"";
			else state += ",\"focused\":" + "-1";
		}
		if (this.flags.hasFlag(ConstructorUpdate.AlignWidgets)) state += ",\"alignWidgets\":" + this._$alignWidgets;
		return state;
	}

	setFocusedWidget(widget) {
		if(this._$focusedWidgets.length > 0) {
			this._$focusedWidgets = [];
		}
		this._$focusedWidget.push(widget);
		this.run("onFocusItem", widget);
		this.update(ConstructorUpdate.Focused);
	}

	setFocusedWidgetById(id) {
		this._$focusedWidgets = [];
		let focusedWidgetId = Rex.webScene.findObject(id);
		if(this._$focusedWidgets.length > 0) this._$focusedWidgets = [];
		this._$focusedWidgets.push(focusedWidgetId);
		this.run("onFocusItem", focusedWidgetId);
		this.update(ConstructorUpdate.Focused);
	}

	setFocusedWidgetsById(widgetsId) {
		this._$focusedWidgets = [];
		this._$focusedWidget = undefined;
		// TODO
	}

	setHoveredWidget(widget) {
		this._$hoveredWidget = widget;
		this.update(ConstructorUpdate.Hovered);
	}

	setHoveredWidgetById(id) {
		this.hoveredWidget = this._$scene.findObject(id);
		this.update(ConstructorUpdate.Hovered);
	}

	correctPositionsWidgets(dx, dy) {
		if (this._$children.length == 0) return;
		for (let widget in this._$children) {
			widget.setAutoUpdateScene(false);
		}
		this.setAutoUpdateScene(false);
		for (let obj in this._$children) {
			if (obj === undefined) continue;
			let widget = obj;
			if (widget == undefined) continue;
			let posX = widget.getPosX() + dx;
			let posY = widget.getPosY() + dy;
			widget.setPos(posX, posY);
		}
		for (let widget in this._$children) {
			widget.setAutoUpdateScene(true);
		}
		this.setAutoUpdateScene(true);
		this.update(BaseUpdate.Position);
	}

	setPositionsWidgets(dx, dy) {
		if(dx == 0 && dy == 0) return;
		if (this._$focusedWidgets.length <= 0) return;
		for (let widget in this._$focusedWidgets) {
			widget.setAutoUpdateScene(false);
		}
		this.setAutoUpdateScene(false);
		for (let widget in this._$focusedWidgets) {
			if (widget == undefined) continue;
			let posX = widget.getPosX() + dx;
			let posY = widget.getPosY() + dy;
			widget.setPos(posX, posY);
		}
		for (let widget in this._$focusedWidgets) {
			widget.setAutoUpdateScene(true);
		}
		this.setAutoUpdateScene(true);
		this.update(BaseUpdate.Position);
	}

	setGeometryWidgets(dx, dy, dw, dh) {
		if (this._$focusedWidgets.length <= 0) return;
		for (let widget in this._$focusedWidgets) {
			widget.setAutoUpdateScene(false);
		}
		this.setAutoUpdateScene(false);
		for (let widget in this._$focusedWidgets) {
			if (widget == undefined) continue;
			let posX = widget.getPosX() + dx;
			let posY = widget.getPosY() + dy;
			let width = widget.getWidth() + dw;
			let height = widget.getHeight() + dh;
			if(width <= 0 || heigth <= 0) continue;
			widget.setGeometry(posX, posY, width, height);
		}
		for (let widget in this._$focusedWidgets) {
			widget.setAutoUpdateScene(true);
		}
		this.setAutoUpdateScene(true);
		this.update(BaseUpdate.Position);
		this.update(BaseUpdate.Size);
	}

	getHoveredWidget() {
		return this._$hoveredWidget;
	}

	destroyWidgetById(id) {
		if (this._$focusedWidgets.length > 0) this._$focusedWidgets = [];
		let temp = this._$scene.findObject(id);
		if (temp == undefined) return;
		temp.setParent(undefined);
		temp.destroy();
		this.update(BaseUpdate.Children);
	}

	destroyWidgets() {
		if(this._$focusedWidgets.length <= 0) return;
		for(let widget in this._$focusedWidgets) {
			if(widget == undefined) continue;
			let temp = this._$scene.findObject(widget.getID());
			if(temp == undefined) return;
			temp.setParent(undefined);
			temp.destroy();
		}
		this._$focusedWidgets = [];
		this.setFocusedWidgetById(-1);
		this.setHoveredWidgetById(-1);
		this.update(BaseUpdate.Children);
	}

	duplicate() {
		if (this._$focusedWidgets.length > 0) {
			for (let widget in this._$focusedWidgets) {
				this.duplicateWidget(widget);
			}
		} else if (this._$focusedWidget !== undefined) {
			this.duplicateWidget(this._$focusedWidget);
		}
	}

	duplicateWidget(widget) {
		//TODO
	}

	setImageData(data) {
		this.imageData = data;
		//
	}

	getImageData() {
		return this._$imageData;
	}

	setAlignWidgets(value) {
		if (this._$alignWidgets == value) return;
		this._$alignWidgets = value;
		this.run("onChangeAlignWidgets", value);
		this.update(ConstructorUpdate.AlignWidgets);
	}

	getAlignWidgets() {
		return this._$alignWidgets;
	}

	getFocusedWidget() {
		if(this._$focusedWidgets.length === 1) {
			let widget = this._$focusedWidgets[0];
			if(widget == undefined) return widget;
			else return undefined;
		} else return undefined;
	}

}



/**
 * Created by prg-15 on 10.01.2018.
 */
class Holiday {
	constructor(){
		this._$day = 1;
		this._$month = 1;
		this._$year = 1;
	}
}

class CalendarEvent {
	constructor() {
		this.day = 1;
		this.month = 1;
		this.year = 1;
		this.color = "red";
		this.title = ""
	}
}

class WebWidgetCalendar extends WebWidget{
	constructor(parent){
		super(parent);
		this._$day = 1;
		this._$month = 1;
		this._$year = 2018;
		
		this._$secondaryDay = 1;
		this._$secondaryMonth = 1;
		this._$secondaryYear = 2018;
		
		this._$calendarType = 0;
		
		this._$elevation = 24;
		this._$styleName = this.getTypeName();
		this._$holidays = [];
		this._$events = [];
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetCalendar";
	}

	onGenerateConstructor(state) {
		state += "new WidgetCalendar(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state){
		if(this.flags.hasFlag(CalendarUpdate.CalendarType))	state += ",\"calendarType\":"  + (this._$calendarType);
		
		if (this.flags.hasFlag(CalendarUpdate.Day)) state += ",\"day\":" + this._$day;
		if (this.flags.hasFlag(CalendarUpdate.Month)) state += ",\"month\":" + this._$month;
		if (this.flags.hasFlag(CalendarUpdate.Year)) state += ",\"year\":" + this._$year;
		
		if(this.flags.hasFlag(CalendarUpdate.SecondaryDay))		state += ",\"secondaryDay\":"  +		this._$secondaryDay;
		if(this.flags.hasFlag(CalendarUpdate.SecondaryMonth))		state += ",\"secondaryMonth\":" +		this._$secondaryMonth;
		if(this.flags.hasFlag(CalendarUpdate.SecondaryYear))		state += ",\"secondaryYear\":" +		this._$secondaryYear;
		
		
		if (this.flags.hasFlag(CalendarUpdate.Holidays)) {
			state += ",\"holidays\":[";
			for (let i = 0; i < this._$holidays.length; ++i){
				let h = this._$holidays[i];
				if(h == null) continue;
				if(!i) state += "{";
				else state += ",{";
				state += "\"day\":" + h._$day;
				state += ",\"month\":" + h._$month;
				state += ",\"year\":" + h._$year;
				state += "}";
			}
			state += "]";
		}
		
		if(this.flags.hasFlag(CalendarUpdate.Events)) {
			state += ",\"events\":[";
			for(let i = 0; i < this._$events.length; ++i) {
				let e = this._$events[i];
				if(e == null) continue;
				if(!i) state += "{";
				else state += ",{";
				state += "\"day\":" + e.day;
				state += ",\"month\":" + e.month;
				state += ",\"year\":" + e.year;
				state += ",\"color\":\"" + e.color + "\"";
				
				state += ",\"title\":\"" +  btoa(unescape(encodeURIComponent(e.title))) + "\"";
				state += "}";
			}
			state += "]";
		}
		
		return state;
	}
	
	addChild(widget) {
		if(!widget) return false;
		console.error('WebWidgetCalendar can not has children.');
		widget.destroy();
		return false;
	}

	setDay(value){
		if (value < 0 || value > 31 || value == this._$day) return;
		this._$day = value;
		this.run("onChangeDay", value);
		this.update(CalendarUpdate.Day);
	}

	getDay() {
		return this._$day;
	}

	setMonth(value){
		if (value < 0 || value > 12 || value == this._$month) return;
		this._$month = value;
		this.run("onChangeMonth", value);
		this.update(CalendarUpdate.Month);
	}

	getMonth() {
		return this._$month;
	}

	setYear(value){
		if (this._$year == value) return;
		this._$year = value;
		this.run("onChangeYear", value);
		this.update(CalendarUpdate.Year);
	}

	getYear() {
		return this._$year;
	}

	setSecondaryDay(value) {
		if(value <= 0 || value > 31 || value == this._$secondaryDay) return;
		this._$secondaryDay = value;
		this.run("onChangeSecondaryDay", value);
		this.update(CalendarUpdate.SecondaryDay);
	}

	getSecondaryDay() {
		return this._$secondaryDay;
	}

	setSecondaryMonth(value) {
		if(value <= 0 || value > 12 || value == this._$secondaryMonth) return;
		this._$secondaryMonth = value;
		this.run("onChangeSecondaryMonth", value);
		this.update(CalendarUpdate.SecondaryMonth);
	}

	getSecondaryMonth() {
		return this._$secondaryMonth;
	}

	setSecondaryYear(value) {
		if(this._$secondaryYear == value) return;
		this._$secondaryYear = value;
		this.run("onChangeSecondaryYear", value);
		this.update(CalendarUpdate.SecondaryYear);
	}

	getSecondaryYear() {
		return this._$secondaryYear;
	}

	addHoliday(day, month, year){
		if (day <= 0 || day > 31 || month <= 0 || month > 12) return;
		let h = new Holiday();
		h._$day = day;
		h._$month = month;
		h._$year = year;
		this._$holidays.push(h);
		this.update(CalendarUpdate.Holidays);
	}
	
	addEvent(day, month, year, color, title) {
		if(day <= 0 || day > 31 || month <= 0 || month > 12) return;
		let event = new CalendarEvent();
		event.day = day;
		event.month = month;
		event.year = year;
		event.color = color;
		event.title = title;
		events.push(event);
		this.update(CalendarUpdate.Events);
		
	}

	onSetScene(scene) {
		this.setWidth(330);
		this.setHeight(480);
		super.onSetScene(scene);
	}
}

/**
 * Created by prg-15 on 11.02.2018.
 */
class WebWidgetTime extends WebWidget{
	constructor(parent) {
		super(parent);
		this._$selectedType = 0;
		
		this._$hours = 0;
		this._$minutes = 0;
		this._$seconds = 0;
		
		this._$secondaryHours = 0;
		this._$secondaryMinutes = 0;
		this._$secondarySeconds = 0;
		
		
		this._$styleName = this.getTypeName();
		this.setParent(parent);
	}

	getTypeName() {
		return "WidgetTime";
	}
	
	setSelectedType(type) {
		if(this._$selectedType == type) return;
		this._$selectedType = type;
		this.run("onChangeSelectedType", type);
		this.update(TimeUpdate.SelectedType);
	}

	getSelectedType() {
		return this._$selectedType;
	}

	onGenerateConstructor(state) {
		state += "new WidgetTime(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state){
		if (this.flags.hasFlag(TimeUpdate.Hours)) state += ",\"hours\":"  + this._$hours;
		if (this.flags.hasFlag(TimeUpdate.Minutes)) state += ",\"minutes\":"  + this._$minutes;
		if (this.flags.hasFlag(TimeUpdate.Seconds)) state += ",\"seconds\":"  + this._$seconds;
		
		if(this.flags.hasFlag(TimeUpdate.SelectedType))		state += ",\"selectedType\":"  +	this._$selectedType;
		
		if(this.flags.hasFlag(TimeUpdate.SecondaryHours))		state += ",\"secondaryHours\":"  +		this._$secondaryHours;
		if(this.flags.hasFlag(TimeUpdate.SecondaryMinutes))		state += ",\"secondaryMinutes\":" +		this._$secondaryMinutes;
		if(this.flags.hasFlag(TimeUpdate.SecondarySeconds))		state += ",\"secondarySeconds\":" +		this._$secondarySeconds;
		
		return state;
	}

	setHours(value){
		if (value < 0 || value > 23 || this._$hours == value) return;
		this._$hours = value;
		this.run("onChangeHours", value);
		this.update(TimeUpdate.Hours);
	}

	getHours() {
		return this._$hours;
	}

	setMinutes(value){
		if (value < 0 || value > 59 || this._$minutes == value) return;
		this._$minutes = value;
		this.run("onChangeMinutes", value);
		this.update(TimeUpdate.Minutes);
	}

	getMinutes() {
		return this._$minutes;
	}

	setSeconds(value){
		if (value < 0 || value > 59 || this._$seconds == value) return;
		this._$seconds = value;
		this.run("onChangeSeconds", value);
		this.update(TimeUpdate.Seconds);
	}

	getSeconds() {
		return this._$seconds;
	}

	setSecondaryHours(value){
		if (value < 0 || value > 23 || this._$secondaryHours == value) return;
		this._$secondaryHours = value;
		this.run("onChangeSecondaryHours", value);
		this.update(TimeUpdate.SecondaryHours);
	}

	getSecondaryHours() {
		return this._$secondaryHours;
	}

	setSecondaryMinutes(value){
		if (value < 0 || value > 59 || this._$secondaryMinutes == value) return;
		this._$secondaryMinutes = value;
		this.run("onChangeSecondaryMinutes", value);
		this.update(TimeUpdate.SecondaryMinutes);
	}

	getSecondaryMinutes() {
		return this._$secondaryMinutes;
	}

	setSecondarySeconds(value){
		if (value < 0 || value > 59 || this._$secondarySeconds == value) return;
		this._$secondarySeconds = value;
		this.run("onChangeSecondarySeconds", value);
		this.update(TimeUpdate.SecondarySeconds);
	}

	getSecondarySeconds() {
		return this._$secondarySeconds;
	}

	onSetScene(scene) {
		this.setWidth(330);
		this.setHeight(480);
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}
}

/**
 * Created by prg-15 on 23.12.2017.
 */

class WebWidgetFrame extends WebWidget {
	
	constructor(parent) {
		super(parent);
		this._$external = false;
		this._$src = "";
		this.setParent(parent);
	}
	
	onGenerateConstructor(state) {
		state += "new WidgetFrame(";
		state = this.generateState(state);
		state += ")";
		return state;
	}
	
	onGenerateState(state) {
		if(this.flags.hasFlag(FrameUpdate.Src)) {
			state += ",\"external\":" + this._$external;
			state += ",\"srcEncode\":\"" + btoa(unescape(encodeURIComponent(this._$src))) + "\"";
		}
		return state;
	}
	
	addChild(widget) {
		console.error('WebWidgetFrame can not has children.');
		widget.destroy();
		return false;
	}
	
	getTypeName() {
		return "WidgetFrame";
	}
	
	setSource(src, external) {
		if (this._$src !== src || this._$external !== external){
			this._$src = src;
			this._$external = external;
			this.update(FrameUpdate.Src);
		}
	}

	onIncludeWidget(widget) {
		return false;
	}

	onExtractWidget(widget) {
		return false;
	}
	
	onload(){
		this.run("onLoad");
	}
	
}


/**
 * WebWidgetTable
 */

class WebWidgetTable extends WebWidget {
	constructor(parent) {
		super(parent);
		this._$needHeadRow = true;
		this._$fixHeadRow = false;
		this._$needBorder = false;
		this._$data = [];
		this._$maxRow = -1;
		this._$maxCol = -1;
		this._$meta = {};
		this._$isNumberSort = false;
		this._$needRowsNumber = false;
		this._$needResize = false;
		this.setParent(parent);
	}

	onGenerateConstructor(state) {
		state += "new WidgetTable(";
		state = this.generateState(state);
		state += ")";
		return state;
	}

	onGenerateState(state) {
		if(this._$data.length && this.flags.hasFlag(TableUpdate.Data)) {
			state += ",\"data\":[";
			let rowsSize = this._$data.length;
			for(let i = 0; i < rowsSize; ++i) {
				let row = this._$data[i];
				let colsSize = row.length;
				if(row !== []) {
					state += "[";
					for(let j = 0; j < colsSize; ++j) {
						state += JSON.stringify(row[j]);
						if(j !== colsSize - 1) state += ",";
					}
					state += (i !== rowsSize - 1) ? "]," : "]";
				} else {
					console.error("Invalid data");
					state += (i !== colsSize - 1) ? "[]," : "[]";//но можно и дальше парсить
				}
			}
			state += "]";
		}
		if(this.flags.hasFlag(TableUpdate.NeedHeadRow)) {
			state += ",\"needHeadRow\":"; state += this._$needHeadRow;
		}
		if(this.flags.hasFlag(TableUpdate.FixHeadRow)) {
			state += ",\"fixHeadRow\":"; state += this._$fixHeadRow;
		}
		if(this.flags.hasFlag(TableUpdate.NeedBorder)) {
			state += ",\"needBorder\":"; state += this._$needBorder;
		}
		state += ",\"maxRow\":"; state += this._$maxRow;
		state += ",\"maxCol\":"; state += this._$maxCol;
		if(this.flags.hasFlag(TableUpdate.Data) || this.flags.hasFlag(TableUpdate.Meta)) {
			state += ",\"meta\":"; state += JSON.stringify(this._$meta);
		}
		if(this.flags.hasFlag(TableUpdate.IsNumberSort)) {
			state += ",\"isNumberSort\":"; state += this._$isNumberSort;
		}
		if(this.flags.hasFlag(TableUpdate.NeedRowsNumber)) {
			state += ",\"needRowsNumber\":"; state += this._$needRowsNumber;
		}
		if(this.flags.hasFlag(TableUpdate.NeedResize)) {
			state += ",\"needResize\":"; state += this._$needResize;
		}
		return state;
	}

	setIsNumberSort(value) {
		this._$isNumberSort = value;
		this.update(TableUpdate.IsNumberSort);
	}

	getIsNumberSort() {
		return this._$isNumberSort;
	}

	getData() {
		return this._$data;
	}

	setData(value) {
		this._$data = value;
		this.update(TableUpdate.Data);
	}

	setNeedResize(value) {
		this._$needResize = value;
		this.update(TableUpdate.NeedResize);
	}

	_$setSomeToCell(rowIndex, colIndex, someName, someValue, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent) {
			let widgetID = this._$data[rowIndex][colIndex];
			if (widgetID !== "") {
				composeObj(this._$meta, joinTextToCompose(widgetID, param, someName), someValue);
			} else {
				console.error("You can't set param to clear cell.");
			}
		}
		else
			composeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, param, someName), someValue);
	}

	_$setSomeToRow(rowIndex, someName, someValue, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			composeObj(this._$meta, joinTextToCompose("rows", rowIndex, "content", param, someName), someValue);
		else
			composeObj(this._$meta, joinTextToCompose("rows", rowIndex, param, someName), someValue);
	}

	_$setSomeToAllCells(someName, someValue, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			composeObj(this._$meta, joinTextToCompose("all", "content", param, someName), someValue);
		else
			composeObj(this._$meta, joinTextToCompose("all", param, someName), someValue);
	}

	_$setSomeToCol(colIndex, someName, someValue, isArrt, isContent) {
		for(let i = 0; i <= this._$maxRow; ++i) {
			this._$setSomeToCell(i, colIndex, someName, someValue, isArrt, isContent);
		}
	}

	_$getSomeFromCell(rowIndex, colIndex, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent) {
			let widgetID = this._$data[rowIndex][colIndex];
			if (widgetID !== "") {
				return decomposeObj(this._$meta, joinTextToCompose(widgetID, param));
			} else {
				console.error("You can't get param to clear cell.");
				return undefined;
			}
		}
		else
			return decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, param));
	}

	_$getSomeFromRow(rowIndex, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			return decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "content", param));
		else
			return decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, param));
	}

	_$getSomeFromAll(isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			return decomposeObj(this._$meta, joinTextToCompose("all", "content", param));
		else
			return decomposeObj(this._$meta, joinTextToCompose("all", param));
	}

	_$removeSomeFromCell(rowIndex, colIndex, someName, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent) {
			let widgetID = this._$data[rowIndex][colIndex];
			if (widgetID !== "") {
				if(decomposeObj(this._$meta, joinTextToCompose(widgetID, param, someName))) {
					delete this._$meta[widgetID][param][someName];
				}
			} else {
				console.error("You can't remove.");
			}
		}
		else
			if(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, param, someName))) {
				delete this._$meta["rows"][rowIndex]["cols"][colIndex][param][someName];
			}
	}

	_$removeSomeFromRow(rowIndex, someName, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			if(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "content", param, someName))) {
				delete this._$meta["rows"][rowIndex]["content"][param][someName];
			}
		else
			if(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, param, someName))) {
				delete this._$meta["rows"][rowIndex][param][someName];
			}
	}

	_$removeSomeFromCol(colIndex, someName, isArrt, isContent) {
		for(let i = 0; i <= this._$maxRow; ++i) {
			this._$removeSomeFromCell(i, colIndex, someName, isArrt, isContent);
		}
	}

	_$removeSomeFromAll(someName, isArrt, isContent) {
		let param = isArrt ? "attributes" : "styles";
		if(isContent)
			if(decomposeObj(this._$meta, joinTextToCompose("all", "content", param, someName))) {
				delete this._$meta["all"]["content"][param][someName];
			}
		else
			if(decomposeObj(this._$meta, joinTextToCompose("all", param, someName))) {
				delete this._$meta["all"][param][someName];
			}
	}

	setAttributeToContentCell(rowIndex, colIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToCell(rowIndex, colIndex, attributeName, attributeValue, true, true);
		this.update(TableUpdate.Meta);
	}

	getAttributesFromContentCell(rowIndex, colIndex) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$getSomeFromCell(rowIndex, colIndex, true, true);
	}
	removeAttributeFromContentCell(rowIndex, colIndex, name) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCell(rowIndex, colIndex, name, true, true);
		this.update(TableUpdate.Meta);
	}

	setAttributeToContentRow(rowIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToRow(rowIndex, attributeName, attributeValue, true, true);
		this.update(TableUpdate.Meta);
	}

	getAttributesFromContentRow(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		return this._$getSomeFromRow(rowIndex, true, true);
	}

	removeAttributeFromContentRow(rowIndex, name) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromRow(rowIndex, name, true, true);
		this.update(TableUpdate.Meta);
	}

	setAttributeToContentAll(attributeName, attributeValue) {
		this._$setSomeToAllCells(attributeName, attributeValue, true, true);
		this.update(TableUpdate.Meta);
	}

	getAttributeFromContentAll() {
		return this._$getSomeFromAll(true, true);
	}

	removeAttributeFromContentAll(name) {
		this._$removeSomeFromAll(name, true, true);
		this.update(TableUpdate.Meta);
	}

	setAttributeToContentCol(colIndex, attributeName, attributeValue) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$setSomeToCol(colIndex, attributeName, attributeValue, true, true);
		this.update(TableUpdate.Meta);
	}

	removeAttributeFromContentCol(colIndex, someName) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCol(colIndex, someName, true, true);
		this.update(TableUpdate.Meta);
	}

	setAttributeToCell(rowIndex, colIndex, attributeName, attributeValue) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$setSomeToCell(rowIndex,colIndex, attributeName, attributeValue, true, false);
		this.update(TableUpdate.Meta);
	}

	getAttributesFromCell(rowIndex, colIndex) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$getSomeFromCell(colIndex, rowIndex, true, false);
	}
	removeAttributeFromCell(rowIndex, colIndex, name) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCell(rowIndex, colIndex, name, true, false);
		this.update(TableUpdate.Meta);
	}

	setAttributeToRow(rowIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToRow(rowIndex, attributeName, attributeValue, true, false);
		this.update(TableUpdate.Meta);
	}

	getAttributesFromRow(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		return this._$setSomeToRow(rowIndex, true, false);
	}

	removeAttributeFromRow(rowIndex, name) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromRow(rowIndex, name, true, false);
		this.update(TableUpdate.Meta);
	}

	setAttributeToAllCells(attributeName, attributeValue) {
		this._$setSomeToAllCells(attributeName, attributeValue, true, false);
		this.update(TableUpdate.Meta);
	}

	getAttributesFromAllCells() {
		return this._$getSomeFromAll(true, false);
	}

	removeAttributesFromAllCells(name) {
		this._$removeSomeFromAll(name, true, false);
		this.update(TableUpdate.Meta);
	}

	setAttributeToCol(colIndex, attributeName, attributeValue) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$setSomeToCol(colIndex, attributeName, attributeValue, true, false);
		this.update(TableUpdate.Meta);
	}

	removeAttributeFromCol(colIndex, someName) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCol(colIndex, someName, true, false);
		this.update(TableUpdate.Meta);
	}

	setStyleToContentCell(rowIndex, colIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToCell(rowIndex, colIndex, attributeName, attributeValue, false, true);
		this.update(TableUpdate.Meta);
	}

	getStyleFromContentCell(rowIndex, colIndex) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$getSomeFromCell(rowIndex, colIndex, false, true);
	}
	removeStyleFromContentCell(rowIndex, colIndex, name) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCell(rowIndex, colIndex, name, false, true);
		this.update(TableUpdate.Meta);
	}

	setStyleToContentRow(rowIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToRow(rowIndex, attributeName, attributeValue, false, true);
		this.update(TableUpdate.Meta);
	}

	getStylesFromContentRow(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		return this._$getSomeFromRow(rowIndex, false, true);
	}

	removeStylesFromContentRow(rowIndex, name) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromRow(rowIndex, name, false, true);
		this.update(TableUpdate.Meta);
	}

	setStyleToContentAll(attributeName, attributeValue) {
		this._$setSomeToAllCells(attributeName, attributeValue, false, true);
		this.update(TableUpdate.Meta);
	}

	getStyleFromContentAll() {
		return this._$getSomeFromAll(false, true);
	}

	removeStyleFromContentAll(name) {
		this._$removeSomeFromAll(name, false, true);
		this.update(TableUpdate.Meta);
	}

	setStyleToContentCol(colIndex, attributeName, attributeValue) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$setSomeToCol(colIndex, attributeName, attributeValue, false, true);
		this.update(TableUpdate.Meta);
	}

	removeStyleFromContentCol(colIndex, someName) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCol(colIndex, someName, false, true);
		this.update(TableUpdate.Meta);
	}

	setStyleToCell(rowIndex, colIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToCell(rowIndex, colIndex, attributeName, attributeValue, false, false);
		this.update(TableUpdate.Meta);
	}

	getStylesFromCell(rowIndex, colIndex) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$getSomeFromCell(colIndex, rowIndex, false, false);
	}

	removeStyleFromCell(rowIndex, colIndex, name) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCell(colIndex, rowIndex,name, false, false);
		this.update(TableUpdate.Meta);
	}

	setStyleToRow(rowIndex, attributeName, attributeValue) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$setSomeToRow(rowIndex, attributeName, attributeValue, false, false);
		this.update(TableUpdate.Meta);
	}

	getStylesFromRow(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		return this._$setSomeToRow(rowIndex, false, false);
	}

	removeStyleFromRow(rowIndex, name) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromRow(rowIndex, name, false, false);
		this.update(TableUpdate.Meta);
	}

	setStyleToAllCells(attributeName, attributeValue) {
		this._$setSomeToAllCells(attributeName, attributeValue, false, false);
		this.update(TableUpdate.Meta);
	}

	getStyleFromAllCells() {
		return this._$getSomeFromAll(false, false);
	}

	removeStyleFromAllCells(name) {
		this._$removeSomeFromAll(name, false, false);
		this.update(TableUpdate.Meta);
	}

	setStyleToCol(colIndex, attributeName, attributeValue) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$setSomeToCol(colIndex, attributeName, attributeValue, false, false);
		this.update(TableUpdate.Meta);
	}

	removeStyleFromCol(colIndex, someName) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.log("Invalid parametrs.");
			return;
		}
		this._$removeSomeFromCol(colIndex, someName, false, false);
		this.update(TableUpdate.Meta);
	}

	getNeedResize() {
		return this._$needResize;
	}

	setSort(colIndex) {
		let sort = {};
		composeObj(this._$meta, joinTextToCompose("rows", "0", "cols", colIndex, "sort"),sort);
		this.update(TableUpdate.Meta);
	}

	getSort(colIndex) {
		return decomposeObj(this._$meta, joinTextToCompose("rows", "0", "cols", colIndex, "sort"));
	}

	removeSort(colIndex) {
		if(decomposeObj(this._$meta, joinTextToCompose("rows", "0", "cols", colIndex, "sort"))) {
			delete this._$meta["rows"]["0"]["cols"][colIndex]["sort"];
		}
	}

	setDataJson(data) {
		this.setData(JSON.parse(data, this._$data));
		this.update(TableUpdate.Data);
	}

	setMetaJson(_meta) {
		this.setMeta(JSON.parse(_meta, this._$meta));
		this.update(TableUpdate.Meta);
	}

	addData(rowIndex, colIndex, widgetOrString, colSpan = 1, rowSpan = 1) {
		if(rowIndex < 0 || colIndex < 0 || widgetOrString === undefined || colSpan < 1 || rowSpan < 1) {
			console.error("not valid data");
			return;
		}
		if(rowIndex === 0 && rowSpan > 1 && this._$needHeadRow === true) {
			console.error("can`t collapce head whis rows");
			return;
		}
		if(typeof widgetOrString === "string") {
			let label = new WebWidgetLabel();
			label.setText(widgetOrString);
			widgetOrString = label;
		}
		this.increaseTable(rowIndex, colIndex);
		if(this._$data[rowIndex][colIndex] !== "") {
			this.removeData(rowIndex, colIndex);
			this.increaseTable(rowIndex, colIndex);
		}
		this.increaseTable(rowIndex, colIndex);
		this._$data[rowIndex][colIndex] = widgetOrString.getID();
		this.onIncludeWidget(widgetOrString);
		if(rowSpan === 1 && colSpan === 1) {
			this.update(TableUpdate.Data);
			return;
		}
		if(rowSpan > 1) this.increaseTable(rowIndex + rowSpan -1, colIndex);
		if(colSpan > 1) this.increaseTable(rowIndex, colIndex + colSpan - 1);
		for(let i = 0; i < rowSpan; ++i) {
			for(let j = 0; j < colSpan; ++j) {
				if(!(i === 0 && j === 0)) {
					this.setStyleToCell(rowIndex + i, colIndex + j, "display", "none");
				}
			}
		}
		if(rowSpan > 1) this.setAttributeToCell(rowIndex, colIndex, "rowSpan", JSON.stringify(rowSpan));
		if(colSpan > 1) this.setAttributeToCell(rowIndex, colIndex, "colSpan", JSON.stringify(colSpan));
		this.update(TableUpdate.Data);
	}

	insertRowBefore(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("not valid data.");
			return;
		}
		let newRow = [];
		for(let i = 0; i < this._$maxCol + 1; ++i) {
			newRow.push("");
		}
		this._$data.splice(rowIndex, 0, newRow);
		this._$maxRow++;
	}

	insertColBefore(colIndex) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.error("not valid data.");
			return;
		}
		for(let i = 0; i < this._$maxRow + 1; ++i) {
			this._$data[i].splice(colIndex, 0, 0);
		}
		this._$maxCol++;
	}
	
	removeRow(rowIndex) {
		if(rowIndex < 0 || rowIndex > this._$maxRow) {
			console.error("not valid data.");
			return;
		}
		for(let i = 0; i < this._$data[rowIndex].length; ++i) {
			this.removeData(rowIndex, i);
		}
		this._$removeDataRow(rowIndex);
	}
	
	removeCol(colIndex) {
		if(colIndex < 0 || colIndex > this._$maxCol) {
			console.error("not valid data.");
			return;
		}
		for(let i = 0; i <= this._$maxRow; ++i) {
			this.removeData(i, colIndex);
		}
		this._$removeDataCol(colIndex);
	}
	
	getWidgetByCell(rowIndex, colIndex) {
		if(rowIndex < 0 || colIndex < 0 || rowIndex > this._$maxRow || colIndex > this._$maxCol) {
			console.error("not valid data");
			return undefined;
		}
		let widgetId = this._$data[rowIndex][colIndex];
		if(widgetId === "") return undefined;
		return this.getScene().findObject(widgetId);
	}

	removeData(rowIndex, colIndex) {
		if(this._$data[rowIndex][colIndex] === undefined) {
			console.error("not valid data");
			return;
		}
		if(this._$data[rowIndex][colIndex] !== "") {
			let widget = this.getScene().findObject(this._$data[rowIndex][colIndex]);
			if(widget) this.removeWidget(widget);
		}
		this._$data[rowIndex][colIndex] = "";
		let colSpan = parseInt(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, "attributes", "colSpan")));
		if(isNaN(colSpan)) colSpan = 1;
		let rowSpan = parseInt(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex, "attributes", "rowSpan")));
		if(isNaN(rowSpan)) rowSpan = 1;
		for(let i = rowIndex; i < rowIndex + rowSpan; ++i) {
			for(let j = colIndex; j < colIndex + colSpan; ++j) {
				if(!(i === rowIndex && j === colIndex)) this.setStyleToCell(i, j, "display", "table-cell");
			}
		}
		if(decomposeObj(this._$meta, joinTextToCompose("rows", rowIndex, "cols", colIndex)))
			delete this._$meta["rows"][rowIndex]["cols"][colIndex];
		this.update(TableUpdate.Data);
	}

	getRowIndexByWidgetId(widgetId) {
		for(let i = 0; i <= this._$maxRow; ++i) {
			for(let j = 0; j <= this._$maxCol; ++j) {
				if(this._$data[i][j] == widgetId) {
					return i;
				}
			}
		}
		return -1;
	}

	getColIndexByWidgetId(widgetId) {
		for(let i = 0; i <= this._$maxRow; ++i) {
			for(let j = 0; j <= this._$maxCol; ++j) {
				if(this._$data[i][j] == widgetId) {
					return j;
				}
			}
		}
		return -1;
	}

	removeEmpty() {
		let rows = [];
		let cols = [];
		for(let i = 0; i <= this._$maxRow; ++i) {
			let flag = false;
			for(let j = 0; j <= this._$maxCol; ++j) {
				if(this._$data[i][j] !== "") {
					flag = true;
					break;
				}
			}
			if(flag === false) {
				rows.push(i);
			}
		}
		for(let i = 0; i <= this._$maxCol; ++i) {
			let flag = false;
			for(let j = 0; j <= this._$maxRow; ++j) {
				if(this._$data[j][i] !== "") {
					flag = true;
					break;
				}
			}
			if(flag === false) {
				cols.push(i);
			}
		}
		for(let i = 0; i < rows.length; ++i) {
			this._$removeDataRow(rows[i] - i);
		}
		for(let i = 0; i < cols.length; ++i) {
			this._$removeDataCol(cols[i] - i);
		}
	}

	_$removeDataRow(index) {
		this._$data.splice(index, 1);
		if(decomposeObj(this._$meta, joinTextToCompose("rows", index)))
			delete this._$meta["rows"][index];
		this._$maxRow--;
		this._$recalculateMetaIndices(index, true);
	}
	
	_$recalculateMetaIndices(index, isRow) {
		if(isRow) {
			for(let i = index + 1; i <= this._$maxRow + 1; ++i) {
				composeObj(this._$meta, joinTextToCompose("rows",i - 1),decomposeObj(this._$meta, joinTextToCompose("rows", i)));
			}
		} else {
			for(let i = 0; i < this._$maxRow - 1; ++i) {
				for(let j = index + 1; j <= this._$maxCol + 1; ++j) {
					composeObj(this._$meta, joinTextToCompose("rows",i, "cols", j - 1),decomposeObj(this._$meta, joinTextToCompose("rows",i, "cols", j)));
				}
			}
		}
	}

	_$removeDataCol(index) {
		for(let i = 0; i <= this._$maxRow; ++i) {
			this._$data[i].splice(index, 1);
		}
		this._$maxCol--;
		this._$recalculateMetaIndices(index, false);
	}

	increaseTable(rowIndex, colIndex) {
		if(rowIndex > this._$maxRow) {
			this.resize(this._$data, rowIndex + 1, false);
			for(let i = this._$maxRow + 1; i < rowIndex + 1; ++i) {
				this.resize(this._$data[i], this._$maxCol + 1, true);
			}
			this._$maxRow = rowIndex;
		}
		if(colIndex > this._$maxCol) {
			for(let i = 0; i < this._$maxRow + 1; ++i) {
				this.resize(this._$data[i], colIndex + 1, true);
			}
			this._$maxCol = colIndex;
		}
	}

	resize(arr, newSize, defaultFlag) {
		while(newSize > arr.length)
			arr.push(defaultFlag ? '' : []);
		arr.length = newSize;
	}

	clearData() {
		let count = this._$maxRow + 1;
		for(let i = 0; i < count; ++i) {
			this.removeRow(0);
		}
		this._$meta = {};
	}

	getNeedHeadRow() {
		return this._$needHeadRow;
	}

	setNeedHeadRow(value) {
		this._$needHeadRow = value;
		this.update(TableUpdate.NeedHeadRow);
	}

	getNeedBorder() {
		return this._$needBorder;
	}

	setNeedBorder(value) {
		this._$needBorder = value;
		this.update(TableUpdate.NeedBorder)
	}

	getFixHeadRow() {
		return this._$needHeadRow;
	}

	setFixHeadRow(value) {
		this._$fixHeadRow = value;
		this.update(TableUpdate.FixHeadRow);
	}

	setMinHeightCels(value) {
		for(let i = 0; i < this.getChildren().length; ++i) {
			this.getChild(i).setMinHeight(value);
		}
	}

	getMeta() {
		return this._$meta
	}

	setMeta(value) {
		this._$meta = value;
		this.update(TableUpdate.Meta);
	}

	getNeedRowsNumber() {
	return this._$needRowsNumber;
}

	setNeedRowsNumber(value) {
	this._$needRowsNumber = value;
	this.update(TableUpdate.NeedRowsNumber);
	}
	
	swapCells(rowIndexFrom, colIndexFrom, rowIndexTo, colIndexTo, needSaveStyle = true) {
		if(rowIndexFrom < 0 || colIndexFrom < 0 || rowIndexTo < 0 || colIndexTo < 0 ||
			rowIndexFrom > this._$maxRow || colIndexFrom > this._$maxCol || rowIndexTo > this._$maxRow || colIndexTo > this._$maxCol) return;
		let value1 = this._$data[rowIndexFrom][colIndexFrom];
		this._$data[rowIndexFrom][colIndexFrom] = this._$data[rowIndexTo][colIndexTo];
		this._$data[rowIndexTo][colIndexTo] = value1;
		if(needSaveStyle) {
			let meta1 = decomposeObj(this._$meta, joinTextToCompose("rows", rowIndexFrom, "cols", colIndexFrom));
			let meta2 = decomposeObj(this._$meta, joinTextToCompose("rows", rowIndexTo, "cols", colIndexTo));
			composeObj(this._$meta,joinTextToCompose("rows", rowIndexFrom, "cols", colIndexFrom), meta2);
			composeObj(this._$meta,joinTextToCompose("rows", rowIndexTo, "cols", colIndexTo), meta1);
			this.update(TableUpdate.Meta);
		}
		this.update(TableUpdate.Data);
	}
	
	swapRows(rowIndexFrom, rowIndexTo, needSaveStyle = true) {
		if(rowIndexFrom < 0 || rowIndexTo < 0 || rowIndexFrom > this._$maxRow || rowIndexTo > this._$maxRow) return;
		let value1 = this._$data[rowIndexFrom];
		this._$data[rowIndexFrom] = this._$data[rowIndexTo];
		this._$data[rowIndexTo] = value1;
		if(needSaveStyle) {
			let meta1 = decomposeObj(this._$meta, joinTextToCompose("rows", rowIndexFrom));
			let meta2 = decomposeObj(this._$meta, joinTextToCompose("rows", rowIndexTo));
			composeObj(this._$meta,joinTextToCompose("rows", rowIndexFrom), meta2);
			composeObj(this._$meta,joinTextToCompose("rows", rowIndexTo), meta1);
			this.update(TableUpdate.Meta);
		}
		this.update(TableUpdate.Data);
	}
	
	swapCols(colIndexFrom, colIndexTo, needSaveStyle = true) {
		if(colIndexFrom < 0 || colIndexTo < 0 || colIndexFrom > this._$maxCol || colIndexTo > this._$maxCol) return;
		for(let i = 0; i < this._$maxRow + 1; ++i) {
			let value1 = this._$data[i][colIndexFrom];
			this._$data[i][colIndexFrom] = this._$data[i][colIndexTo];
			this._$data[i][colIndexTo] = value1;
			if(needSaveStyle) {
				let meta1 = decomposeObj(this._$meta, joinTextToCompose("rows", i, "cols", colIndexFrom));
				let meta2 = decomposeObj(this._$meta, joinTextToCompose("rows", i, "cols", colIndexTo));
				composeObj(this._$meta,joinTextToCompose("rows", i, "cols", colIndexFrom), meta2);
				composeObj(this._$meta,joinTextToCompose("rows", i, "cols", colIndexTo), meta1);
				this.update(TableUpdate.Meta);
			}
		}
		this.update(TableUpdate.Data);
}

	setOrderRow(index, value){
		if(index < 0 || index > this._$maxRow) return;
		composeObj(this._$meta,joinTextToCompose("rows", index, "order"), value);
		this.update(TableUpdate.meta);
	}
	
	getOrderRow(index){
		if(index < 0 || index > this._$maxRow) return;
		return decomposeObj(this._$meta, joinTextToCompose("rows", index, "order"));
	}
	
	setOrderCol(index, value) {
		if(index < 0 || index > this._$maxCol) return;
		for(let i = 0; i < this._$maxRow + 1; ++i) {
			composeObj(this._$meta,joinTextToCompose("rows", i, "cols", index, "order"), value);
		}
		this.update(TableUpdate.meta);
	}
	getOrderCol(index) {
		if(index < 0 || index > this._$maxCol) return;
		return decomposeObj(this._$meta, joinTextToCompose("rows", 0, "cols", index, "order"));
	}

	getTypeName() {
		return "WidgetTable";
	}
}

(function (window, document, undefined) {
var L = {
	version: "1.0.3+ed36a04"
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}



/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;




// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};



/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = L.Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};



/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		// This does not necessarily mean that the browser is running in a computer with
		// a touchscreen, it only means that the browser is capable of understanding
		// touch events.
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());



/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};



/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};



/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};



/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();



/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};



/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 */

L.LatLngBounds = function (corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng || 'lat' in obj) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};



/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};



/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};



/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	// Only accepts actual `L.LatLng` instances, not arrays.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = L.latLng({lat: sw.lat - latShift, lng: sw.lng - lngShift}),
		    newNe = L.latLng({lat: ne.lat - latShift, lng: ne.lng - lngShift});

		return new L.LatLngBounds(newSw, newNe);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});



/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});



/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = L.bounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(L.latLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		this._containerId = L.Util.stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		//BLAD' ПОМЕНЯЛ
		// console.log(L.DomUtil);
		// L.DomUtil.getStyle(container)
		// debugger;
		// L.DomUtil.style.backgroundColor = "rgb(1,0,0)";

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return L.bounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};




/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: [],  // Array of events that should not be bubbled to DOM parents (like the map),

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});



/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener &&
		           !(L.Browser.pointer && L.Browser.chrome)) {
			// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
			// See #5180
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;



/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});



/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});



/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z),
		    bounds = new L.LatLngBounds(nw, se);

		if (!this.options.noWrap) {
			map.wrapLatLngBounds(bounds);
		}

		return bounds;
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};



/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option minNativeZoom: Number = null
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.src !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		tileSize = L.GridLayer.prototype.getTileSize.call(this),
		zoom = this._tileZoom + this.options.zoomOffset,
		minNativeZoom = this.options.minNativeZoom,
		maxNativeZoom = this.options.maxNativeZoom;

		// decrease tile size when scaling below minNativeZoom
		if (minNativeZoom !== null && zoom < minNativeZoom) {
			return tileSize.divideBy(map.getZoomScale(minNativeZoom, zoom)).round();
		}

		// increase tile size when scaling above maxNativeZoom
		if (maxNativeZoom !== null && zoom > maxNativeZoom) {
			return tileSize.divideBy(map.getZoomScale(maxNativeZoom, zoom)).round();
		}

		return tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset,
		minNativeZoom = this.options.minNativeZoom,
		maxNativeZoom = this.options.maxNativeZoom;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		zoom += zoomOffset;

		if (minNativeZoom !== null && zoom < minNativeZoom) {
			return minNativeZoom;
		}

		if (maxNativeZoom !== null && zoom > maxNativeZoom) {
			return maxNativeZoom;
		}

		return zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};



/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};



/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Get the img element that represents the ImageOverlay on the map
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};



/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};



/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!L.Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
			L.Icon.Default.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `L.Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = L.DomUtil.create('div',  'leaflet-default-icon-path', document.body);
		var path = L.DomUtil.getStyle(el, 'background-image') ||
		           L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);
		
		var tmp = path.replace(/^url\([\"\']?/, '');
		
		tmp = tmp.replace(/marker-icon\.png[\"\']?\)$/, '') ;
		
		
		return path.indexOf('url') === 0 ?
			path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
	}
});



/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};



/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};



/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});



/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof L.Path)) {
				this._source.on('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof L.Path)) {
				this._source.off('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(L.DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}
		
		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});



/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if (L.Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(L.point(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});



/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};



/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};



/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
		this.off('update', this._updatePaths, this);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});



/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});



/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};



/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};



/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};



/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};



/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};



/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};



/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};



/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[L.stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http:/' + '/www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};



/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[L.stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}



/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({
	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		L.Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			L.DomEvent._fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// signle entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// signle entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};



/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;



/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (L.Draggable._dragging === this) {
			this.finishDrag();
		}

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		L.Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}

});



/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});



/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);



/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);



/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);



/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				if ((!L.Browser.edge) || e.pointerType === 'mouse') { return; }
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					if ((!L.Browser.edge) || e.pointerType === 'mouse') { return; }

					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
		obj.addEventListener('dblclick', handler, false);

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});



/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});



/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);



/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}



/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);



/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);



/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});



/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});



/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http:/' + '/leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};



/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};



/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (L.Browser.touch) {
			L.DomEvent
			    .on(link, 'click', L.DomEvent.stop)
			    .on(link, 'click', this.expand, this);
		} else {
			L.DomEvent.on(link, 'focus', this.expand, this);
		}

		// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
		L.DomEvent.on(form, 'click', function () {
			setTimeout(L.bind(this._onInputClick, this), 0);
		}, this);

		// TODO keyboard accessibility

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(L.bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};



}(window, document));


/*
 * Leaflet.TextPath - Shows text along a polyline
 * Inspired by Tom Mac Wright article :
 * http://mapbox.com/osmdev/2012/11/20/getting-serious-about-svg/
 */

(function () {

var __onAdd = L.Polyline.prototype.onAdd,
    __onRemove = L.Polyline.prototype.onRemove,
    __updatePath = L.Polyline.prototype._updatePath,
    __bringToFront = L.Polyline.prototype.bringToFront;


var PolylineTextPath = {

    onAdd: function (map) {
        __onAdd.call(this, map);
        this._textRedraw();
    },

    onRemove: function (map) {
        map = map || this._map;
        if (map && this._textNode && map._renderer._container)
            map._renderer._container.removeChild(this._textNode);
        __onRemove.call(this, map);
    },

    bringToFront: function () {
        __bringToFront.call(this);
        this._textRedraw();
    },

    _updatePath: function () {
        __updatePath.call(this);
        this._textRedraw();
    },

    _textRedraw: function () {
        var text = this._text,
            options = this._textOptions;
        if (text) {
            this.setText(null).setText(text, options);
        }
    },

    setText: function (text, options) {
        this._text = text;
        this._textOptions = options;

        /* If not in SVG mode or Polyline not added to map yet return */
        /* setText will be called by onAdd, using value stored in this._text */
        if (!L.Browser.svg || typeof this._map === 'undefined') {
          return this;
        }

        var defaults = {
            repeat: false,
            fillColor: 'black',
            attributes: {},
            below: false,
        };
        options = L.Util.extend(defaults, options);

        /* If empty text, hide */
        if (!text) {
            if (this._textNode && this._textNode.parentNode) {
                this._map._renderer._container.removeChild(this._textNode);
                
                /* delete the node, so it will not be removed a 2nd time if the layer is later removed from the map */
                delete this._textNode;
            }
            return this;
        }

        text = text.replace(/ /g, '\u00A0');  // Non breakable spaces
        var id = 'pathdef-' + L.Util.stamp(this);
        var svg = this._map._renderer._container;
        this._path.setAttribute('id', id);

        if (options.repeat) {
            /* Compute single pattern length */
            var pattern = L.SVG.create('text');
            for (var attr in options.attributes)
                pattern.setAttribute(attr, options.attributes[attr]);
            pattern.appendChild(document.createTextNode(text));
            svg.appendChild(pattern);
            var alength = pattern.getComputedTextLength();
            svg.removeChild(pattern);

            /* Create string as long as path */
            text = new Array(Math.ceil(this._path.getTotalLength() / alength)).join(text);
        }

        /* Put it along the path using textPath */
        var textNode = L.SVG.create('text'),
            textPath = L.SVG.create('textPath');

        var dy = options.offset || this._path.getAttribute('stroke-width');

		let namespaceURL = decodeURIComponent(escape(window.atob("aHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaw==")));
        textPath.setAttributeNS(namespaceURL, "xlink:href", '#'+id);
        textNode.setAttribute('dy', dy);
        for (var attr in options.attributes)
            textNode.setAttribute(attr, options.attributes[attr]);
        textPath.appendChild(document.createTextNode(text));
        textNode.appendChild(textPath);
        this._textNode = textNode;

        if (options.below) {
            svg.insertBefore(textNode, svg.firstChild);
        }
        else {
            svg.appendChild(textNode);
        }

        /* Center text according to the path's bounding box */
        if (options.center) {
            var textLength = textNode.getComputedTextLength();
            var pathLength = this._path.getTotalLength();
            /* Set the position for the left side of the textNode */
            textNode.setAttribute('dx', ((pathLength / 2) - (textLength / 2)));
        }

        /* Change label rotation (if required) */
        if (options.orientation) {
            var rotateAngle = 0;
            switch (options.orientation) {
                case 'flip':
                    rotateAngle = 180;
                    break;
                case 'perpendicular':
                    rotateAngle = 90;
                    break;
                default:
                    rotateAngle = options.orientation;
            }

            var rotatecenterX = (textNode.getBBox().x + textNode.getBBox().width / 2);
            var rotatecenterY = (textNode.getBBox().y + textNode.getBBox().height / 2);
            textNode.setAttribute('transform','rotate(' + rotateAngle + ' '  + rotatecenterX + ' ' + rotatecenterY + ')');
        }

        /* Initialize mouse events for the additional nodes */
        if (this.options.clickable) {
            if (L.Browser.svg || !L.Browser.vml) {
                textPath.setAttribute('class', 'leaflet-clickable');
            }

            L.DomEvent.on(textNode, 'click', this._onMouseClick, this);

            var events = ['dblclick', 'mousedown', 'mouseover',
                          'mouseout', 'mousemove', 'contextmenu'];
            for (var i = 0; i < events.length; i++) {
                L.DomEvent.on(textNode, events[i], this._fireMouseEvent, this);
            }
        }

        return this;
    }
};

L.Polyline.include(PolylineTextPath);

L.LayerGroup.include({
    setText: function(text, options) {
        for (var layer in this._layers) {
            if (typeof this._layers[layer].setText === 'function') {
                this._layers[layer].setText(text, options);
            }
        }
        return this;
    }
});



})();


//Google maps API
	var script = document.createElement('script');
	script.src = "https://maps.googleapis.com/maps/api/js";
	document.head.appendChild(script);

// Based on https://github.com/shramov/leaflet-plugins
// GridLayer like https://avinmathew.com/leaflet-and-google-maps/ , but using MutationObserver instead of jQuery


// 🍂class GridLayer.GoogleMutant
// 🍂extends GridLayer
L.GridLayer.GoogleMutant = L.GridLayer.extend({
	options: {
		minZoom: 0,
		maxZoom: 23,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',	// The mutant container will add its own attribution anyways.
		opacity: 1,
		continuousWorld: false,
		noWrap: false,
		// 🍂option type: String = 'roadmap'
		// Google's map type. Valid values are 'roadmap', 'satellite' or 'terrain'. 'hybrid' is not really supported.
		type: 'roadmap',
		maxNativeZoom: 21
	},

	initialize: function (options) {
		L.GridLayer.prototype.initialize.call(this, options);

		this._ready = !!window.google && !!window.google.maps && !!window.google.maps.Map;

		this._GAPIPromise = this._ready ? Promise.resolve(window.google) : new Promise(function (resolve, reject) {
			var checkCounter = 0;
			var intervalId = null;
			intervalId = setInterval(function () {
				if (checkCounter >= 10) {
					clearInterval(intervalId);
					return reject(new Error('window.google not found after 10 attempts'));
				}
				if (!!window.google && !!window.google.maps && !!window.google.maps.Map) {
					clearInterval(intervalId);
					return resolve(window.google);
				}
				checkCounter++;
			}, 500);
		});

		// Couple data structures indexed by tile key
		this._tileCallbacks = {};	// Callbacks for promises for tiles that are expected
		this._freshTiles = {};	// Tiles from the mutant which haven't been requested yet

		this._imagesPerTile = (this.options.type === 'hybrid') ? 2 : 1;
	},

	onAdd: function (map) {
		L.GridLayer.prototype.onAdd.call(this, map);
		this._initMutantContainer();

		this._GAPIPromise.then(function () {
			this._ready = true;
			this._map = map;

			this._initMutant();

			map.on('viewreset', this._reset, this);
			map.on('move', this._update, this);
			map.on('zoomend', this._handleZoomAnim, this);
			map.on('resize', this._resize, this);

			//handle layer being added to a map for which there are no Google tiles at the given zoom
			google.maps.event.addListenerOnce(this._mutant, 'idle', function () {
				this._checkZoomLevels();
				this._mutantIsReady = true;
			}.bind(this));

			//20px instead of 1em to avoid a slight overlap with google's attribution
			map._controlCorners.bottomright.style.marginBottom = '20px';
			map._controlCorners.bottomleft.style.marginBottom = '20px';

			this._reset();
			this._update();

			if (this._subLayers) {
				//restore previously added google layers
				for (var layerName in this._subLayers) {
					this._subLayers[layerName].setMap(this._mutant);
				}
			}
		}.bind(this));
	},

	onRemove: function (map) {
		L.GridLayer.prototype.onRemove.call(this, map);
		map._container.removeChild(this._mutantContainer);
		this._mutantContainer = undefined;

		google.maps.event.clearListeners(map, 'idle');
		google.maps.event.clearListeners(this._mutant, 'idle');
		map.off('viewreset', this._reset, this);
		map.off('move', this._update, this);
		map.off('zoomend', this._handleZoomAnim, this);
		map.off('resize', this._resize, this);

		if (map._controlCorners) {
			map._controlCorners.bottomright.style.marginBottom = '0em';
			map._controlCorners.bottomleft.style.marginBottom = '0em';
		}
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (opacity < 1) {
			L.DomUtil.setOpacity(this._mutantContainer, opacity);
		}
	},

	setElementSize: function (e, size) {
		e.style.width = size.x + 'px';
		e.style.height = size.y + 'px';
	},


	addGoogleLayer: function (googleLayerName, options) {
		if (!this._subLayers) this._subLayers = {};
		return this._GAPIPromise.then(function () {
			var Constructor = google.maps[googleLayerName];
			var googleLayer = new Constructor(options);
			googleLayer.setMap(this._mutant);
			this._subLayers[googleLayerName] = googleLayer;
			return googleLayer;
		}.bind(this));
	},

	removeGoogleLayer: function (googleLayerName) {
		var googleLayer = this._subLayers && this._subLayers[googleLayerName];
		if (!googleLayer) return;

		googleLayer.setMap(null);
		delete this._subLayers[googleLayerName];
	},


	_initMutantContainer: function () {
		if (!this._mutantContainer) {
			this._mutantContainer = L.DomUtil.create('div', 'leaflet-google-mutant leaflet-top leaflet-left');
			this._mutantContainer.id = '_MutantContainer_' + L.Util.stamp(this._mutantContainer);
			this._mutantContainer.style.zIndex = '800'; //leaflet map pane at 400, controls at 1000
			this._mutantContainer.style.pointerEvents = 'none';

			this._map.getContainer().appendChild(this._mutantContainer);
		}

		this.setOpacity(this.options.opacity);
		this.setElementSize(this._mutantContainer, this._map.getSize());

		this._attachObserver(this._mutantContainer);
	},

	_initMutant: function () {
		if (!this._ready || !this._mutantContainer) return;
		this._mutantCenter = new google.maps.LatLng(0, 0);

		var map = new google.maps.Map(this._mutantContainer, {
			center: this._mutantCenter,
			zoom: 0,
			tilt: 0,
			mapTypeId: this.options.type,
			disableDefaultUI: true,
			keyboardShortcuts: false,
			draggable: false,
			disableDoubleClickZoom: true,
			scrollwheel: false,
			streetViewControl: false,
			styles: this.options.styles || {},
			backgroundColor: 'transparent'
		});

		this._mutant = map;

		google.maps.event.addListenerOnce(map, 'idle', function () {
			var nodes = this._mutantContainer.querySelectorAll('a');
			for (var i = 0; i < nodes.length; i++) {
				nodes[i].style.pointerEvents = 'auto';
			}
		}.bind(this));

		// 🍂event spawned
		// Fired when the mutant has been created.
		this.fire('spawned', {mapObject: map});
	},

	_attachObserver: function _attachObserver (node) {
// 		console.log('Gonna observe', node);

		var observer = new MutationObserver(this._onMutations.bind(this));

		// pass in the target node, as well as the observer options
		observer.observe(node, { childList: true, subtree: true });
	},

	_onMutations: function _onMutations (mutations) {
		for (var i = 0; i < mutations.length; ++i) {
			var mutation = mutations[i];
			for (var j = 0; j < mutation.addedNodes.length; ++j) {
				var node = mutation.addedNodes[j];

				if (node instanceof HTMLImageElement) {
					this._onMutatedImage(node);
				} else if (node instanceof HTMLElement) {
					Array.prototype.forEach.call(node.querySelectorAll('img'), this._onMutatedImage.bind(this));
				}
			}
		}
	},

	// Only images which 'src' attrib match this will be considered for moving around.
	// Looks like some kind of string-based protobuf, maybe??
	// Only the roads (and terrain, and vector-based stuff) match this pattern
	_roadRegexp: /!1i(\d+)!2i(\d+)!3i(\d+)!/,

	// On the other hand, raster imagery matches this other pattern
	_satRegexp: /x=(\d+)&y=(\d+)&z=(\d+)/,

	// On small viewports, when zooming in/out, a static image is requested
	// This will not be moved around, just removed from the DOM.
	_staticRegExp: /StaticMapService\.GetMapImage/,

	_onMutatedImage: function _onMutatedImage (imgNode) {
// 		if (imgNode.src) {
// 			console.log('caught mutated image: ', imgNode.src);
// 		}

		var coords;
		var match = imgNode.src.match(this._roadRegexp);
		var sublayer = 0;

		if (match) {
			coords = {
				z: match[1],
				x: match[2],
				y: match[3]
			};
			if (this._imagesPerTile > 1) { 
				imgNode.style.zIndex = 1;
				sublayer = 1;
			}
		} else {
			match = imgNode.src.match(this._satRegexp);
			if (match) {
				coords = {
					x: match[1],
					y: match[2],
					z: match[3]
				};
			}
// 			imgNode.style.zIndex = 0;
			sublayer = 0;
		}

		if (coords) {
			var tileKey = this._tileCoordsToKey(coords);
			imgNode.style.position = 'absolute';
			imgNode.style.visibility = 'hidden';

			var key = tileKey + '/' + sublayer;
			// console.log('mutation for tile', key)
			//store img so it can also be used in subsequent tile requests
			this._freshTiles[key] = imgNode;

			if (key in this._tileCallbacks && this._tileCallbacks[key]) {
// console.log('Fullfilling callback ', key);
				//fullfill most recent tileCallback because there maybe callbacks that will never get a 
				//corresponding mutation (because map moved to quickly...)
				this._tileCallbacks[key].pop()(imgNode); 
				if (!this._tileCallbacks[key].length) { delete this._tileCallbacks[key]; }
			} else {
				if (this._tiles[tileKey]) {
					//we already have a tile in this position (mutation is probably a google layer being added)
					//replace it
					var c = this._tiles[tileKey].el;
					var oldImg = (sublayer === 0) ? c.firstChild : c.firstChild.nextSibling;
					var cloneImgNode = this._clone(imgNode);
					c.replaceChild(cloneImgNode, oldImg);
				}
			}
		} else if (imgNode.src.match(this._staticRegExp)) {
			imgNode.style.visibility = 'hidden';
		}
	},


	createTile: function (coords, done) {
		var key = this._tileCoordsToKey(coords);

		var tileContainer = L.DomUtil.create('div');
		tileContainer.dataset.pending = this._imagesPerTile;
		done = done.bind(this, null, tileContainer);

		for (var i = 0; i < this._imagesPerTile; i++) {
			var key2 = key + '/' + i;
			if (key2 in this._freshTiles) {
				var imgNode = this._freshTiles[key2];
				tileContainer.appendChild(this._clone(imgNode));
				tileContainer.dataset.pending--;
// 				console.log('Got ', key2, ' from _freshTiles');
			} else {
				this._tileCallbacks[key2] = this._tileCallbacks[key2] || [];
				this._tileCallbacks[key2].push( (function (c/*, k2*/) {
					return function (imgNode) {
						c.appendChild(this._clone(imgNode));
						c.dataset.pending--;
						if (!parseInt(c.dataset.pending)) { done(); }
// 						console.log('Sent ', k2, ' to _tileCallbacks, still ', c.dataset.pending, ' images to go');
					}.bind(this);
				}.bind(this))(tileContainer/*, key2*/) );
			}
		}

		if (!parseInt(tileContainer.dataset.pending)) {
			L.Util.requestAnimFrame(done);
		}
		return tileContainer;
	},

	_clone: function (imgNode) {
		var clonedImgNode = imgNode.cloneNode(true);
		clonedImgNode.style.visibility = 'visible';
		return clonedImgNode;
	},

	_checkZoomLevels: function () {
		//setting the zoom level on the Google map may result in a different zoom level than the one requested
		//(it won't go beyond the level for which they have data).
		var zoomLevel = this._map.getZoom();
		var gMapZoomLevel = this._mutant.getZoom();
		if (!zoomLevel || !gMapZoomLevel) return;


		if ((gMapZoomLevel !== zoomLevel) || //zoom levels are out of sync, Google doesn't have data
			(gMapZoomLevel > this.options.maxNativeZoom)) { //at current location, Google does have data (contrary to maxNativeZoom)
			//Update maxNativeZoom
			this._setMaxNativeZoom(gMapZoomLevel);
		}
	},

	_setMaxNativeZoom: function (zoomLevel) {
		if (zoomLevel != this.options.maxNativeZoom) {
			this.options.maxNativeZoom = zoomLevel;
			this._resetView();
		}
	},

	_reset: function () {
		this._initContainer();
	},

	_update: function () {
		// zoom level check needs to happen before super's implementation (tile addition/creation)
		// otherwise tiles may be missed if maxNativeZoom is not yet correctly determined
		if (this._mutant) {
			var center = this._map.getCenter();
			var _center = new google.maps.LatLng(center.lat, center.lng);

			this._mutant.setCenter(_center);
			var zoom = this._map.getZoom();
			var fractionalLevel = zoom !== Math.round(zoom);
			var mutantZoom = this._mutant.getZoom();

			//ignore fractional zoom levels
			if (!fractionalLevel && (zoom != mutantZoom)) {
				this._mutant.setZoom(zoom);
							
				if (this._mutantIsReady) this._checkZoomLevels();
				//else zoom level check will be done later by 'idle' handler
			}
		}

		L.GridLayer.prototype._update.call(this);
	},

	_resize: function () {
		var size = this._map.getSize();
		if (this._mutantContainer.style.width === size.x &&
			this._mutantContainer.style.height === size.y)
			return;
		this.setElementSize(this._mutantContainer, size);
		if (!this._mutant) return;
		google.maps.event.trigger(this._mutant, 'resize');
	},

	_handleZoomAnim: function () {
		if (!this._mutant) return;
		var center = this._map.getCenter();
		var _center = new google.maps.LatLng(center.lat, center.lng);

		this._mutant.setCenter(_center);
		this._mutant.setZoom(Math.round(this._map.getZoom()));
	},

	// Agressively prune _freshtiles when a tile with the same key is removed,
	// this prevents a problem where Leaflet keeps a loaded tile longer than
	// GMaps, so that GMaps makes two requests but Leaflet only consumes one,
	// polluting _freshTiles with stale data.
	_removeTile: function (key) {
		if (!this._mutant) return;

		//give time for animations to finish before checking it tile should be pruned
		setTimeout(this._pruneTile.bind(this, key), 1000);


		return L.GridLayer.prototype._removeTile.call(this, key);
	},

	_pruneTile: function (key) {
		var gZoom = this._mutant.getZoom();
		var tileZoom = key.split(':')[2];
		var googleBounds = this._mutant.getBounds();
		var sw = googleBounds.getSouthWest();
		var ne = googleBounds.getNorthEast();
		var gMapBounds = L.latLngBounds([[sw.lat(), sw.lng()], [ne.lat(), ne.lng()]]);

		for (var i=0; i<this._imagesPerTile; i++) {
			var key2 = key + '/' + i;
			if (key2 in this._freshTiles) { 
				var tileBounds = this._map && this._keyToBounds(key);
				var stillVisible = this._map && tileBounds.overlaps(gMapBounds) && (tileZoom == gZoom);

				if (!stillVisible) delete this._freshTiles[key2]; 
//				console.log('Prunning of ', key, (!stillVisible))
			}
		}
	}
});


// 🍂factory gridLayer.googleMutant(options)
// Returns a new `GridLayer.GoogleMutant` given its options
L.gridLayer.googleMutant = function (options) {
	return new L.GridLayer.GoogleMutant(options);
};

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('leaflet')) :
	typeof define === 'function' && define.amd ? define(['leaflet'], factory) :
	(factory(global.L));
}(this, (function (L$1) { 'use strict';

L$1 = L$1 && L$1.hasOwnProperty('default') ? L$1['default'] : L$1;

// functional re-impl of L.Point.distanceTo,
// with no dependency on Leaflet for easier testing
function pointDistance(ptA, ptB) {
    var x = ptB.x - ptA.x;
    var y = ptB.y - ptA.y;
    return Math.sqrt(x * x + y * y);
}

var computeSegmentHeading = function computeSegmentHeading(a, b) {
    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;
};

var asRatioToPathLength = function asRatioToPathLength(_ref, totalPathLength) {
    var value = _ref.value,
        isInPixels = _ref.isInPixels;
    return isInPixels ? value / totalPathLength : value;
};

function parseRelativeOrAbsoluteValue(value) {
    if (typeof value === 'string' && value.indexOf('%') !== -1) {
        return {
            value: parseFloat(value) / 100,
            isInPixels: false
        };
    }
    var parsedValue = value ? parseFloat(value) : 0;
    return {
        value: parsedValue,
        isInPixels: parsedValue > 0
    };
}

var pointsEqual = function pointsEqual(a, b) {
    return a.x === b.x && a.y === b.y;
};

function pointsToSegments(pts) {
    return pts.reduce(function (segments, b, idx, points) {
        // this test skips same adjacent points
        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {
            var a = points[idx - 1];
            var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;
            var distAB = pointDistance(a, b);
            segments.push({
                a: a,
                b: b,
                distA: distA,
                distB: distA + distAB,
                heading: computeSegmentHeading(a, b)
            });
        }
        return segments;
    }, []);
}

function projectPatternOnPointPath(pts, pattern) {
    // 1. split the path into segment infos
    var segments = pointsToSegments(pts);
    var nbSegments = segments.length;
    if (nbSegments === 0) {
        return [];
    }

    var totalPathLength = segments[nbSegments - 1].distB;

    var offset = asRatioToPathLength(pattern.offset, totalPathLength);
    var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);
    var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);

    var repeatIntervalPixels = totalPathLength * repeat;
    var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;
    var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;

    // 2. generate the positions of the pattern as offsets from the path start
    var positionOffsets = [];
    var positionOffset = startOffsetPixels;
    do {
        positionOffsets.push(positionOffset);
        positionOffset += repeatIntervalPixels;
    } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);

    // 3. projects offsets to segments
    var segmentIndex = 0;
    var segment = segments[0];
    return positionOffsets.map(function (positionOffset) {
        // find the segment matching the offset,
        // starting from the previous one as offsets are ordered
        while (positionOffset > segment.distB && segmentIndex < nbSegments - 1) {
            segmentIndex++;
            segment = segments[segmentIndex];
        }

        var segmentRatio = (positionOffset - segment.distA) / (segment.distB - segment.distA);
        return {
            pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),
            heading: segment.heading
        };
    });
}

/**
* Finds the point which lies on the segment defined by points A and B,
* at the given ratio of the distance from A to B, by linear interpolation.
*/
function interpolateBetweenPoints(ptA, ptB, ratio) {
    if (ptB.x !== ptA.x) {
        return {
            x: ptA.x + ratio * (ptB.x - ptA.x),
            y: ptA.y + ratio * (ptB.y - ptA.y)
        };
    }
    // special case where points lie on the same vertical axis
    return {
        x: ptA.x,
        y: ptA.y + (ptB.y - ptA.y) * ratio
    };
}

(function() {
    // save these original methods before they are overwritten
    var proto_initIcon = L.Marker.prototype._initIcon;
    var proto_setPos = L.Marker.prototype._setPos;

    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');

    L.Marker.addInitHook(function () {
        var iconOptions = this.options.icon && this.options.icon.options;
        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
        if (iconAnchor) {
            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');
        }
        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom' ;
        this.options.rotationAngle = this.options.rotationAngle || 0;

        // Ensure marker keeps rotated during dragging
        this.on('drag', function(e) { e.target._applyRotation(); });
    });

    L.Marker.include({
        _initIcon: function() {
            proto_initIcon.call(this);
        },

        _setPos: function (pos) {
            proto_setPos.call(this, pos);
            this._applyRotation();
        },

        _applyRotation: function () {
            if(this.options.rotationAngle) {
                this._icon.style[L.DomUtil.TRANSFORM+'Origin'] = this.options.rotationOrigin;

                if(oldIE) {
                    // for IE 9, use the 2D rotation
                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';
                } else {
                    // for modern browsers, prefer the 3D accelerated version
                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';
                }
            }
        },

        setRotationAngle: function(angle) {
            this.options.rotationAngle = angle;
            this.update();
            return this;
        },

        setRotationOrigin: function(origin) {
            this.options.rotationOrigin = origin;
            this.update();
            return this;
        }
    });
})();

// enable rotationAngle and rotationOrigin support on L.Marker
/**
* Defines several classes of symbol factories,
* to be used with L.PolylineDecorator
*/

L$1.Symbol = L$1.Symbol || {};

/**
* A simple dash symbol, drawn as a Polyline.
* Can also be used for dots, if 'pixelSize' option is given the 0 value.
*/
L$1.Symbol.Dash = L$1.Class.extend({
    options: {
        pixelSize: 10,
        pathOptions: {}
    },

    initialize: function initialize(options) {
        L$1.Util.setOptions(this, options);
        this.options.pathOptions.clickable = false;
    },

    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
        var opts = this.options;
        var d2r = Math.PI / 180;

        // for a dot, nothing more to compute
        if (opts.pixelSize <= 1) {
            return L$1.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);
        }

        var midPoint = map.project(dirPoint.latLng);
        var angle = -(dirPoint.heading - 90) * d2r;
        var a = L$1.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);
        // compute second point by central symmetry to avoid unecessary cos/sin
        var b = midPoint.add(midPoint.subtract(a));
        return L$1.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);
    }
});

L$1.Symbol.dash = function (options) {
    return new L$1.Symbol.Dash(options);
};

L$1.Symbol.ArrowHead = L$1.Class.extend({
    options: {
        polygon: true,
        pixelSize: 10,
        headAngle: 60,
        pathOptions: {
            stroke: false,
            weight: 2
        }
    },

    initialize: function initialize(options) {
        L$1.Util.setOptions(this, options);
        this.options.pathOptions.clickable = false;
    },

    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
        return this.options.polygon ? L$1.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$1.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);
    },

    _buildArrowPath: function _buildArrowPath(dirPoint, map) {
        var d2r = Math.PI / 180;
        var tipPoint = map.project(dirPoint.latLng);
        var direction = -(dirPoint.heading - 90) * d2r;
        var radianArrowAngle = this.options.headAngle / 2 * d2r;

        var headAngle1 = direction + radianArrowAngle;
        var headAngle2 = direction - radianArrowAngle;
        var arrowHead1 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));
        var arrowHead2 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));

        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];
    }
});

L$1.Symbol.arrowHead = function (options) {
    return new L$1.Symbol.ArrowHead(options);
};

L$1.Symbol.Marker = L$1.Class.extend({
    options: {
        markerOptions: {},
        rotate: false
    },

    initialize: function initialize(options) {
        L$1.Util.setOptions(this, options);
        this.options.markerOptions.clickable = false;
        this.options.markerOptions.draggable = false;
    },

    buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {
        if (this.options.rotate) {
            this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);
        }
        return L$1.marker(directionPoint.latLng, this.options.markerOptions);
    }
});

L$1.Symbol.marker = function (options) {
    return new L$1.Symbol.Marker(options);
};

L$1.PolylineDecorator = L$1.FeatureGroup.extend({
    options: {
        patterns: []
    },

    initialize: function initialize(paths, options) {
        L$1.FeatureGroup.prototype.initialize.call(this);
        L$1.Util.setOptions(this, options);
        this._map = null;
        this._paths = this._initPaths(paths);
        this._patterns = this._initPatterns(this.options.patterns);
    },

    /**
    * Deals with all the different cases. input can be one of these types:
    * array of LatLng, array of 2-number arrays, Polyline, Polygon,
    * array of one of the previous.
    */
    _initPaths: function _initPaths(input, isPolygon) {
        var _this = this;

        if (this._isCoordArray(input)) {
            // Leaflet Polygons don't need the first point to be repeated, but we do
            var coords = isPolygon ? input.concat([input[0]]) : input;
            return [coords];
        }
        if (input instanceof L$1.Polyline) {
            // we need some recursivity to support multi-poly*
            return this._initPaths(input.getLatLngs(), input instanceof L$1.Polygon);
        }
        if (Array.isArray(input)) {
            // flatten everything, we just need coordinate lists to apply patterns
            return input.reduce(function (flatArray, p) {
                return flatArray.concat(_this._initPaths(p, isPolygon));
            }, []);
        }
        return [];
    },

    _isCoordArray: function _isCoordArray(ll) {
        return Array.isArray(ll) && this._isCoord(ll[0]);
    },

    _isCoord: function _isCoord(c) {
        return c instanceof L$1.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === 'number';
    },

    // parse pattern definitions and precompute some values
    _initPatterns: function _initPatterns(patternDefs) {
        return patternDefs.map(this._parsePatternDef);
    },

    /**
    * Changes the patterns used by this decorator
    * and redraws the new one.
    */
    setPatterns: function setPatterns(patterns) {
        this.options.patterns = patterns;
        this._patterns = this._initPatterns(this.options.patterns);
        this.redraw();
    },

    /**
    * Changes the patterns used by this decorator
    * and redraws the new one.
    */
    setPaths: function setPaths(paths) {
        this._paths = this._initPaths(paths);
        this.redraw();
    },

    /**
    * Parse the pattern definition
    */
    _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {
        return {
            symbolFactory: patternDef.symbol,
            // Parse offset and repeat values, managing the two cases:
            // absolute (in pixels) or relative (in percentage of the polyline length)
            offset: parseRelativeOrAbsoluteValue(patternDef.offset),
            endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),
            repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)
        };
    },

    onAdd: function onAdd(map) {
        this._map = map;
        this._draw();
        this._map.on('moveend', this.redraw, this);
    },

    onRemove: function onRemove(map) {
        this._map.off('moveend', this.redraw, this);
        this._map = null;
        L$1.LayerGroup.prototype.onRemove.call(this, map);
    },

    /**
    * Returns an array of ILayers object
    */
    _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {
        var _this2 = this;

        return directionPoints.map(function (directionPoint, i) {
            return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);
        });
    },

    _projectPatternOnPath: function _projectPatternOnPath(latLngs, pattern, map) {
        var pathAsPoints = latLngs.map(function (latLng) {
            return map.project(latLng);
        });
        return projectPatternOnPointPath(pathAsPoints, pattern).map(function (point) {
            return {
                latLng: map.unproject(L$1.point(point.pt)),
                heading: point.heading
            };
        });
    },

    /**
    * Select pairs of LatLng and heading angle,
    * that define positions and directions of the symbols
    * on the path
    */
    _getDirectionPoints: function _getDirectionPoints(pathIndex, pattern) {
        var latLngs = this._paths[pathIndex];
        if (latLngs.length < 2) {
            return [];
        }

        return this._projectPatternOnPath(latLngs, pattern, this._map);
    },

    /**
    * Public redraw, invalidating the cache.
    */
    redraw: function redraw() {
        if (!this._map) {
            return;
        }
        this.clearLayers();
        this._draw();
    },

    /**
    * Returns all symbols for a given pattern as an array of LayerGroup
    */
    _getPatternLayers: function _getPatternLayers(pattern) {
        var _this3 = this;

        var directionPoints = void 0,
            symbols = void 0;
        var mapBounds = this._map.getBounds().pad(0.1);
        return this._paths.map(function (path, i) {
            directionPoints = _this3._getDirectionPoints(i, pattern)
            // filter out invisible points
            .filter(function (point) {
                return mapBounds.contains(point.latLng);
            });

            return L$1.layerGroup(_this3._buildSymbols(path, pattern.symbolFactory, directionPoints));
        });
    },

    /**
    * Draw all patterns
    */
    _draw: function _draw() {
        var _this4 = this;

        this._patterns.map(function (pattern) {
            return _this4._getPatternLayers(pattern);
        }).forEach(function (layers) {
            _this4.addLayer(L$1.layerGroup(layers));
        });
    }
});
/*
 * Allows compact syntax to be used
 */
L$1.polylineDecorator = function (paths, options) {
    return new L$1.PolylineDecorator(paths, options);
};

})));

/**
 * GeoMapChecker
 */

class GeoMapChecker {
	constructor(callerObject) {
		this.caller = callerObject;
		
		if(callerObject == undefined)
			this.caller = this;
	}
	
	undefinedTest(method, object, objectInfo, container) {
		//let errorColor = "color: red";
		//let errorMessage = "%c" + "Error! " + method;
		
		//if (object == undefined) {
		//	if (container != undefined) {
		//		errorMessage += " Can't find '" + objectInfo + "' in:";
		//		console.log(errorMessage, errorColor, container);
		//	} else {
		//		errorMessage += "'" + objectInfo + "' is undefined";
		//		console.log(errorMessage, errorColor);
		//	}
		//	return true;
		//}
		//
		//if(objectInfo == undefined) {
		//	errorMessage += " " + object;
		//	console.log(errorMessage, errorColor);
		//	return true;
		//}
		
		return false;
	}
	
	getUndefinedTestFunction(method) {
		let methodName = this.caller.constructor.name + "::" + method + "()";
		
		let self = this;
		
		return function (object, objectInfo, container) {
			return self.undefinedTest(methodName, object, objectInfo, container);
		}
	}
};

/**
 * GeoMapProviderLayers
 */

class GeoMapProviderLayers {
	
	constructor() {
		this.checker = new GeoMapChecker(this);
	}
	
	getCheckFunction(method) {
		return this.checker.getUndefinedTestFunction(method);
	}
	
	checkParameters(parameters) {
		if (parameters != undefined)
			if(Object.keys(parameters).length > 0)
				return true;
	}
	
	createLayer(providerName, parameters) {
		let undef = this.getCheckFunction("createLayer");

		if(undef(providerName, "provider name"))
			return;

		let createFunctionName = "create" + providerName + "Layer";

		let createFunction = this[createFunctionName];

		if(undef(createFunction, "'" + createFunctionName + "' function", this))
			return;

		return createFunction.call(this, parameters);
	}

	createOpenStreetMapLayer(layerParameters) {
		let undef = this.getCheckFunction("createOpenStreetMapLayer");
		
		let parameters = {};
		
		let url = "";
		
		if(this.checkParameters(layerParameters)) {
			parameters = layerParameters;
			
			url = parameters['url'];
			
			delete parameters['url'];
		} else {
			url = "http:\/\/{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
			
			parameters['attribution'] = "Map data © OpenStreetMap contributors";
			
			parameters['minZoom'] = 0;
			parameters['maxZoom'] = 25;
			
			parameters['minNativeZoom'] = parameters['minZoom'];
			parameters['maxNativeZoom'] = 19;//parameters['maxZoom'];
		}
		
		return L.tileLayer(url, parameters);
	}
	
	createYandexMapLayer(layerParameters) {
		let undef = this.getCheckFunction("createYandexMapLayer");
		
		let parameters = {};
		
		let url = "";
		
		if(this.checkParameters(layerParameters)) {
			parameters = layerParameters;
			
			url = parameters['url'];
			
			delete parameters['url'];
		} else {
			url = "http:\/\/vec{s}.maps.yandex.net/tiles?l=map&v=4.55.2&z={z}&x={x}&y={y}&scale=2";
			
			parameters['attribution'] = "<a http='yandex.ru' target='_blank'>Yandex</a>";
			
			parameters['subdomains'] = ["01", "02", "03", "04"];
		}
		
		return L.tileLayer(url, parameters);
	}
	
	createGoogleMapLayer(layerParameters) {
		let undef = this.getCheckFunction("createGoogleMapLayer");
		
		let parameters = {};
		
		if(this.checkParameters(layerParameters))
			parameters = layerParameters;
		else
			parameters['type'] = "hybrid";
		
		return L.gridLayer.googleMutant(parameters);
	}
	
	createGlobeXYMapLayer(layerParameters) {
		
		let parameters = {};
		
		let url = "";
		
		if(this.checkParameters(layerParameters)) {

			parameters = layerParameters;
			
			url = parameters['url'];
			
			delete parameters['url'];

		} else {
			
			url = "http://192.168.10.65:9090/?x={x}&y={y}&z={z}&layer=main";
			
			parameters['attribution'] = "Map data ©2019 GlobeXY";
			
			parameters['minZoom'] = 0;
			parameters['maxZoom'] = 25;
			
			parameters['minNativeZoom'] = parameters['minZoom'];
			parameters['maxNativeZoom'] = parameters['maxZoom'];
		}
		
		return L.tileLayer(url, parameters);
	}

	
};

/**
 * GeoMap ProviderControls
 */

class GeoMapProviderControls {
	
	constructor() {
		this.checker = new GeoMapChecker(this);
	}
	
	getCheckFunction(method) {
		return this.checker.getUndefinedTestFunction(method);
	}
	
	createProviderControl(providerName, controlName) {
		let undef = this.getCheckFunction("createProviderControl");

		if(undef(providerName, "provider name"))
			return;

		let createFunctionName = "create" + providerName + "Control";

		let createFunction = this[createFunctionName];

		if(undef(createFunction, "\'" + createFunctionName + "\" function", this))
			return;

		return createFunction.call(this, controlName);
	}
	
	createControl(providerName, controlName) {
		let control = this.createProviderControl(providerName, controlName);
		return control;
	}
	
	createOpenStreetMapControl(controlName) {
		let undef = this.getCheckFunction("createOpenStreetMapControl");
		
		let name = controlName;
		
		if (name == undefined)
			name = "OSMGeocoder";
		
		let control;
		
		switch (name) {
			case "OSMGeocoder":
				control = new L.Control.OSMGeocoder();
				break;
			default:
				if(undef(undefined, "control name \'" + controlName + "\'", "createOpenStreetMapControl"))
					return undefined;
		}
	}
	
};

/**
 * WidgetGeoMap::GeoObject
 */

class GeoBaseEvents {
	
	constructor(object) {
		this.object = object;
	}
	
};

class GeoEvents {
	
	constructor(object) {
		this.checker = new GeoMapChecker(this);
		this.object = object;
		this.addedEvents = [];
	}
	
	getCheckFunction(method) {
		return this.checker.getUndefinedTestFunction(method, this);
	}
	
	add(name) {
		let undef = this.getCheckFunction("add");
		
		if(undef(name, "name"))
			return;
		
		if(this.has(name))
			return;
		
		if(undef(this[name], "function " + name, this))
			return;

		// if (obj == undefined)//CHANGE
		this[name](name);
		// else
		// 	this[name](name, leafGeom);
	}

	addExistObj (name, leafObj) {
		let undef = this.getCheckFunction("add");

		if(undef(name, "name"))
			return;

		this[name](name, leafObj);
	}

	has(eventName) {
		return this.addedEvents.indexOf(eventName) > -1;
	}
	
	addInitEvents() {
		let undef = this.getCheckFunction("addInitEvents");
		
		let events = this.object.initEvents;
		
		if(undef(events, "events"))
			return;
		
		for(let i = 0; i < events.length; ++i)
			this.add(events[i]);
	}

	addEventsToExistObj (leafObj) {
		let undef = this.getCheckFunction("addInitEvents");

		let events = this.object.initEvents;

		if(undef(events, "events"))
			return;

		for(let i = 0; i < events.length; ++i)
			this.addExistObj(events[i], leafObj);
	}
};

class GeoObject {
	
	constructor(properties) {
		this.checker = new GeoMapChecker(this);
		this.id = undefined;
		this.events = undefined;
		this.initEvents = undefined;
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let id = properties.id;
		
		if(undef(id, "id", properties))
			return;
		
		this.id = id;
		
		let events = properties.events;
		
		if(undef(events, "events", properties))
			return;
		
		this.initEvents = events;
	}
	
	getCheckFunction(method) {
		return this.checker.getUndefinedTestFunction(method, this);
	}
	
	addEvent(name) {
		let undef = this.getCheckFunction("addEvent");
		
		let events = this.events;
		
		if(undef(events, "events", this))
			return;
		
		events.add(name);
	}
	
	addInitEvents() {
		let undef = this.getCheckFunction("addInitEvents");
		
		let events = this.initEvents;
		
		if(undef(events, "initEvents", this))
			return;
		
		for(let i = 0; i < events.length; ++i)
			addEvent(events[i]);
	}
	
};


/**
 * WidgetGeoMap::GeoLayerObject
 */

class GeoLayerBaseEvents extends GeoBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
	click(event) {
		console.log("click", event);
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
	dblclick(event) {
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}

	contextmenu (event) {
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	mousedown(event) {//console.log("mousedown", event);
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
	mouseup(event) {//console.log("mouseup", event);
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
	mouseover(event) {
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
	mouseout(event) {
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
};

class GeoLayerEvents extends GeoEvents {

	constructor(object, inherited) {
		super(object);

		this.baseEvents = undefined;

		if(inherited === false) {
			this.baseEvents = new GeoLayerBaseEvents(object);

			this.addInitEvents();
		}
	}

	//listenObject : undefined или leafletObj
	addBaseEvent(eventName, baseEventName, listenObject) {
		let undef = this.getCheckFunction("add");

		if(undef(eventName, "eventName"))
			return;

		if(undef(baseEventName, "baseEventName"))
			return;

		if(undef(this.baseEvents, "baseEvents", this))
			return;

		let baseHandler = this.baseEvents[baseEventName];

		if(undef(baseHandler, "function " + baseEventName, this.baseEvents))
			return;

		let object = this.object;//js object

		if (listenObject == undefined) {
			if (object.object != undefined)
				this.addEventToLeafletObject(eventName, baseEventName, object.map, object.id);

			else {
				for (let id in object.maps) {

					listenObject = object.maps[id];//

					if (undef(listenObject, "listenObject")) return;

					this.addEventToLeafletObject(eventName, baseEventName, listenObject, id);
				}
			}
		}
		// else if (listenObject instanceof L.Map)
		// 	this.addEventToLeafletObject(eventName,baseEventName,listenObject);

		else
			for (let id in object.maps){
				if (object.maps[id] == listenObject){
					this.addEventToLeafletObject(eventName,baseEventName,listenObject,id);
					break;
				}
			}

		// if (object.object == null) debugger;

		// if(listenObject == undefined){
		// 	//если не пришел
		// 	if (this.object.object == undefined) {
		// 		//если это линия полигон или точка
		// 		for (let id in object.maps) {
		//
		// 			listenObject = object.maps[id];//todo
		//
		// 			if(undef(listenObject, "listenObject")) {
		// 				return;
		//
		// 			}
		// 			let self = this;
		//
		// 			listenObject.addEventListener(baseEventName, (baseEvent) => {
		// 				let event = baseHandler.call(self.baseEvents, baseEvent);
		//
		// 				if(event == undefined)
		// 					return;
		//
		// 				object.handleEvent(eventName, event, id);
		// 			});
		// 		}
		// 		return;
		// 	}
		// 	else listenObject = object.object;
		// }

		// if(undef(listenObject, "listenObject"))
		// 	return;

		// let self = this;
		//
		// listenObject.addEventListener(baseEventName, (baseEvent) => {
		// 	let event = baseHandler.call(self.baseEvents, baseEvent);
		//
		// 	if(event == undefined)
		// 		return;
		//
		// 	object.handleEvent(eventName, event);
		// });

	}

	addEventToLeafletObject (eventName, baseEventName, leaflet, mapId) {
		if (leaflet == undefined) return;
		if (baseEventName == undefined) return;

		leaflet.addEventListener(baseEventName, (baseEvent) => {
			// console.log(baseEvent);
			let event = this.baseEvents[baseEventName].call(this.baseEvents, baseEvent);

			if(event == undefined)
				return;

			// if (baseEventName == "contextmenu") debugger;
			this.object.handleEvent(eventName, event, mapId);//если карта, то mapId просто проебем
		});
	}

	onClick(eventName, leafObj) {
		this.addBaseEvent(eventName, "click", leafObj);
	}
	
	onDoubleClick(eventName, leafObj) {
		this.addBaseEvent(eventName, "dblclick", leafObj);
	}

	onRightClick (eventName, leafObj) {
		this.addBaseEvent(eventName, "contextmenu", leafObj);
	}
	
	onMouseDown(eventName, leafObj) {
		this.addBaseEvent(eventName, "mousedown", leafObj);
	}
	
	onMouseUp(eventName, leafObj) {
		this.addBaseEvent(eventName, "mouseup", leafObj);
	}
	
	onMouseOver(eventName, leafObj) {
		this.addBaseEvent(eventName, "mouseover", leafObj);
	} 
	
	onMouseOut(eventName, leafObj) {
		this.addBaseEvent(eventName, "mouseout", leafObj);
	} 
	
};

class GeoLayerObject extends GeoObject {
	
	constructor(properties) {
		super(properties.GeoObject);
		
		this.popup = undefined;
		this.tooltip = undefined;
		
		if(properties != undefined) {
			this.popupId = properties.popupId;
			this.tooltipId = properties.tooltipId;
		}
	}
	
	init() {
		this.initGeoTooltip("popup", this.popupId);
		this.initGeoTooltip("tooltip", this.tooltipId);
	}
	
	initGeoTooltip(type, id) {
		if(id == undefined)
			return;
		
		let tooltip = geoManager.objects[id];
		
		if (tooltip != undefined) {
			tooltip.unbind();
			
			tooltip.layerObject = this;
			debugger;
			
			tooltip.onBindTo(this);
			
			this[type] = tooltip;
		}
	}

};


/**
 * WidgetGeoMap::GeoMap
 */

class GeoMapBaseEvents extends GeoLayerBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
	move(event) {
		let map = event.target;
		
		let v = this.object.view;
		
		let latLng = map.getCenter();
		let zoom = map.getZoom();
		
		let pixelOffset = map.project(L.latLng(latLng));
		
		if(Rex.compare(v.zoom , zoom))
			if(Rex.compare(v.x, pixelOffset.x, 1))
				if(Rex.compare(v.y, pixelOffset.y, 1))
					return undefined;
		
		v.lon = latLng.lng;
		v.lat = latLng.lat;
		
		v.zoom = zoom;
		
		v.x = pixelOffset.x;
		v.y = pixelOffset.y;
		
		return {
			lon : latLng.lng,
			lat : latLng.lat,
			zoom : zoom
		};
	}
	
	mousemove(event) {
		// //console.log("mousemove", event);
		return {
			lon : event.latlng.lng,
			lat : event.latlng.lat
		};
	}
	
};

class GeoMapEvents extends GeoLayerEvents {
	
	constructor(object) {
		super(object);
		
		this.baseEvents = new GeoMapBaseEvents(object);
		
		this.addInitEvents();
	}
	
	onChangeView(eventName) {
		this.addBaseEvent(eventName, "move");
	}
	
	onMouseMove(eventName) {
		this.addBaseEvent(eventName, "mousemove");
	}
};

class GeoMap extends GeoLayerObject {
	
	constructor(mapWidget, properties, htmlContainer) {
		//console.log("GeoMap constructor");
		super(properties.GeoLayerObject);

		this.htmlContainer = htmlContainer;

		//console.log("GeoMap properties", properties);

		this.checker = new GeoMapChecker(this);

		let undef = this.getCheckFunction("constructor");
		if(undef(properties, "properties")) {
			return;
		}

		let init = properties.init;
		if(undef(init, "init", properties)) {
			return;

		}

		// this.clientId = Math.round(Math.random() * 1e8);

		this.mapWidget = mapWidget;
		
		this.htmlMapStyle = undefined;
		
		this.view = {
			lon : 0,
			lat : 0,
			x : undefined,
			y : undefined,
			zoom : 0
		};
		
		this.initLeafletSettings();
		
		this.map = this.createMap();
		
		this.object = this.map;
		
		this.visible = true;
		this.interactive = true;
		this.draggable = true;
		
		this.map.doubleClickZoom.disable();
		this.map.keyboard.disable();
		
		this.setInteractive(true);

		this.setVisible(mapWidget.visible);
		this.setDraggable(this.draggable);
		
		this.setView(init.viewPosition);
		
		// this.objectTypes = this.createObjectTypes();
		// this.styleTypes = this.createStyleTypes();
		
		this.objects = {};
		// this.styles = {};
		// this.images = {};

		this.gridLayers = {};
		
		this.currentGridLayer = undefined;
		
		this.providerLayers = new GeoMapProviderLayers();
		
		this.addProviderLayer({parameters : {provider : "OpenStreetMap"} });
		this.addProviderLayer({parameters : {provider : "GoogleMap"} });
		this.addProviderLayer({parameters : {provider : "YandexMap"} });
		this.addProviderLayer({parameters : {provider : "GlobeXYMap"} });
		
		//this.addProviderLayer({name : "roadmap", parameters : {provider : "GoogleMap", type : "roadmap"} });
		//this.addProviderLayer({name : "satellite", parameters : {provider : "GoogleMap", type : "satellite"} });
		//this.addProviderLayer({name : "terrain", parameters : {provider : "GoogleMap", type : "terrain"} });
		
		this.providerControls = new GeoMapProviderControls();
		this.events = new GeoMapEvents(this);
	}
	//this.addProviderControl("OpenStreetMap");
	
	initLeafletSettings() {
		let undef = this.getCheckFunction("initLeafletSettings");

		if(undef(L, "Leaflet global object L"))
			return;

		GeoImageIcon.setDefaultOptions(L.Icon.Default.prototype.options);
	}

	createMap() {
		let htmlMap = document.createElement('div');
		htmlMap.id = "geoMap" + this.id;

		this.htmlMap = htmlMap;

		let style = htmlMap.style;

		this.htmlMapStyle = style;

		style.backgroundColor = "rgb(253,250,243)";
		//style.zIndex = "1";
		let abs = 1;

		if(abs == 1) {
			style.position = 'absolute';
			style.left = '0%';
			style.top = '0%';
			style.width = '100%';
			style.height = '100%';
		} else {
			style.position = 'relative';
			style.left = '0%';
			style.top = '0%';
			style.width = '100%';
			style.height = '100%';
		}

		this.htmlContainer.appendChild(htmlMap);

		let v = this.view;

		let lonLat = [v.lon, v.lat];

		let map = L.map(htmlMap, {center: lonLat, zoom: v.zoom});

		let pixelOffset = map.project(lonLat, v.zoom);

		v.x = pixelOffset.x;
		v.y = pixelOffset.y;

		return map;
		// let htmlMap = document.createElement('div');
		//
		// htmlMap.id = "geoMap" + this.id;
		//
		// this.htmlMap = htmlMap;
		//
		// let style = htmlMap.style;
		//
		// this.htmlMapStyle = style;
		//
		// style.backgroundColor = "rgb(242,239,233)";
		// style.zIndex = "1";
		// style.position = 'absolute';
		//
		// let widget = this.mapWidget;
		//
		// let x, y, w, h;
		//
		// x = 200;
		// y = 200;
		// w = 300;
		// h = 300;
		//
		// if(Rex[widget.parentId] != undefined) {
		// 	x = widget.getAbsolutePosX();
		// 	y = widget.getAbsolutePosY();
		// 	w = widget.getAbsoluteWidth();
		// 	h = widget.getAbsoluteHeight();
		// }
		//
		// let paddingLeft = 5;
		// let paddingRight = 5;
		// let paddingTop = h * 0.06 + 5;
		// let paddingBottom = 5;
		//
		// x = x + paddingLeft;
		// y = y + paddingTop;
		// w = w - paddingLeft - paddingRight;
		// h = h - paddingTop - paddingBottom;
		//
		// //this.setPos(x, y);
		// //this.setSize(w, h);
		// this.mapWidget.view.htmlElement.appendChild(htmlMap);
		//
		// //document.getElementById('canvas').parentElement.appendChild(htmlMap);
		//
		// let v = this.view;
		//
		// let lonLat = [v.lon, v.lat];
		//
		// let map = L.map(htmlMap, {center: lonLat, zoom: v.zoom});
		//
		// let pixelOffset = map.project(lonLat, v.zoom);
		//
		// v.x = pixelOffset.x;
		// v.y = pixelOffset.y;
		//
		// return map;
	}
	
	setPos(x, y) {
		if(Math.abs(x - this.posX) > 0.1) {
			this.posX = x;
			this.htmlMapStyle.left = x + "px";
		}
		
		if(Math.abs(y - this.posY) > 0.1) {
			this.posY = y;
			this.htmlMapStyle.top = y + "px";
		}
	}
	
	setSize(width, height) {
		if(Math.abs(width - this.width) > 0.1) {
			this.width = width;
			this.htmlMapStyle.width = width + "px";
		}
		
		if(Math.abs(height - this.height) > 0.1) {
			this.height = height;
			this.htmlMapStyle.height = height + "px";
		}
		
		this.invalidateSize();
	}

	invalidateSize() {
		if(this.map != undefined)
			this.map.invalidateSize();
	}
	
	setInteractive(interactive) {
		if(this.interactive == interactive)
			return;
		
		this.interactive = interactive;
		
		let map = this.map;
		
		if(1||interactive) {
			if(this.draggable)
				map.dragging.enable();
			
			map.touchZoom.enable();
			//map.doubleClickZoom.enable();
			map.scrollWheelZoom.enable();
			map.boxZoom.enable();
			//map.keyboard.enable();
			
			if (map.tap) map.tap.enable();
		} else {
			map.dragging.disable();
			map.touchZoom.disable();
			//map.doubleClickZoom.disable();
			map.scrollWheelZoom.disable();
			map.boxZoom.disable();
			//map.keyboard.disable();
			
			if (map.tap) map.tap.disable();
		}
	}
	
	setDraggable(draggable) {
		if(this.draggable == draggable)
			return;
		
		this.draggable = draggable;
		
		if(draggable)
			this.map.dragging.enable();
		else
			this.map.dragging.disable();
	}
	
	setView(pos) {
		console.log("assdas",pos);
		let undef = this.getCheckFunction("setView");
		
		if(undef(pos, "pos"))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;
		
		let zoom = pos.zoom;
		
		if(undef(zoom, "zoom", pos))
			return;
			
		let v = this.view;
		
		if(Rex.compare(v.lon, lon, 1e-9))
			if(Rex.compare(v.lat, lat, 1e-9))
				if(Rex.compare(v.zoom, zoom, 1e-9))
					return;
		
		let map = this.map;
		
		let latLng = L.latLng([lat, lon]);
		
		let pixelOffset = map.project(latLng, zoom);
		
		v.lon = lon;
		v.lat = lat;
		
		v.zoom = zoom;
		
		v.x = pixelOffset.x;
		v.y = pixelOffset.y;
		
		map.setView(latLng, zoom, {animate : false});
	}
	
	flyTo(properties) {
		let undef = this.getCheckFunction("flyTo");
		
		if(undef(properties, "properties"))
			return;
		
		let pos = properties.pos;
		
		if(undef(pos, "pos", properties))
			return;
		
		let duration = properties.duration;
		
		if(undef(duration, "duration", properties))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;
		
		let zoom = pos.zoom;
		
		if(undef(zoom, "zoom", pos))
			return;
		
		this.map.flyTo({lng : lon, lat : lat}, zoom, {animate : true, duration : duration / 1000});
	}
	
	panTo(parameters) {
		let undef = this.getCheckFunction("panTo");
		
		if(undef(parameters, "properties"))
			return;
		
		let pos = parameters.pos;
		
		if(undef(pos, "pos", parameters))
			return;
		
		let duration = parameters.duration;
		
		if(undef(duration, "duration", parameters))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;

		this.map.panTo({lng : lon, lat : lat}, {animate : true, duration : duration / 1000});
	}
	
	setCurrentLayer(layerName) {
		let undef = this.getCheckFunction("setCurrentLayer");
		
		if(undef(layerName, "layerName"))
			return;

		let currentLayer = this.currentGridLayer;
		
		if(layerName == "") {
			if(currentLayer)
				currentLayer.removeFrom(this.map);
			
			this.currentGridLayer = undefined;
			
			return;
		}
		
		let layer = this.gridLayers[layerName];
		
		if(undef(layer, "layer " + layerName, this.gridLayers))
			return;
		
		if(layer == currentLayer)
			return;
		
		if(currentLayer)
			currentLayer.removeFrom(this.map);
		
		this.map.addLayer(layer);
		
		this.currentGridLayer = layer;
	}
	
	addProviderLayer(layerInfo) {
		let undef = this.getCheckFunction("addProviderLayer");
		
		if(undef(layerInfo, "parameters"))
			return;
		
		let name = layerInfo.name;
		
		let parameters = layerInfo.parameters;
		
		if(parameters !== Object(parameters))
			parameters = JSON.parse(parameters);
		
		if(undef(parameters, "parameters", layerInfo))
			return;
		
		let providerName = parameters.provider;
		
		if(undef(providerName, "providerName", parameters))
			return;
		
		delete parameters['provider'];
		
		if(name == undefined || name == "")
			name = providerName;
		
		let layer = this.gridLayers[name];
		
		if(layer == undefined) {
			layer = this.providerLayers.createLayer(providerName, parameters);
			
			if(undef(layer, "Provider layer with parameters" + parameters))
				return undefined;
			
			this.gridLayers[name] = layer;
		} else {
			undef("Layer with name " + name + " already exists!");
			return undefined;
		}
		
		return layer;
	}
	
	removeProviderLayer(layerName) {
		let undef = this.getCheckFunction("removeProviderLayer");
		
		if(undef(layerName, "layerName"))
			return;
		
		let layer = this.gridLayers[layerName];
		
		if(undef(layer, "layer " + layerName,  this.gridLayers))
			return;
		
		if(this.currentGridLayer == layer) {
			layer.removeFrom(this.map);
			this.currentGridLayer = undefined;
		}
		
		delete this.gridLayers[layerName];
	}
	
	addProviderControl(providerName, controlName) {
		let undef = this.getCheckFunction("addProviderControl");
		
		let control = this.providerControls.createControl(providerName, controlName);
		
		if(undef(control, "Provider control " + controlName))
			return;
		
		this.map.addControl(control);
	}
	
	checkRange(range) {
		let undef = this.getCheckFunction("checkRange");
		
		if(undef(range, "range"))
			return false;
		
		let start = range.start;
		
		if(undef(start, "start", range))
			return false;
		
		let end = range.end;
		
		if(undef(end, "end", range))
			return false;

		if(start < 0)
			if(undef("start index < 0"))
				return false;
			
		if(end < 0)
			if(undef("end index < 0"))
				return false;
			
		if(end < start)
			if(undef("end index < start index"))
				return false;
		
		return true;
	}
	
	init(state) {
		if(state == undefined)
			return;
		
		let undef = this.getCheckFunction("init");
		
		let init = state.init;
		
		if(init == undefined)
			return;
		
		let range = init.initRequestsRange;
		
		if(range != undefined)
			if(state.requests != undefined)
				this.handleInitRequests(state.requests, range);

		//console.log("cur LAYER", init.currentLayer);
		this.setCurrentLayer(init.currentLayer);
	}
	
	setState(state) {
		if(state == undefined)
			return;
		
		let init = state.init;
		
		let range = undefined;
		
		if(init != undefined)
			range = init.initRequestsRange;
		
		this.handleRequests(state.requests, range);
	}
	
	handleInitRequests(requests, requestsRange) {
		if(!this.checkRange(requestsRange))
			return;
		
		for (var i = requestsRange.start; i <= requestsRange.end; ++i)
			this.handleRequest(requests[i]);
		
		requestsRange.start = 0;
	}
	
	handleRequest(request) {
		let undef = this.getCheckFunction("handleRequest");
		
		if(undef(request, "request"))
			return;
		
		let r = request;
		
		if(undef(r.clientId, "clientId", r))
			return;
		
		if(this.clientId == r.clientId)
			return;
		
		let method = r.method;
		
		if(undef(method, "method", r))
			return;
		
		let id = r.id;
		
		if(undef(id, "id", r))
			return;
		
		let type = r.type;
		
		if(undef(type, "type", r))
			return;
		
		let object;
		
		switch(type) {
			case "map" :
				object = this;
				break;
				
			case "object" :
				object = this.objects[id];
				
				if(undef(object, "map object with id = " + id, this.objects))
					return;
				
				break;
				
			case "style" :
				object = this.styles[id];
				
				if(undef(object, "style with id = " + id, method, this.styles))
					return;
		}
		
		let requestFunction = object[method];
		
		if(undef(requestFunction, "function " + method, object))
			return;
		
		requestFunction.call(object, r.parameters);
	}
	
	handleRequests(requests, initRequestsRange) {
		if(requests == undefined)
			return;
		if(initRequestsRange == undefined) {
			for (var i = 0; i < requests.length; ++i)
				this.handleRequest(requests[i]);
		} else {
			if(!this.checkRange(initRequestsRange))
				return;
			
			for (let i = 0; i < initRequestsRange.start; ++i)
				this.handleRequest(requests[i]);
			
			for (let i = initRequestsRange.end + 1; i < requests.length; ++i)
				this.handleRequest(requests[i]);
			
			return;
		}
	}
	
	addOnMapLayer(object) {
		let undef = this.getCheckFunction("addOnBaseMap");
		
		if(undef(object, "object"))
			return;

		if (object.maps[this.id] == undefined){
			if (Object.keys(object.maps).length < 1) {
				console.warn("Error can't add to map object not init");
				return;
			}
			else {
				// //console.log("before", object.maps[0]);
				let existId = Object.keys(object.maps)[0];

				let temp = object.cloneLayer(object.maps[existId]);//COPY Object

				object.maps[this.id] = temp;
				// if (temp != )
				// object.maps[this.id].redraw();
				object.geoEvents.addEventsToExistObj(temp);
				// 	temp.addEventListener()
				// }
				// //console.log("after", temp);
			}
		}

		let baseObject = object.maps[this.id];

		if(undef(baseObject, "object", object))
			return;
		//console.log(baseObject);
		baseObject.addTo(this.map);
	}
	
	addObject(parameters) {
		let undef = this.getCheckFunction("addObject");
		
		if(undef(parameters, "parameters"))
			return;
		
		let id = parameters.id;
		
		if(undef(id, "id", parameters))
			return;

		if(this.objects[id] != undefined)
			return;

		let object;

		if (geoManager.isObjectExist(id)){
			//console.log("exists", id);
			object = geoManager.getObject(id);
		}
		else {
			//console.log("NOT exists", id);
			object = geoManager.addObject(this,parameters);
		}

		//console.log("OBJECT", object);
		object.onAddOnMap(this);
		
		this.objects[id] = object;//надо ли?
	}

	// addObjectToMap (object) {
	// 	object.onAddOnMap(this);
	//
	// 	this.objects[object.id] = object;//надо ли?
	// }

	addObjectToMap (id) {
		let object = geoManager.objects[id];

		if (object === undefined) {
			// debugger;
			console.error("prosto beda");
			return;
		}

		object.onAddOnMap(this);

		this.objects[object.id] = object;//надо ли?
	}

	removeObject(objectId) {
		let undef = this.getCheckFunction("removeObject");
		
		if(undef(objectId, "objectId"))
			return;
		
		let object = geoManager.objects[objectId];
		
		if(object === undefined) debugger;

		object.removeFromMap(this.id);

		delete this.objects[object.id];
	}
	
	addStyle(parameters) {
		let undef = this.getCheckFunction("addStyle");
		
		if(undef(parameters, "parameters"))
			return;
		
		let id = parameters.id;

		if(undef(id, "id", parameters))
			return;
		
		if(this.styles[id] != undefined)
			return;

		if (!geoManager.isStyleExist(id))
			geoManager.addStyle(this,parameters);
	}
	
	removeStyle(styleId) {
		let undef = this.getCheckFunction("removeStyle");
		
		if(undef(styleId, "styleId"))
			return;
		
		let style = this.styles[styleId];
		
		if(style.getNumObjects() > 0) {
			undef("Removed style has " + style.getNumObjects() + " objects!");
			return;
		}
		
		delete this.styles[styleId];
	}
	
	addImage(parameters) {
		let undef = this.getCheckFunction("addImage");
		
		if(undef(parameters, "parameters"))
			return;
		
		let id = parameters.id;
		
		if(undef(id, "id", parameters))
			return;
		
		if(this.images[id] != undefined)
			return;

		if (!geoManager.isImageExist(id))
			geoManager.addImage(parameters);

		this.images.id = geoManager.getImage(id);//надо ли??
	}
	
	handleEvent(eventName, event, id) {
		this.handleObjectEvent(this.id, eventName, event, id);
	}
	
	handleObjectEvent(objectId, eventName, eventData, mapId) {
		let undef = this.getCheckFunction("handleObjectEvent");
		
		if(undef(objectId, "objectId"))
			return;
		
		if(undef(eventName, "eventName"))
			return;
		
		if(undef(eventData, "eventData"))
			return;

		let event = {
			clientId : geoManager.clientId + "",
			objectId : objectId,
			name : eventName,
			data : eventData
		};

		if (mapId != undefined)
			event.mapId = parseInt(mapId);

		this.mapWidget.handleGeoMapEvent(event);
	}
	
	setVisible(v) {
		let undef = this.getCheckFunction("setVisible");
		
		if(undef(v, "v"))
			return;
		
		if(this.visible == v)
			return;
		
		this.visible = v;
		
		let style = this.htmlMapStyle;
		
		if(style == undefined)
			return;
		
		if(v)
			style.visibility = "visible";
		else
			style.visibility = "hidden";
	}
	
	clear() {
		let undef = this.getCheckFunction("clear");
		
		if(undef(this.map, "map", this))
			return;
		
		this.map.remove();
		
		// this.htmlMap.remove();
	}
		
	addCollection(collection) {////console.log("addCollection", collection);
		let undef = this.getCheckFunction("addCollection");
		
		if(undef(collection, "collection"))
			return;
		
		if(!Array.isArray(collection)) {
			undef("collection is not array : " + collection);
			return;
		}
		
		// let objects = [];

		/*
		for(let i = 0; i < collection.length; ++i) {
			let parameters = collection[i];
		
			let id = parameters.id;
			
			if(undef(id, "id", parameters))
				return;
			
			if(this.objects[id] != undefined) {
				//console.log("addCollection error object already exists : id = " + id, this.objects[id], this.objects);
				undef("object " + this.objects[id] + " already exists in " + this.objects);
				return;
			}
			
			let objectType = parameters.type;
			
			if(undef(objectType, "type", parameters))
				return;
			
			let type = this.objectTypes[objectType];
	
			if(undef(type, "type " + objectType, this.geoObjectTypes))
				return;
			
			let object = new type(this, this, parameters.properties);
			
			this.objects[id] = object;
			
			objects.push(object);
		}
		*/

		for(let i = 0; i < collection.length; ++i) {

			let id = collection[i];
			if (this.objects[id] != undefined) continue;

			// console.log("this",this.map);
			this.addObjectToMap(id);
		}
	}
	
	removeCollection(collection) {
		let undef = this.getCheckFunction("removeCollection");
		
		if(undef(collection, "collection"))
			return;
		
		if(!Array.isArray(collection)) {
			undef("collection is not array : " + collection);
			return;
		}
		
		let objects = [];
		
		for(let i = 0; i < collection.length; ++i) {		
			let objectId = collection[i];
			
			if(undef(objectId, "objectId", collection))
				return;
			
			let object = this.objects[objectId];
			
			if(undef(object, "object", this.objects))
				return;

			if (object == undefined) {
				// debugger;
				console.log("ну просто хз как так");
				continue;
			}
			objects.push(object);
			
			delete this.objects[objectId];
		}
		
		for(let i = 0; i < objects.length; ++i) {
			let obj = objects[i];
			if (obj == undefined) {
				debugger;
				continue;
			}
			obj.removeFromMap(this.id);
		}
	}
	
};


/**
 * WidgetGeoMap::GeoStyle
 */

class GeoStyle extends GeoObject {
	
	constructor(properties) {
		super(properties.GeoObject);
	}
	
	getNumObjects() {
		let undef = this.getCheckFunction("getNumObjects");
		
		undef("Call the abstract method!");
	}
	
	setOption(baseName, value) {
		if(this[baseName] == value)
			return;
		
		this[baseName] = value;
		
		this.update();
	}
	
};


/**
 * WidgetGeoMap::GeoIcon
 */

class GeoIcon extends GeoStyle {
	
	constructor(properties) {
		super(properties.GeoStyle);
		
		let undef = this.getCheckFunction("constructor");
		
		// this.object = undefined;
		
		this.size = {width : undefined, height : undefined};
		this.anchor = {x : undefined, y : undefined};
		this.popupAnchor = {};
		this.tooltipAnchor = {};
		
		let size = properties.size;
		
		if(undef(size, "size", properties))
			return;
		
		let width = size.width;
		
		if(undef(width, "width", size))
			return;
		
		if(width != -1)
			this.size.width = width;
		
		let height = size.height;
		
		if(undef(height, "height", size))
			return;
		
		if(height != -1)
			this.size.height = height;
		
		this.setAnchor("anchor", properties.anchor);
		this.setAnchor("popupAnchor", properties.popupAnchor);
		this.setAnchor("tooltipAnchor", properties.tooltipAnchor);
		
		this.markers = [];
		
		let markerIds = properties.markers;
		
		if(markerIds)
			this.setMarkers(markerIds);
		
		this.options = undefined;
		this.opacity = properties.opacity;//ADD opacity04.07.19 @smag
		// iconUrl:       'marker-icon.png',
		// iconRetinaUrl: 'marker-icon-2x.png',
		// shadowUrl:     'marker-shadow.png',
		// iconSize:    [25, 41],
		// iconAnchor:  [12, 41],
		// popupAnchor: [1, -34],
		// tooltipAnchor: [16, -28],
		// shadowSize:  [41, 41]
	}
	
	setOpacity (opacity) {
		let undef = this.getCheckFunction("setOpacity");

		if (undef(opacity)) return;

		this.object.options.opacity = opacity;
		this.update();
	}

	setAnchor(name, anchor) {
		let undef = this.getCheckFunction("setAnchor");
				
		if(undef(name, "name"))
			return;
		
		if(undef(anchor, "anchor"))
			return;
		
		let x = anchor.x;
		
		if(undef(x, "x", anchor))
			return;
		
		if(x != -1)
			this[name].x = x;
		
		let y = anchor.y;
		
		if(undef(y, "y", anchor))
			return;
		
		if(y != -1)
			this[name].y = y;
	}
	
	init() {
		this.options = this.object.options;
		this.options.iconSize = [this.size.width, this.size.height];
		this.options.iconAnchor = [this.anchor.x, this.anchor.y];
		this.options.popupAnchor = [this.popupAnchor.x, this.popupAnchor.y];
		this.options.tooltipAnchor = [this.tooltipAnchor.x, this.tooltipAnchor.y];
	}
	
	setMarkers(markerIds) {
		let mapObjects = geoManager.objects;
		
		for(let i = 0; i < markerIds.length; ++i) {
			let marker = mapObjects[markerIds[i]];
			
			if(marker == undefined)
				continue;
			
			marker.icon = this;
			
			this.markers.push(marker);
		}
	}
	
	setSize(size) {
		let undef = this.getCheckFunction("setSize");
				
		if(undef(size, "size"))
			return;
		
		let width = size.width;
		
		if(undef(width, "width", size))
			return;
		
		let height = size.height;
		
		if(undef(height, "height", size))
			return;
		
		if(this.width == width)
			if(this.height == height)
				return;
			
		this.width = width;
		this.height = height;
		
		this.options.iconSize = [width, height];
				
		this.update();
	}
	
	setIconAnchor(pos) {
		let undef = this.getCheckFunction("setIconAnchor");
				
		if(undef(pos, "pos"))
			return;
		
		let x = pos.x;
		
		if(undef(x, "x", pos))
			return;
		
		let y = pos.y;
		
		if(undef(y, "y", pos))
			return;
		
		let anchor = this.anchor;
		
		if(anchor.x == x)
			if(anchor.y == y)
				return;
			
		anchor.x = x;
		anchor.y = y;
		
		this.options.iconAnchor = [x, y];
		
		this.update();
	}
	
	setPopupAnchor(pos) {
		let undef = this.getCheckFunction("setPopupAnchor");
				
		if(undef(pos, "pos"))
			return;
		
		let x = pos.x;
		
		if(undef(x, "x", pos))
			return;
		
		let y = pos.y;
		
		if(undef(y, "y", pos))
			return;
		
		let anchor = this.popupAnchor;
		
		if(anchor.x == x)
			if(anchor.y == y)
				return;
			
		anchor.x = x;
		anchor.y = y;
		
		this.options.popupAnchor = [x, y];
		
		this.update();
	}
	
	setTooltipAnchor(pos) {
		let undef = this.getCheckFunction("setTooltipAnchor");
				
		if(undef(pos, "pos"))
			return;
		
		let x = pos.x;
		
		if(undef(x, "x", pos))
			return;
		
		let y = pos.y;
		
		if(undef(y, "y", pos))
			return;
		
		let anchor = this.tooltipAnchor;
		
		if(anchor.x == x)
			if(anchor.y == y)
				return;
			
		anchor.x = x;
		anchor.y = y;
		
		this.options.tooltipAnchor = [x, y];
		
		this.update();
	}
	
	update() {
		let markers = this.markers;
		let object = this.object;
		
		//TODO for new maps
		for(let i = 0; i < markers.length; ++i) {
			let marker = markers[i];
			
			if(marker != undefined) {

				for (let id in marker.maps){
					let leafleat = marker.maps[id];
					leafleat.setIcon(object);
					leafleat.setOpacity(object.options.opacity);

					// leafleat.setOpacity(object.options.opacity);
					
					// if(leafleat.popup != undefined)
					// 	leafleat.popup.update();
				
					// if(marker.tooltip != undefined)
					// 	marker.tooltip.update();
				}
			}
		}
	}
	
	hasMarker(marker) {
		return this.markers.indexOf(marker) > -1;
	}
	
	addMarker(marker) {
		let undef = this.getCheckFunction("addMarker");
		
		if(undef(marker, "marker"))
			return;
		
		if(this.hasMarker(marker))
			return;
		
		this.markers.push(marker);
	}
	
	removeMarker(marker) {
		let undef = this.getCheckFunction("removeMarker");
		
		if(undef(marker, "marker"))
			return;
		
		if(!this.hasMarker(marker))
			return;
		
		let markers = this.markers;
		
		markers.splice(markers.indexOf(marker), 1);
	}
	
};


/**
 * WidgetGeoMap::GeoImageIcon
 */

class GeoImageIcon extends GeoIcon {
	
	static setDefaultOptions(options) {
		
		//options.iconUrl = "marker-icon.png";
		options.iconUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=";
		//options.shadowUrl = "marker-shadow.png";
		options.shadowUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC";
		//options.iconRetinaUrl = "marker-icon-2x.png";
		options.iconRetinaUrl = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABSCAMAAAAhFXfZAAAC91BMVEVMaXEzeak2f7I4g7g3g7c3grY3grg8hJo3grY4g7c4g7c3grU0gLI4grY9hrpBi79HkMM2frE0daA0fq82gbROlslbo9Vgp9dcpNZQmcxFjsIwd6QzeKk3gbRfptdepdZcpdY2gLMtd5s3gLNZotVSntNPnNJLmtFImdBZodU1f7A2f7A1frA2f7I2f7FHmNBUnM9Wn9VGmNAydaNYoNJOm9M9hLc0e6w3fa46f7BKmdFFltBVndE1fK1Els82fq41fK1Dlc89g7RClc9XoNVUndQ0eqxClM9Jl9FRms81eqo0eqpHltFBk89Fi75Qm9M/k89KkcYzealSjbadvdPH2ufz9/r4+vzP3+qlxNljmL08gLNSnNQzeKgydqUzeKg/ks6NtM/////+/v8+kc/f6fFAgK1CiLwydKIzd6c8kM6Tt9C1zd5OmdNBh7pTjLRzn78xdKIydqU7j86jwdbM3egxdKIydaQydaMydKNGlNE6js5OiLAxc6FKkshDk9E5jc09e6Zekrcxc6I4jc03eagyc6FIldI3jM0wcaBMl9J+psNKltIwcZ82i83k7fMubJhLlc81is1Lg6pklbZNl9I/j9AvbJlEjcVdkLPt8/cwcZ4ubZkwcJ00icy0y9swcJwvb5wzicxHkcpTh60ubZhCkNAyiMwvbpoxh8xAicBHj8hGk9FHks0+jdAubJcubJdEkdEwhsw6i88ubJgta5cvhswxapgubJcuhcstbJcubZcuhMsubJcvbJZBjMgthMsubJcvbZkubJcrg8stbJctbZcubJgrgssua5gubJc6is8qgcs8i9A9iMYtg8spgcoogMo7hcMrbZcubJcngMonf8olfsoubJc4gr8kfckua5g5iM8jfMk4iM8he8k1froua5g7itAgeskubJc2hs8eecgzfLcofssdeMg0hc4ubJccd8g2hcsxeLQbdsgZdcgxeLImfcszhM0vda4xgckzhM4xg84wf8Yxgs4udKsvfcQucqjbZ8obAAAA7HRSTlMAHDdTb4yPA+L/7ZxE/////yYLgvb///////8SYf/////qB/////////+1wNHd//////8s////r/////////+O/P///////////8f///////////////////////+P2P///////////3f//////////5j/////tczn//////L///////////////////////8+////////R/////Ww////tf////9q////////////4P/////Yd/8W+P/xov+UNv///STN/7hc1P/AUv//////////MMT///+m//+e//////+M//+C////////6cqo94AAAAXmSURBVHgBrNKDoipBGADgbHMRpjuKi2xOdu//MHe2Y6tvOdZvuhGzxWqzO2xWi9lp+g6L3eV+5PH6vmpltrv8nDsQDIWCAbef83jDpo9FojFeJxhPJO8JosQzYnb5oxYpVzodiCcyhiwA2esPEAPpdM727vT+eSH0x7McwoTmOUpxIcvF/RAWI29byCUIpUQ2m8A0/xwx8kIQls2vW4QrihIHQMDqGyQBgAiVnOXVTuWUtAaAnq++I48B0PxKrPZiq8qKvy4IpPqBhiDUm0rl+ca12h1NQN3eh7pI6MN26WnfooNBPIHU4SdUlBAHg9Hj0seDEEJ08pxKqfoio4tQaDAOP0xrMEWIzB4NCWaIK8xJ7ymXItQcFO/jcLGIF+bLRytW4LS18Wbd5SNcEBcLn8mw2TYZ2+3vLRuMaYdme7sdTA8iY8flQ0mPscC2fB1ku12z4+necs7YebDlri9JZ3rvoazB1tutxdiuy1TXl4/Zer95ufzneq7524qBAIBr61TmtxXX/MK4FC6cKIwvViozXMDMzLbCTF+1JBn/4/EtLi2vrK6tbywsbE506vVxnZ3fF7YIIQamdX7dVqb/RtnCr1X+n3F9gA2MdA7Vsl87nzEDId2MTUCHSdr+As/Y1DKvM1uYFWBGpTtggrFuYrMPApgc0jhMTNmdvInLbn8NqNImgEG7jWzZnwB1KAg79t1V3mzPvgm6Q+n9m98n/e5ZQI+iw6Dby1v43AzApPIIs24/Cbg1GFcRE+h29xpvseJ2v4cxjzQOmjtAgqF5PRyRZvTXIfcqbxUNPdOnI1JYnw8FSSwUp4mklKDzoRRvkw7N0vF6QTwUI4aMRsNZyUQnMhkzb2HMZeJ0RhUMUy1jIP68lRaKUpLSXN7FW5jz+QnqKEoFas37yX6pD8tFpYybpQpv4S3lEGv5KvaV9olNDPwNHUhh1ETex5scpsQOVg8UxAFhI0dCHKPjRIogDorT1aZPzkTuHC9U2oPnQlySRzFxhYkTJYHHIXFt5srNnhBxLDSyV+L2IyF395vnhQflpHCuifv80g3/a+UPIXWNEDEAQEE0HR23weEk6XGnwR1iH3eJu7udbt26fe30I17x/PYH+9iv+CB5qT1v+YhlL5WeS5ZV72RZftvlNF6Wj75Zdn2kHcl6e5Sy/A3D7DsBMP0gd/DkC/Bp9l3gW5Y7a5asWVCm3WcaAFSHnFtxAXivwwAsWf9E25dl+TiwhwIKPVRgD33Ct6wvom0ijKapOBllpkEcf6ZCMsqjyCgjuvKIoajXYgya8vhIJ7rKKnKOP+sxjOPJZmV0DRRHGIZx/KW6npaOvor3M/G+pqalS00TT5q4G7qzPGe4O+wu7mxw59wt8p3LCre//pn/J+iupIwe1HKcpVdXI8c9QB9l9QMDnHVQF8+9xdAw5YzgBmfuHdVh4bj7GKO8cZYxW/UmvHkAeEl5pgncMJt7JzVZzOYaTFGh6WRGEDVJ5pniCDOCWw0Ns3MaLA0NdRijYm+AmQZhXoO1YQFYpBJLqGloGF1W1ZuMfKRSL1OZFVXJyNBlUhhD7evXk6sqZl+/rscaKfUDC68FtYn19Xr64xU+oo7nxQ2FWZ6vxyapuTyEdV5WTgR+HZ3DpGoN9Szzu8Qkzz9CH6kbZhlpa7uELO2gs4I0bOKRJInFC1GyPsMuaanoxPre1n6hbXlvB90dpKkPj4Q9sXAi7gnfcEDaOjqxIxwe5e1vCcforiIdu/gkyyenOSeyrBthqrpxvHV2lF0cHW4d47ySdB3g29bWiSPjZMvZBDvpqzxPZk7Ti9PDLZcyomBHk/PwxJ1ycsgiv4guzrgOz9wexn126EVbNV3oVzLj8zBaEYXqNnjP/G4W8Z8F0GYiKisTPGMZ31kQGKdymGwIhMIeTzgUgM1EZRkHgmGfL8wi01Qe0wQCYSaAESrXNBCJRiN6EYURxKLRmF5E4Q0QjwNvyIAlJBKYIiNegnlJhowBY2RMP9BPBn38SEYtLpKG/+tgQe8M5cY7AAAAAElFTkSuQmCC";
		
		options.imagePath = " ";
	}
	
	constructor(properties) {
		super(properties.GeoIcon);
				
		let undef = this.getCheckFunction("constructor");
		
		let imageId = properties.imageId;
		
		if(undef(imageId, "imageId", properties))
			return;
		
		let images = geoManager.images;
		
		let iconUrl = images[imageId];
		
		if(undef(iconUrl, "image with id = " + imageId, images))
			return;
		
		this.object = L.icon({iconUrl : iconUrl, opacity : this.opacity});
		
		this.options = this.object.options;
		
		this.init();
		
		this.update();
	}
	
	init() {
		super.init();
	}
	
	setImage(imageId) {
		let undef = this.getCheckFunction("setImage");

		if(undef(imageId, "imageId"))
			return false;
				
		if(this.imageId == imageId)
			return;
		
		let image = geoManager.images[imageId];
		
		if(undef(image, "image with id = " + imageId, images))
			return;
		
		this.imageId = imageId;
		
		this.options.iconUrl = image;
		
		this.update();
	}
	
};


/**
 * WidgetGeoMap::GeoHtmlIcon
 */

class GeoHtmlIcon extends GeoIcon {
	
	constructor(properties) {
		super(properties.GeoIcon);
				
		this.content = "";
		
		let content = properties.content;
		
		if(content != undefined)
			this.content = content;
				
		// let videoData = '<video id="my" controls><source type="video/mp4" src="';
		// videoData += "data:video/mp4;base64,AAAAHGZ0eXBtcDQyAAAAAG1wNDJpc29tYXZjMQAAMaBtb292AAAAbG12aGQAAAAAymdGY8pnRmUAAV+QACHWgAABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT/";
		// videoData += "/";
		// videoData += "/D3/";
		// videoData += "/AAAa93RyYWsAAABcdGtoZAAAAAHKZ0ZjymdGZQAAAAEAAAAAACHIcAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAwLBiAGAAAAAAGm9tZGlhAAAAIG1kaGQAAAAAymdGY8pnRmUAAV+QACHIcFXEAAAAAAAhaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAAAAABombWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAZ5nN0YmwAAAC+c3RzZAAAAAAAAAABAAAArmF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAwABgAEgAAABIAAAAAAAAAAEOSlZUL0FWQyBDb2RpbmcAAAAAAAAAAAAAAAAAAAAAAAAY/";
		// videoData += "/8AAAA2YXZjQwFNQAr/4QAeZ01ACuyhht/4GjgaI1BgEGQAAAMABAAK/IA8SJZYAQAFaOrBssgAAAASY29scm5jbGMABgABAAYAAAAQcGFzcAAAA0cAAANEAAAAGHN0dHMAAAAAAAAAAQAAAewAABGUAAAHxHN0c3oAAAAAAAAAAAAAAewAAA9rAAABngAAAsQAAAInAAADSgAAAlgAAATOAAAAvwAABZIAAACmAAAETwAAAF8AAANlAAAAWgAAAFsAAAHRAAAC6QAAADcAAANiAAAAVQAAAsgAAANmAAAASQAAAEoAAAMBAAADKQAAAE8AAAHkAAADEAAAAaYAAAKAAAAAMgAAAEMAAAILAAAAKAAAADIAAAM1AAAAXgAAAEgAAALuAAAAIAAAAE8AAAGeAAAA9AAAAnUAAABOAAAARAAAAuEAAABYAAAC3AAAAEwAAAP7AAAA5wAAAagAAANmAAACMwAAA/QAAAIwAAAC6wAAAd0AAAImAAAC1wAAACcAAAAtAAACcgAAADsAAAAuAAABewAAAuoAAAHiAAACuQAAAE4AAAA3AAABbwAAAncAAAAvAAAAOAAAAkQAAAAfAAAAHwAAAeQAAAHoAAAAHgAAAB8AAAGNAAABZQAAABgAAAAkAAAB8gAAAiAAAAAmAAAAJwAAAjIAAAA4AAAAKwAAAlAAAAA6AAAAMwAAAmkAAAK+AAAAMAAAAEIAAANRAAAASgAAAFkAAANGAAAAQQAAACkAAAHGAAABpQAAAzYAAABjAAAASAAAAdYAAANFAAAATAAAADAAAAOKAAAASAAAAEoAAAL/AAAANgAAA2MAAABaAAAATQAAAVsAAAF4AAABPAAAAnYAAABgAAAASwAAAYgAAAIeAAABwAAAAjcAAAH0AAAC7QAAADgAAAOQAAAAWwAAAEYAAAM7AAAAQAAAAGQAAAPbAAAAUgAAAD8AAAGBAAADAQAAAD0AAAAqAAACngAAACEAAAAkAAABGQAAARIAAAGMAAAA8wAAARgAAAHOAAAAPQAAACAAAAMbAAAAVQAAAFUAAAKuAAAASgAAADcAAANzAAAAWgAAAFIAAAHZAAACAgAAAzIAAABDAAAARAAAAuYAAABDAAADZgAAAD4AAAO/AAAARwAAAEcAAAMJAAAAOwAAADwAAAJkAAAAMgAAACQAAAJVAAAALgAAADYAAAIDAAAAPgAAACgAAAD/AAACUgAAAlIAAAQHAAAA0AAAEhEAAANiAAAAWAAAAiAAAAQnAAAAhAAAAFcAAAOaAAAAMgAAAE4AAAMxAAAAPgAAADwAAAEjAAABbAAAAOEAAAFDAAACNAAAACwAAAAjAAACagAAACQAAAAVAAABSwAAA6cAAAA4AAAAOQAAAVsAAAJBAAAAJQAAAB8AAAIyAAAAHgAAACEAAAGMAAABrgAAACAAAAAtAAAB4AAAAWoAAAMSAAAALQAAAD4AAAKjAAAANwAAACcAAAOrAAAARwAAAEsAAAKmAAAANQAAADcAAALHAAAANwAAAngAAAHkAAACawAAACMAAAKyAAAAUAAAACwAAAKZAAAAMgAAACIAAAPtAAAAPAAAACcAAAMrAAAAOQAAAFgAAAJEAAAB6AAAABkAAAAXAAADHwAAADEAAAA0AAADoQAAACwAAAAvAAAB/wAAAvsAAAAtAAAAIgAAAtEAAAAuAAAAHgAAAQUAAAI8AAAAFAAAABEAAAE6AAACyAAAACYAAAAcAAABogAAAhgAAAMvAAAAQwAAADsAAAJ1AAACZAAAAB0AAAAcAAACQgAAAC8AAAAiAAABNwAAAc0AAAL+AAAAKwAAADUAAAIkAAACfQAAACUAAAAeAAABbQAAAxMAAABPAAAAJAAAA30AAABCAAAAXQAAAqUAAAA2AAAARgAAAycAAAGVAAACtQAAAEcAAAArAAADQgAAADQAAAAxAAADjAAAAE0AAAA+AAABLQAAAsYAAAAzAAAAMAAAAeIAAAAdAAAALwAAAqoAAABCAAAAMwAAAjcAAAAaAAAAIAAAAT8AAAHKAAAAFAAAABEAAAIVAAAAJAAAAC0AAAH/AAAAKQAAABEAAAEqAAABGwAAAigAAABKAAAALwAAATwAAAMRAAAAOQAAADoAAAFSAAADLQAAAHcAAABkAAABjAAAAoYAAAF/AAACWAAAAeUAAAKCAAADMgAAADwAAAAvAAADHwAAADQAAAI2AAAARAAAAqcAAALzAAAARAAAAmcAAAA5AAAAPgAAAqwAAABCAAAANwAAAl8AAAAsAAACMQAAAeUAAABQAAASNwAAAMkAAAHbAAAByQAAAe4AAAKSAAAAGgAAACgAAAGmAAAAHgAAABwAAAEgAAAC/QAAAFIAAAKtAAAAPgAAAEkAAAFeAAABkQAAAdoAAAJjAAAAMwAAADAAAAI8AAAALQAAACwAAANLAAAANAAAAEgAAAJ8AAAAKgAAACwAAAJ3AAAAMwAAACgAAAD1AAABkwAAARIAAAGwAAAAFQAAABYAAACjAAABMQAAAMMAAADyAAABigAAAX4AAAEfAAABnQAAAPsAAAGDAAACWAAAAB4AAAAoAAACxAAAACcAAAAsAAABcwAAAmMAAAAcAAAAFwAAANMAAAEHAAABQQAAALgAAADPAAABMwAAABoAAAAMAAACGwAAAHkAAACPAAADTwAAAI4AAAOuAAAAaAAAAGMAAAFcAAACGQAAACQAAAAqAAAA4AAAAA4AAAARAAAA2wAAAHYAAABHAAAAHQAAABQAAABNAAAAPwAAACIAAAAcc3RzYwAAAAAAAAABAAAAAQAAAAQAAAABAAAB/HN0Y28AAAAAAAAAewAAMcQAAFDGAABlHwAAfOUAAJOsAACp0QAAvWUAANUfAADrXQAA+64AAQ8BAAEdjgABMAcAAUVyAAFb0AABduQAAXw1AAGNcgABo6cAAbYQAAHEgAAB1N8AAeatAAH5MQACDFwAAiAIAAIymAACRCMAAlg7AAJpkAACfKwAApE1AAKVkQACqBoAAr6aAALVxAAC6AQAAvvvAAMPhAADH5oAAzHqAANB1QADUNUAA2TTAAN3UQADiwsAA6FZAAOzdgADtlMAA8gLAAPgJgAEBMIABBtcAAQuagAEP+YABE/xAARfIAAEcaQABIMbAASULQAEpX8ABLjoAATJ2AAE25sABOL1AAT0pAAFBIsABRjgAAUr/QAFPVwABU9EAAVh+gAFdKMABYSeAAWVeAAFqhcABbo5AAXLogAF32MABfIAAAX28wAGChcABh0pAAYx+gAGRScABlaUAAZoGAAGfIIABo4jAAadxAAGrNgABr1bAAbPiAAG4acABvSjAAcKwAAHDn4AByJRAAcxiwAHQxIAB1JTAAd2kwAHhnUAB5YaAAepoAAHuqwAB8v9AAfcDAAH62wAB/tMAAgMXAAIG8wACCDlAAgzOQAIRD4ACFM+AAhglgAIcP4ACIJJAAiVJgAIpq8ACLKhAAjB6QAADRhjdHRzAAAAAAAAAaEAAAAGAAAjKAAAAAEAADS8AAAAAQAAEZQAAAABAAA0vAAAAAEAABGUAAAAAQAANLwAAAABAAARlAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAANLwAAAABAAARlAAAAAEAADS8AAAAAQAAEZQAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAANLwAAAABAAARlAAAAAMAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAgAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAA0vAAAAAEAABGUAAAAAQAANLwAAAABAAARlAAAAAEAADS8AAAAAQAAEZQAAAAIAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAMAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAIAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAA0vAAAAAEAABGUAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAwAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAAFAAAjKAAAAAEAADS8AAAAAQAAEZQAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAUAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAgAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAA0vAAAAAEAABGUAAAAAQAANLwAAAABAAARlAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAYAACMoAAAAAQAANLwAAAABAAARlAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAABAAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAACAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAADS8AAAAAQAAEZQAAAACAAAjKAAAAAEAADS8AAAAAQAAEZQAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAIAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAACAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAACAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAACAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAAGAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAADS8AAAAAQAAEZQAAAABAAA0vAAAAAEAABGUAAAAAQAAIygAAAABAAA0vAAAAAEAABGUAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAANLwAAAABAAARlAAAAAgAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAAA0vAAAAAEAABGUAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAwAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAADAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAoAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAQAAIygAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAAFAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAADS8AAAAAQAAEZQAAAABAABGUAAAAAEAACMoAAAAAQAAAAAAAAABAAAjKAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAEAAEZQAAAAAQAAIygAAAABAAAAAAAAAAIAACMoAAAAAQAARlAAAAABAAAjKAAAAAEAAAAAAAAAAwAAIygAAAAcc3RzcwAAAAAAAAADAAAAAQAAAMkAAAGRAAAB+HNkdHAAAAAABERERERERAhECEQIRAQIREQIRAhERAQIREQIRERERAQIRAQIRAQIRAQIREREBAhECEQIRAhEREREREREREQECEQECEREREQECEREBAhEBAhERAQIREQECEREBAhEBAhEBAhERAQIRAQIRAQIREREBAhERAQIRAQIRAhEBAhEREREBAhEREREREQIRAQIRAQIRAQIREQECEQECERERERERAQIRAQIRAQIRAQIREREBAhECEQIRAQIRAQIRAQIRAQIRAQIREREREQERAhERAQIRAQIRAQIREREREQECEQECEREBAhERAQIRAQIREQECERERAQIRAQIRAQIRAQIRAhEREQIRAQIRAQIRAQIRAQIREQECEQECEQECEREBAhEBAhERAQIREQECERERAQIREQECEQECERERAQIREQECEREBAhEBAhEBAhEREQECEQECEQECEREBAhEBAhEBAhEBAhERAQIRAQIRAQIREREBAhERAQIREQECEREREREREQECEQIRAhERAhEBAhEBAhECERERARERERERAQIRAQIREQIRAQIRERERAQIRAQIRAQIRAQIRAQIRERERAQIREREREREREREREQECEQECEREBAhEREREREQECEQECEQIRAQIREQECEQECERERAQIREREAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABACHIcAAAIygAAQAAAAAVrnRyYWsAAABcdGtoZAAAAAPKZ0ZjymdGZQAAAAIAAAAAACHWgAAAAAAAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAFTRtZGlhAAAAIG1kaGQAAAAAymdGY8pnRmUAALuAABIMABXHAAAAAAAhaGRscgAAAAAAAAAAc291bgAAAAAAAAAAAAAAAAAAABTrbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAABSvc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAALuAAAAAAAAzZXNkcwAAAAADgICAIgAAAASAgIAUQBUAApwAAjLQAAHwGwWAgIACEZAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAEgwAABAAAABIgc3RzegAAAAAAAAAAAAAEgwAAAJoAAACuAAAA2QAAAZIAAAEdAAAA6QAAAM4AAAC3AAAA5gAAAOoAAADMAAAA8gAAAPwAAADEAAAA4wAAAPQAAADwAAABDAAAAPkAAADgAAAA1gAAAQwAAAEbAAABQgAAAZoAAAFqAAABRgAAAWsAAAFSAAABmgAAApwAAAJDAAABmwAAAXsAAAFOAAABZwAAAYQAAAGVAAABcgAAAacAAAGgAAABZwAAAaAAAAGbAAABmAAAAbEAAAFjAAABXwAAAXIAAAGPAAABNwAAAUkAAAFqAAABTgAAATUAAAEuAAABXgAAAT4AAAFjAAABOQAAAWEAAAGhAAABrwAAAW0AAAF0AAABdAAAAasAAAGdAAABagAAAaUAAAGuAAABwAAAAXUAAAGQAAABxAAAAXoAAAFjAAABMQAAATMAAAFeAAABNAAAASIAAAErAAABZAAAAYIAAAGWAAABegAAAWYAAAFrAAABYQAAAWgAAAFdAAABHQAAARYAAAEpAAABLgAAAU4AAAFhAAABWQAAATMAAADyAAAA9wAAASoAAAFjAAABIwAAASUAAAEyAAABLQAAATkAAAE2AAABJgAAATAAAAEkAAABlAAAAZ8AAAEaAAABMQAAAS8AAAE0AAABNgAAAQcAAAElAAABWwAAAZoAAAGpAAABIQAAATcAAAGDAAABrAAAAZ8AAAE2AAABoAAAAZcAAAGNAAABJAAAATgAAAExAAABfAAAAYwAAAGnAAABVQAAAX4AAAHHAAABrAAAAbYAAAHCAAABowAAAbkAAAGkAAABagAAAXMAAAGIAAABZgAAAWIAAAFXAAABLgAAAVEAAAEmAAABAAAAASgAAAE4AAABOQAAAVEAAAGmAAAB3wAAAZ8AAAF+AAABVwAAAU4AAAFZAAABYAAAAV0AAAFcAAABNAAAAWgAAAFeAAABLAAAAaAAAAGkAAABmgAAATEAAAFBAAABKQAAAPMAAAEZAAABLAAAATIAAAE4AAABQQAAATgAAAEwAAABKAAAASsAAAFVAAABXAAAAV8AAAErAAAA/QAAARgAAAGDAAABywAAAZQAAAFbAAABNAAAATAAAAFYAAABbAAAAWIAAAHBAAABmwAAAcQAAAFxAAABjwAAAY4AAAFlAAABMwAAAU0AAAFrAAABWAAAASsAAAFpAAABowAAAawAAAE0AAABXAAAAYgAAAGAAAABegAAAVkAAAEjAAABIQAAAS8AAAEpAAABXQAAAZEAAAGqAAABoQAAAZQAAAEwAAABogAAAa8AAAGUAAABewAAAVkAAAGfAAABaQAAAZUAAAFjAAABNQAAATcAAAFQAAABlwAAAVcAAAEtAAABqQAAAZ0AAAGbAAAA8wAAASAAAAEjAAABSwAAAYAAAAGNAAABWgAAATMAAAFIAAABLwAAAVMAAAE3AAABLgAAASUAAAEqAAABcAAAAWsAAAE3AAABKwAAAPIAAAEBAAABJgAAAQEAAAGQAAABkgAAAY0AAAGeAAABJwAAAUwAAAHQAAABjwAAAWsAAAFGAAAA+AAAAQAAAAEyAAABMQAAAT0AAAGbAAABeAAAAYsAAAGHAAAB2gAAAa8AAAGyAAABaQAAAV8AAAEzAAABNAAAAYIAAAFRAAABVQAAASgAAAE5AAABRgAAAS4AAAExAAABtAAAAcIAAAHDAAABgQAAAX4AAAFhAAABcgAAAXgAAAGSAAABsAAAAbEAAAF9AAABZAAAAbEAAAHyAAABuQAAAZQAAAFnAAABMgAAAS8AAAFeAAABkgAAAYgAAAF9AAABbQAAAV0AAAFkAAABOQAAAS4AAAF+AAABwgAAAZ0AAAGkAAABVgAAATEAAAErAAABYAAAAYQAAAF8AAABnwAAAX0AAAFXAAABNgAAATcAAAEuAAABIQAAASAAAAGZAAABhAAAAY0AAAGfAAAA/AAAAUAAAAFxAAABZgAAASoAAAEkAAABJgAAAS8AAAErAAABNgAAASQAAAGYAAABmAAAAZcAAAEmAAABLQAAATYAAAEzAAABMgAAATMAAAExAAABKgAAATcAAAExAAABYAAAAU0AAAFOAAABUAAAASoAAAEgAAABFgAAASIAAAEkAAAA8AAAAPsAAAECAAAA+wAAAZkAAAGTAAABjAAAAZAAAAGOAAABkwAAAU4AAAFSAAABVQAAATUAAAEsAAABmgAAAZcAAAGbAAAA+wAAAQAAAAD7AAABSwAAAVAAAAExAAABJAAAASYAAAE/AAABGgAAAagAAAGXAAAA/gAAAYwAAAGMAAABhAAAAZIAAAGaAAABJAAAASkAAAEyAAABvQAAAdcAAAGpAAABHQAAAVMAAAGrAAABawAAAZ8AAAF3AAABkwAAAbQAAAGHAAABpgAAATUAAAE8AAABVAAAAaAAAAGjAAABlwAAAWYAAAGMAAABXgAAAWEAAAGLAAABiQAAAXEAAAFYAAABcQAAAVkAAAEmAAABlwAAAaoAAAGSAAABLQAAASsAAAEfAAABMwAAATUAAAExAAABlgAAAZMAAAEjAAABVQAAATYAAAEyAAABJAAAASoAAAFyAAABqwAAAaAAAAGeAAABiwAAAWIAAAG3AAABqgAAAV8AAAGIAAABfwAAAYIAAAFpAAABtgAAAZcAAAEgAAABIQAAAaMAAAGjAAABMQAAASoAAAGVAAABjgAAAZAAAAEqAAABMQAAASoAAAEjAAABUgAAAXwAAAFHAAABAQAAAS4AAAEyAAABMAAAAVIAAAEnAAABBQAAASIAAAEyAAABJwAAASYAAAEsAAABJAAAAS0AAAD3AAABJwAAASsAAAEsAAABJQAAASMAAAEWAAABtAAAAawAAAFnAAABbgAAAYcAAAFeAAABOAAAAR8AAAD2AAAA8gAAAZcAAAGgAAABZwAAAP4AAADvAAAA7wAAAY8AAAG8AAABiwAAATQAAAFxAAABcgAAAZ0AAAExAAABJAAAATAAAAEzAAABIAAAAZgAAAGjAAABGQAAAZIAAAGqAAABhAAAAUsAAAD2AAAA9QAAAZgAAAGKAAABLAAAAWUAAAEqAAABkwAAAaMAAAEjAAABNQAAASkAAAGaAAABmAAAASwAAAEtAAABNgAAATMAAAErAAABWAAAAScAAAEdAAABjgAAAZIAAAFCAAABrAAAAbEAAAGaAAABcQAAAU8AAAEqAAAA9gAAAZkAAAGIAAABGgAAASIAAAEqAAAA/QAAASwAAAEnAAABJAAAASoAAAFVAAABNAAAASoAAAD6AAABRwAAAbkAAAGsAAABRAAAAY8AAAGMAAABigAAAZMAAAGPAAAA+QAAAPMAAADxAAAA8gAAAY8AAAGXAAABlQAAAZEAAAGMAAABiAAAAY4AAAEgAAABLwAAASMAAAGIAAABgQAAAX4AAAGOAAAA/wAAAPkAAAD5AAABkgAAAcYAAAGBAAABlwAAAZwAAAEvAAABNgAAASMAAAGdAAABkQAAAZUAAAEcAAABHgAAARkAAAD3AAAA+AAAAZcAAAGeAAABhQAAAY8AAAGWAAAA8gAAAZQAAAGUAAABiwAAAZwAAAEmAAABJgAAASkAAAGYAAABjgAAAaAAAAGRAAABJQAAATIAAAEbAAABGwAAASgAAAExAAABIwAAAZYAAAGYAAABKQAAATUAAAEkAAABFQAAASMAAAGTAAABnwAAAPoAAAElAAABIAAAASwAAAGZAAABmAAAAY4AAAGYAAABmwAAASEAAAEjAAABkgAAAX4AAAGUAAABKAAAASQAAAEuAAABIgAAAPwAAAD9AAABHwAAAQAAAAEpAAABMwAAAS0AAAEpAAAA/AAAAZEAAAGgAAABLQAAAVoAAAE0AAABlAAAAc0AAAHCAAABXQAAAVgAAAE1AAABWgAAAaMAAAGMAAABmwAAASsAAAGbAAABqgAAAV8AAAErAAABJwAAAScAAAGqAAABeQAAAZcAAAFRAAABLAAAASUAAAEnAAABJgAAAVsAAAFlAAABWQAAAUkAAAElAAABOgAAATAAAAEvAAABGwAAAR4AAAF4AAABzAAAAZsAAAFqAAABZQAAAWQAAAFgAAABOAAAAVgAAAEoAAABYwAAAYIAAAGLAAABngAAAY8AAAF0AAABnwAAAXgAAAGJAAABXQAAAVkAAAGkAAABkQAAAa4AAAF7AAABawAAAW8AAAFgAAABYgAAAVUAAAFkAAABYgAAAW0AAAFVAAABMAAAAPkAAAFBAAABewAAAZQAAAGAAAABpAAAAYkAAAF0AAABhQAAAWcAAAFzAAABlwAAAZsAAAGIAAABowAAAa0AAAFjAAABtAAAAZ8AAAFXAAABNQAAAV8AAAGCAAABiQAAAZEAAAFdAAABXwAAAVQAAAGUAAABmQAAATQAAAFRAAABhAAAAVUAAAE5AAABHwAAASsAAAE7AAABLAAAAaAAAAGPAAABUQAAAWUAAAFcAAABIAAAAP8AAAGYAAABnQAAASYAAAEpAAABJgAAASQAAAEhAAABMgAAAVEAAAFXAAABNQAAASoAAAD/AAAA9gAAAPEAAAGMAAABiQAAAY4AAAGGAAAA+QAAASUAAAGXAAABmgAAAS8AAAEqAAABMwAAATgAAAEwAAABHAAAANIAAADtAAABiwAAAY8AAAF3AAABoAAAAXsAAAGMAAABmgAAAP4AAAD5AAABoAAAAZkAAAEmAAABNwAAAS8AAAElAAABJAAAASkAAAEmAAABFgAAAZMAAAGUAAABGwAAATMAAAETAAABGwAAAUoAAAEaAAABkQAAAUsAAAEpAAABKwAAASUAAAEVAAAA7wAAAQIAAAEiAAABLwAAASYAAAE1AAABHgAAATgAAAEeAAAA8AAAAYYAAAGCAAABiwAAAX8AAAFHAAABcgAAAVYAAAD+AAAA/AAAASAAAADpAAAA5wAAAPkAAAD1AAAA9gAAAPQAAADuAAAA6QAAASEAAAE2AAABGQAAAZAAAAGRAAABJwAAASoAAAEfAAABhgAAAXgAAAGNAAAA9QAAAYoAAAGRAAAA7AAAAPEAAADxAAAA8wAAAPYAAAEeAAABHgAAARkAAAGMAAABiAAAAYAAAAGTAAAA9wAAAPcAAADxAAAA8gAAAQQAAAGlAAABhAAAAZQAAAEiAAABIgAAASMAAAD4AAAA8wAAAZgAAAGQAAABoAAAAZoAAAGYAAAA9QAAAP0AAADxAAABEwAAASwAAAEiAAAA9gAAAZ0AAAGQAAABkwAAAR0AAAElAAABOgAAAZsAAAGeAAABHgAAAR4AAAEfAAABIgAAAR0AAAEhAAABJAAAASkAAAEdAAABjwAAAYYAAAD4AAAA9wAAARgAAAGQAAABkwAAAZQAAAGLAAABIgAAATAAAAEfAAABFAAAAPcAAAD1AAABIwAAARcAAAEkAAAA6QAAAYgAAAGWAAAA8gAAASgAAAEoAAABDgAAAYcAAAGBAAAA7gAAASMAAAEwAAABJQAAAZIAAAGLAAABjQAAAPAAAAElAAABLQAAASoAAAEWAAABkgAAAZ4AAAGYAAABHwAAATUAAAEeAAABHAAAASkAAAExAAABHQAAAYcAAAGLAAAA9AAAAPsAAADyAAAA8AAAAYcAAAGTAAAA9gAAAY4AAAGbAAABKAAAASoAAAEdAAABjAAAAY8AAAGYAAAA8gAAAPkAAADxAAAA8wAAAZoAAAGNAAAA9wAAAQEAAAD9AAAA9wAAAPEAAAD0AAAA+wAAAOsAAAD5AAAA8QAAAP8AAAEjAAABLwAAASAAAAGYAAABhQAAAPYAAADqAAAA8AAAAY8AAAGGAAABkgAAAYcAAAF5AAABhAAAAZYAAAGLAAAA8AAAAPQAAAGDAAABiQAAAYkAAAGEAAABegAAAX4AAAEQAAAA5gAAAPwAAAEZAAAA9QAAAP4AAAD1AAAA7QAAAYwAAAGJAAAA5gAAAXgAAAGFAAAA9gAAAR8AAAF+AAABhAAAAYkAAAGBAAABHQAAASwAAAEhAAAA9QAAAR0AAAEDAAAA+gAAARgAAAEpAAABDwAAARcAAAGYAAABdQAAAX8AAAGPAAABHwAAAYgAAAGQAAABGQAAAREAAAEPAAABDAAAAXwAAAF+AAABXQAAAChzdHNjAAAAAAAAAAIAAAABAAAACgAAAAEAAAB0AAAABQAAAAEAAAHgc3RjbwAAAAAAAAB0AABHuAAAW/UAAHAFAACC0AAAmoMAALCSAADFwgAA3IcAAO4FAAECdwABEgIAASN2AAE3ggABTZoAAWa8AAGAiwABlUUAAafzAAG4ygAByIkAAdgNAAHrDAAB/hYAAhHwAAIkFQACNqEAAksnAAJd6gACbdwAAoOeAAKaOgACsCMAAsWqAALZ6QAC7fEAAwH1AAMR9AADJP8AAzW3AANFWQADVs0AA2qOAAN+HgADkmEAA6RmAAO5uwAD0YYAA/gRAAQNXgAEH0sABDIWAARDrAAEU98ABGSTAAR2WwAEhpQABJfEAASrnwAEvTgABM01AATohQAE970ABQwGAAUdnQAFL30ABUGMAAVUjQAFZhwABXg+AAWJSgAFmz0ABa8pAAW+AwAF0M0ABeRHAAX9tAAGD08ABiOSAAY2OAAGSYsABljyAAZtbgAGf8UABpCBAAagKgAGsY8ABsIQAAbUuAAG55wABv6UAAcWkgAHJXMABzcPAAdHpAAHaPcAB3tVAAeJdQAHnFQAB66yAAe/rgAHz9UAB98mAAfvMwAH/7YACA8JAAgnWAAINmoACEhcAAhWcAAIY2oACHQtAAiKPAAImSIACKfYAAi0VgAIwqsAAAAWdWR0YQAAAA5uYW1lU3RlcmVvAAAAb3VkdGEAAABnbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcgAAAAAAAAAAAAAAAAAAAAA6aWxzdAAAADKpdG9vAAAAKmRhdGEAAAABAAAAAEhhbmRCcmFrZSAwLjkuNSAyMDExMDEwMzAwAAiXYW1kYXQAAAJ8BgX/";
		// videoData += "/3jcRem95tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTEyIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxMCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTIgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9NiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0tMiB0aHJlYWRzPTMgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0yIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTAgb3Blbl9nb3A9MCB3ZWlnaHRwPTIga2V5aW50PTIwMCBrZXlpbnRfbWluPTIwIHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMC4wIHFjb21wPTAuNjAgcXBtaW49MyBxcG1heD01MSBxcHN0ZXA9NCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAM52WIhABX9/oAKWTe0vigvEk2XEvOlCv8nzP6QKpCPye+/BdkDN7MCUQJQWX2hHMqrGEx7QG64F42xjntT0IEv8PZ0B2hN59FwmqwQwM5TqlPTV2rNjajE5mfwjM/NmViPNXglsFtIhm4C8z0p1S5Kxb6Z0qGmjDstGAfsBoFArujzledYJUd5I6s7+xgcMuw0s38YuwbIrnJqk/VGEF9MiyzZPLTJvtvLWxWqkOFTLUrfP6l/6mznwt/AZu+MUtaou56pE2i+Bhk3kdA/vTHgwEcY5uk2K+WBja2u8qFsy+kQIGmUG9djqFF+on3byv792VrSt/KQiN1ghwQldPi+uPDPTe7DjxFcn4jUAbDhwfuPLE5Em/4F+o2dPmviy5+YXSjuAvP6suvRM5YX6iBeeZlCpt/S/4Fkxd1beFqN6zFFUr8ShvX7eou2E0nn8RoU/50wbZ9MYn4B2BzDmyTxCx514suDkOYJodFkWQvbHFl/cK5wYddQi8wvYO0oSU9djHr5gMFBtjANqhSywi3Bqd6QY2v++9w3E+9qXiM7LWughp3JwqbPMy1hMIV7LCZtf7H6h5jz8hQ3uBs+CC6t+T54NLT+7gaf1HObthKkmQMUtixTfnGWk9F8mQXO2eiKJfXelph/W40hZtE/SWlFRjNfM+RSmBpyta0a5qJzX3UnX4NOp2PXVyvc0CjmDYBpqdJn9x3p3PCijpufno1gCGyijYXnvUo8t/k12mHYw+ykT7UZKc6/xy26Sy/Tohw2VXisfc/Pfzc6JG/pxM9h9HBEArfr3SosSStNgluUUq/ldeNGNyXPVGdJYQ4sACAfRBNG8lPpVQISEMTNC7z6m8R8S2h/SgLyfkOemIrgsjPSsv9lnn7owYtVGDpFGow30hYX/kHIebsMOYtaOiaIFRJcNMJRm2RkLlmOuNpPlGxJbp4r5yrWi7oK2WNLMKKsMLXI3ztmGrEzdZQ5lcOnKyqr6S59RVB7/rl30wCA41+ELgW8UyYX8Yo25msjVqdZCSGKfOY1WaBh4P3EXCoHALMpSkTIG/RwwIqOtvSgvtLS4m6pdKqd+7FUQNWyuEdB8NnNXpHgM5JPWsAH+B9NXhJJGq+WndUtqETP5f4qRpablMSlpCgf9bou7muV1kKXFMei5L5ZTAP9azMqehe47KL7xpOs9OPdvx7bu+UZAMpny6csmS8Tcm5WFCKQaJNHAuqAeGhVdB+sCCWZcYTZ8UK0DENYIAVwsiS2YTfDRdS/QFIu+anpY33WCCN0BdXXA/USuCT2z/39A2iNzyVKnxafz4yxDTuXu5QSo0GIXmuJy3gKcsfMYsbLRe0HYmKy8PoeN+V7bmiKAQLX4Hq00t3c8kpEmndf4sp2gO7BKrr+8epxyaQtaZ9O8jbt2dcDGDr2GkTNLdV+hu5xJ3ocvOtqFjzpM2BY+ibIOM3IVZiUjVEdPxIV9CE2hSRGQQaVB8ZRUWtqqoowszAl+jKDpTp8wx6dwnKZipaWUkJJAwiYOzqDPwRmYj8AivhxCKwMoyzECmyVgIXbFUUNTNHPdDVaxXhD78+6D/dIiANrTMesC7c2nVgN5efnrKnqAORu/RBGBL6cXJ6Pqhn5n5QnDxI2pJvP/xtsNEvD8wdw1a1QcyAa0Vkic8gPneeRVbZftUwO412Efx3gUEC/XZDYP9DfigO6MV4MB/snD2K1wkocWyyeEZ5d/Nx4pW5tCAuUtmYxUJ6BbTnsWbBDI7O5rFiUr5TconXvK+Zqy3MFSIOokTJclhLS3zOlzEBrHcD9j69yFCK3Xu3rJ/LIE+BipE45YCP1YKpSF/F8npLrpqV37LOtgOKbvlGSe1+JUKZwLglPKho5mwkcD2BlXrKOrg5dcd0FwJiu+5MzHPawz2gpeWqCnYWcrhWwuuRTouPPORhRn5ESTPQK7OYsxJMf2DmkffL4IqFqFoCW8IrE8shUsdTHxo/iuR0X1zoC72dKMeTdyZ83c3+jrR5YXQvmbZ/PqZ2DKUPNlIJKATVSYEjxf4YKMhjZhVtkbma4xpZgD4AlFvNeQrJm7qdkGWUR7Nai4yQyLgnm9RysJz2OAtIxXaCnkSsAhqtXvoAtTbnVjv7QpPzUbAQQU9uacaZ1GbLqb5pNf/ZGlZGFiQOfnd6zkUX87jMX72eEXIfjEnxO89wvlGsUpdgMZbSeTVZSnzmk0Ymc/ZJAID1U1Tcb3Oj/8mhia6u0Iwxl+2BRORD8ArkISZ0yIXFu10Z/Pau08beqcv3GBjJqlx1OCAEiY9MMXUdIApNdtIc/AFpjDejQuCkSM8a44uTjQkuXE5RaNp50+1UgO9Dh/DlAJ0WteecdFv0wy2/Wr6z9mg/UOJEIpu8wEpLyyC3zTTYEk1djBSwm64Gbn7glbjapAXjd/0GulBHKDtbBdDVsEoZUO0G4JKE+xKm6gZD1CFT/oXHGbwhGr4GcYA7DIEV5WIsPPkXnU9PfDM8D0oMib+sOZqDfvnjw2eSGsPPnfbfTgIDt9FRWsYA2ioMvSOis28eBItIxxGPNgTTgSj/008K30j8EiBsm1UjcBDszqO96FOhij7i2F0aiCrDaDP0fo/dZ6oK20/gVSgkpdAnpkYjbnGMWBhCZbjTABmbBPx1vsjrsQajyms8RqD2HypL9oVfCH7Pnk3fPP/u69nM13AKO46RxBHs9zrUhE54sdVE5SRS9cmHQn4B/1RlzbOwqkoGFnuwdPHWPpNaamiitLNlehGYR0Jkptho++BM/kzo1Ix5s7LpJixZXsXFBVwfnI0jhhC23saS1cl6XWwt0v7F4vLSKUwhbAbaf1RLBkHll7sJksaAQQkQwW1zCebQ/ortRMk5jg0CUzcNwvIFYiZ2m2wnVMEg/+4LQgHl7Ovax17MvCwo4gPHectnt6/pzTykUOHWE7aeCKEH6uH6dhyF5/F+LwAFO/aolvTvMhBymvOFMWWEd4lCv/Q7nqVSNVPw4+sqQStCKCDGZcSGqMdhvyMCpsedqfaXAuARZLdnKyItKbIiNLeGreLmG2WwsmRcvkibZAGea4GnRhBZKPGbQq09u0ETkXv03y9lXQ3ohapI978oHNdRDp+fgDT+ke6JjjJd41TluRvgT0z0yUnWEp5Gam2eiyYxxHHadM5Dnc5l2uxdKgmJij5xEuLboCd1OrBYhfPebw3azcy8rdXoryDzTQ3RErZigU3e7/GGbgH5YfJ4MVM920hS6Egut92QhTuxye3IxVWHZYit9+xIls7IryONX41HPxE5K5nEerON8oKPTDBFy8Bm+6gkaWEtNexGcXWuRJG3FA7gvVn122sMe3lqKI7FXqKuMCb/ANgXnJhu+5TVQDT/BBh36LQQCkMuErwIGLJ6o+XdY38fCfonDiusXt09hJXsXZkTpHydh9q9y/cRAJoDo/HehJa2Ji6t7ZPzouVYrFkqu/WVX/FjOxjUjkGMe4tBze1nFx/cKYpllVuTpkU4RMMvwcqUAn36096UCzRtNJxMHDCqC0idfEto3i2QQAbgDdoK1zX+8vsIvA1JQT9F5Sl02cRtJdzgOgP92YllpHvVGdxUoMkkM3BsXoOfZT/LB9/hNc41F62+ipdmFLGpjHjsDGH1FviGfHOCbRP5JnwfIN/nUy7I3l6hvrFXbIn2eWkPVASOoAocvVTerYlkUrYNdCH49UafnTZV5U9wjM/PQGdC9yBYam96c/kH2L2zabIIGxCx2RippJiG+4cv6joLDwmNrnt8mMWY8VQzSpPDtpqfiQI9f8/N4L2soypiOrHuCw/nj85OHixeK1CEm/+qJ21EtFpDHQG/dW6x09kEE9o3MdqSPKill933ZHoCmRdwh8UNfUPNDYJAqp/50PadMPm2UiVak6C2z+Brd7y2JxLU0Dysnmw2TtVTjBxXYdJlNK51ii+JMk9E7NLOEC5WnzLhEDud9TKPqulS4CHcIdtxQVSl0PodyLO6myuKhCzYElxCxIbrtZKsXG5XNf85azXTyi9TkO/QkIBFjUX28KWD52SpMbyZUGWHySBSKSEtofq6hG1sSDGlynseSIfdx84jJKgGuZ0pYL2K16cMuDGdYIby7OBApG5EI8LZhTLxaMiVmLSDbxvCZywtzC2OGfHMnEPExiXHFDlOoadkg9RB3nQKqIsDhs8Xl6hrJL4Ud2yS6AKGpOgGOcbyX4gOgf0u7rZctAKvDGXcTNa6dw37iXUE8m8w1omF/YRQVxNsjcC7iXHeTtGC2KADEtjkrmKCCbAuedAHSlWEmaO0pfSVkKBmlvHvvEDdIL27hZc8x0DTV4CDs1NP8kQUSW/N9YKZk42bHpeOLRrb4LSuD38OQ1SSnuVdwt03dSZEGogt72fzIyGsrbPWNFCeVDMakLLK0ODZDg5wJzCTgQAAAZpBmiFsRX+ivshLmrGQEHzO4HCkXgUZUoi4O5hq/PGPaMqn6Tq4QkcRk2vxonpJ4zodrMHT+sxg8/GAD9kZ8sSLNcAAifWy22lbi6tDJY6/jkFpv9tao84lAHcJFm4DU2nx0/KGn4bVxY7Hw7lQrj4+Tf5iwLK0LImLSZs+t068PDudf3YLsd9LusgxERyQReKRViHgGoujcAijs6xhLHRXQ+710JZt/81gmtmRzkx7rEH+sP53gGU1EngIKPhDsvCrCQekhQnQPkkDrojtTE2cbAfSlvqpWcllKlnzo+omklJ3t3+/iQi7SKlc1TSZw9i4UVmQk6RzSXqxCm6yGjkLWt9uea3kIjS75fVlgZ5qoPdAlpgdWKj024/Mbctjd/ecE9RLfjT81wB804ZPXdPhUQ8m4dX3lBkRJ63FjpS0EpILogvBODn5/U0h8/tmGLdKiUFh9yAgWqLL3j/629aA9dwVTMwFLN9F8vtUwz2cG7ST5fk/IbOQOAWJbx10KD420JYCzlviCzro/k+LaXgsj7hbuoRjINi3vAAAAsBBmkJfhDJlMIr/ZSLnm37Dwwi0UQkBezI4aFhtRCKrXIQs4uxI+Es451+ZVsV0RKhTJrqZOFQ8vdhTYN9gf34W/yCNAnUubDuixPt6OeAU5+RW5232Vo1tfALucNK/+F5QyIOk4mQ2Sxv81hNmDxq3kLwS76k8HFJ6gKlyQtQrHTxxQ7MtcbI8y5Hsek5axPJ7IhTnkRnm+NWpY9djAZrv9UGVeiH5ScGRptSgrxhWulxHOboDReiU95dnKz/VAIPF9lOCR0YlwPTRKnfXsXO7pgB92F16sa9fyXxEm/wp3+JaN/SAJbphj35KTM0Tv2MsA4A2ZSRCmsy/IjxMCMKbb5u32uEczCK0DYP1mEWrNRcrsyqSN8N2i7b4quGR00bv4qaMZN4z0s0ef0IoYzua3tigeC1ZV+xAoiXTaSLPjV+egDDEisdRRlNX6FuQEwml9x/6PdlQHeY7HybTEgEYWgqDYQTeuizEWDyMzynQxF5ErK1bkpy2v5OfzjREhpR0FATtTW9C4+Y+1oLLDjPPKTj9Z1Kn9kLiLeYn0mZOf39QB9QNrJKl4Z9mKrPAnbJOCgMoWHozruShXSkuMM2vd7yWXP5QLRZXc4Uj6Gky9hUFm9p6KnYn5AInjuul8L0YcgTGgKqiHu4qd9Ykt44VX7YrqrInfoHC8VvRXBH4udepdG4B8peMuYGu2AG3/DG7Ev0oAZspGtbRJbAYIsGpAuIC87P+l4w3KLhtg5B+65OLwheObKeCu9Hc4GFCEm0w+po3SwpDpMA+h9QySOUGqAXnLUsBhtrjk9rAZfI5qU42q7haNgUH0For6riLo53XYMuCt27cL+WkWnq97gq6hSh4zcvdpOkQld8MflIV0tK4OaSr7mVNh3HMeYmUdvMUC+b7Dx2mgns7fZARDxAifs5TZ53tGXT8AAc4gjfIQQAAAiNBmmNfhDJlMIr/eFmZvSnAXxI85A2d6FfMH5NSS/uOgVaI0WwGW5Poep0EmDQl60C4NjRH2gAqane+hk9HMX5qG3JHLO2O1RJLKL/xYG+bNFJ0G+Snx6QG0TgzR9Iy55Iyp1qlEryqG5IdffR79t8ZTIeA1cgyVoJbHKIpGP3vAuHBFxgQ6ishoaGNP/AUppJ1xWXZYa8mOHMqdVyJL4hLjo0/A6ijjRRY8Y9CAOUck9YyVxYdTryXhHo4TqxC5yDXD0a7oY0bm9And6hJN3jIH20NpckaRoBNWI84v4vChcAkvaRH5gczCRU1uTwEX84Jv8noNnh/decs9ZTl9bXk+qbyf+zuXJcR6wwyJa5zK6zHMERb5W9JXBxRTlqDD/GqQcWQsE0ObZfWXRqaM7OSx1nDQA/o+qCdPLkNJNxSyI7bJq4gAPf/DcEjJFBbCVkW7naKn+foUpfi1HZJ/qeJVRgkPm7ljMKAeUrDiqWxsLR6nI7iV8iQSo/hvQDnxohd1zFpXk+rHmniiJAGhE3gzwxMbcKcjrLQmD8dPyV4AKZ6sHzwcDBUZ12Gdmk36035BE97psdv/FcLE4kmeXRihohBKzzxb0UU+j0PVIYnLfEIDrNtoH/15rraut660euQ6giOm4tjvya50Fa4dk/V9zFYA6ymKo6Rt5Aq2TQyYMSUhggZH9YnMYMHaUzomMFntBGvTTi9Zb8Xmh1whhARi1FL3gQAAGxpYmZhYWMgMS4yOAAAQlMf";
		// videoData += '" ></video>';
		
		this.object = L.divIcon({html : this.content});
		
		this.init();
		
		this.update();
	}
	
	init() {
		super.init();
	}
	
	setContent(content) {
		let undef = this.getCheckFunction("setContent");

		if(undef(content, "content"))
			return false;
				
		if(this.content == content)
			return;
		
		this.content = content;
		
		this.options.html = content;
		
		this.update();
	}
	
};


/**
 * WidgetGeoMap::GeoPolygonStyle
 */

class GeoPolygonStyle extends GeoStyle {
	
	static getDefaultStyle() {
		return {
			stroke : true,
			color : "rgba(51, 136, 255, 1)",
			weight : 3,
			dashArray : "",
			dashOffset : "",
			fill : true,
			fillColore : "rgba(51, 136, 255, 1)",
			lineJoin : "round",
			fillRule : "evenodd"
		}
	}
	
	constructor(properties) {
		super(properties.GeoStyle);

		let undef = this.getCheckFunction("constructor");

		this.geometries = [];
		this.options = {opacity : 1, fillOpacity : 1};

		let options = [
			"color",
			"weight",
			"dashOffset",
			["dashPattern", "dashArray"],
			"fillColor",
			["bordered", "stroke"],
			["filled", "fill"],
			"lineJoin",
			"fillRule"
		];

		this.initOptions(properties, options);
		
		this.setGeometries(properties.polygons);
	}

	setGeometries(geometryIds) {
		if(geometryIds == undefined)
			return;

		let mapObjects = geoManager.objects;

		for(let i = 0; i < geometryIds.length; ++i) {
			let geometry = mapObjects[geometryIds[i]];

			if(geometry == undefined)
				continue;

			geometry.style = this;

			this.geometries.push(geometry);

			// geometry.callObjectsMethod("setStyle",this.options);
			for (let mapId in geometry.maps)
				geometry.maps[mapId].setStyle(this.options);
		}
	}

	initOptions(properties, names) {
		let undef = this.getCheckFunction("initOptions");

		let name, baseName;

		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}

			let option = properties[name];

			if(undef(option, name, properties))
				return false;

			this.options[baseName] = option;
		}

		return true;
	}

	setOption(baseName, value) {
		if(this.options[baseName] == value)
			return;

		this.options[baseName] = value;

		this.update();
	}

	update() {
		let geometries = this.geometries;
		let options = this.options;

		for(let i = 0; i < geometries.length; ++i) {
			let geometry = geometries[i];
			if(geometry != undefined)
				for (let id in geometry.maps)
					geometry.maps[id].setStyle(options);
		}
	}

	getNumObjects() {
		return this.geometries.length;
	}

	hasGeometry(geometry) {
		return this.geometries.indexOf(geometry) > -1;
	}

	addGeometry(geometry) {
		let undef = this.getCheckFunction("addGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(this.hasGeometry(geometry))
			return;

		this.geometries.push(geometry);

		for (let id in geometry.maps) {
			geometry.maps[id].setStyle(this.options);
		}
	}

	removeGeometry(geometry) {
		let undef = this.getCheckFunction("removeGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(!this.hasGeometry(geometry))
			return;

		let geometries = this.geometries;

		geometries.splice(geometries.indexOf(geometry), 1);
	}

	setColor(v) {
		this.setOption("color", v);
	}

	setStrokeWeight(v) {
		this.setOption("weight", v);
	}

	setDashPattern(v) {
		this.setOption("dashArray", v);
	}

	setDashOffset(v) {
		this.setOption("dashOffset", v);
	}

	setFillColor(v) {
		this.setOption("fillColor", v);
	}

	setBordered(v) {
		this.setOption("stroke", v);
	}

	setFilled(v) {
		this.setOption("fill", v);
	}

	setLineJoin(v) {
		this.setOption("lineJoin", v);
	}
	
	setFillRule(v) {
		this.setOption("fillRule", v);
	}
	
};


/**
 * WidgetGeoMap::GeoRectangleStyle
 */

class GeoRectangleStyle extends GeoStyle {
	
	static getDefaultStyle() {
		return {
			stroke : true,
			color : "rgba(51, 136, 255, 1)",
			weight : 3,
			dashArray : "",
			dashOffset : "",
			fill : true,
			fillColor : "rgba(51, 136, 255, 1)",
			lineJoin : "round"
		}
	}
	
	constructor(properties) {
		super(properties.GeoStyle);

		let undef = this.getCheckFunction("constructor");

		this.geometries = [];
		this.options = {opacity : 1, fillOpacity : 1};

		let options = [
			"color",
			"weight",
			"dashOffset",
			["dashPattern", "dashArray"],
			"fillColor",
			["bordered", "stroke"],
			["filled", "fill"],
			"lineJoin"
		];

		this.initOptions(properties, options);
		
		this.setGeometries(properties.rectangles);
	}

	setGeometries(geometryIds) {
		if(geometryIds == undefined)
			return;

		let mapObjects = geoManager.objects;

		for(let i = 0; i < geometryIds.length; ++i) {
			let geometry = mapObjects[geometryIds[i]];

			if(geometry == undefined)
				continue;

			geometry.style = this;

			this.geometries.push(geometry);

			for (let mapId in geometry.maps)
				geometry.maps[mapId].setStyle(this.options);
			// geometry.object.setStyle(this.options);
		}
	}

	initOptions(properties, names) {
		let undef = this.getCheckFunction("initOptions");

		let name, baseName;

		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}

			let option = properties[name];

			if(undef(option, name, properties))
				return false;

			this.options[baseName] = option;
		}

		return true;
	}

	setOption(baseName, value) {
		if(this.options[baseName] == value)
			return;

		this.options[baseName] = value;

		this.update();
	}

	update() {
		let geometries = this.geometries;
		let options = this.options;

		for(let i = 0; i < geometries.length; ++i) {
			let geometry = geometries[i];
			if(geometry != undefined)
				for (let id in geometry.maps)
					geometry.maps[id].setStyle(options);
		}
	}

	getNumObjects() {
		return this.geometries.length;
	}

	hasGeometry(geometry) {
		return this.geometries.indexOf(geometry) > -1;
	}

	addGeometry(geometry) {
		let undef = this.getCheckFunction("addGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(this.hasGeometry(geometry))
			return;

		this.geometries.push(geometry);

		for (let id in geometry.maps) {
			geometry.maps[id].setStyle(this.options);
		}
	}

	removeGeometry(geometry) {
		let undef = this.getCheckFunction("removeGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(!this.hasGeometry(geometry))
			return;

		let geometries = this.geometries;

		geometries.splice(geometries.indexOf(geometry), 1);
	}

	setColor(v) {
		this.setOption("color", v);
	}

	setStrokeWeight(v) {
		this.setOption("weight", v);
	}

	setDashPattern(v) {
		this.setOption("dashArray", v);
	}

	setDashOffset(v) {
		this.setOption("dashOffset", v);
	}

	setFillColor(v) {
		this.setOption("fillColor", v);
	}

	setBordered(v) {
		this.setOption("stroke", v);
	}

	setFilled(v) {
		this.setOption("fill", v);
	}

	setLineJoin(v) {
		this.setOption("lineJoin", v);
	}
	
};


/**
 * WidgetGeoMap::GeoCircleStyle
 */

class GeoCircleStyle extends GeoStyle {

	static getDefaultStyle() {
		return {
			stroke : true,
			color : "rgba(51, 136, 255, 1)",
			weight : 3,
			dashArray : "",
			dashOffset : "",
			fill : true,
			fillColor : "rgba(51, 136, 255, 1)"
		}
	}

	constructor(properties) {
		super(properties.GeoStyle);

		let undef = this.getCheckFunction("constructor");

		this.geometries = [];
		this.options = {opacity : 1, fillOpacity : 1};

		let options = [
			"color",
			"weight",
			"dashOffset",
			["dashPattern", "dashArray"],
			"fillColor",
			["bordered", "stroke"],
			["filled", "fill"]
		];
		this.initOptions(properties, options);

		this.setGeometries(properties.circles);
	}

	setGeometries(geometryIds) {
		if(geometryIds == undefined)
			return;

		let mapObjects = geoManager.objects;

		for(let i = 0; i < geometryIds.length; ++i) {
			let geometry = mapObjects[geometryIds[i]];

			if(geometry == undefined)
				continue;

			geometry.style = this;

			this.geometries.push(geometry);

			for (let id in geometry.maps)
				geometry.maps[id].setStyle(this.options);
			//geometry.object.setStyle(this.options);
		}
	}

	initOptions(properties, names) {
		let undef = this.getCheckFunction("initOptions");

		let name, baseName;

		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}

			let option = properties[name];

			if(undef(option, name, properties))
				return false;

			this.options[baseName] = option;
		}

		return true;
	}

	setOption(baseName, value) {
		if(this.options[baseName] == value)
			return;

		this.options[baseName] = value;

		this.update();
	}

	update() {
		let geometries = this.geometries;
		let options = this.options;

		for(let i = 0; i < geometries.length; ++i) {
			let geometry = geometries[i];
			if(geometry != undefined)
				for (let id in geometry.maps)
					geometry.maps[id].setStyle(options);
		}
	}

	getNumObjects() {
		return this.geometries.length;
	}

	hasGeometry(geometry) {
		return this.geometries.indexOf(geometry) > -1;
	}

	addGeometry(geometry) {
		let undef = this.getCheckFunction("addGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(this.hasGeometry(geometry))
			return;

		this.geometries.push(geometry);

		for (let id in geometry.maps) {
			geometry.maps[id].setStyle(this.options);
		}
	}

	removeGeometry(geometry) {
		let undef = this.getCheckFunction("removeGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(!this.hasGeometry(geometry))
			return;

		let geometries = this.geometries;

		geometries.splice(geometries.indexOf(geometry), 1);
	}

	setColor(v) {
		this.setOption("color", v);
	}

	setStrokeWeight(v) {
		this.setOption("weight", v);
	}

	setDashPattern(v) {
		this.setOption("dashArray", v);
	}

	setDashOffset(v) {
		this.setOption("dashOffset", v);
	}

	setFillColor(v) {
		this.setOption("fillColor", v);
	}

	setBordered(v) {
		this.setOption("stroke", v);
	}

	setFilled(v) {
		this.setOption("fill", v);
	}
};


/**
 * WidgetGeoMap::GeoLineStyle
 */

class GeoLineStyle extends GeoStyle {
	
	static getDefaultStyle() {

		return {
			stroke : true,
			color : "rgba(51, 136, 255, 1)",
			weight : 3,
			dashArray : "",
			dashOffset : "",
			lineJoin : "round",
			lineCap : "round"
		}

	}
	
	constructor(properties) {
		super(properties.GeoStyle);

		let undef = this.getCheckFunction("constructor");

		this.geometries = [];
		this.options = {opacity : 1, fillOpacity : 1};

		let options = [
			"color",
			"weight",
			"dashOffset",
			["dashPattern", "dashArray"],
			"lineCap",
			"lineJoin"
		];

		this.initOptions(properties, options);
		
		this.setGeometries(properties.lines);

		// geoManger.addToMapStyles(this.id, this);
	}

	setGeometries(geometryIds) {
		if(geometryIds == undefined)
			return;

		let mapObjects = geoManager.objects;

		for(let i = 0; i < geometryIds.length; ++i) {
			let geometry = mapObjects[geometryIds[i]];

			if(geometry == undefined)
				continue;

			let oldS = geometry.style;

			geometry.style = this;

			if (oldS != undefined)
				oldS.removeGeometry(geometry);

			this.geometries.push(geometry);

			for (let id in geometry.maps)
				geometry.maps[id].setStyle(this.options);
			// geometry.object.setStyle(this.options);
		}
	}

	initOptions(properties, names) {
		let undef = this.getCheckFunction("initOptions");

		let name, baseName;

		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}

			let option = properties[name];

			if(undef(option, name, properties))
				return false;

			this.options[baseName] = option;
		}

		return true;
	}

	setOption(baseName, value) {
		if(this.options[baseName] == value)
			return;

		this.options[baseName] = value;

		this.update();
	}

	update() {
		let geometries = this.geometries;
		let options = this.options;

		for(let i = 0; i < geometries.length; ++i) {
			let geometry = geometries[i];
			if(geometry != undefined)
				for (let id in geometry.maps){
					geometry.maps[id].setStyle(options);
				}
		}
	}

	getNumObjects() {
		return this.geometries.length;
	}

	hasGeometry(geometry) {
		return this.geometries.indexOf(geometry) > -1;
	}

	addGeometry(geometry) {
		let undef = this.getCheckFunction("addGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(this.hasGeometry(geometry))
			return;

		this.geometries.push(geometry);

		for (let id in geometry.maps) {
			geometry.maps[id].setStyle(this.options);
		}
	}

	removeGeometry(geometry) {
		let undef = this.getCheckFunction("removeGeometry");

		if(undef(geometry, "geometry"))
			return;

		if(!this.hasGeometry(geometry))
			return;

		let geometries = this.geometries;

		geometries.splice(geometries.indexOf(geometry), 1);
	}

	setColor(v) {
		this.setOption("color", v);
	}

	setStrokeWeight(v) {
		this.setOption("weight", v);
	}

	setDashPattern(v) {
		this.setOption("dashArray", v);
	}

	setDashOffset(v) {
		this.setOption("dashOffset", v);
	}

	setLineCap(v) {
		this.setOption("lineCap", v);
	}
	
	setLineJoin(v) {
		this.setOption("lineJoin", v);
	}
	
};



/**
 * WidgetGeoMap::GeoFont
 */

class GeoFont extends GeoStyle {
	
	constructor(properties) {
		super(properties.GeoStyle);console.log("GeoFont::constructor", properties);
		
		let undef = this.getCheckFunction("constructor");
		
		this.texts = [];
		
		this.color = "rgba(0, 0, 0, 1)";
		
		this.size = 10;
		
		this.family = undefined;
			
		this.weight = "normal";	
		
		this.style = "normal";
		
		let optionNames = [
			"color",
			"size",
			"family",
			"weight",
			"style"
		];
		
		if(undef(properties, "properties"))
			return;
		
		this.initOptions(properties, optionNames);
		
		let textIds = properties.texts;
		
		if(textIds != undefined)
			this.setTexts(textIds);
	}
	
	initOptions (properties, names) {
		let undef = this.getCheckFunction("initOptions");
		
		let name, baseName;
		
		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}
			
			let option = properties[name];
			
			if(undef(option, name, properties))
				return false;
			
			this[baseName] = option;
		}
		
		return true;
	}
	
	
	setTexts(textIds) {
		if(textIds == undefined)
			return;
		
		let styles = geoManager.styles;
		
		let texts = this.texts;
		
		for(let i = 0; i < textIds.length; ++i) {
			let text = styles[textIds[i]];
			
			if(text == undefined)
				continue;
			
			if(text.font != undefined)
				text.font.removeText(text);
			
			text.font = this;
			
			texts.push(text);
		}
		
		this.update();
	}
	
	update() {
		let texts = this.texts;
		
		for(let i = 0; i < texts.length; ++i)
			texts[i].update();
	}
	
	getNumObjects() {
		return this.texts.length;
	}
	
	hasText(text) {
		return this.texts.indexOf(text) > -1;
	}
	
	addText(text) {
		let undef = this.getCheckFunction("addText");
		
		if(undef(text, "text"))
			return;
		
		if(this.hasText(text))
			return;
		
		this.texts.push(text);
	}
	
	removeText(text) {
		let undef = this.getCheckFunction("removeText");
		
		if(undef(text, "text"))
			return;
		
		if(!this.hasText(text))
			return;
		
		let texts = this.texts;
		
		texts.splice(texts.indexOf(text), 1);
	}
	
	setColor(v) {
		this.setOption("color", v);
	}
	
	setSize(v) {
		this.setOption("size", v);
	}
	
	setFamily(v) {
		this.setOption("family", v);
	}
	
	setWeight(v) {
		this.setOption("weight", v);
	}
	
	setStyle(v) {console.log(v);
		this.setOption("style", v);
	}
	
};


/**
 * WidgetGeoMap::GeoLineText
 */

class GeoLineText extends GeoStyle {
	
	constructor(properties) {
		super(properties.GeoStyle);
		
		let undef = this.getCheckFunction("constructor");
		
		this.lines = [];
		
		this.text = "";
		
		this.font = undefined;
		
		this.below = false;
		
		this.repeat = false;
		
		this.offset = 0;
		
		this.angle = 0;
		
		if(undef(properties, "properties"))
			return;
		
		let options = [
			"text",
			"below",
			"repeat",
			"offset",
			"angle"
		];
		
		this.initOptions(properties, options);
		
		let fontId = properties.font;
		
		if(fontId != undefined) {
			let font = geoManager.styles[fontId];
			
			if(font != undefined) {
				this.font == font;
				
				font.addText(this);
			}
		}
		
		let lineIds = properties.lines;
		
		if(lineIds != undefined)
			this.setLines(lineIds);
	}
	
	initOptions (properties, names) {
		let undef = this.getCheckFunction("initOptions");
		
		let name, baseName;
		
		for(let i = 0; i < names.length; ++i) {
			if(!Array.isArray(names[i])) {
				name = names[i];
				baseName = name;
			}
			else {
				name = names[i][0];
				baseName = names[i][1];
			}
			
			let option = properties[name];
			
			if(undef(option, name, properties))
				return false;
			
			this[baseName] = option;
		}
		
		return true;
	}
	
	setLines(lineIds) {
		if(lineIds == undefined)
			return;
		
		let mapObjects = geoManager.objects;
		
		let lines = this.lines;
		
		for(let i = 0; i < lineIds.length; ++i) {
			let line = mapObjects[lineIds[i]];
			
			if(line == undefined)
				continue;
			
			line.text = this;
			
			lines.push(line);
			
			this.setTextToLine(line);
		}
	}
	
	update() {
		let lines = this.lines;
		
	 	for(let i = 0; i < lines.length; ++i)
			this.setTextToLine(lines[i]);
	}
	
	getNumObjects() {
		return this.lines.length;
	}
	
	hasLine(line) {
		return this.lines.indexOf(line) > -1;
	}
	
	addLine(line) {
		let undef = this.getCheckFunction("addLine");
		
		if(undef(line, "line"))
			return;
		
		if(this.hasGeometry(line))
			return;
		
		this.lines.push(line);
		
		this.setLineText(line);
	}
	
	removeLine(line) {
		let undef = this.getCheckFunction("removeLine");
		
		if(undef(line, "line"))
			return;
		
		if(!this.hasLine(line))
			return;
		
		let lines = this.lines;
		
		lines.splice(lines.indexOf(line), 1);
	}
	
	setText(text) {
		let undef = this.getCheckFunction("setText");
		
		if(undef(text, "text"))
			return;
		
		if(this.text == text)
			return;
		
		this.text = text;
		
		this.update();
	}
	
	setTextToLine(line) {
		let undef = this.getCheckFunction("setTextToLine");
		
		if(undef(line, "line"))
			return;
		
		if(line.text.text != "") {
			for (let mapId in line.maps)
				line.maps[mapId].setText("");
		}
			//line.object.setText("");
		
		let options = {
			below: this.below,
			repeat: this.repeat,
			offset: this.offset,
			orientation: this.angle
		};
		
		let attributes = {};
		 // wind.setText('aaa) ', {repeat: true,
                            // offset: 7,
                            // attributes: {fill: '#007DEF',
                                         // 'font-weight': 'bold',
                                         // 'font-size': '14'}});
		
		this.setFontProperties(attributes);
		
		options.attributes = attributes;
		
		for (let mapId in line.maps)
			line.maps[mapId].setText(this.text, options);
		//line.object.setText(this.text, options);
	}
	
	setFontProperties(attributes) {
		let undef = this.getCheckFunction("setFontProperties");
		
		if(this.font == undefined)
			return;
		
		if(undef(attributes, "attributes"))
			return;
		
		attributes['fill'] = this.font.color;
		attributes['font-size'] = this.font.size;
		attributes['font-family'] = this.font.family;
		attributes['font-weight'] = this.font.weight;
		attributes['font-style'] = this.font.style;
	}
	
	setFont(fontId) {
		let undef = this.getCheckFunction("setFont");
		
		if(undef(fontId, "fontId"))
			return;
		
		if(fontId == undefined)
			return;
		
		let font = this.geoObjects.styles[fontId];
		
		if(undef(font, "font"))
			return;
			
		if(this.font == font)
			return;
		
		if(this.font != undefined)
			this.font.removeText(this);
			
		this.font = font;
				
		font.addText(this);
		
		this.update();
	}
	
	setText(v) {		
		this.setOption("text", v);
	}
	
	setBelow(v) {
		this.setOption("below", v);
	}
	
	setRepeat(v) {
		this.setOption("repeat", v);
	}
	
	setOffset(v) {
		this.setOption("offset", v);
	}
	
	setAngle(v) {		
		this.setOption("angle", v);
	}
	
};


/**
 * WidgetGeoMap::GeoMapObject
 */

class GeoMapObjectBaseEvents extends GeoLayerBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
};

class GeoMapObjectEvents extends GeoLayerEvents {
	
	constructor(object) {
		super(object);
	}
};

class GeoMapObject extends GeoLayerObject {

	constructor(properties) {
	// constructor(map, geoObjects, properties) {
		super(properties.GeoLayerObject);

		let undef = this.getCheckFunction("constructor");

		let maps = properties.maps;

		this.maps = {};

		if (maps == undefined){
			console.warn("Maps ", maps);
			return;
		}
		else {
			if (geoManager == null) console.warn("AAAAA MANAGER NULL addObj::MAPOBJECT");
			// for (let mapId in maps) {
			for (let i=0; i<maps.length; ++i)
				this.maps[maps[i]] = undefined;
		}

		// this.object = undefined;
	}

	callObjectsMethod(methodName, ...args) {
		let m = this.maps;

		if (m.length < 1) return;

		// for (int i=0; i<arguments.s);//вырезали указатель на метод

		let method = m[0][methodName];

		for(let key in m)
			method.call(m[key], ...args);//передали оставльные параметры
	}

	fillMaps (objectCreater) {
		for (let mapId in this.maps)
			this.maps[mapId] = objectCreater();
	}

	handleEvent(eventName, event, id) {
		geoManager.maps[id].handleObjectEvent(this.id, eventName, event, id);
	}

	onAddOnMap(map) {
		if (this.maps[map.id] != undefined)
			console.warn("ya yje na karte");
		map.addOnMapLayer(this);
	}

	removeFromMap(mapId) {
		let map = geoManager.maps[mapId];

		if(map == undefined)
			return;

		this.maps[mapId].removeFrom(map.object);
	}
	// removeFromMap() {
	// 	let map = this.maps;
	//
	// 	if(map == undefined)
	// 		return;
	//
	// 	map.object.removeLayer(this.object);
	// }

	onMove() {

	}

	move(offset) {
		let lon = parseFloat(offset.lon);
		let lat = parseFloat(offset.lat);

		if(lon == 0)
			if(lat == 0)
				return;

		this.onMove(lon, lat);
	}

	cloneLayer (layer) {
		let options = this.cloneOptions(layer.options);

		// we need to test for the most specific class first, i.e.
		// Circle before CircleMarker

		// Renderers
		if (layer instanceof L.SVG) {
			return L.svg(options);
		}
		if (layer instanceof L.Canvas) {
			return L.canvas(options);
		}

		// Tile layers
		if (layer instanceof L.TileLayer.WMS) {
			return L.tileLayer.wms(layer._url, options);
		}
		if (layer instanceof L.TileLayer) {
			return L.tileLayer(layer._url, options);
		}
		if (layer instanceof L.ImageOverlay) {
			return L.imageOverlay(layer._url, layer._bounds, options);
		}

		// Marker layers
		if (layer instanceof L.Marker) {
			return L.marker(layer.getLatLng(), options);
		}

		if (layer instanceof L.Circle) {
			return L.circle(layer.getLatLng(), layer.getRadius(), options);
		}
		if (layer instanceof L.CircleMarker) {
			return L.circleMarker(layer.getLatLng(), options);
			// return circle.getLatLng() = layer.getLatLng();
		}

		if (layer instanceof L.Rectangle) {
			let rect = L.rectangle([[1,1],[-1,-1]],options);

			rect.getLatLngs()[0] = this.data;

			rect.getBounds()._northEast = this.maxPoint;
			rect.getBounds()._southWest = this.minPoint;

			return rect;
		}

		if (layer instanceof L.Polygon) {//TODO
			let pol = L.polygon(GeoMapPolygon.polygonGetDefaultJson(), options);

			for (let i=0; i<layer.getLatLngs().length; ++i)
				pol.getLatLngs()[i] = layer.getLatLngs()[i];

			return pol;
		}
		if (layer instanceof L.Polyline) {
			let line = L.polyline(GeoMapLine.lineGetDefaultJson(), options);

			for (let i=0; i<layer.getLatLngs().length; ++i)
				line.getLatLngs()[0] = layer.getLatLngs()[i];

			return line;
		}

		if (layer instanceof L.GeoJSON) {
			return L.geoJson(layer.toGeoJSON(), options);
		}

		if (layer instanceof L.LayerGroup) {
			return L.layerGroup(this.cloneInnerLayers(layer));
		}
		if (layer instanceof L.FeatureGroup) {
			return L.FeatureGroup(this.cloneInnerLayers(layer));
		}
	}

	cloneOptions (options) {
		let ret = {};
		for (let i in options) {
			let item = options[i];

			if (item && item.clone) ret[i] = item.clone();

			else if (item instanceof L.Layer) ret[i] = this.cloneLayer(item);

			else ret[i] = item;
		}
		return ret;
	}

	cloneInnerLayers (layer) {
		let layers = [];
		layer.eachLayer((inner) =>{
			layers.push(this.cloneLayer(inner));
		});
		return layers;
	}

	bringToFront () {
		// debugger;
		for (let id in this.maps){
			let leafObj = this.maps[id];
			leafObj.bringToFront();
		}
	}

	bringToBack () {
		// debugger;
		for (let id in this.maps){
			let leafObj = this.maps[id];
			leafObj.bringToBack();
		}
	}
};


/**
 * WidgetGeoMap::GeoTooltipEvents
 */

class GeoTooltipEvents  /*extends GeoEvents {//*/extends GeoMapObjectEvents {
	
	constructor(object) {
		super(object);
		// this.map = this.object.map.map;
		// this.object = object;
		this.maps = [];
		for (let id in this.object.maps){
			this.maps = geoManager.maps[id];
		}
	}
	
};

class GeoTooltip extends GeoLayerObject {
	
	constructor(properties) {
		super(properties.GeoLayerObject);
		
		this.content = "";
		this.opened = false;
		
		this.lon = 0;
		this.lat = 0;

		this.maps = {};
		// debugger;
		// this.layerObject = undefined;

		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		if(properties.content != undefined)
			this.content = properties.content;
		
		// let opened = properties.opened;
		//
		// if(undef(opened, "opened", properties))
		// 	return;
		
		// this.opened = opened;
		// this.openedAt = {};

		let p = properties.position;
		
		if(undef(p, "position", properties))
			return;
		
		if(undef(p.lon, "lon", p))
			return;
		
		if(undef(p.lat, "lat", p))
			return;
		
		this.lon = p.lon;
		this.lat = p.lat;
		
		let layerIds = properties.layerIds;

		this.layerObjects = {};

		this.opened = {};

		for (let id in layerIds) {
			let object = geoManager.objects[id];
			if (object == undefined) continue;
			this.layerObjects[id] = object;
			this.opened[id] = {};
			for (let mapId in object.maps)
				this.opened[id][mapId] = false;
		}
		// if(layerId != undefined)
		// 	this.layerObject = geoManager.objects[layerId];
	}

	handleEvent(eventName, event, id) {
		geoManager.maps[id].handleObjectEvent(this.id, eventName, event);
	}

	onAddOnMap(map) {
		
	}
	
	setPosition(pos) {
		this.object.setLatLng(pos);
	}
	
	setContent(content) {
		let undef = this.getCheckFunction("setContent");
		
		if(undef(content, "content"))
			return;
		
		if(this.content == content)
			return;
		
		this.content = content;
		
		this.object.setContent(content);
	}
	
	unbind() {
		
	}
	
	onBindTo(layerObj) {
	
	}
	
	bindTo(layerId) {
		let undef = this.getCheckFunction("bindTo");
		
		if(undef(layerId, "layerId"))
			return;

		let objectOnMaps = this.opened[layerId];

		if (objectOnMaps != undefined) {
			debugger;
			return;
		}

		objectOnMaps = {};
		this.opened[layerId] = objectOnMaps;
		// if(this.layerObject != undefined)
		// 	if(this.layerObject.id == layerId)
		// 		return;


		let layer = geoManager.objects[layerId];
		
		if(layer == undefined && layerId == this.map.id)
			layer = this.map;
				
		if(undef(layer, "layer"))
			return;

		for (let mapId in layer.maps)
			objectOnMaps[mapId] = false;

		this.layerObjects[layerId] = layer;

		this.onBindTo(layer);
	}
	
	setPos(pos) {
		if(Rex.compare(this.lon, pos.lon, 1e-9))
			if(Rex.compare(this.lat, pos.lat, 1e-9))
				return;
			
		this.lon = pos.lon;
		this.lat = pos.lat;
		
		this.object.setLatLng(pos);
	}
	
};

/**
 * WidgetGeoMap::GeoMapPopup
 */

class GeoMapPopupBaseEvents extends GeoMapObjectBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
	popupopen(event, objectId, mapId) {
		let object = this.object;

		let leafObj = object.maps[objectId][mapId];

		if (leafObj == undefined) {
			console.error("Error obj not found");
			return undefined;
		}

		if(object.opened[objectId][mapId])
			return undefined;

		object.opened[objectId][mapId] = true;

		let retEvent = {
			"objectId" : parseInt(objectId),
			"mapId" : parseInt(mapId),
			// "open" : true,
			"type" : "popUp"
		}
		return retEvent;
	}
	
	popupclose(event, objectId, mapId) {
		let object = this.object;

		let leafObj = object.maps[objectId][mapId];

		if (leafObj == undefined) {
			console.error("Error obj not found");
			return undefined;
		}

		if(!object.opened[objectId][mapId])
			return undefined;

		object.opened[objectId][mapId] = false;

		let retEvent = {
			"objectId" : parseInt(objectId),
			"mapId" : parseInt(mapId),
			"type" : "popUp"
		}

		return retEvent;
	}
	
}; 

class GeoMapPopupEvents extends GeoTooltipEvents {
	
	constructor(object) {
		super(object);
		
		this.baseEvents = new GeoMapPopupBaseEvents(object);
		
		this.addInitEvents();
	}
	
	onOpen(eventName, leafObj) {
		let baseEventName = "popupopen";
		if (leafObj == undefined){
			let maps = this.object.maps;
			for (let id in maps){
				for (let mapId in maps[id]) {

					geoManager.objects[id].maps[mapId].addEventListener(baseEventName, (baseEvent) => {
						let event = this.baseEvents[baseEventName].call(this.baseEvents, baseEvent, id, mapId);
						if (event == undefined)
							return;
						this.object.handleEvent(eventName, event, mapId);
					});
				}
			}
		}
		else {
			let maps = this.object.maps;
			for (let id in maps){
				for (let mapId in maps[id]) {
					let leafletObj = maps[id][mapId];//L.PopUp
					if (leafletObj != leafObj) continue;

					geoManager.objects[id].maps[mapId].addEventListener(baseEventName, (baseEvent) => {
						let event = this.baseEvents[baseEventName].call(this.baseEvents, baseEvent, id, mapId);
						if (event == undefined)
							return;
						this.object.handleEvent(eventName, event, mapId);
					});
				}
			}
		}
	}
	
	onClose(eventName, leafObj) {
		let baseEventName = "popupclose";
		if (leafObj == undefined){
			let maps = this.object.maps;
			for (let id in maps){
				for (let mapId in maps[id]) {

					geoManager.objects[id].maps[mapId].addEventListener(baseEventName, (baseEvent) => {
						let event = this.baseEvents[baseEventName].call(this.baseEvents, baseEvent, id, mapId);
						if (event == undefined)
							return;
						this.object.handleEvent(eventName, event, mapId);
					});
				}
			}
		}
		else {
			let maps = this.object.maps;
			for (let id in maps){
				for (let mapId in maps[id]) {
					let leafletObj = maps[id][mapId];//L.PopUp
					if (leafletObj != leafObj) continue;

					geoManager.objects[id].maps[mapId].addEventListener(baseEventName, (baseEvent) => {
						let event = this.baseEvents[baseEventName].call(this.baseEvents, baseEvent, id, mapId);
						if (event == undefined)
							return;
						this.object.handleEvent(eventName, event, mapId);
					});
				}
			}
		}
	}
	
};

class GeoMapPopup extends GeoTooltip {
	
	constructor(properties) {
		super(properties.GeoTooltip);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		var popup = L.popup({autoPan : false});
		
		popup.setLatLng([this.lat, this.lon]);
		
		// var frameData;// = '<iframe src="https:\/\/ru.wiktionary.org\/wiki\/%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" width="400" height="200" align="left">';
		// frameData = '<iframe src="http:\/\/192.168.10.65\/?type=AppServer&obj_id=5a1bad09e4610de6c3ec6987&ses_key=5a1be2d91003e87ac248b9de" width="400" height="200" align="left">'
		// frameData += 'Ваш браузер не поддерживает плавающие фреймы!';
		// frameData += '</iframe>';
		
		//popup.setContent(frameData);
		popup.setContent(this.content);
		
		this.object = popup;

		for (let id in this.layerObjects)
			this.onBindTo(this.layerObjects[id]);
		// if(this.layerObject != undefined)
		// 	this.onBindTo();
		//
		this.events = new GeoMapPopupEvents(this);
	}
	
	setPosition(pos) {
		this.object.setLatLng(pos);
	}
	
	unbind(objectId) {
		let layer = this.layerObjects[objectId];

		if(layer == undefined)
			return;

		layer.popup = undefined;

		for (let id in this.maps[objectId]){
			let lefObj = this.maps[objectId][id];
			if (lefObj == undefined) continue;
			if (this.opened[objectId][id])
				layer.maps[id].closePopup(lefObj);
			layer.maps[id].unbindPopup(lefObj);
		}

		delete this.layerObjects[objectId];
		delete this.opened[objectId];
		// if(layer.object != this.map.map)
		// 	layer.object.unbindPopup(this.object);
		// else
		// 	if(this.opened)
		// 		this.object.closePopup(this.object);
		//
		// debugger;
		// this.layerObject = undefined;
	}
	
	open(property) {
		let mapId = property.MapId;

		let objId = property.ObjectId;

		if (mapId == undefined || objId == undefined)
			return;

		if(this.opened[objId][mapId])
			return;

		this.opened[objId][mapId] = true;

		let layer = this.layerObjects[objId];

		if(layer == undefined)
			return;

		layer.maps[mapId].openPopup();
	}
	
	close(property) {
		let mapId = property.MapId;

		let objId = property.ObjectId;

		if (mapId == undefined || objId == undefined)
			return;

		if(!this.opened[objId][mapId])
			return;

		this.opened[objId][mapId] = false;

		let layer = this.layerObjects[objId];

		if(layer == undefined)
			return;

		layer.maps[mapId].closePopup();
		// if(!this.opened)
		// 	return;
		//
		// this.opened = false;
		//
		// let layer = this.layerObject;
		//
		// if(layer == undefined)
		// 	return;
		//
		// if(layer != this.map)
		// 	layer.object.closePopup();
		// else
		// 	layer.map.closePopup(this.object);
	}
	
	setContent(content) {
		let undef = this.getCheckFunction("constructor");
		
		if(undef(content, "content"))
			return;
		
		if(this.content == content)
			return;
		
		this.object.setContent(content);
	}

		
	onBindTo(layerObj) {
		// let undef = this.getCheckFunction("onBindTo");

		let objId = layerObj.id;

		if (objId == undefined) debugger;

		if (this.layerObjects[objId] != layerObj) {
			console.log("addToolTip");
			this.layerObjects[objId] = layerObj;
		}

		let mapsOpened = this.opened[objId];

		if (this.maps == undefined) {
			debugger;
			this.maps = {};
		}

		if (this.maps[objId] != undefined) {
			console.error("ALREADY EXIST");
			debugger;
		}

		this.maps[objId] = {};
		let leafPopups = this.maps[objId];

		for (let mapId in mapsOpened){

			let object = layerObj.maps[mapId];

			if (object == undefined) {
				console.error("object not found");
				debugger;
			}

			leafPopups[mapId] = new L.popup({autoPan : false});
			leafPopups[mapId].setContent(this.content);
			object.bindPopup(leafPopups[mapId]);
			this.events.addEventsToExistObj(leafPopups[mapId]);

			if(mapsOpened[mapId])
				object.openPopup();
		}
		layerObj.popup = this;

		// let layer = this.layerObject;
		
		// if(undef(layer, "layerObject", this))
		// 	return;

		// if (layer instanceof  L.map){
		// 	console.log("i bind to map");
		//
		// 	if(this.map.map != layer.object){
		// 		layer.object.bindPopup(this.object);
		//
		// 		if(this.opened)
		// 			layer.object.openPopup();
		// 	}
		// 	else
		// 		if(this.opened)
		// 			layer.object.openPopup(this.object);
		//
		// 	this.layerObject.tooltip = this;
		// 	return;
		// }


		//
		//
		//
		//
		//
		// let object = layer.object;
		//
		// if(undef(object, "object", layer))
		// 	return;
		//
		// if(object != this.map.map) {
		// 	object.bindPopup(this.object);
		//
		// 	if(this.opened)
		// 		object.openPopup();
		// }
		// else {
		// 	if(this.opened)
		// 		object.openPopup(this.object);
		// }
		//
		// this.layerObject.popup = this;
	}
	
};


/**
 * WidgetGeoMap::GeoMapTooltip
 */

class GeoMapTooltipBaseEvents extends GeoMapObjectBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
	tooltipopen(event) {
		let object = this.object;
		
		if(event.tooltip != object.object)
			return undefined;
		
		if(object.opened)
			return undefined;
		
		object.opened = true;
				
		return {};
	}
	
	tooltipclose(event) {
		let object = this.object;
		
		if(event.tooltip != object.object)
			return undefined;
		
		if(!object.opened)
			return undefined;
		
		object.opened = false;
		
		return {};
	}
	
};

class GeoMapTooltipEvents extends GeoTooltipEvents {
	
	constructor(object) {
		super(object);
		
		this.baseEvents = new GeoMapTooltipBaseEvents(object);
		
		this.addInitEvents();
	}
	
	onOpen(eventName, objectId) {
		if (objectId == undefined){
			let maps = this.maps;
			for (let id in maps){
				for (let mapId in maps[id]) {
					let leafletObj = maps[id][mapId];//L.PopUp
					leafletObj.addEventListener( (baseEvent) => {
						let event = this.baseEvents["tooltipopen"].call(this.baseEvents, baseEvent);
						event.objId = id;
						if (event == undefined)
							return;
						this.object.handleEvent(eventName, event, mapId);
					});
				}
			}
		}
		// this.addBaseEvent(eventName, "tooltipopen", this.map);
	}
	
	onClose(eventName, objectId) {

		this.addBaseEvent(eventName, "tooltipclose", this.map);
	}

};

class GeoMapTooltip extends GeoTooltip {
	
	constructor(properties) {
		super(properties.GeoTooltip);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		var tooltip = L.tooltip();
		
		tooltip.setLatLng([this.lat, this.lon]);
		tooltip.setContent(this.content);
		
		this.object = tooltip;

		for (let id in this.layerObjects)
			this.onBindTo(this.layerObjects[id]);
		// if(this.layerObject != undefined)
		// 	this.onBindTo();
		
		this.events = new GeoMapTooltipEvents(this);
	}
	
	unbind(objectId) {
		let layer = this.layerObjects[objectId];
		
		if(layer == undefined)
			return;
		
		layer.tooltip = undefined;

		for (let id in this.maps[objectId]){
			let leafObj = this.maps[objectId][id];
			if (leafObj == undefined) continue;
			if (this.opened[objectId][id])
				layer.maps[id].closeTooltip(leafObj);
			layer.maps[id].unbindTooltip(leafObj);
		}

		delete this.layerObjects[objectId];
		delete this.opened[objectId];
		// if(layer.object != this.map.map)
		// 	layer.object.unbindTooltip(this.object);
		// else
		// 	if(this.opened)
		// 		this.object.closeTooltip(this.object);
	
		// this.layerObject = undefined;
	}

	open(property) {
		let mapId = property.MapId;

		let objId = property.ObjectId;

		if (mapId == undefined || objId == undefined)
			return;

		if(this.opened[objId][mapId])
			return;

		this.opened[objId][mapId] = true;
		
		let layer = this.layerObjects[objId];

		if(layer == undefined)
			return;

		layer.maps[mapId].openTooltip();
		// if(layer != this.map)

		// else
		// 	layer.map.openTooltip(this.object);
	}
	
	close(property) {
		let mapId = property.MapId;

		let objId = property.ObjectId;

		if (mapId == undefined || objId == undefined)
			return;

		if(!this.opened[objId][mapId])
			return;

		this.opened[objId][mapId] = false;
		
		let layer = this.layerObjects[objId];
		
		if(layer == undefined)
			return;
		
		layer.maps[mapId].closeTooltip();
	}
	
	onBindTo(layerObj) {
		let objId = layerObj.id;

		if (objId == undefined) debugger;

		if (this.layerObjects[objId] != layerObj) {
			console.log("addToolTip");
			this.layerObjects[objId] = layerObj;
		}

		let mapsOpened = this.opened[objId];

		if (this.maps == undefined) {
			debugger;
			this.maps = {};
		}

		if (this.maps[objId] != undefined) {
			console.error("ALREADY EXIST");
			debugger;
			return;
		}

		this.maps[objId] = {};
		let leafToolTips = this.maps[objId];

		for (let mapId in mapsOpened){

			let object = layerObj.maps[mapId];

			if (object == undefined) {
				console.error("object not found");
				debugger;
			}

			leafToolTips[mapId] = new L.tooltip();
			// leafPopups[mapId].setContent(this.content);
			object.bindTooltip(this.content,leafToolTips[mapId]);
			this.events.addEventsToExistObj(leafToolTips[mapId]);

			if(mapsOpened[mapId])
				object.openTooltip();
		}
		layerObj.tooltip = this;

		//властью данной мне их больше не будет на картах
		// if (layer instanceof  L.map){
		// 	console.log("i bind to map");
		//
		// 	if(this.opened)
		// 		layer.object.openTooltip(this.object);
		//
		// 	this.layerObject.tooltip = this;
		// 	return;
		// }

		// for (let mapId in layer.maps){
		// 	let object = layer.maps[mapId];
		//
		// 	object.bindTooltip(this.object);
		//
		// 	if(this.opened[layer.id][mapId])
		// 		object.openTooltip();
		// }
		//
		// layer.tooltip = this;
	}
	
};


/**
 * WidgetGeoMap::GeoMapMarker
 */

class GeoMarkerBaseEvents extends GeoMapObjectBaseEvents {
	
	constructor(object) {
		super(object);
	}
	
	move(event) {
		let object = this.object;
		
		let lon = event.latlng.lng;
		let lat = event.latlng.lat;
		
		if(Rex.compare(object.lon, lon, 1e-9))
			if(Rex.compare(object.lat, lat, 1e-9))
				return undefined;
			
		object.lon = lon;
		object.lat = lat;
		
		return {
			lon : lon,
			lat : lat
		};
	}

};

class GeoMarkerEvents extends GeoMapObjectEvents {
	
	constructor(object) {
		super(object);
		
		this.baseEvents = new GeoMarkerBaseEvents(object);
		
		this.addInitEvents();
	}
	
	onChangePos(eventName) {
		this.addBaseEvent(eventName, "move");
	}

};

class GeoMapMarker extends GeoMapObject {
	
	constructor(properties) {
		super(properties.GeoMapObject);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let p = properties.position;
		
		if(undef(p, "position", properties))
			return;
		
		if(undef(p.lon, "lon", p))
			return;
		
		if(undef(p.lat, "lat", p))
			return;
		
		this.lon = parseFloat(p.lon);
		this.lat = parseFloat(p.lat);
		
		let draggable = properties.draggable;
		
		if(undef(draggable, "draggable", properties))
			return;

		this.draggable = draggable;

		GeoMapObject.prototype.fillMaps.call(this, () => {
			let marker = L.marker([this.lat, this.lon], {opacity: 1});
			
			marker.options.draggable = draggable;

			return marker;
		});
		
		let iconId = properties.iconId;
		
		if(iconId != undefined) {
			let icon = geoManager.styles[iconId];
			
			if(icon != undefined)
				this.setIcon(iconId);
		}
		
		this.geoEvents = new GeoMarkerEvents(this);
	}
	
	setPos(pos) {
		if(Rex.compare(this.lon, pos.lon, 1e-9))
			if(Rex.compare(this.lat, pos.lat, 1e-9))
				return;
			
		this.lon = parseFloat(pos.lon);
		this.lat = parseFloat(pos.lat);

		for (let id in this.maps)
			this.maps[id].setLatLng({lng: this.lon, lat : this.lat});
	}
	
	setIcon(iconId) {
		let undef = this.getCheckFunction("setIcon");
		
		if(undef(iconId, "iconId"))
			return;
		
		let icon = geoManager.styles[iconId];
		
		if(undef(icon, "icon"))
			return;
		
		if(this.icon == icon)
			return;
		
		let i = this.icon;
		
		this.icon = icon;
		
		if(i != undefined)
			i.removeMarker(this);
		
		if(!icon.hasMarker(this))
			icon.addMarker(this);

		for (let id in this.maps) {
			let leafletEntity = this.maps[id];
			leafletEntity.setIcon(icon.object);
			leafletEntity.setOpacity(icon.object.options.opacity);
			// leafletEntity.setOpacity(icon.object.options.opacity);
		}
	}
	
	removeIcon() {
		if(this.icon == undefined)
			return;
		
		let i = this.icon;
		
		this.icon = undefined;
		
		if(i.hasMarker(this))
			i.removeMarker(this);

		for (let id in this.maps)
			this.maps[id].setIcon(new L.Icon.Default());
	}
	
	setDraggable(draggable) {
		if(this.draggable == draggable)
			return;
		
		this.draggable = draggable;
				
		if(draggable)
			for (let id in this.maps)
				this.maps[id].dragging.enable();
		else
			for (let id in this.maps)
				this.maps[id].dragging.disable();
	}

	onMove(lon, lat) {
		this.setPos({lon : this.lon + lon, lat : this.lat + lat});
	}
	
};

/**
 * WidgetGeoMap::GeoMapGeometry
 */

class GeoMapGeometry extends GeoMapObject {
	constructor(properties) {
		super(properties.GeoMapObject);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		this.style = undefined;
		
	}
	
	static pathToGeoJson(path) {
		//let undef = this.getCheckFunction("pathToGeoJson");
		
		//if(undef(path, "path"))
			//return undefined;
		
		let ret = [];
		
		for(let i = 0; i < path.length; ++i) {
			let point = path[i];
			ret.push(L.latLng(point.lat,point.lon));
		}
		
		return ret;
	}

	static pathGetDefaultJson () {
		return [{"lng":"0","lat":"1"}];
	}

	init() {
		super.init();
		
		this.geoEvents = new GeoLayerEvents(this, false);
		
		if(this.style != undefined)
			this.style.addGeometry(this);
	}
	

	
	getDefaultStyle() {
		
	}
	
	setStyle(styleId) {
		let undef = this.getCheckFunction("setStyle");
		
		if(undef(styleId, "styleId"))
			return false;
		
		let style = geoManager.styles[styleId];

		if (style == undefined) debugger;
		// if(undef(style, "style"))
		// 	return false;
		
		// if(this.style == style)
		// 	return false;

		let s = this.style;
		
		this.style = style;
		
		if(s != undefined)
			s.removeGeometry(this);
		
		if(!style.hasGeometry(this))
			style.addGeometry(this);

		//this.callObjectsMethod("setStyle",style.options);

		return true;
	}
	
	removeStyle() {
		if(this.style == undefined)
			return;
		
		this.style.removeGeometry(this);
		
		this.style = undefined;

		for (let id in this.maps) {
			this.maps[id].setStyle(this.getDefaultStyle());
			this.maps[id].redraw();
		}
	}
	

	
};


/**
 * WidgetGeoMap::GeoMapLine
 */

class GeoMapLine extends GeoMapGeometry {
	
	constructor(properties) {
		super(properties.GeoMapGeometry);

		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let arrowEnabled = properties.arrow;
		
		if(undef(arrowEnabled, "arrow", properties))
			return;
		
		this.arrowEnabled = arrowEnabled;
		
		let arrowSize = properties.arrowSize;
		
		if(undef(arrowSize, "arrowSize", properties))
			return;
		
		this.arrowSize = arrowSize;
		
		let l = properties.line;
		
		if(l == undefined)
			l = [];
		
		this.data = GeoMapLine.lineToGeoJson(l);

		GeoMapObject.prototype.fillMaps.call(this, () => {
			let line = L.polyline(GeoMapLine.lineGetDefaultJson());

			for (let i=0; i<this.data.length; ++i)
				line.getLatLngs()[i] = this.data[i];

			return line;
		});

		if(properties.styleId != undefined)
			this.style = geoManager.styles[properties.styleId];

		if(properties.textId != undefined) {
			let text = geoManager.styles[properties.textId];
			
			if(text != undefined) {
				text.addLine(this);
				this.text = text;
			}
		}
		
		this.init();
		
		this.arrow = undefined;
		this.arrowOptions = undefined;
		
		if(arrowEnabled) {
			this.createArrow();
			this.arrow.addTo(this.map.object);
		}
		
	}



	// init(objectMaker) {
	// 	for(var key in this.maps) {
	// 		this.maps[key] = objectMaker();
	// 	}
	// }
	// init(){
	// 	for (var id in this.maps){
	// 		geoManager.maps[id]
	// 	}
	// }

	getDefaultStyle() {
		return GeoLineStyle.getDefaultStyle();
	}
	
	setStyle(styleId) {
		if(!super.setStyle(styleId))
			return false;
		
		if(!this.arrowEnabled)
			return true;
		
		if(this.arrow == undefined) 
			this.createArrow();
		else
			this.updateArrowStyle();
		
		return true;
	}
	
	createArrow() {
		let arrowOptions = {
				pixelSize: this.arrowSize,
				polygon: false,
				pathOptions: {stroke: true}
			};
			
		let pattern = {
			offset: "100%",
			repeat: 0,
			symbol: L.Symbol.arrowHead(arrowOptions)
		};
		
		this.arrowOptions = pattern.symbol.options;

		for (let id in this.maps) {

			let leafObj = this.maps[id];

			this.arrow = L.polylineDecorator(leafObj, {patterns: [pattern]});

			this.arrow.addTo(geoManager.maps[id].map);
		}
	}
	
	addArrowOnMap() {
		if(this.arrow == undefined)
			return;
		
		let map = this.map;
		
		if(map != undefined)
			this.arrow.addTo(map.object);
	}
	
	removeArrowFromMap() {
		if(this.arrow == undefined)
			return;
		
		let map = this.map;
		
		if(map != undefined)
			map.object.removeLayer(this.arrow);
	}
	
	updateArrowSize() {
		this.arrowOptions.pixelSize = this.arrowSize;
			
		this.arrow.setPatterns(this.arrow.options.patterns);
	}
	
	updateArrowStyle() {
		this.arrowOptions.pathOptions =  this.object.options;
		
		this.arrowOptions.pathOptions['stroke']  = true;
			
		this.arrow.setPatterns(this.arrow.options.patterns);
	}
	
	setArrowEnabled(arrowEnabled) {
		console.log("setArrowEnabled::", arrowEnabled);
		let undef = this.getCheckFunction("setArrowEnabled");
		
		if(undef(arrowEnabled, "arrowEnabled"))
			return;
		
		if(this.arrowEnabled == arrowEnabled)
			return;
		
		this.arrowEnabled = arrowEnabled;
		
		if(this.arrowEnabled)
			if(this.arrow == undefined) 
				this.createArrow();
			else {
				this.updateArrowStyle();
				this.updateArrowSize();
				this.addArrowOnMap();
			}
		else
			if(this.arrow != undefined)
				this.removeArrowFromMap();
	}

	setArrowSize(arrowSize) {
		let undef = this.getCheckFunction("setArrowSize");
		
		if(undef(arrowSize, "arrowSize"))
			return;
		
		if(this.arrowSize == arrowSize)
			return;
		
		this.arrowSize = arrowSize;
		
		this.updateArrowSize();
	}
	
	// removeFromMap() {
	// 	super.removeFromMap();
	//
	// 	let map = this.map;
	//
	// 	if(map == undefined)
	// 		return;
	//
	// 	map.object.removeLayer(this.object);
	//
	// 	if(this.arrow != undefined)
	// 		map.object.removeLayer(this.arrow);
	// }
	
	static lineToGeoJson(line) {
		if(line == undefined)
			return undefined;
		
		return [GeoMapGeometry.pathToGeoJson(line)];
	}

	static lineGetDefaultJson () {
		return [GeoMapGeometry.pathGetDefaultJson()];
	}

	onMove(lon, lat) {

		//console.log("onMove:move",lon,lat);
		//console.log("onMove:coor",this.data[0][0].lng,this.data[0][0].lat);

		// let lines = this.object.getLatLngs();
		let arrLines = this.data;
		for(let i = 0; i < arrLines.length; ++i) {
			let line = arrLines[i];
			
			for(let j = 0; j < line.length; ++j) {
				let pos = line[j];
				pos.lng += lon;
				pos.lat += lat;
			}
		}
		
		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	addPoint(pos) {
		let undef = this.getCheckFunction("addPoint");
		
		if(undef(pos, "pos"))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;

		// this.data[0].push({lng : parseFloat(lon), lat : parseFloat(lat)});//надо прям latlng

		this.data[0].push(L.latLng(lat,lon));

		for (let id in this.maps) {
			this.maps[id].redraw();
		}
	}
	
	setPoint(point) {
		let undef = this.getCheckFunction("setPoint");
		
		if(undef(point, "point"))
			return;
		
		let id = point.id;
		
		if(undef(id, "id", point))
			return;
		
		let pos = point.pos;

		if(undef(pos, "pos", point))
			return;
		
		let lon = pos.lon;
				
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		let line = this.data[0];
		
		if(id >= line.length || id < 0)
			if(undef("Point id is out of range"))
				return;
		
		line[id].lng = parseFloat(lon);
		line[id].lat = parseFloat(lat);

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	removePoint(index) {
		let line = this.data[0];
		
		if(index >= line.length || index < 0)
			if(undef("Point index is out of range"))
				return;
		
		line.splice(index, 1);

		for (let id in this.maps)
			this.maps[id].redraw();
	}

	insertPoint (point){
		let index = parseInt(point.id);
		if (index == undefined) console.error("insertPoint index undefined");

		let pos = point.pos;
		if (pos == undefined) console.error("insertPoint pos undefined");

		let line = this.data[0];

		if (index > line.length || index < 0)
			console.error("insertPolygon: Point index out of range");

		let latLngPoint = L.latLng(pos);

		line.splice(index,0,latLngPoint);

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setLine(line) {
		if(undef(line, "line"))
			return;
		
		let data = this.lineToGeoJson(line);
		
		this.object.setLatLngs(data);
	}
	
	setText(textId) {
		let undef = this.getCheckFunction("setText");
		
		if(undef(textId, "textId"))
			return;
		
		let text = geoManager.styles[textId];
		
		// if(undef(text, "text", this.geoObjects.styles))
		// 	return;
		
		let t = this.text;
		
		if(t == text)
			return;
		
		if(t != undefined)
			t.removeLine(this);
			
		this.text = text;
		
		text.addLine(this);
	}
	
	removeText() {
		 let t = this.text;
		
		if(t == "")
			return;
		
		t.removeLine(this);
		
		this.object.setText("");
	}
	
};


/**
 * WidgetGeoMap::GeoMapPolygon
 */

class GeoMapPolygon extends GeoMapGeometry {
	
	constructor(properties) {
		super(properties.GeoMapGeometry);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;

		this.data = [[]];

		if(properties.polygon != undefined)
			this.data = GeoMapPolygon.polygonToGeoJson(properties.polygon);

		GeoMapObject.prototype.fillMaps.call(this, () => {//TODO зачем по разному
			// let pol = L.polygon.apply(L, GeoMapPolygon.polygonGetDefaultJson());
			let pol = L.polygon(GeoMapPolygon.polygonGetDefaultJson());

			for (let i=0; i<this.data.length; ++i)
				pol.getLatLngs()[i] = this.data[i];

			return pol;
		});

		if(properties.styleId != undefined)
			this.style = geoManager.styles[properties.styleId];
		
		this.init();
	}
	
	getDefaultStyle() {
		return GeoPolygonStyle.getDefaultStyle();
	}
	
	static polygonToGeoJson(multiPolygon) {
		// let undef = this.getCheckFunction("polygonToGeoJson");
		
		// if(undef(multiPolygon, "multiPolygon"))
		// 	return undefined;
		
		let ret = [];

		for(let i = 0; i < multiPolygon.length; ++i) {
			let polygon = GeoMapGeometry.pathToGeoJson(multiPolygon[i]);

			polygon.push(polygon[0]);
			
			ret.push(polygon);
		}
		
		return ret;
	}

	static polygonGetDefaultJson () {
		return [GeoMapGeometry.pathGetDefaultJson()];
	}
	
	addPoint(lonLat) {
		let undef = this.getCheckFunction("addPoint");
		
		if(undef(lonLat, "lonLat"))
			return;
		
		let lon = lonLat.lon;
		
		if(undef(lon, "lon", lonLat))
			return;
		
		let lat = lonLat.lat;
		
		if(undef(lat, "lat", lonLat))
			return;

		let dlina = this.data[0].length;
		// if (dlina < 2)
		// 	console.log("OPA !!!!", this.data[0]);

		if (dlina == 0) {
			this.data[0].push(L.latLng(lat,lon));
			this.data[0].push(this.data[0][0]);
			// this.data[0][1] = this.data[0][0];
			// this.data[0][1].lng = this.data[0][0].lng;
		}
		else this.data[0].splice(dlina-1,0,L.latLng(lat,lon));
		// this.maps[0].addLatLng({lng : lon, lat : lat});

		for (let id in this.maps)
			this.maps[id].redraw();
		// for (let i=1; i<Object.keys(this.maps).length; ++i)
		// 	this.maps[i].redraw();
	}
	
	setPoint(point) {console.log("setPoint", point);
		let undef = this.getCheckFunction("setPoint");
		
		if(undef(point, "point"))
			return;
		
		let id = point.id;
		
		if(undef(id, "id", point))
			return;
		
		let pos = point.pos;

		if(undef(pos, "pos", point))
			return;
		
		let lon = pos.lon;
				
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;

		let polygon = this.data[0];

		if(id >= polygon.length || id < 0)
			if(undef("Point id is out of range"))
				return;

		polygon[id].lng = parseFloat(lon);
		polygon[id].lat = parseFloat(lat);

		for (let id in this.maps){
			this.maps[id].redraw();
		}
	}
	
	setInnerPoint(innerPoint) {
		let undef = this.getCheckFunction("setInnerPoint");
		
		if(undef(innerPoint, "innerPoint"))
			return;
		
		let innerId = innerPoint.innerId;
		
		if(undef(innerId, "innerId"))
			return;
		
		let point = innerPoint.point;
		
		if(undef(point, "point"))
			return;
		
		let id = point.id;
		
		if(undef(id, "id", point))
			return;
		
		let pos = point.pos;

		if(undef(pos, "pos", point))
			return;
		
		let lon = pos.lon;
				
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		// let polygons = this.object.getLatLngs();
		let polygons = this.data;

		innerId++;
		
		if(innerId < 1 || innerId >= polygons.length) {
			undef("Inner id is out of range");
			return;
		}
		
		let inner = polygons[innerId];
		
		if(id >= inner.length || id < 0) {
			undef("Point id is out of range");
			return;
		}
		
		inner[id].lng = parseFloat(lon);
		inner[id].lat = parseFloat(lat);
		
		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	addInnerPoint(innerPoint) {
		let undef = this.getCheckFunction("addInnerPoint");
		
		if(undef(innerPoint, "innerPoint"))
			return;
		
		let innerId = innerPoint.innerId;
		
		if(undef(innerId, "innerId", innerPoint))
			return;
		
		let pos = innerPoint.pos;

		if(undef(pos, "pos", innerPoint))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		let polygons = this.maps[0].getLatLngs();

		if(innerId < 0) {
			undef("Bad inner id " + innerId);
			return;
		}
		
		let size = polygons.length - 1;
		
		if(innerId > size)
			undef((innerId - size) + " empty inners will be generated.");
		
		for(let i = size; i <= innerId; ++i)
			polygons.push([]);
		
		let inner = polygons[innerId + 1];
		
		inner.push({lon : lon, lat : lat});//TODO ЗАЧЕМ lon если lng???

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	addInnerPolygon(inner) {
		let undef = this.getCheckFunction("addInnerPolygon");
		
		if(undef(inner, "inner"))
			return;
		
		if(!Array.isArray(inner)) {
			undef("inner is not array : " + inner);
			return;
		}

		let polygons = this.maps[0].getLatLngs();

		for(let i = 0; i < inner.length; ++i) {
			inner[i] = L.latLng({lng: inner[i].lon, lat: inner[i].lat});
		}

		polygons.push(inner);

		this.maps[0].redraw();

		for (let i=1; i<Object.keys(this.maps).length; ++i){
			polygons = this.maps[i].getLatLngs();
			polygons.push(inner);
			this.maps[i].redraw();
		}
	}

	onMove(lon, lat) {
		let polygons = this.data;
		for(let i = 0; i < polygons.length; ++i) {
			let polygon = polygons[i];
			
			for(let j = 0; j < polygon.length-1; ++j) {
				let pos = polygon[j];
				pos.lng += lon;
				pos.lat += lat;
			}
		}

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setPolygon(polygon) {//console.log("setPolygon", polygon);
		if(undef(polygon, "polygon"))
			return;
		
		let data = GeoMapPolygon.polygonToGeoJson(polygon);
		
		this.maps[0].setLatLngs(data);

		for (let i=1; i<Object.keys(this.maps).length; ++i)
			this.maps[i].redraw();
	}
	
	setOuter(outer) {//console.log("setOuter", outer);
		let undef = this.getCheckFunction("setOuter");
		
		if(undef(outer, "outer"))
			return;
		
		if(!Array.isArray(outer)) {
			undef("outer is not array : " + outer);
			return;
		}
		
		let polygons = this.data;//.getLatLngs();
				
		for(let i = 0; i < outer.length; ++i)
			outer[i] = L.latLng({lng : outer[i].lon, lat: outer[i].lat});
				
		polygons[0] = outer;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setInner(innerInfo) {
		let undef = this.getCheckFunction("setInner");
		
		if(undef(innerInfo, "innerInfo"))
			return;
		
		let id = innerInfo.id;
		
		if(undef(id, "id", innerInfo))
			return;
		
		let inner = innerInfo.inner;
		
		if(undef(inner, "inner", innerInfo))
			return;
		
		if(!Array.isArray(inner)) {
			undef("inner is not array : " + inner);
			return;
		}
		
		id++;
		
		let polygons = this.data;//this.object.getLatLngs();
		
		if(id < 1 || id >= polygons.length) {
			undef("Inner id is out of range");
			return;
		}
				
		for(let i = 0; i < inner.length; ++i)
			inner[i] = L.latLng({lng : inner[i].lon, lat: inner[i].lat});
				
		polygons[id] = inner;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	removePoint(index) {
		// let polygon = this.object.getLatLngs()[0];
		let polygon = this.data[0];

		if(index >= polygon.length || index < 0)
			if(undef("Point index is out of range"))
				return;


		// this.object.getLatLngs()[0].splice(index, 1);

		if (index == 0) {
			polygon.splice(0,1);
			polygon[polygon.length-1] = polygon[0];
		}
		else polygon.splice(index, 1)

		for (let id in this.maps)
			this.maps[id].redraw();
	}

	insertPoint (point){

		let index = parseInt(point.id);
		if (index == undefined) console.error("insertPoint index undefined");

		let pos = point.pos;
		if (pos == undefined) console.error("insertPoint pos undefined");

		let polygon = this.data[0];

		if (index >= polygon.length || index < 0)
			console.error("insertPolygon: Point index out of range");

		let latLngPoint = L.latLng(pos);

		// console.log("polygon", polygon);
		if (index == 0) {// || index == polygon.length-1){
			//swap data
			let oldPoint = polygon[0];
			polygon[0] = latLngPoint;
			polygon[polygon.length-1] = latLngPoint;
			// if (index == 0)
			polygon.splice(1,0,oldPoint);
			// else polygon.splice(index,0,oldPoint);
		}
		else polygon.splice(index,0,latLngPoint);

		// console.log("polygon2", polygon);
		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
};


/**
 * WidgetGeoMap::GeoMapRectangle
 */

class GeoMapRectangle extends GeoMapGeometry {
	
	constructor(properties) {
		super(properties.GeoMapGeometry);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let r = properties.rectangle;
		
		if(undef(r, "rectangle", properties))
			return;
		
		let min = r.min;
		
		if(undef(min, "min", r))
			return;
		
		let minLon = parseFloat(min.lon);
		let minLat = parseFloat(min.lat);

		let max = r.max;

		if(undef(max, "max", r))
			return;

		let maxLon = parseFloat(max.lon);
		let maxLat = parseFloat(max.lat);

		this.data = [];

		this.data.push(L.latLng(minLat,minLon));
		this.data.push(L.latLng(maxLat,minLon));
		this.data.push(L.latLng(maxLat,maxLon));
		this.data.push(L.latLng(minLat,maxLon));

		this.minPoint = L.latLng(minLat,minLon);
		this.maxPoint = L.latLng(maxLat,maxLon);

		GeoMapObject.prototype.fillMaps.call(this, () => {//TODO зачем по разному
			let rect = L.rectangle([[1,1],[-1,-1]]);

			rect.getLatLngs()[0] = this.data;

			rect.getBounds()._northEast = this.maxPoint;
			rect.getBounds()._southWest = this.minPoint;

			return rect;
		});

		// this.object = rectangle;
		
		if(properties.styleId != undefined)
			this.style = geoManager.styles[properties.styleId];
		
		this.init();
	}
	
	getDefaultStyle() {
		return GeoRectangleStyle.getDefaultStyle();
	}
	
	setMinPosition(pos) {
		if(this.minLon == pos.lon)
			if(this.minLat == pos.lat)
				return;

		// TODO 2 redraw?
		this.setMinLon(pos.lon);
		this.setMinLat(pos.lat);
	}
	
	setMaxPosition(pos) {
		if(this.maxLon == pos.lon)
			if(this.maxLat == pos.lat)
				return;

		// TODO 2 redraw?
		this.setMaxLon(pos.lon);
		this.setMaxLat(pos.lat);
	}
	
	setMinLon(longitude) {
		if(this.minPoint.lng == longitude)
			return;

		this.minPoint.lng = longitude;
		this.data[1].lng = longitude;
		this.data[0].lng = longitude;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setMinLat(latitude) {
		if(this.minPoint.lat == latitude)
			return;

		this.minPoint.lat = latitude;
		this.data[0].lat = latitude;
		this.data[3].lat = latitude;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setMaxLon(longitude) {
		if(this.maxPoint.lng == longitude)
			return;
			
		this.maxPoint.lng = longitude;
		this.data[2].lng = longitude;
		this.data[3].lng = longitude;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	setMaxLat(latitude) {
		if(this.maxPoint.lat == latitude)
			return;
			
		this.maxPoint.lat = latitude;
		this.data[1].lat = latitude;
		this.data[2].lat = latitude;

		for (let id in this.maps)
			this.maps[id].redraw();
	}
	
	onMove(lon, lat) {
		this.minPoint.lng += lon;
		this.minPoint.lat += lat;
		this.maxPoint.lng += lon;
		this.maxPoint.lat += lat;

		for (let i=0; i<this.data.length; ++i) {
			let latLng = this.data[i];
			latLng.lng += lon;
			latLng.lat += lat;
		}

		this.callObjectsMethod("redraw")
	}
};


/**
 * WidgetGeoMap::GeoCircle
 */

class GeoCircle extends GeoMapGeometry {
	
	constructor(properties) {
		super(properties.GeoMapGeometry);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let c = properties.center;
		
		if(undef(c, "center", properties))
			return;
		
		if(undef(c.lon, "lon", c))
			return;
		
		if(undef(c.lat, "lat", c))
			return;
		
		this.center = {lon : parseFloat(c.lon), lat : parseFloat(c.lat)};
		
		if(properties.styleId != undefined)
			this.style = geoManager.styles[properties.styleId];
	}

	getDefaultStyle() {
		return GeoCircleStyle.getDefaultStyle();
	}
	
	updateCenter() {
		for (let id in this.maps) {
			this.maps[id].setLatLng({lng: this.center.lon, lat: this.center.lat});
			this.maps[id].redraw();
		}
	}
	
	onMove(lon, lat) {
		//console.log("move PixelC", lon, lat);
		//console.log("move PixelC", this.center.lon, this.center.lat);
		this.center.lon += lon;
		this.center.lat += lat;
		
		this.updateCenter();
	}
	
	setCenter(pos) {
		let undef = this.getCheckFunction("setCenter");
		
		if(undef(pos, "pos"))
			return;
		
		let lon = pos.lon;
		
		if(undef(lon, "lon", pos))
			return;
		
		let lat = pos.lat;
		
		if(undef(lat, "lat", pos))
			return;
		
		this.center.lon = parseFloat(lon);
		this.center.lat = parseFloat(lat);
		
		this.updateCenter();
	}
	
};

/**
 * WidgetGeoMap::GeoPixelCircle
 */

class GeoPixelCircle extends GeoCircle {
	
	constructor(properties) {
		super(properties.GeoCircle);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let radius = properties.radius;
		
		if(undef(radius, "radius", properties))
			return;
		
		this.radius = radius;

		this.data = this.center;

		GeoMapObject.prototype.fillMaps.call(this, () => {return L.circleMarker(this.data, {radius : radius});});

		this.init();
		
	}
	
};

/**
 * WidgetGeoMap::GeoMeterCircle
 */

class GeoMeterCircle extends GeoCircle {
	
	constructor(properties) {
		super(properties.GeoCircle);
		
		let undef = this.getCheckFunction("constructor");
		
		if(undef(properties, "properties"))
			return;
		
		let radius = properties.radius;
		
		if(undef(radius, "radius", properties))
			return;
		
		this.radius = radius;
		
		this.data = this.center;


		GeoMapObject.prototype.fillMaps.call(this, () => {let test = L.circle(this.data, {radius : radius}); test.setRadius(parseInt(this.radius)); return test;});
		// let latLng = {
		// 	lng : this.center.lon,
		// 	lat : this.center.lat
		// };
		
		// let circle = L.circle(latLng, {radius : radius});

		// this.object = circle;
		
		this.init();
		
	}
	
};

//GetGeoPos
// navigator.geolocation.getCurrentPosition(function(location) {
// 	alert(location.coords.latitude);
// 	alert(location.coords.longitude);
// 	alert(location.coords.accuracy);
// });
/**
 * GeoManager
 */


var geoManager = null;//GlobalVariable

class GeoManager {

	constructor(state) {
		geoManager = this;

		this.objectTypes = this.createObjectTypes();
		this.styleTypes = this.createStyleTypes();

		this.maps = {};
		this.images = {};
		this.styles = {};
		this.tooltips = {};
		this.objects = {};

		this.clientId = Math.round(Math.random() * 1e8) + "";

		this.setState(state);
	}

	setState(state) {

		if (geoManager == null) return;

		if (state === undefined) return;

		if (state.geoManager == undefined) return;

		let initParameters = state.geoManager.init;

		if (initParameters != undefined) this.init(initParameters);

		let requests = state.geoManager.requests;

		if (requests == undefined) return;

		if (requests === undefined) return;

		for (var i = 0; i < requests.length; ++i) {
			// console.log("OneRec", requests[i]);
			let request = requests[i];
			if (request === undefined) continue;
			// console.log("method",request.method);
			if (this.clientId == request.clientId) return;

			this[request.method](request.parameters);
		}
	}

	init(parameters) {

		let style, object, id;

		let allImage = parameters.Images;

		if (allImage != undefined)
			this.images = allImage;

		let allObjects = parameters.Objects;

		if (allObjects != undefined) {
			for (let objectType in allObjects) {
				let type = this.objectTypes[objectType];
				for (let i = 0; i < allObjects[objectType].length; ++i) {
					object = new type(allObjects[objectType][i]);
					id = object.id;
					this.objects[id] = object;
				}
			}
		}

		let allStyles = parameters.Styles;

		if (allStyles != undefined) {
			for (let objectType in allStyles) {
				let type = this.styleTypes[objectType];
				for (let i = 0; i < allStyles[objectType].length; ++i) {
					style = new type(allStyles[objectType][i]);
					id = style.id;
					this.styles[id] = style;
				}
			}
		}
	}

	run(parameters) {

		let obj = this[parameters.type + 's'][parameters.id];

		if (obj == undefined) return;
		// if (obj == undefined) debugger;


		obj[parameters.method](parameters.properties);
	}

	addCollection(parameters) {

		let mapId = parameters.mapId;

		let initParameters = parameters.init;

		let styles = initParameters.styles;

		for (let id in styles)
			geoManager.addStyle(styles[id]);

		let objects = initParameters.objects;
		for (let id in objects) {
			let oneObj = objects[id];
			oneObj.mapId = mapId;
			geoManager.addObject(oneObj);
		}
	}

	addObject(parameters) {

		let objectType = parameters.type;

		let type = this.objectTypes[objectType];

		let map = this.maps[parameters.mapId];

		let object = new type(parameters.properties);

		let id = object.id;
		this.objects[id] = object;

		map.addObjectToMap(id);
	}

	addStyle(parameters) {

		let objectType = parameters.type;

		let type = this.styleTypes[objectType];

		let style = new type(parameters.properties);

		let id = style.id;

		this.styles[id] = style;
	}

	addTooltip(parameters) {
		let tooltip;

		let typeTooltip = parameters.type;

		if (typeTooltip == "Popup")
			tooltip = new GeoMapPopup(parameters.properties);
		else if (typeTooltip == "ToolTip")
			tooltip = new GeoMapTooltip(parameters.properties);
		else {
			console.error("error unknow type tooltip");
			return;
		}

		let id = tooltip.id;

		this.tooltips[id] = tooltip;
	}

	addImage(parameters) {
		//console.log("PARAMETERS", parameters);
		let id = parameters.id;

		if (this.images[id] === undefined)
			this.images[id] = parameters.data;
	}

	addMap(map) {
		if (map == undefined)
			console.log("OPA ERROR MAPA HZ");

		this.maps[map.id] = map;
	}

	removeObject (id) {
		let object = this.objects[id];

		if (object == undefined) {
			console.error("obj undefined");
			return;
		}

		for (let mapId in object.maps)
			this.maps[mapId].removeObject(object.id);

		object.maps = {};

		if (object.removeStyle != undefined) object.removeStyle();
		

		delete this.objects[id];
	}

	removeStyle (id) {

		let style = this.styles[id];

		if (style == undefined){
			console.error("style undefined");
			return;
		}

		for (let objId in style.geometries)
			this.objects[objId].removeStyle();

		delete this.styles[id];
	}

	removeToolTip (id) {
		let toolTip = this.tooltips[id];

		if (toolTip == undefined) {
			console.log("toolTip undefined");
			return;
		}

		delete this.tooltips[id];
	}

	// deleteToolTip (id) {
	//
	// }

	createObjectTypes() {
		const types = {
			'Marker': GeoMapMarker,
			'Popup': GeoMapPopup,
			// 'Tooltip': GeoMapTooltip,
			'Line': GeoMapLine,
			'Polygon': GeoMapPolygon,
			'Rectangle': GeoMapRectangle,
			'PixelCircle': GeoPixelCircle,
			'MeterCircle': GeoMeterCircle
		};
		return types;
	}


	createStyleTypes() {
		const types = {
			'ImageIcon': GeoImageIcon,
			'HtmlIcon': GeoHtmlIcon,
			'Font' : GeoFont,
			'LineText' : GeoLineText,
			'LineStyle': GeoLineStyle,
			'CircleStyle': GeoCircleStyle,
			'PolygonStyle': GeoPolygonStyle,
			'RectangleStyle': GeoRectangleStyle
		};
		return types;
	}

	getMap(id) {
		console.log("getMap");
		let map = this.maps[id];
		if (map === undefined)
			console.log("HeT TAKOU MAP");
		return map;
	}

	getObject(id) {
		return (this.objects[id]);
	}

	getStyle(id) {
		return (this.images[id]);
	}

	getImage(id) {
		return (this.styles[id]);
	}

	isObjectExist(id) {
		console.log("isExist", this.objects[id]);
		return (this.objects[id] !== undefined);
	}

	isStyleExist(id) {
		return (this.styles[id] !== undefined);
	}

	isImageExist(id) {
		return (this.images[id] !== undefined);
	}

}





/**
 * WidgetGeoMap
 */
var counter = 0;
class WidgetGeoMap extends Widget {

	constructor(state) {

		super(state);

		this.geoMapState = state.geoMap;
		
		this.setState(state);
	};

	createView() {
		//виртуальная вызывается через базовый конструктор super
		this.view = new WidgetGeoMapHtml(this);
	}

	onInit() {
		this.geoMapInit(this.geoMapState);
		window.dispatchEvent(new Event('resize'));
	}

	geoMapInit(state) {

		this.map = new GeoMap(this, state, this.view.htmlElement);
		console.log("SSSSSSSSSS",this);

		if (geoManager == null)
			geoManager = new GeoManager ();

		let objectIds = state.init.ObjectIds;

		if (objectIds != undefined)
			for (let i=0; i<objectIds.length; ++i)
				this.map.addObjectToMap(objectIds[i]);
		// this.map.addObjectToMap(geoManager.objects[objectIds[i]]);

		geoManager.maps[this.map.id] = this.map;

		this.map.init(state);
	}

	destroy() {
		if(this.map != undefined)
			this.map.clear();
	}

	geoMapSetInteractive(editable) {
		if(editable != undefined)
			this.map.setInteractive(editable);
	}

	addObjectToMap (property){
		// //console.log("this.map",this.map);
		this.map.addObjectToMap(property.objId);
	}

	handleGeoMapEvent(event) {
		//console.log(event);
		let eventString = JSON.stringify(event);
		
		Rex.callRpcMethod("Widgets", this.id, this.type, "handleGeoMapEvent", [eventString]);
	}

	setState(state) {
		//console.log("set state WidgetGeoMap", state);
		super.setState(state);
		
		if(this.map != undefined) {
			this.map.setState(state.geoMap);
			
			if(state.visible != undefined)
				this.map.setVisible(state.visible);
			
			if(state.editable != undefined)
				this.map.setInteractive(!state.editable);
		}
		if(state.ManagerId != null) {
			Rex.widgets[state.ManagerId]
		}
	}
	
	setVisible(v) {
		if(this.map != undefined)
			this.map.setVisible(v);
		super.setVisible(v);
	}

	onResize() {
		if(this.map != undefined)
			this.map.invalidateSize();
	}
	
};




/**
 * WidgetGeoMap
 */
class WidgetGeoManager extends Widget {

	createView() {
		//хз надо ли виртуальная вызывается через базовый конструктор super
		this.view = new WidgetGeoManagerHtml(this);
	}

	constructor(state) {
		console.log("Create RexWidgetGeoMap");
		super(state);
	};


	setState(state){
		super.setState(state);//надо ли?
		if (geoManager == null)
			geoManager = new GeoManager(state);
		geoManager.setState(state);
	}

};




/**
 * WidgetGeoMap
 */
 
class WidgetGeoMapHtml extends WidgetViewHtml {
	
	constructor(widget) {
		console.log("Create GeoMapHTML");

		super(widget);
		this.addClassName("WidgetGeoMap");
		this.createDomElement("div");
		this.htmlElement.style.backgroundColor = "rgb(1,0,0) !important";
		new ResizeObserver(this.onResize.bind(this)).observe(this.htmlElement);
	};
	
	onDestroy() {
		console.log("DESTROY",this);
		this.widget.destroy();
	}

	onResize() {
		this.widget.onResize();
	}

};


/**
 * WidgetGeoMap
 */

class WidgetGeoManagerHtml extends WidgetViewHtml {

	constructor(widget) {
		//console.log("Create GeoManager");

		super(widget);

		this.addClassName("WidgetGeoManager");


		this.createDomElement("div");

		this.htmlElement.style.display = "none";
	};

};


